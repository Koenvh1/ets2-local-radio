<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpDX.Direct2D1</name>
    </assembly>
    <members>
        <member name="M:SharpDX.Direct2D1.AnalysisTransform.ProcessAnalysisResults(SharpDX.DataStream)">
            <summary>	
            Supplies the analysis data to an analysis transform.
            </summary>	
            <param name="analysisData"><para>The data that the transform will analyze.</para></param>	
            <remarks>	
            The output of the transform will be copied to CPU-accessible memory by the imaging effects system before being passed to the implementation.If this call fails, the corresponding <see cref="T:SharpDX.Direct2D1.Effect"/> instance is placed into an error state and fails to draw.	
            </remarks>	
            <unmanaged>HRESULT ID2D1AnalysisTransform::ProcessAnalysisResults([In, Buffer] const unsigned char* analysisData,[In] unsigned int analysisDataCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.AnalysisTransform.ProcessAnalysisResults``1(``0)">
            <summary>	
            Supplies the analysis data to an analysis transform.
            </summary>	
            <param name="analysisData"><para>The data that the transform will analyze.</para></param>	
            <remarks>	
            The output of the transform will be copied to CPU-accessible memory by the imaging effects system before being passed to the implementation.If this call fails, the corresponding <see cref="T:SharpDX.Direct2D1.Effect"/> instance is placed into an error state and fails to draw.	
            </remarks>	
            <unmanaged>HRESULT ID2D1AnalysisTransform::ProcessAnalysisResults([In, Buffer] const unsigned char* analysisData,[In] unsigned int analysisDataCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.AnalysisTransform.ProcessAnalysisResults``1(``0[])">
            <summary>	
            Supplies the analysis data to an analysis transform.
            </summary>	
            <param name="analysisData"><para>The data that the transform will analyze.</para></param>	
            <remarks>	
            The output of the transform will be copied to CPU-accessible memory by the imaging effects system before being passed to the implementation.If this call fails, the corresponding <see cref="T:SharpDX.Direct2D1.Effect"/> instance is placed into an error state and fails to draw.	
            </remarks>	
            <unmanaged>HRESULT ID2D1AnalysisTransform::ProcessAnalysisResults([In, Buffer] const unsigned char* analysisData,[In] unsigned int analysisDataCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.AnalysisTransform.ProcessAnalysisResults(System.IntPtr,System.Int32)">
            <summary>
            <p>Supplies the analysis data to an analysis transform.</p>
            </summary>
            <param name = "analysisData"><dd>  <p>The data that the transform will analyze.</p> </dd></param>
            <param name = "analysisDataCount"><dd>  <p>The size of the analysis data.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The output of the transform will be copied to CPU-accessible memory by the imaging effects system before being passed to the implementation.</p><p> If this call fails, the corresponding <strong><see cref = "T:SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>
            </remarks>
            <doc-id>hh404348</doc-id>
            <unmanaged>HRESULT ID2D1AnalysisTransform::ProcessAnalysisResults([In, Buffer] const unsigned char* analysisData,[In] unsigned int analysisDataCount)</unmanaged>
            <unmanaged-short>ID2D1AnalysisTransform::ProcessAnalysisResults</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.AssemblyDoc">
            <summary>
            The <see cref="A:SharpDX.Direct2D1"/> assembly provides managed API for <see cref="N:SharpDX.Direct2D1"/>, <see cref="N:SharpDX.DirectWrite"/> and <see cref="N:SharpDX.WIC"/>.
            </summary>
            <msdn-id>ee663274</msdn-id>
            <unmanaged>Direct2D1 / DirectWrite</unmanaged>	
            <unmanaged-short>Direct2D1 / DirectWrite</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Size2)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <msdn-id>dd371800</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Size2,SharpDX.Direct2D1.BitmapProperties)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="bitmapProperties">The pixel format and dots per inch (DPI) of the bitmap to create.</param>
            <msdn-id>dd371800</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Size2,SharpDX.DataPointer,System.Int32)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="dataPointer">A pointer to the memory location of the image data, or NULL to create an uninitialized bitmap.</param>
            <param name="pitch">The byte count of each scanline, which is equal to (the image width in pixels * the number of bytes per pixel) + memory padding. If srcData is NULL, this value is ignored. (Note that pitch is also sometimes called stride.)</param>
            <msdn-id>dd371800</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Size2,SharpDX.DataPointer,System.Int32,SharpDX.Direct2D1.BitmapProperties)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="dataPointer">A pointer to the memory location of the image data, or NULL to create an uninitialized bitmap.</param>
            <param name="pitch">The byte count of each scanline, which is equal to (the image width in pixels * the number of bytes per pixel) + memory padding. If srcData is NULL, this value is ignored. (Note that pitch is also sometimes called stride.)</param>
            <param name="bitmapProperties">The pixel format and dots per inch (DPI) of the bitmap to create.</param>
            <msdn-id>dd371800</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Bitmap)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> whose data is shared with another resource.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="bitmap">An <see cref="T:SharpDX.Direct2D1.Bitmap"/> that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
            <msdn-id>dd371865</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Direct2D1.BitmapProperties})">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> whose data is shared with another resource.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="bitmap">An <see cref="T:SharpDX.Direct2D1.Bitmap"/> that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
            <param name="bitmapProperties">The pixel format  and DPI of the bitmap to create . The <see cref="T:SharpDX.DXGI.Format"/> portion of the pixel format  must match the <see cref="T:SharpDX.DXGI.Format"/> of data or the method will fail, but the alpha modes don't have to match. To prevent a  mismatch, you can pass NULL or the value obtained from the {{D2D1::PixelFormat}} helper function. The DPI settings do not have to match those of data. If both dpiX and dpiY are  0.0f, the default DPI, 96, is used.</param>
            <msdn-id>dd371865</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.DXGI.Surface)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> whose data is shared with another resource.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="surface">An <see cref="T:SharpDX.DXGI.Surface"/> that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
            <msdn-id>dd371865</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.DXGI.Surface,System.Nullable{SharpDX.Direct2D1.BitmapProperties})">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> whose data is shared with another resource.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="surface">An <see cref="T:SharpDX.DXGI.Surface"/> that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
            <param name="bitmapProperties">The pixel format  and DPI of the bitmap to create . The <see cref="T:SharpDX.DXGI.Format"/> portion of the pixel format  must match the <see cref="T:SharpDX.DXGI.Format"/> of data or the method will fail, but the alpha modes don't have to match. To prevent a  mismatch, you can pass NULL or the value obtained from the {{D2D1::PixelFormat}} helper function. The DPI settings do not have to match those of data. If both dpiX and dpiY are  0.0f, the default DPI, 96, is used.</param>
            <msdn-id>dd371865</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.WIC.BitmapLock)">
            <summary>
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> that points to the bitmap data already stored in the <see cref="T:SharpDX.WIC.BitmapLock"/>. 
            </summary>
            <param name="renderTarget">An instance of <see cref="T:SharpDX.Direct2D1.RenderTarget" />.</param>
            <param name="bitmapLock">An <see cref="T:SharpDX.Direct2D1.RenderTarget" /> that contains the data to share with the new <see cref="T:SharpDX.Direct2D1.Bitmap"/>.</param>
            <msdn-id>dd371865</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.WIC.BitmapLock,System.Nullable{SharpDX.Direct2D1.BitmapProperties})">
            <summary>
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> that points to the bitmap data already stored in the <see cref="T:SharpDX.WIC.BitmapLock"/>. 
            </summary>
            <param name="renderTarget">An instance of <see cref="T:SharpDX.Direct2D1.RenderTarget" />.</param>
            <param name="bitmapLock">An <see cref="T:SharpDX.Direct2D1.RenderTarget" /> that contains the data to share with the new <see cref="T:SharpDX.Direct2D1.Bitmap"/>.</param>
            <param name="bitmapProperties">The pixel format  and DPI of the bitmap to create . The <see cref="T:SharpDX.DXGI.Format"/> portion of the pixel format  must match the <see cref="T:SharpDX.DXGI.Format"/> of data or the method will fail, but the alpha modes don't have to match. To prevent a  mismatch, you can pass NULL or the value obtained from the {{D2D1::PixelFormat}} helper function. The DPI settings do not have to match those of data. If both dpiX and dpiY are  0.0f, the default DPI, 96, is used.</param>
            <msdn-id>dd371865</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.New``1(SharpDX.Direct2D1.RenderTarget,SharpDX.Size2,``0[],SharpDX.Direct2D1.BitmapProperties)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="pixelDatas">A pointer to an array of pixel data. The size of the array must be equal to sizeof(pixel) * Size.Width * Height.</param>
            <param name="bitmapProperties">The pixel format and dots per inch (DPI) of the bitmap to create.</param>
            <msdn-id>dd371800</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.FromWicBitmap(SharpDX.Direct2D1.RenderTarget,SharpDX.WIC.BitmapSource)">
            <summary>
            Creates a Bitmap from a WIC bitmap.
            </summary>
            <param name="renderTarget">The render target.</param>
            <param name="wicBitmapSource">A reference to a <see cref="T:SharpDX.WIC.BitmapSource"/> WIC bitmap.</param>
            <returns></returns>
            <msdn-id>dd371797</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmapFromWicBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.FromWicBitmap(SharpDX.Direct2D1.RenderTarget,SharpDX.WIC.BitmapSource,SharpDX.Direct2D1.BitmapProperties)">
            <summary>
            Creates a Bitmap from a WIC bitmap.
            </summary>
            <param name="renderTarget">The render target.</param>
            <param name="wicBitmap">The WIC bitmap.</param>
            <param name="bitmapProperties">The bitmap properties.</param>
            <returns></returns>
            <msdn-id>dd371797</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::CreateBitmapFromWicBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromBitmap(SharpDX.Direct2D1.Bitmap)">
            <summary>	
            Copies the specified region from the specified bitmap into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="sourceBitmap">The bitmap to copy from. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371152</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromBitmap(SharpDX.Direct2D1.Bitmap,SharpDX.Mathematics.Interop.RawPoint)">
            <summary>	
            Copies the specified region from the specified bitmap into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="sourceBitmap">The bitmap to copy from. </param>
            <param name="destinationPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371152</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromBitmap(SharpDX.Direct2D1.Bitmap,SharpDX.Mathematics.Interop.RawPoint,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            Copies the specified region from the specified bitmap into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="sourceBitmap">The bitmap to copy from. </param>
            <param name="sourceArea">The area of bitmap to copy. </param>
            <param name="destinationPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371152</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory(System.IntPtr,System.Int32)">
            <summary>	
            Copies the specified region from memory into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="pointer">The data to copy. </param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory(System.Byte[],System.Int32)">
            <summary>	
            Copies the specified region from memory into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="memory">The data to copy. </param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory``1(``0[],System.Int32)">
            <summary>	
            Copies the specified region from memory into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="memory">The data to copy. </param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory(System.IntPtr,System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            Copies the specified region from memory into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="pointer">The data to copy. </param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <param name="destinationArea">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory(System.Byte[],System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            Copies the specified region from memory into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="memory">The data to copy. </param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <param name="destinationArea">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory``1(``0[],System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            Copies the specified region from memory into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="memory">The data to copy. </param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <param name="destinationArea">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromRenderTarget(SharpDX.Direct2D1.RenderTarget)">
            <summary>	
            Copies the specified region from the specified render target into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  All clips and layers must be popped off of the render target before calling this method.  The method returns {{D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT}} if any clips or layers are currently applied to the render target. 	
            </remarks>	
            <param name="renderTarget">The render target that contains the region to copy. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371158</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromRenderTarget</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromRenderTarget(SharpDX.Direct2D1.RenderTarget,SharpDX.Mathematics.Interop.RawPoint)">
            <summary>	
            Copies the specified region from the specified render target into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  All clips and layers must be popped off of the render target before calling this method.  The method returns {{D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT}} if any clips or layers are currently applied to the render target. 	
            </remarks>	
            <param name="renderTarget">The render target that contains the region to copy. </param>
            <param name="destinationPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371158</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromRenderTarget</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromRenderTarget(SharpDX.Direct2D1.RenderTarget,SharpDX.Mathematics.Interop.RawPoint,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            Copies the specified region from the specified render target into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  All clips and layers must be popped off of the render target before calling this method.  The method returns {{D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT}} if any clips or layers are currently applied to the render target. 	
            </remarks>	
            <param name="renderTarget">The render target that contains the region to copy. </param>
            <param name="destinationPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <param name="sourceArea">The area of renderTarget to copy. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371158</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromRenderTarget</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromStream(System.IO.Stream,System.Int32,System.Int32)">
            <summary>	
            Copies the specified region from a stream into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="stream">The stream to copy the data from. </param>
            <param name="length">Length in bytes of the data to copy from the stream.</param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromStream(System.IO.Stream,System.Int32,System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            Copies the specified region from a stream into the current bitmap. 	
            </summary>	
            <remarks>	
            This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match.  Passing this method invalid input, such as an invalid destination rectangle, can produce unpredictable results, such as a distorted image or device failure. Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <see cref="T:System.Int32"/> and tag state will be returned at the next call to {{EndDraw}} or {{Flush}}.  	
            </remarks>	
            <param name="stream">The stream to copy the data from. </param>
            <param name="length">Length in bytes of the data to copy from the stream.</param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding. </param>
            <param name="destinationArea">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <msdn-id>dd371155</msdn-id>	
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>	
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>	
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap.DotsPerInch">
            <summary>	
            Return the dots per inch (DPI) of the bitmap.	
            </summary>	
            <value>The dots per inch (DPI) of the bitmap.</value>
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap.Size">
            <summary>
            <p>Returns the size, in device-independent pixels (DIPs), of the bitmap.</p>
            </summary>
            <remarks>
            <p>A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <strong>ID2D1Bitmap::GetPixelSize</strong> method.</p>
            </remarks>
            <doc-id>dd371170</doc-id>
            <unmanaged>GetSize</unmanaged>
            <unmanaged-short>GetSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap.PixelSize">
            <summary>
            <p>Returns the size, in device-dependent units (pixels), of the bitmap.</p>
            </summary>
            <doc-id>dd371167</doc-id>
            <unmanaged>GetPixelSize</unmanaged>
            <unmanaged-short>GetPixelSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap.PixelFormat">
            <summary>
            <p>Retrieves the pixel format and alpha mode of the bitmap.</p>
            </summary>
            <doc-id>dd371164</doc-id>
            <unmanaged>GetPixelFormat</unmanaged>
            <unmanaged-short>GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.GetSize">
            <summary>
            <p>Returns the size, in device-independent pixels (DIPs), of the bitmap.</p>
            </summary>
            <returns><p>The size, in DIPs, of the bitmap.</p></returns>
            <remarks>
            <p>A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <strong>ID2D1Bitmap::GetPixelSize</strong> method.</p>
            </remarks>
            <doc-id>dd371170</doc-id>
            <unmanaged>D2D_SIZE_F ID2D1Bitmap::GetSize()</unmanaged>
            <unmanaged-short>ID2D1Bitmap::GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.GetPixelSize">
            <summary>
            <p>Returns the size, in device-dependent units (pixels), of the bitmap.</p>
            </summary>
            <returns><p>The size, in pixels, of the bitmap.</p></returns>
            <doc-id>dd371167</doc-id>
            <unmanaged>D2D_SIZE_U ID2D1Bitmap::GetPixelSize()</unmanaged>
            <unmanaged-short>ID2D1Bitmap::GetPixelSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.GetPixelFormat">
            <summary>
            <p>Retrieves the pixel format and alpha mode of the bitmap.</p>
            </summary>
            <returns><p>The pixel format and alpha mode of the bitmap.</p></returns>
            <doc-id>dd371164</doc-id>
            <unmanaged>D2D1_PIXEL_FORMAT ID2D1Bitmap::GetPixelFormat()</unmanaged>
            <unmanaged-short>ID2D1Bitmap::GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.GetDpi(System.Single@,System.Single@)">
            <summary>
            <p>Return the dots per inch (DPI) of the bitmap.</p>
            </summary>
            <param name = "dpiX"><dd>  <p>The horizontal DPI of the image. You must allocate storage for this parameter.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>The vertical DPI of the image.  You must allocate storage for this parameter.</p> </dd></param>
            <doc-id>dd371161</doc-id>
            <unmanaged>void ID2D1Bitmap::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
            <unmanaged-short>ID2D1Bitmap::GetDpi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromBitmap(System.Nullable{SharpDX.Mathematics.Interop.RawPoint},SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p>Copies the specified region from the specified bitmap into the current bitmap. </p>
            </summary>
            <param name = "destPoint"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>
            <param name = "bitmap"><dd>  <p>The bitmap to copy from.</p> </dd></param>
            <param name = "srcRect"><dd>  <p>The area of <em>bitmap</em> to copy.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref = "T:SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>.</p><p>Starting with Windows?8.1,  this method supports block compressed bitmaps.  If you are using a block compressed format, the end coordinates of the <em>srcRect</em> parameter must be multiples of 4 or the method returns <strong>E_INVALIDARG</strong>.</p>
            </remarks>
            <doc-id>dd371152</doc-id>
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>
            <unmanaged-short>ID2D1Bitmap::CopyFromBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromRenderTarget(System.Nullable{SharpDX.Mathematics.Interop.RawPoint},SharpDX.Direct2D1.RenderTarget,System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p>Copies the specified region from the specified render target into the current bitmap. </p>
            </summary>
            <param name = "destPoint"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>
            <param name = "renderTarget"><dd>  <p>The render target that contains the region to copy.</p> </dd></param>
            <param name = "srcRect"><dd>  <p>The area of <em>renderTarget</em> to copy.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref = "T:SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>. </p><p>All clips and layers must be popped off of the render target before calling this method.  The method returns <strong><see cref = "!:RenderTargetHasLayerOrCliprect"/></strong> if any clips or layers are currently applied to the render target.</p>
            </remarks>
            <doc-id>dd371158</doc-id>
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>
            <unmanaged-short>ID2D1Bitmap::CopyFromRenderTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap.CopyFromMemory(System.Nullable{SharpDX.Mathematics.Interop.RawRectangle},System.IntPtr,System.Int32)">
            <summary>
            <p>Copies the specified region from memory into the current bitmap. </p>
            </summary>
            <param name = "dstRect"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>
            <param name = "srcData"><dd>  <p>The data to copy.</p> </dd></param>
            <param name = "pitch"><dd>  <p>The stride, or pitch, of the source bitmap stored in <em>srcData</em>. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match. </p><p>If this method is passed invalid input (such as an invalid destination rectangle), can produce unpredictable results, such as a distorted image or device failure.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref = "T:SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>. </p><p>Starting with Windows?8.1,  this method supports block compressed bitmaps.  If you are using a block compressed format, the end coordinates of the <em>srcRect</em> parameter must be multiples of 4 or the method returns <strong>E_INVALIDARG</strong>.</p>
            </remarks>
            <doc-id>dd371155</doc-id>
            <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>
            <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Size2)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Buffer, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Size2,SharpDX.Direct2D1.BitmapProperties1)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="bitmapProperties">The pixel format and dots per inch (DPI) of the bitmap to create.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Buffer, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Size2,SharpDX.DataStream,System.Int32)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="dataStream">A pointer to the memory location of the image data, or NULL to create an uninitialized bitmap.</param>
            <param name="pitch">The byte count of each scanline, which is equal to (the image width in pixels * the number of bytes per pixel) + memory padding. If srcData is NULL, this value is ignored. (Note that pitch is also sometimes called stride.)</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Buffer, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Size2,SharpDX.DataStream,System.Int32,SharpDX.Direct2D1.BitmapProperties1)">
            <summary>	
            Creates a Direct2D bitmap from a pointer to in-memory source data.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">The dimension of the bitmap to create in pixels.</param>
            <param name="dataStream">A pointer to the memory location of the image data, or NULL to create an uninitialized bitmap.</param>
            <param name="pitch">The byte count of each scanline, which is equal to (the image width in pixels * the number of bytes per pixel) + memory padding. If srcData is NULL, this value is ignored. (Note that pitch is also sometimes called stride.)</param>
            <param name="bitmapProperties">The pixel format and dots per inch (DPI) of the bitmap to create.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Buffer, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.DXGI.Surface)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> whose data is shared with another resource.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="surface">An <see cref="T:SharpDX.DXGI.Surface"/> that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromDxgiSurface([In] IDXGISurface* surface,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap1)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.DXGI.Surface,SharpDX.Direct2D1.BitmapProperties1)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.Bitmap"/> whose data is shared with another resource.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="surface">An <see cref="T:SharpDX.DXGI.Surface"/> that contains the data to share with the new ID2D1Bitmap. For more information, see the Remarks section.</param>
            <param name="bitmapProperties">The pixel format  and DPI of the bitmap to create . The <see cref="T:SharpDX.DXGI.Format"/> portion of the pixel format  must match the <see cref="T:SharpDX.DXGI.Format"/> of data or the method will fail, but the alpha modes don't have to match. To prevent a  mismatch, you can pass NULL or the value obtained from the {{D2D1::PixelFormat}} helper function. The DPI settings do not have to match those of data. If both dpiX and dpiY are  0.0f, the default DPI, 96, is used.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromDxgiSurface([In] IDXGISurface* surface,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap1)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.FromWicBitmap(SharpDX.Direct2D1.DeviceContext,SharpDX.WIC.BitmapSource)">
            <summary>
            Creates a Bitmap from a WIC bitmap.
            </summary>
            <param name="deviceContext">The render target.</param>
            <param name="wicBitmapSource">A reference to a <see cref="T:SharpDX.WIC.BitmapSource"/> WIC bitmap.</param>
            <returns></returns>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out] ID2D1Bitmap1** bitmap)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.FromWicBitmap(SharpDX.Direct2D1.DeviceContext,SharpDX.WIC.BitmapSource,SharpDX.Direct2D1.BitmapProperties1)">
            <summary>
            Creates a Bitmap from a WIC bitmap.
            </summary>
            <param name="deviceContext">The render target.</param>
            <param name="wicBitmap">The WIC bitmap.</param>
            <param name="bitmapProperties">The bitmap properties.</param>
            <returns></returns>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out] ID2D1Bitmap1** bitmap)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.Map(SharpDX.Direct2D1.MapOptions)">
            <summary>
            Maps the given bitmap into memory.
            </summary>
            <param name="options"><para>The options used in mapping the bitmap into memory.</para></param>	
            <returns>a reference to the rectangle that is mapped into memory</returns>	
            <remarks>	
            The bitmap must have been created with the <see cref="F:SharpDX.Direct2D1.MapOptions.Read" /> flag specified.The caller should try to unmap the memory as quickly as is feasible to release occupied DMA aperture memory.	
            </remarks>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1Bitmap1::Map']/*" />	
            <unmanaged>HRESULT ID2D1Bitmap1::Map([In] D2D1_MAP_OPTIONS options,[Out] D2D1_MAPPED_RECT* mappedRect)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap1.ColorContext">
            <summary>
            <p>Gets the color context information associated with the bitmap. </p>
            </summary>
            <remarks>
            <p>If the bitmap was created without specifying a color context, the returned context is <strong><c>null</c></strong>.</p>
            </remarks>
            <doc-id>hh404350</doc-id>
            <unmanaged>GetColorContext</unmanaged>
            <unmanaged-short>GetColorContext</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap1.Options">
            <summary>
            <p>Gets the options used in creating the bitmap.</p>
            </summary>
            <doc-id>hh404351</doc-id>
            <unmanaged>GetOptions</unmanaged>
            <unmanaged-short>GetOptions</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Bitmap1.Surface">
            <summary>
            <p>Gets either the surface that was specified when the bitmap was created, or the default surface created when the bitmap was created. </p>
            </summary>
            <remarks>
            <p>The bitmap used must have been created from a DXGI surface render target, a derived render target, or a device context created from an <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong>.</p><p>The returned surface can be used with Microsoft Direct3D or any other API that interoperates with shared surfaces. The application must transitively ensure that the surface is usable on the Direct3D device that is used in this context. For example, if using the surface with Direct2D  then the Direct2D render target must have been created through <strong>ID2D1Factory::CreateDxgiSurfaceRenderTarget</strong> or on a device context created on the same device.</p>
            </remarks>
            <doc-id>hh404355</doc-id>
            <unmanaged>GetSurface</unmanaged>
            <unmanaged-short>GetSurface</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.GetColorContext(SharpDX.Direct2D1.ColorContext@)">
            <summary>
            <p>Gets the color context information associated with the bitmap. </p>
            </summary>
            <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to the  color context interface associated with the bitmap.</p> </dd></param>
            <remarks>
            <p>If the bitmap was created without specifying a color context, the returned context is <strong><c>null</c></strong>.</p>
            </remarks>
            <doc-id>hh404350</doc-id>
            <unmanaged>void ID2D1Bitmap1::GetColorContext([Out, Optional] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1Bitmap1::GetColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.GetOptions">
            <summary>
            <p>Gets the options used in creating the bitmap.</p>
            </summary>
            <returns><p>This method returns the options used.</p></returns>
            <doc-id>hh404351</doc-id>
            <unmanaged>D2D1_BITMAP_OPTIONS ID2D1Bitmap1::GetOptions()</unmanaged>
            <unmanaged-short>ID2D1Bitmap1::GetOptions</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.GetSurface(SharpDX.DXGI.Surface@)">
            <summary>
            <p>Gets either the surface that was specified when the bitmap was created, or the default surface created when the bitmap was created. </p>
            </summary>
            <param name = "dxgiSurface"><dd>  <p>The underlying DXGI surface for the bitmap.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "!:BitmapBoundAsTarget"/></td><td>Cannot draw with a bitmap that is currently bound as the target bitmap.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The bitmap used must have been created from a DXGI surface render target, a derived render target, or a device context created from an <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong>.</p><p>The returned surface can be used with Microsoft Direct3D or any other API that interoperates with shared surfaces. The application must transitively ensure that the surface is usable on the Direct3D device that is used in this context. For example, if using the surface with Direct2D  then the Direct2D render target must have been created through <strong>ID2D1Factory::CreateDxgiSurfaceRenderTarget</strong> or on a device context created on the same device.</p>
            </remarks>
            <doc-id>hh404355</doc-id>
            <unmanaged>HRESULT ID2D1Bitmap1::GetSurface([Out, Optional] IDXGISurface** dxgiSurface)</unmanaged>
            <unmanaged-short>ID2D1Bitmap1::GetSurface</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.Map(SharpDX.Direct2D1.MapOptions,SharpDX.Direct2D1.MappedRectangle@)">
            <summary>
            <p>Maps  the given bitmap into memory.</p>
            </summary>
            <param name = "options"><dd>  <p>The options used in mapping the bitmap into memory.</p> </dd></param>
            <param name = "mappedRect"><dd>  <p>When this method returns, contains a reference to the rectangle that is mapped into memory.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid</td></tr> <tr><td>D3DERR_DEVICELOST</td><td>The device has been lost but cannot be reset at this time.</td></tr> </table><p>?</p></returns>
            <remarks>
            <strong>Note</strong>??You can't use bitmaps for some purposes while mapped. Particularly, the <strong>ID2D1Bitmap::CopyFromBitmap</strong> method doesn't work if either the source or destination bitmap is mapped.?<p>The bitmap must have been created with the <strong>D2D1_BITMAP_OPTIONS_CPU_READ</strong> flag specified.</p>
            </remarks>
            <doc-id>hh404357</doc-id>
            <unmanaged>HRESULT ID2D1Bitmap1::Map([In] D2D1_MAP_OPTIONS options,[Out] D2D1_MAPPED_RECT* mappedRect)</unmanaged>
            <unmanaged-short>ID2D1Bitmap1::Map</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Bitmap1.Unmap">
            <summary>
            <p>Unmaps the bitmap from memory. </p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid.</td></tr> <tr><td>E_POINTER</td><td>Pointer is not valid.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Any memory returned from the <strong>Map</strong> call is now invalid and may be reclaimed by the operating system or used for other purposes. </p><p>The bitmap must have been previously mapped.</p>
            </remarks>
            <doc-id>hh404359</doc-id>
            <unmanaged>HRESULT ID2D1Bitmap1::Unmap()</unmanaged>
            <unmanaged-short>ID2D1Bitmap1::Unmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Bitmap)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.BitmapBrushProperties)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <param name="bitmapBrushProperties">The extend modes and interpolation mode of the new brush, or NULL. If this parameter is NULL, the brush defaults to the <see cref="F:SharpDX.Direct2D1.ExtendMode.Clamp"/> horizontal and vertical extend modes and the <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/> interpolation mode. </param>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.BrushProperties)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <param name="brushProperties">The opacity and transform of the new brush, or NULL. If this parameter is NULL, the brush defaults to an opacity of 1.0f and its transform is the identity matrix.</param>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Direct2D1.BitmapBrushProperties},System.Nullable{SharpDX.Direct2D1.BrushProperties})">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <param name="bitmapBrushProperties">The extend modes and interpolation mode of the new brush, or NULL. If this parameter is NULL, the brush defaults to the <see cref="F:SharpDX.Direct2D1.ExtendMode.Clamp"/> horizontal and vertical extend modes and the <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/> interpolation mode. </param>
            <param name="brushProperties">The opacity and transform of the new brush, or NULL. If this parameter is NULL, the brush defaults to an opacity of 1.0f and its transform is the identity matrix.</param>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.BitmapBrush.ExtendModeX">
            <summary>
            <p>Gets or sets the method by which the brush horizontally tiles those areas that extend past its bitmap. </p>
            </summary>
            <remarks>
            <p>Like all brushes, <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
            </remarks>
            <doc-id>dd371128</doc-id>
            <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>
            <unmanaged-short>GetExtendModeX</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.BitmapBrush.ExtendModeY">
            <summary>
            <p>Gets or sets the method by which the brush vertically tiles those areas that extend past its bitmap. </p>
            </summary>
            <remarks>
            <p>Like all brushes, <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
            </remarks>
            <doc-id>dd371132</doc-id>
            <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>
            <unmanaged-short>GetExtendModeY</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.BitmapBrush.InterpolationMode">
            <summary>
            <p>Gets or sets the interpolation method used when the brush bitmap is scaled or rotated. </p>
            </summary>
            <remarks>
            <p>This method gets the interpolation mode of a bitmap, which is specified by the <strong><see cref = "T:SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <strong>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</strong> represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. </p>
            </remarks>
            <doc-id>dd371134</doc-id>
            <unmanaged>GetInterpolationMode / SetInterpolationMode</unmanaged>
            <unmanaged-short>GetInterpolationMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.BitmapBrush.Bitmap">
            <summary>
            <p>Gets or sets the bitmap source that this brush uses to paint.</p>
            </summary>
            <doc-id>dd371124</doc-id>
            <unmanaged>GetBitmap / SetBitmap</unmanaged>
            <unmanaged-short>GetBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.SetExtendModeX(SharpDX.Direct2D1.ExtendMode)">
            <summary>
            <p>Specifies how the brush horizontally tiles those areas that extend past its bitmap. </p>
            </summary>
            <param name = "extendModeX"><dd>  <p>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap. </p> </dd></param>
            <remarks>
            <p>Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (<strong>SetExtendModeX</strong>) and vertical (<strong>SetExtendModeY</strong>) extend mode settings to determine how to fill the remaining area.</p><p>The following illustration shows the results from  every  possible combination of the extend modes for an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong>: <strong>D2D1_EXTEND_MODE_CLAMP</strong> (CLAMP), <strong>D2D1_EXTEND_MODE_WRAP</strong> (WRAP), and <strong>D2D1_EXTEND_MIRROR</strong> (MIRROR).</p><p></p>
            </remarks>
            <doc-id>dd371139</doc-id>
            <unmanaged>void ID2D1BitmapBrush::SetExtendModeX([In] D2D1_EXTEND_MODE extendModeX)</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::SetExtendModeX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.SetExtendModeY(SharpDX.Direct2D1.ExtendMode)">
            <summary>
            <p>Specifies how the brush vertically tiles those areas that extend past its bitmap.</p>
            </summary>
            <param name = "extendModeY"><dd>  <p>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</p> </dd></param>
            <remarks>
            <p>Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (<strong>SetExtendModeX</strong>) and vertical (<strong>SetExtendModeY</strong>) extend mode settings to determine how to fill the remaining area.</p><p>The following illustration shows the results from  every  possible combination of the extend modes for an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong>: <strong>D2D1_EXTEND_MODE_CLAMP</strong> (CLAMP), <strong>D2D1_EXTEND_MODE_WRAP</strong> (WRAP), and <strong>D2D1_EXTEND_MIRROR</strong> (MIRROR).</p><p></p>
            </remarks>
            <doc-id>dd371142</doc-id>
            <unmanaged>void ID2D1BitmapBrush::SetExtendModeY([In] D2D1_EXTEND_MODE extendModeY)</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::SetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.SetInterpolationMode(SharpDX.Direct2D1.BitmapInterpolationMode)">
            <summary>
            <p>Specifies the interpolation mode used when the brush bitmap is scaled or rotated.</p>
            </summary>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode used when the brush bitmap is scaled or rotated.</p> </dd></param>
            <remarks>
            <p>This method sets the interpolation mode for a bitmap, which is an enum value that is specified in the <strong><see cref = "T:SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR represents nearest neighbor filtering. It looks up the nearest bitmap pixel to the current rendering pixel and chooses its exact color. D2D1_BITMAP_INTERPOLATION_MODE_LINEAR represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, bilinear interpolation positions the bitmap more precisely to the application requests, but blurs the bitmap in the process. </p>
            </remarks>
            <doc-id>dd371145</doc-id>
            <unmanaged>void ID2D1BitmapBrush::SetInterpolationMode([In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::SetInterpolationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.SetBitmap(SharpDX.Direct2D1.Bitmap)">
            <summary>
            <p>Specifies the bitmap source that this brush uses to paint. </p>
            </summary>
            <param name = "bitmap"><dd>  <p>The bitmap source used by the brush.</p> </dd></param>
            <remarks>
            <p>This method specifies the bitmap source that this brush uses to paint. The bitmap is not resized or rescaled automatically to fit the geometry that it fills. The bitmap stays at its native size. To resize or translate the bitmap, use the <strong>SetTransform</strong> method to apply  a transform to the brush. </p><p>The native size of a bitmap is the width and height in bitmap pixels, divided by the bitmap DPI. This native size forms the base tile of the brush. To tile a subregion of the bitmap, you must generate a new bitmap containing this subregion and use <strong>SetBitmap</strong> to apply it to the brush. 
            </p>
            </remarks>
            <doc-id>dd371136</doc-id>
            <unmanaged>void ID2D1BitmapBrush::SetBitmap([In, Optional] ID2D1Bitmap* bitmap)</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::SetBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.GetExtendModeX">
            <summary>
            <p> Gets the method by which the brush horizontally tiles those areas that extend past its bitmap. </p>
            </summary>
            <returns><p>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap.</p></returns>
            <remarks>
            <p>Like all brushes, <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
            </remarks>
            <doc-id>dd371128</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeX()</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::GetExtendModeX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.GetExtendModeY">
            <summary>
            <p> Gets the method by which the brush vertically tiles those areas that extend past its bitmap. </p>
            </summary>
            <returns><p>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</p></returns>
            <remarks>
            <p>Like all brushes, <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
            </remarks>
            <doc-id>dd371132</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeY()</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::GetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.GetInterpolationMode">
            <summary>
            <p>Gets the interpolation method used when the brush bitmap is scaled or rotated. </p>
            </summary>
            <returns><p>The interpolation method used when the brush bitmap is scaled or rotated.</p></returns>
            <remarks>
            <p>This method gets the interpolation mode of a bitmap, which is specified by the <strong><see cref = "T:SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <strong>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</strong> represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. </p>
            </remarks>
            <doc-id>dd371134</doc-id>
            <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE ID2D1BitmapBrush::GetInterpolationMode()</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::GetInterpolationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush.GetBitmap(SharpDX.Direct2D1.Bitmap@)">
            <summary>
            <p> Gets the bitmap source that this brush uses to paint.</p>
            </summary>
            <param name = "bitmap"><dd>  <p>When this method returns, contains the address to a reference to the bitmap with which this brush paints.</p> </dd></param>
            <doc-id>dd371124</doc-id>
            <unmanaged>void ID2D1BitmapBrush::GetBitmap([Out, Optional] ID2D1Bitmap** bitmap)</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush::GetBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.Bitmap1)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.DeviceContext" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.Bitmap1,SharpDX.Direct2D1.BitmapBrushProperties1)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.DeviceContext" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <param name="bitmapBrushProperties">The extend modes and interpolation mode of the new brush, or NULL. If this parameter is NULL, the brush defaults to the <see cref="F:SharpDX.Direct2D1.ExtendMode.Clamp"/> horizontal and vertical extend modes and the <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/> interpolation mode. </param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.Bitmap1,SharpDX.Direct2D1.BrushProperties)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.DeviceContext" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <param name="brushProperties">The opacity and transform of the new brush, or NULL. If this parameter is NULL, the brush defaults to an opacity of 1.0f and its transform is the identity matrix.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.Bitmap1,System.Nullable{SharpDX.Direct2D1.BitmapBrushProperties1},System.Nullable{SharpDX.Direct2D1.BrushProperties})">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.BitmapBrush"/> from the specified bitmap.	
            </summary>	
            <param name="deviceContext">an instance of <see cref = "T:SharpDX.Direct2D1.DeviceContext" /></param>
            <param name="bitmap">The bitmap contents of the new brush.</param>
            <param name="bitmapBrushProperties">The extend modes and interpolation mode of the new brush, or NULL. If this parameter is NULL, the brush defaults to the <see cref="F:SharpDX.Direct2D1.ExtendMode.Clamp"/> horizontal and vertical extend modes and the <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/> interpolation mode. </param>
            <param name="brushProperties">The opacity and transform of the new brush, or NULL. If this parameter is NULL, the brush defaults to an opacity of 1.0f and its transform is the identity matrix.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.BitmapBrush1.InterpolationMode1">
            <summary>
            <p>Returns or sets the current interpolation mode of the brush.</p>
            </summary>
            <doc-id>hh871448</doc-id>
            <unmanaged>GetInterpolationMode1 / SetInterpolationMode1</unmanaged>
            <unmanaged-short>GetInterpolationMode1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush1.SetInterpolationMode1(SharpDX.Direct2D1.InterpolationMode)">
            <summary>
            <p>Sets the interpolation mode for the brush.</p>
            </summary>
            <param name = "interpolationMode"><dd>  <p>The mode to use.</p> </dd></param>
            <doc-id>hh871449</doc-id>
            <unmanaged>void ID2D1BitmapBrush1::SetInterpolationMode1([In] D2D1_INTERPOLATION_MODE interpolationMode)</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush1::SetInterpolationMode1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapBrush1.GetInterpolationMode1">
            <summary>
            <p>Returns the current interpolation mode of the brush.</p>
            </summary>
            <returns><p>The current interpolation mode.</p></returns>
            <doc-id>hh871448</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE ID2D1BitmapBrush1::GetInterpolationMode1()</unmanaged>
            <unmanaged-short>ID2D1BitmapBrush1::GetInterpolationMode1</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapProperties">
            <summary>
            <p>Describes the pixel format and dpi  of a bitmap.</p>
            </summary>
            <doc-id>dd368075</doc-id>
            <unmanaged>D2D1_BITMAP_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_BITMAP_PROPERTIES</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties.#ctor(SharpDX.Direct2D1.PixelFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties"/> struct.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties.#ctor(SharpDX.Direct2D1.PixelFormat,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties"/> struct.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
            <param name="dpiX">The dpi X.</param>
            <param name="dpiY">The dpi Y.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties.PixelFormat">
            <summary>
            <dd> <p>The bitmap's pixel format and alpha mode.</p> </dd>
            </summary>
            <doc-id>dd368075</doc-id>
            <unmanaged>pixelFormat</unmanaged>
            <unmanaged-short>pixelFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties.DpiX">
            <summary>
            <dd> <p>The horizontal dpi of the bitmap.</p> </dd>
            </summary>
            <doc-id>dd368075</doc-id>
            <unmanaged>dpiX</unmanaged>
            <unmanaged-short>dpiX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties.DpiY">
            <summary>
            <dd> <p>The vertical dpi of the bitmap.</p> </dd>
            </summary>
            <doc-id>dd368075</doc-id>
            <unmanaged>dpiY</unmanaged>
            <unmanaged-short>dpiY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapProperties1">
            <summary>
            <p>This structure allows a <strong><see cref = "T:SharpDX.Direct2D1.Bitmap1"/></strong> to be created with bitmap options and color context information available.
            </p>
            </summary>
            <remarks>
            <p>If both <strong>dpiX</strong> and <strong>dpiY</strong> are 0, the dpi of the bitmap will be set to the desktop dpi if the device context is a windowed context, or 96 dpi for any other device context.</p>
            </remarks>
            <doc-id>hh404275</doc-id>
            <unmanaged>D2D1_BITMAP_PROPERTIES1</unmanaged>
            <unmanaged-short>D2D1_BITMAP_PROPERTIES1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties1"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties1.#ctor(SharpDX.Direct2D1.PixelFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties"/> struct.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties1.#ctor(SharpDX.Direct2D1.PixelFormat,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties"/> struct.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
            <param name="dpiX">The dpi X.</param>
            <param name="dpiY">The dpi Y.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties1.#ctor(SharpDX.Direct2D1.PixelFormat,System.Single,System.Single,SharpDX.Direct2D1.BitmapOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties1"/> class.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
            <param name="dpiX">The dpi X.</param>
            <param name="dpiY">The dpi Y.</param>
            <param name="bitmapOptions">The bitmap options.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapProperties1.#ctor(SharpDX.Direct2D1.PixelFormat,System.Single,System.Single,SharpDX.Direct2D1.BitmapOptions,SharpDX.Direct2D1.ColorContext)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.BitmapProperties1"/> class.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
            <param name="dpiX">The dpi X.</param>
            <param name="dpiY">The dpi Y.</param>
            <param name="bitmapOptions">The bitmap options.</param>
            <param name="colorContext">The color context.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties1.PixelFormat">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404275</doc-id>
            <unmanaged>pixelFormat</unmanaged>
            <unmanaged-short>pixelFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties1.DpiX">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404275</doc-id>
            <unmanaged>dpiX</unmanaged>
            <unmanaged-short>dpiX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties1.DpiY">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404275</doc-id>
            <unmanaged>dpiY</unmanaged>
            <unmanaged-short>dpiY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties1.BitmapOptions">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404275</doc-id>
            <unmanaged>bitmapOptions</unmanaged>
            <unmanaged-short>bitmapOptions</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapProperties1.ColorContext">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404275</doc-id>
            <unmanaged>colorContext</unmanaged>
            <unmanaged-short>colorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapRenderTarget.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.CompatibleRenderTargetOptions)">
            <summary>	
             Creates a bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target with same size, pixel size and pixel format.
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
            <unmanaged>HRESULT CreateCompatibleRenderTarget([In, Optional] const D2D1_SIZE_F* desiredSize,[In, Optional] const D2D1_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[None] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapRenderTarget.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.CompatibleRenderTargetOptions,SharpDX.Size2F)">
            <summary>	
             Creates a bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target with same pixel size and pixel format.
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
            <param name="desiredSize">The desired size of the new render target in device-independent pixels if it should be different from the original render target. For more information, see the Remarks section.</param>
            <unmanaged>HRESULT CreateCompatibleRenderTarget([In, Optional] const D2D1_SIZE_F* desiredSize,[In, Optional] const D2D1_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[None] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapRenderTarget.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.CompatibleRenderTargetOptions,System.Nullable{SharpDX.Direct2D1.PixelFormat})">
            <summary>	
             Creates a bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target with same size and pixel size.	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="desiredFormat">The desired pixel format and alpha mode of the new render target. If the pixel format is set to DXGI_FORMAT_UNKNOWN, the new render target uses the same pixel format as the original render target. If the alpha mode is <see cref="F:SharpDX.Direct2D1.AlphaMode.Unknown"/>, the alpha mode of the new render target defaults to D2D1_ALPHA_MODE_PREMULTIPLIED. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
            <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
            <unmanaged>HRESULT CreateCompatibleRenderTarget([In, Optional] const D2D1_SIZE_F* desiredSize,[In, Optional] const D2D1_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[None] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapRenderTarget.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.CompatibleRenderTargetOptions,System.Nullable{SharpDX.Size2F},System.Nullable{SharpDX.Size2},System.Nullable{SharpDX.Direct2D1.PixelFormat})">
            <summary>	
             Creates a bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target.	
            </summary>	
            <remarks>	
            The pixel size and DPI of the new render target can be altered by specifying values for desiredSize or desiredPixelSize:  If desiredSize is specified but desiredPixelSize is not, the pixel size is computed from the desired size using the parent target DPI. If the desiredSize maps to a integer-pixel size, the DPI of the compatible render target is the same as the DPI of the parent target.  If desiredSize maps to a fractional-pixel size, the pixel size is rounded up to the nearest integer and the DPI for the compatible render target is slightly higher than the DPI of the parent render target. In all cases, the coordinate (desiredSize.width, desiredSize.height) maps to the lower-right corner of the compatible render target.If the desiredPixelSize is specified and desiredSize is not, the DPI of the new render target is the same as the original render target.If both desiredSize and desiredPixelSize are specified, the DPI of the new render target is computed to account for the difference in scale.If neither desiredSize nor desiredPixelSize is specified, the new render target size and DPI match the original render target. 	
            </remarks>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="desiredSize">The desired size of the new render target in device-independent pixels if it should be different from the original render target. For more information, see the Remarks section.</param>
            <param name="desiredPixelSize">The desired size of the new render target in pixels if it should be different from the original render target. For more information, see the Remarks section.</param>
            <param name="desiredFormat">The desired pixel format and alpha mode of the new render target. If the pixel format is set to DXGI_FORMAT_UNKNOWN, the new render target uses the same pixel format as the original render target. If the alpha mode is <see cref="F:SharpDX.Direct2D1.AlphaMode.Unknown"/>, the alpha mode of the new render target defaults to D2D1_ALPHA_MODE_PREMULTIPLIED. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
            <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
            <unmanaged>HRESULT CreateCompatibleRenderTarget([In, Optional] const D2D1_SIZE_F* desiredSize,[In, Optional] const D2D1_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[None] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.BitmapRenderTarget.Bitmap">
            <summary>
            <p>Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </p>
            </summary>
            <remarks>
            <p>The DPI for the <strong><see cref = "T:SharpDX.Direct2D1.Bitmap"/></strong> obtained from <strong>GetBitmap</strong> will be the DPI of the <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> when the render target was created. Changing the DPI of the <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> by calling  <strong>SetDpi</strong> doesn't affect the DPI of the bitmap, even if <strong>SetDpi</strong> is called before <strong>GetBitmap</strong>. Using <strong>SetDpi</strong> to change the DPI of the <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by <strong>GetBitmap</strong>.</p>
            </remarks>
            <doc-id>dd371150</doc-id>
            <unmanaged>GetBitmap</unmanaged>
            <unmanaged-short>GetBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BitmapRenderTarget.GetBitmap(SharpDX.Direct2D1.Bitmap@)">
            <summary>
            <p>Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </p>
            </summary>
            <param name = "bitmap"><dd>  <p>When this method returns, contains the address of a reference to the bitmap for this render target. This bitmap can be used for drawing operations. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The DPI for the <strong><see cref = "T:SharpDX.Direct2D1.Bitmap"/></strong> obtained from <strong>GetBitmap</strong> will be the DPI of the <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> when the render target was created. Changing the DPI of the <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> by calling  <strong>SetDpi</strong> doesn't affect the DPI of the bitmap, even if <strong>SetDpi</strong> is called before <strong>GetBitmap</strong>. Using <strong>SetDpi</strong> to change the DPI of the <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by <strong>GetBitmap</strong>.</p>
            </remarks>
            <doc-id>dd371150</doc-id>
            <unmanaged>HRESULT ID2D1BitmapRenderTarget::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
            <unmanaged-short>ID2D1BitmapRenderTarget::GetBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BlendTransform.#ctor(SharpDX.Direct2D1.EffectContext,System.Int32,SharpDX.Direct2D1.BlendDescription)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.BlendTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="numInputs">The number of inputs.</param>
            <param name="blendDescription">The blend description</param>
        </member>
        <member name="M:SharpDX.Direct2D1.BlendTransform.#ctor(SharpDX.Direct2D1.EffectContext,System.Int32,SharpDX.Direct2D1.BlendDescription@)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.BlendTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="numInputs">The number of inputs.</param>
            <param name="blendDescription">The blend description</param>
        </member>
        <member name="P:SharpDX.Direct2D1.BlendTransform.Description">
            <summary>
            <p>Gets or sets the blend description of the corresponding blend transform object.</p>
            </summary>
            <doc-id>hh404363</doc-id>
            <unmanaged>GetDescription / SetDescription</unmanaged>
            <unmanaged-short>GetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BlendTransform.SetDescription(SharpDX.Direct2D1.BlendDescription@)">
            <summary>
            <p>Changes the blend description of the corresponding blend transform object.</p>
            </summary>
            <param name = "description"><dd>  <p>The new blend description specified for the blend transform.</p> </dd></param>
            <doc-id>hh404365</doc-id>
            <unmanaged>void ID2D1BlendTransform::SetDescription([In] const D2D1_BLEND_DESCRIPTION* description)</unmanaged>
            <unmanaged-short>ID2D1BlendTransform::SetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BlendTransform.GetDescription(SharpDX.Direct2D1.BlendDescription@)">
            <summary>
            <p>Gets the blend description of the corresponding blend transform object.</p>
            </summary>
            <param name = "description"><dd>  <p>When this method returns, contains the blend description specified for the blend transform.</p> </dd></param>
            <doc-id>hh404363</doc-id>
            <unmanaged>void ID2D1BlendTransform::GetDescription([Out] D2D1_BLEND_DESCRIPTION* description)</unmanaged>
            <unmanaged-short>ID2D1BlendTransform::GetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BorderTransform.#ctor(SharpDX.Direct2D1.EffectContext,SharpDX.Direct2D1.ExtendMode,SharpDX.Direct2D1.ExtendMode)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.BorderTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="extendModeX">The extend mode for X coordinates</param>
            <param name="extendModeY">The extend mode for Y coordinates</param>
            <unmanaged>HRESULT ID2D1EffectContext::CreateBorderTransform([In] D2D1_EXTEND_MODE extendModeX,[In] D2D1_EXTEND_MODE extendModeY,[Out, Fast] ID2D1BorderTransform** transform)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.BorderTransform.ExtendModeX">
            <summary>
            <p>Gets or sets the extend mode in the x direction.</p>
            </summary>
            <doc-id>hh404381</doc-id>
            <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>
            <unmanaged-short>GetExtendModeX</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.BorderTransform.ExtendModeY">
            <summary>
            <p>Gets or sets the extend mode in the y direction.</p>
            </summary>
            <doc-id>hh404383</doc-id>
            <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>
            <unmanaged-short>GetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BorderTransform.SetExtendModeX(SharpDX.Direct2D1.ExtendMode)">
            <summary>
            <p>Sets the extend mode in the x direction.</p>
            </summary>
            <param name = "extendMode"><dd>  <p>The extend mode in the x direction.</p> </dd></param>
            <remarks>
            <p>If the extend mode enumeration is invalid, this operation is ignored.</p>
            </remarks>
            <doc-id>hh404385</doc-id>
            <unmanaged>void ID2D1BorderTransform::SetExtendModeX([In] D2D1_EXTEND_MODE extendMode)</unmanaged>
            <unmanaged-short>ID2D1BorderTransform::SetExtendModeX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BorderTransform.SetExtendModeY(SharpDX.Direct2D1.ExtendMode)">
            <summary>
            <p>Sets the extend mode in the y direction.</p>
            </summary>
            <param name = "extendMode"><dd>  <p>The extend mode in the y direction.</p> </dd></param>
            <remarks>
            <p>If the extend mode enumeration is invalid, this operation is ignored.</p>
            </remarks>
            <doc-id>hh404387</doc-id>
            <unmanaged>void ID2D1BorderTransform::SetExtendModeY([In] D2D1_EXTEND_MODE extendMode)</unmanaged>
            <unmanaged-short>ID2D1BorderTransform::SetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BorderTransform.GetExtendModeX">
            <summary>
            <p>Gets the extend mode in the x direction.</p>
            </summary>
            <returns><p>This method returns the extend mode in the x direction.</p></returns>
            <doc-id>hh404381</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeX()</unmanaged>
            <unmanaged-short>ID2D1BorderTransform::GetExtendModeX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BorderTransform.GetExtendModeY">
            <summary>
            <p>Gets the extend mode in the y direction.</p>
            </summary>
            <returns><p>This method returns the extend mode in the y direction.</p></returns>
            <doc-id>hh404383</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeY()</unmanaged>
            <unmanaged-short>ID2D1BorderTransform::GetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BoundsAdjustmentTransform.#ctor(SharpDX.Direct2D1.EffectContext,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.BoundsAdjustmentTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="outputRectangle">The output rectangle region used for this transformation</param>
            <unmanaged>HRESULT ID2D1EffectContext::CreateBoundsAdjustmentTransform([In] const RECT* outputRectangle,[Out, Fast] ID2D1BoundsAdjustmentTransform** transform)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.BoundsAdjustmentTransform.OutputBounds">
            <summary>
            <p>Returns or sets the output rectangle of the support transform.</p>
            </summary>
            <doc-id>hh847964</doc-id>
            <unmanaged>GetOutputBounds / SetOutputBounds</unmanaged>
            <unmanaged-short>GetOutputBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BoundsAdjustmentTransform.SetOutputBounds(SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>
            <p>This sets the output bounds for the support transform.</p>
            </summary>
            <param name = "outputBounds"><dd>  <p>The output bounds.</p> </dd></param>
            <doc-id>hh847965</doc-id>
            <unmanaged>void ID2D1BoundsAdjustmentTransform::SetOutputBounds([In] const RECT* outputBounds)</unmanaged>
            <unmanaged-short>ID2D1BoundsAdjustmentTransform::SetOutputBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.BoundsAdjustmentTransform.GetOutputBounds(SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>
            <p>Returns the output rectangle of the support transform.</p>
            </summary>
            <param name = "outputBounds"><dd>  <p>The output bounds.</p> </dd></param>
            <doc-id>hh847964</doc-id>
            <unmanaged>void ID2D1BoundsAdjustmentTransform::GetOutputBounds([Out] RECT* outputBounds)</unmanaged>
            <unmanaged-short>ID2D1BoundsAdjustmentTransform::GetOutputBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext.#ctor(SharpDX.Direct2D1.EffectContext,SharpDX.Direct2D1.ColorSpace,System.Byte[])">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext"/> class from a color profile.
            </summary>
            <param name="context">The effect context.</param>
            <param name="space">The space of color context to create.</param>	
            <param name="profileRef">No documentation.</param>	
            <unmanaged>HRESULT ID2D1EffectContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out] ID2D1ColorContext** colorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext.#ctor(SharpDX.Direct2D1.EffectContext,System.String)">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext"/> class from a filename.
            </summary>	
            <param name="context">The effect context.</param>	
            <param name="filename">The path to the file containing the profile bytes to initialize the color context with..</param>	
            <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out] ID2D1ColorContext** colorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext.#ctor(SharpDX.Direct2D1.EffectContext,SharpDX.WIC.ColorContext)">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext"/> class from WIC color context.
            </summary>	
            <param name="context">No documentation.</param>	
            <param name="wicColorContext">No documentation.</param>	
            <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out] ID2D1ColorContext** colorContext)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.ColorContext.ProfileData">
            <summary>
            Gets the profile data.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.ColorContext.ColorSpace">
            <summary>
            <p>Gets the color space  of the color context.</p>
            </summary>
            <doc-id>dn890780</doc-id>
            <unmanaged>GetColorSpace</unmanaged>
            <unmanaged-short>GetColorSpace</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ColorContext.ProfileSize">
            <summary>
            <p>Gets the size of the color profile associated with the bitmap. 	</p>
            </summary>
            <remarks>
            <p>This can be used to allocate a buffer to receive the color profile bytes associated with the context.</p>
            </remarks>
            <doc-id>hh404390</doc-id>
            <unmanaged>GetProfileSize</unmanaged>
            <unmanaged-short>GetProfileSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext.GetColorSpace">
            <summary>
            <p>Gets the color space  of the color context.</p>
            </summary>
            <returns><p>This method returns the color space of the contained ICC profile.</p></returns>
            <doc-id>dn890780</doc-id>
            <unmanaged>D2D1_COLOR_SPACE ID2D1ColorContext::GetColorSpace()</unmanaged>
            <unmanaged-short>ID2D1ColorContext::GetColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext.GetProfileSize">
            <summary>
            <p>Gets the size of the color profile associated with the bitmap. 	</p>
            </summary>
            <returns><p>This method returns the  size of the profile in bytes.</p></returns>
            <remarks>
            <p>This can be used to allocate a buffer to receive the color profile bytes associated with the context.</p>
            </remarks>
            <doc-id>hh404390</doc-id>
            <unmanaged>unsigned int ID2D1ColorContext::GetProfileSize()</unmanaged>
            <unmanaged-short>ID2D1ColorContext::GetProfileSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext.GetProfile(System.Byte[],System.Int32)">
            <summary>
            <p>Gets the color profile bytes for an <strong><see cref = "T:SharpDX.Direct2D1.ColorContext"/></strong>. </p>
            </summary>
            <param name = "rofileRef">No documentation.</param>
            <param name = "profileSize">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "!:InsufficientBuffer"/></td><td>The supplied buffer was too small to accomodate the data.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If <em>profileSize</em> is insufficient to store the entire profile, <em>profile</em> is zero-initialized before this method fails.</p>
            </remarks>
            <doc-id>hh404389</doc-id>
            <unmanaged>HRESULT ID2D1ColorContext::GetProfile([Out, Buffer] unsigned char* profile,[In] unsigned int profileSize)</unmanaged>
            <unmanaged-short>ID2D1ColorContext::GetProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.#ctor(SharpDX.Direct2D1.DeviceContext5,SharpDX.DXGI.ColorSpaceType)">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext1"/> class from ColorSpaceType.
            </summary>	
            <param name="context">No documentation.</param>	
            <param name="wicColorContext">No documentation.</param>	
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.#ctor(SharpDX.Direct2D1.DeviceContext5,SharpDX.Direct2D1.SimpleColorProfile@)">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext1"/> class from SimpleColorProfile.
            </summary>	
            <param name="context">No documentation.</param>	
            <param name="wicColorContext">No documentation.</param>	
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.#ctor(SharpDX.Direct2D1.EffectContext2,SharpDX.DXGI.ColorSpaceType)">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext1"/> class from ColorSpaceType.
            </summary>	
            <param name="context">No documentation.</param>	
            <param name="wicColorContext">No documentation.</param>	
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.#ctor(SharpDX.Direct2D1.EffectContext2,SharpDX.Direct2D1.SimpleColorProfile@)">
            <summary>	
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.ColorContext1"/> class from SimpleColorProfile.
            </summary>	
            <param name="context">No documentation.</param>	
            <param name="wicColorContext">No documentation.</param>	
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.ColorContext1.ColorContextType">
            <summary>
            <p>Represents a color context to be used with the Color Management Effect.</p>
            </summary>
            <doc-id>mt797797</doc-id>
            <unmanaged>GetColorContextType</unmanaged>
            <unmanaged-short>GetColorContextType</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ColorContext1.DXGIColorSpace">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDXGIColorSpace</unmanaged>
            <unmanaged-short>GetDXGIColorSpace</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ColorContext1.SimpleColorProfile">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetSimpleColorProfile</unmanaged>
            <unmanaged-short>GetSimpleColorProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.GetColorContextType">
            <summary>
            <p>Represents a color context to be used with the Color Management Effect.</p>
            </summary>
            <returns>No documentation.</returns>
            <doc-id>mt797797</doc-id>
            <unmanaged>D2D1_COLOR_CONTEXT_TYPE ID2D1ColorContext1::GetColorContextType()</unmanaged>
            <unmanaged-short>ID2D1ColorContext1::GetColorContextType</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.GetDXGIColorSpace">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>DXGI_COLOR_SPACE_TYPE ID2D1ColorContext1::GetDXGIColorSpace()</unmanaged>
            <unmanaged-short>ID2D1ColorContext1::GetDXGIColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ColorContext1.GetSimpleColorProfile(SharpDX.Direct2D1.SimpleColorProfile@)">
            <summary>
            No documentation.
            </summary>
            <param name = "simpleProfile">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1ColorContext1::GetSimpleColorProfile([Out] D2D1_SIMPLE_COLOR_PROFILE* simpleProfile)</unmanaged>
            <unmanaged-short>ID2D1ColorContext1::GetSimpleColorProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandList.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.CommandList"/> class.
            </summary>
            <param name="deviceContext">The device context.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandList.Stream(SharpDX.Direct2D1.CommandSink)">
            <summary>
            <p>Streams the contents of the command list  to the specified command sink. </p>
            </summary>
            <param name = "sink"><dd>  <p>The sink into which the command list will be streamed.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p><p>The return value indicates any failures the command sink implementation  returns through its <strong>EndDraw</strong> method.</p></returns>
            <remarks>
            <p>The command sink can be implemented by any caller of the API.</p><p>If the caller makes any design-time failure calls while a command list is selected as a target, the command list is placed in an error state. The stream call fails without making any calls to the passed in sink.</p><p>Sample use:</p><pre>Class MyCommandSink : public <see cref = "T:SharpDX.Direct2D1.CommandSink"/>
            {
            public: // All of the <see cref = "T:SharpDX.Direct2D1.CommandSink"/> methods implemented here.
            }; <see cref = "T:SharpDX.Result"/>
            StreamToMyCommandSink( __in <see cref = "T:SharpDX.Direct2D1.CommandList"/> *pCommandList  )
            { <see cref = "T:SharpDX.Result"/> hr = <see cref = "F:SharpDX.Result.Ok"/>; MyCommandSink *pCommandSink = new MyCommandSink(); hr = pCommandSink ? <see cref = "F:SharpDX.Result.Ok"/> : E_OUTOFMEMORY; if (SUCCEEDED(hr)) { // Receive the contents of the command sink streamed to the sink. hr = pCommandList-&gt;Stream(pCommandSink); } SafeRelease(&amp;pCommandSink); return hr; }</pre>
            </remarks>
            <doc-id>hh404393</doc-id>
            <unmanaged>HRESULT ID2D1CommandList::Stream([In] ID2D1CommandSink* sink)</unmanaged>
            <unmanaged-short>ID2D1CommandList::Stream</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandList.Close">
            <summary>
            <p>Instructs the command list to stop accepting commands so that you can use it as an input to an effect or in a call to <strong>ID2D1DeviceContext::DrawImage</strong>.  You should call the method after it has been attached to an <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext"/></strong> and written to but before the command list is used.</p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "!:WrongState"/> </td><td>Close has already been called on the command list.</td></tr> </table><p>?</p><p> </p><strong>Note</strong>??If the device context associated with the command list has an error, the command list returns the same error.?</returns>
            <remarks>
            <p>This method returns <see cref = "!:WrongState"/> if it has already been called on the command list. If an error occurred on the device context during population, the method returns that error. Otherwise, the method returns <see cref = "F:SharpDX.Result.Ok"/>. </p><p>If the <strong>Close</strong> method returns an error, any future use of the command list results in the same error.</p>
            </remarks>
            <doc-id>hh871450</doc-id>
            <unmanaged>HRESULT ID2D1CommandList::Close()</unmanaged>
            <unmanaged-short>ID2D1CommandList::Close</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.BeginDraw">
            <summary>	
            Begins a draw sequence.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.EndDraw">
            <summary>	
            Ends a draw sequence.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink.AntialiasMode">
            <summary>	
            Sets the antialias mode.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.SetTags(System.Int64,System.Int64)">
            <summary>	
            Sets tags.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink.TextAntialiasMode">
            <summary>	
            Sets the text antialias mode.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink.TextRenderingParams">
            <summary>	
            Sets the parameters for text rendering.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink.Transform">
            <summary>	
            Sets the matrix transform.
            </summary>	
            <remarks>	
            The transform will be applied to the corresponding device context.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink.PrimitiveBlend">
            <summary>	
            Sets the blending for primitives.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink.UnitMode">
            <summary>	
            Sets the unit mode
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.Clear(System.Nullable{SharpDX.Mathematics.Interop.RawColor4})">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="color"><para>The color to which the command sink should be cleared.</para></param>	
            <remarks>	
            The clear color is restricted by the currently selected clip and layer bounds.If no color is specified, the color should be interpreted by context. Examples include but are not limited to:Transparent black for a premultiplied bitmap target. Opaque black for an ignore bitmap target. Containing no content (or white) for a printer page.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.MeasuringMode)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="baselineOrigin"><para>The sequence of  glyphs to be sent.</para></param>	
            <param name="glyphRun"><para>Additional non-rendering information about the glyphs.</para></param>	
            <param name="glyphRunDescription"><para>The brush used to fill the glyphs.</para></param>	
            <param name="foregroundBrush"><para>The measuring mode to apply to the glyphs.</para></param>	
            <param name="measuringMode">No documentation.</param>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawLine(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="point0"><para>The start point of the line.</para></param>	
            <param name="point1"><para>The end point of the line.</para></param>	
            <param name="brush"><para>The brush used to fill the line.</para></param>	
            <param name="strokeWidth"><para>The width of the stroke to fill the line.</para></param>	
            <param name="strokeStyle"><para>The style of the stroke. If not specified, the stroke is solid.</para></param>	
            <remarks>	
            Additional References	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="geometry"><para>The geometry to be stroked.</para></param>	
            <param name="brush"><para>The brush that will be used to fill the stroked geometry.</para></param>	
            <param name="strokeWidth"><para>The width of the stroke.</para></param>	
            <param name="strokeStyle"><para>The style of the stroke.</para></param>	
            <remarks>	
            You must convert ellipses and rounded rectangles to the corresponding ellipse and rounded rectangle geometries before calling into the DrawGeometry method.Additional ReferencesID2D1CommandList::Stream, <see cref="M:SharpDX.Direct2D1.RenderTarget.DrawGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush)"/>RequirementsMinimum supported operating systemSame as Interface / Class Highest IRQL levelN/A (user mode) Callable from DlllMain()No Callable from services and session 0Yes Callable from UI threadYes?	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="rect">No documentation.</param>	
            <param name="brush">No documentation.</param>	
            <param name="strokeWidth">No documentation.</param>	
            <param name="strokeStyle">No documentation.</param>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Single,SharpDX.Direct2D1.InterpolationMode,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawMatrix})">
            <summary>	
            No documentation.	
            </summary>	
            <param name="bitmap">No documentation.</param>	
            <param name="destinationRectangle">No documentation.</param>	
            <param name="opacity">No documentation.</param>	
            <param name="interpolationMode">No documentation.</param>	
            <param name="sourceRectangle">No documentation.</param>	
            <param name="erspectiveTransformRef">No documentation.</param>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawImage(SharpDX.Direct2D1.Image,System.Nullable{SharpDX.Mathematics.Interop.RawVector2},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="image"><para>The image to be drawn to the command sink.</para></param>	
            <param name="targetOffset"><para>This defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image will be rendered to the corresponding destination. If not specified, the destination origin will be (0, 0). The top-left corner of the image will be mapped to the target offset. This will not necessarily be the origin.</para></param>	
            <param name="imageRectangle"><para>The corresponding rectangle in the image space will be mapped to the provided origins when processing the image.</para></param>	
            <param name="interpolationMode"><para>The interpolation mode that will be used to scale the image if necessary.</para></param>	
            <param name="compositeMode"><para>If specified, the composite mode that will be applied to the limits of the currently selected clip.</para></param>	
            <remarks>	
            Because the image can itself be a command list or contain an effect graph that in turn contains a command list, this method can result in recursive processing.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawVector2})">
            <summary>	
            No documentation.	
            </summary>	
            <param name="gdiMetafile">No documentation.</param>	
            <param name="targetOffset">No documentation.</param>	
            <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.FillMesh(SharpDX.Direct2D1.Mesh,SharpDX.Direct2D1.Brush)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="mesh"><para>The mesh object to be filled.</para></param>	
            <param name="brush"><para>The brush with which to fill the mesh.</para></param>	
            <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.FillOpacityMask(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="opacityMask"><para>The bitmap whose alpha channel will be sampled to define the opacity mask.</para></param>	
            <param name="brush"><para>The brush with which to fill the mask.</para></param>	
            <param name="destinationRectangle"><para>The type of content that the mask represents.</para></param>	
            <param name="sourceRectangle"><para>The destination rectangle in which to fill the mask. If not specified, this is the origin.</para></param>	
            <remarks>	
            The opacity mask bitmap must be considered to be clamped on each axis.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.FillGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.Brush)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="geometry"><para>The geometry that should be filled.</para></param>	
            <param name="brush"><para>The primary brush used to fill the geometry.</para></param>	
            <param name="opacityBrush"><para>A brush whose alpha channel is used to modify the opacity of the primary fill brush.  </para></param>	
            <remarks>	
            If the opacity brush is specified, the primary brush will be a bitmap brush fixed on both the x-axis and the y-axis.Ellipses and rounded rectangles are converted to the corresponding geometry before being passed to FillGeometry.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.FillRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="rect"><para>The rectangle to fill.</para></param>	
            <param name="brush"><para>The brush with which to fill the rectangle.</para></param>	
            <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.PushAxisAlignedClip(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.AntialiasMode)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="clipRect"><para>The rectangle that defines the clip.</para></param>	
            <param name="antialiasMode"><para>Whether the given clip should be antialiased.</para></param>	
            <remarks>	
            If the current world transform is not preserving the axis, clipRectangle is transformed and the bounds of the transformed rectangle are used instead.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.PushLayer(SharpDX.Direct2D1.LayerParameters1@,SharpDX.Direct2D1.Layer)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="layerParameters1">No documentation.</param>	
            <param name="layer">No documentation.</param>	
            <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.PopAxisAlignedClip">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink.PopLayer">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink1.PrimitiveBlend1">
            <summary>	
            <p>Enables access to the new primitive blend modes, MIN and ADD.</p>	
            </summary>	
            <param name="value">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink1::SetPrimitiveBlend1']/*" />	
            <msdn-id>dn280436</msdn-id>	
            <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink1::SetPrimitiveBlend1</unmanaged-short>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink1Native.PrimitiveBlend1">
            <summary>	
            <p>Enables access to the new primitive blend modes, MIN and ADD.</p>	
            </summary>	
            <param name="value">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink1::SetPrimitiveBlend1']/*" />	
            <msdn-id>dn280436</msdn-id>	
            <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink1::SetPrimitiveBlend1</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink1Native.PrimitiveBlend1_">
            <summary>
            <p>Sets a new primitive blend mode. </p>
            </summary>
            <doc-id>dn280438</doc-id>
            <unmanaged>SetPrimitiveBlend1</unmanaged>
            <unmanaged-short>SetPrimitiveBlend1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink1Native.SetPrimitiveBlend1_(SharpDX.Direct2D1.PrimitiveBlend)">
            <summary>
            <p>Sets a new primitive blend mode. </p>
            </summary>
            <param name = "primitiveBlend"><dd>  <p>The primitive blend that will apply to subsequent primitives.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>dn280438</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
            <unmanaged-short>ID2D1CommandSink1::SetPrimitiveBlend1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink1Shadow.ToIntPtr(SharpDX.Direct2D1.CommandSink1)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSink1Shadow.CommandSink1Vtbl.SetPrimitiveBlend1Delegate">
            <summary>	
            Sets the blending for primitives.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2.DrawInk(SharpDX.Direct2D1.Ink,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.InkStyle)">
            <summary>	
            No documentation for Direct3D12	
            </summary>	
            <param name="ink">No documentation.</param>	
            <param name="brush">No documentation.</param>	
            <param name="inkStyle">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink2::DrawInk']/*" />	
            <unmanaged>HRESULT ID2D1CommandSink2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink2::DrawInk</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2.DrawGradientMesh(SharpDX.Direct2D1.GradientMesh)">
            <summary>	
            No documentation for Direct3D12	
            </summary>	
            <param name="gradientMesh">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink2::DrawGradientMesh']/*" />	
            <unmanaged>HRESULT ID2D1CommandSink2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink2::DrawGradientMesh</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2.DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>	
            No documentation for Direct3D12	
            </summary>	
            <param name="gdiMetafile">No documentation.</param>	
            <param name="destinationRectangle">No documentation.</param>	
            <param name="sourceRectangle">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink2::DrawGdiMetafile']/*" />	
            <unmanaged>HRESULT ID2D1CommandSink2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink2::DrawGdiMetafile</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2Native.DrawInk(SharpDX.Direct2D1.Ink,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.InkStyle)">
            <summary>	
            No documentation for Direct3D12	
            </summary>	
            <param name="ink">No documentation.</param>	
            <param name="brush">No documentation.</param>	
            <param name="inkStyle">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink2::DrawInk']/*" />	
            <unmanaged>HRESULT ID2D1CommandSink2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink2::DrawInk</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2Native.DrawGradientMesh(SharpDX.Direct2D1.GradientMesh)">
            <summary>	
            No documentation for Direct3D12	
            </summary>	
            <param name="gradientMesh">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink2::DrawGradientMesh']/*" />	
            <unmanaged>HRESULT ID2D1CommandSink2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink2::DrawGradientMesh</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2Native.DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>	
            No documentation for Direct3D12	
            </summary>	
            <param name="gdiMetafile">No documentation.</param>	
            <param name="destinationRectangle">No documentation.</param>	
            <param name="sourceRectangle">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink2::DrawGdiMetafile']/*" />	
            <unmanaged>HRESULT ID2D1CommandSink2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink2::DrawGdiMetafile</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2Native.DrawInk_(SharpDX.Direct2D1.Ink,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.InkStyle)">
            <summary>
            <p>Renders the given ink object using the given brush and ink style.</p>
            </summary>
            <param name = "ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>
            <param name = "inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>
            <returns><p>This method does not return a value.</p></returns>
            <doc-id>dn890784</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>
            <unmanaged-short>ID2D1CommandSink2::DrawInk</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2Native.DrawGradientMesh_(SharpDX.Direct2D1.GradientMesh)">
            <summary>
            <p>Renders a given gradient mesh to the target.</p>
            </summary>
            <param name = "gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>
            <returns><p>This method does not return a value.</p></returns>
            <doc-id>dn890783</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>
            <unmanaged-short>ID2D1CommandSink2::DrawGradientMesh</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink2Native.DrawGdiMetafile_(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>
            <p>Draws a metafile to the command sink using the given source and destination rectangles.</p>
            </summary>
            <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs). If <c>null</c> is specified, the destination rectangle is the size of the target.</p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs).  If <c>null</c> is specified, the source rectangle is the value returned by <strong>ID2D1GdiMetafile1::GetSourceBounds</strong>.</p> </dd></param>
            <returns><p>This method does not return a value.</p></returns>
            <doc-id>dn890782</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1CommandSink2::DrawGdiMetafile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink3.DrawSpriteBatch(SharpDX.Direct2D1.SpriteBatch,System.Int32,System.Int32,SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.BitmapInterpolationMode,SharpDX.Direct2D1.SpriteOptions)">
            <summary>	
            <p>Renders part or all of the given sprite batch to the device context using the specified drawing options.</p>	
            </summary>	
            <param name="spriteBatch"><dd>  <p>The sprite batch to draw.</p> </dd></param>	
            <param name="startIndex"><dd>  <p>The index of the first sprite in the sprite batch to draw.</p> </dd></param>	
            <param name="spriteCount"><dd>  <p>The number of sprites to draw.</p> </dd></param>	
            <param name="bitmap"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>	
            <param name="interpolationMode"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>	
            <param name="spriteOptions"><dd>  <p>The additional drawing options, if any, to be used for this sprite batch.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink3::DrawSpriteBatch']/*" />	
            <msdn-id>mt619823</msdn-id>	
            <unmanaged>HRESULT ID2D1CommandSink3::DrawSpriteBatch([In] ID2D1SpriteBatch* spriteBatch,[In] unsigned int startIndex,[In] unsigned int spriteCount,[In] ID2D1Bitmap* bitmap,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In] D2D1_SPRITE_OPTIONS spriteOptions)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink3::DrawSpriteBatch</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink3Native.DrawSpriteBatch(SharpDX.Direct2D1.SpriteBatch,System.Int32,System.Int32,SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.BitmapInterpolationMode,SharpDX.Direct2D1.SpriteOptions)">
            <summary>	
            <p>Renders part or all of the given sprite batch to the device context using the specified drawing options.</p>	
            </summary>	
            <param name="spriteBatch"><dd>  <p>The sprite batch to draw.</p> </dd></param>	
            <param name="startIndex"><dd>  <p>The index of the first sprite in the sprite batch to draw.</p> </dd></param>	
            <param name="spriteCount"><dd>  <p>The number of sprites to draw.</p> </dd></param>	
            <param name="bitmap"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>	
            <param name="interpolationMode"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>	
            <param name="spriteOptions"><dd>  <p>The additional drawing options, if any, to be used for this sprite batch.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink3::DrawSpriteBatch']/*" />	
            <msdn-id>mt619823</msdn-id>	
            <unmanaged>HRESULT ID2D1CommandSink3::DrawSpriteBatch([In] ID2D1SpriteBatch* spriteBatch,[In] unsigned int startIndex,[In] unsigned int spriteCount,[In] ID2D1Bitmap* bitmap,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In] D2D1_SPRITE_OPTIONS spriteOptions)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink3::DrawSpriteBatch</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink3Native.DrawSpriteBatch_(SharpDX.Direct2D1.SpriteBatch,System.Int32,System.Int32,SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.BitmapInterpolationMode,SharpDX.Direct2D1.SpriteOptions)">
            <summary>
            <p>Renders part or all of the given sprite batch to the device context using the specified drawing options.</p>
            </summary>
            <param name = "spriteBatch"><dd>  <p>The sprite batch to draw.</p> </dd></param>
            <param name = "startIndex"><dd>  <p>The index of the first sprite in the sprite batch to draw.</p> </dd></param>
            <param name = "spriteCount"><dd>  <p>The number of sprites to draw.</p> </dd></param>
            <param name = "bitmap"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>
            <param name = "spriteOptions"><dd>  <p>The additional drawing options, if any, to be used for this sprite batch.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt619823</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink3::DrawSpriteBatch([In] ID2D1SpriteBatch* spriteBatch,[In] unsigned int startIndex,[In] unsigned int spriteCount,[In] ID2D1Bitmap* bitmap,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In] D2D1_SPRITE_OPTIONS spriteOptions)</unmanaged>
            <unmanaged-short>ID2D1CommandSink3::DrawSpriteBatch</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink4.SetPrimitiveBlend2(SharpDX.Direct2D1.PrimitiveBlend)">
            <summary>	
            <p>Sets a new primitive blend mode. Allows access to the MAX primitive blend mode.</p>	
            </summary>	
            <param name="primitiveBlend">The primitive blend that will apply to subsequent primitives.</param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink4::SetPrimitiveBlend2']/*" />	
            <msdn-id>mt797802</msdn-id>	
            <unmanaged>HRESULT ID2D1CommandSink4::SetPrimitiveBlend2([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink4::SetPrimitiveBlend2</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink4Native.SetPrimitiveBlend2(SharpDX.Direct2D1.PrimitiveBlend)">
            <summary>	
            <p>Sets a new primitive blend mode. Allows access to the MAX primitive blend mode.</p>	
            </summary>	
            <param name="primitiveBlend">The primitive blend that will apply to subsequent primitives.</param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1CommandSink4::SetPrimitiveBlend2']/*" />	
            <msdn-id>mt797802</msdn-id>	
            <unmanaged>HRESULT ID2D1CommandSink4::SetPrimitiveBlend2([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
            <unmanaged-short>ID2D1CommandSink4::SetPrimitiveBlend2</unmanaged-short>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSink4Native.PrimitiveBlend2_">
            <summary>
            No documentation.
            </summary>
            <unmanaged>SetPrimitiveBlend2</unmanaged>
            <unmanaged-short>SetPrimitiveBlend2</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSink4Native.SetPrimitiveBlend2_(SharpDX.Direct2D1.PrimitiveBlend)">
            <summary>
            No documentation.
            </summary>
            <param name = "primitiveBlend">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1CommandSink4::SetPrimitiveBlend2([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
            <unmanaged-short>ID2D1CommandSink4::SetPrimitiveBlend2</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.BeginDraw">
            <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.EndDraw">
            <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.AntialiasMode">
            <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetTags(System.Int64,System.Int64)">
            <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.TextAntialiasMode">
            <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.TextRenderingParams">
            <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.Transform">
            <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.PrimitiveBlend">
            <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.UnitMode">
            <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.Clear(System.Nullable{SharpDX.Mathematics.Interop.RawColor4})">
            <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.MeasuringMode)">
            <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawLine(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Single,SharpDX.Direct2D1.InterpolationMode,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawMatrix})">
            <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawImage(SharpDX.Direct2D1.Image,System.Nullable{SharpDX.Mathematics.Interop.RawVector2},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawVector2})">
            <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillMesh(SharpDX.Direct2D1.Mesh,SharpDX.Direct2D1.Brush)">
            <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillOpacityMask(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.Brush)">
            <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush)">
            <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PushAxisAlignedClip(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.AntialiasMode)">
            <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PushLayer(SharpDX.Direct2D1.LayerParameters1@,SharpDX.Direct2D1.Layer)">
            <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PopAxisAlignedClip">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PopLayer">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.AntialiasMode_">
            <summary>
            <p>Sets the antialiasing mode that will be used to render any subsequent geometry.</p>
            </summary>
            <doc-id>hh404420</doc-id>
            <unmanaged>SetAntialiasMode</unmanaged>
            <unmanaged-short>SetAntialiasMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.TextAntialiasMode_">
            <summary>
            <p>Indicates the new default antialiasing mode for text.</p>
            </summary>
            <doc-id>hh404423</doc-id>
            <unmanaged>SetTextAntialiasMode</unmanaged>
            <unmanaged-short>SetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.TextRenderingParams_">
            <summary>
            <p>Indicates more detailed text rendering parameters.</p>
            </summary>
            <doc-id>hh404424</doc-id>
            <unmanaged>SetTextRenderingParams</unmanaged>
            <unmanaged-short>SetTextRenderingParams</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.Transform_">
            <summary>
            <p>Sets a new transform.</p>
            </summary>
            <remarks>
            <p>The transform will be applied to the corresponding device context.</p>
            </remarks>
            <doc-id>hh404425</doc-id>
            <unmanaged>SetTransform</unmanaged>
            <unmanaged-short>SetTransform</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.PrimitiveBlend_">
            <summary>
            <p>Sets a new primitive blend mode.</p>
            </summary>
            <doc-id>hh404421</doc-id>
            <unmanaged>SetPrimitiveBlend</unmanaged>
            <unmanaged-short>SetPrimitiveBlend</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.CommandSinkNative.UnitMode_">
            <summary>
            <p>The unit mode changes the meaning of subsequent units from device-independent pixels (DIPs) to pixels  or the other way. The command sink does not record a DPI, this is implied by the playback context or other playback interface such as <strong><see cref = "T:SharpDX.Direct2D1.PrintControl"/></strong>.</p>
            </summary>
            <remarks>
            <p>The unit mode changes the interpretation of units from DIPs to pixels  or vice versa.</p>
            </remarks>
            <doc-id>hh404426</doc-id>
            <unmanaged>SetUnitMode</unmanaged>
            <unmanaged-short>SetUnitMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.BeginDraw_">
            <summary>
            <p>Notifies the implementation of the command sink that drawing is about to commence.</p>
            </summary>
            <returns><p> This method always returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. </p></returns>
            <doc-id>hh404395</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>
            <unmanaged-short>ID2D1CommandSink::BeginDraw</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.EndDraw_">
            <summary>
            <p>Indicates when  <strong><see cref = "T:SharpDX.Direct2D1.CommandSink"/></strong> processing has completed.</p>
            </summary>
            <returns><p>If the method/function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.Result"/></strong> active at the end of the command list will be returned.</p><p> It allows the calling function or method to indicate a failure back to the stream implementation.</p>
            </remarks>
            <doc-id>hh404409</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>
            <unmanaged-short>ID2D1CommandSink::EndDraw</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetAntialiasMode_(SharpDX.Direct2D1.AntialiasMode)">
            <summary>
            <p>Sets the antialiasing mode that will be used to render any subsequent geometry.</p>
            </summary>
            <param name = "antialiasMode"><dd>  <p>The antialiasing mode selected for the command list.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404420</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetTags_(System.Int64,System.Int64)">
            <summary>
            <p>Sets the tags that correspond to the tags in the command sink.</p>
            </summary>
            <param name = "tag1"><dd>  <p>The first tag to associate with the primitive.</p> </dd></param>
            <param name = "tag2"><dd>  <p>The second tag to associate with the primitive.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404422</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetTags</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetTextAntialiasMode_(SharpDX.Direct2D1.TextAntialiasMode)">
            <summary>
            <p>Indicates the new default antialiasing mode for text.</p>
            </summary>
            <param name = "textAntialiasMode"><dd>  <p>The antialiasing mode for the text.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404423</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetTextRenderingParams_(SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p>Indicates more detailed text rendering parameters.</p>
            </summary>
            <param name = "textRenderingParams"><dd>  <p>The parameters to use for text rendering.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404424</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetTextRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetTransform_(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Sets a new transform.</p>
            </summary>
            <param name = "transform"><dd>  <p>The transform to be set.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>The transform will be applied to the corresponding device context.</p>
            </remarks>
            <doc-id>hh404425</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetPrimitiveBlend_(SharpDX.Direct2D1.PrimitiveBlend)">
            <summary>
            <p>Sets a new primitive blend mode.</p>
            </summary>
            <param name = "primitiveBlend"><dd>  <p>The primitive blend that will apply to subsequent primitives.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404421</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetPrimitiveBlend</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.SetUnitMode_(SharpDX.Direct2D1.UnitMode)">
            <summary>
            <p>The unit mode changes the meaning of subsequent units from device-independent pixels (DIPs) to pixels  or the other way. The command sink does not record a DPI, this is implied by the playback context or other playback interface such as <strong><see cref = "T:SharpDX.Direct2D1.PrintControl"/></strong>.</p>
            </summary>
            <param name = "unitMode">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>The unit mode changes the interpretation of units from DIPs to pixels  or vice versa.</p>
            </remarks>
            <doc-id>hh404426</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::SetUnitMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.Clear_(System.Nullable{SharpDX.Mathematics.Interop.RawColor4})">
            <summary>
            <p>Clears the drawing area to the specified color.  </p>
            </summary>
            <param name = "color"><dd>  <p>The color to which the command sink should be cleared.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>The clear color is restricted by the currently selected clip and layer bounds.</p><p>If no color is specified, the color should be interpreted by context. Examples include but are not limited to:</p><ul> <li>Transparent black for a premultiplied bitmap target.</li> <li>Opaque black for an ignore bitmap target.</li> <li>Containing no content (or white) for a printer page.</li> </ul>
            </remarks>
            <doc-id>hh404397</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::Clear</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawGlyphRun_(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p>Indicates the glyphs to be drawn.</p>
            </summary>
            <param name = "baselineOrigin"><dd>  <p>The upper left corner of the baseline.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
            <param name = "glyphRunDescription"><dd>  <p>Additional non-rendering information about the glyphs.</p> </dd></param>
            <param name = "foregroundBrush"><dd>  <p>The brush used to fill the glyphs.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>The measuring mode to apply to the glyphs.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p> <strong>DrawText</strong> and <strong>DrawTextLayout</strong> are broken down into glyph runs and rectangles by the time the command sink is processed. So, these methods aren't available on the command sink. Since the application may require additional callback processing when calling <strong>DrawTextLayout</strong>, this semantic can't be easily preserved in the command list.</p>
            </remarks>
            <doc-id>hh404401</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawLine_(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Draws a line drawn between two points.</p>
            </summary>
            <param name = "point0"><dd>  <p>The start point of the line.</p> </dd></param>
            <param name = "point1"><dd>  <p>The end point of the line.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to fill the line.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke to fill the line.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of the stroke. If not specified, the stroke is solid.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404405</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawLine</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawGeometry_(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Indicates the geometry to be drawn to the command sink.</p>
            </summary>
            <param name = "geometry"><dd>  <p>The geometry to be stroked.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush that will be used to fill the stroked geometry.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>
            <returns><p>An <see cref = "T:SharpDX.Result"/>. </p></returns>
            <remarks>
            <p> <strong>Ellipses</strong> and <strong>rounded rectangles</strong> are converted to the corresponding ellipse and rounded rectangle geometries before calling into the <strong>DrawGeometry</strong> method.
            </p>
            </remarks>
            <doc-id>hh404399</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawRectangle_(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Draws a rectangle.</p>
            </summary>
            <param name = "rect"><dd>  <p>The rectangle to be drawn to the command sink.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to stroke the geometry.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404407</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawBitmap_(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Single,SharpDX.Direct2D1.InterpolationMode,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawMatrix})">
            <summary>
            <p>Draws a bitmap to the render target.</p>
            </summary>
            <param name = "bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>
            <param name = "opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>
            <param name = "erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>
            <returns><p>This method does not return a value.</p></returns>
            <remarks>
            <p>The <em>destinationRectangle</em> parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If you specify <c>null</c>, then the destination rectangle is (left=0, top=0, right = width(<em>sourceRectangle</em>), bottom = height(<em>sourceRectangle</em>). </p><p>The <em>sourceRectangle</em> defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> clips this rectangle to the size of the source bitmap, so it's impossible to sample outside of the bitmap.  If you specify <c>null</c>, then the source rectangle is taken to be the size of the source bitmap. </p><p>The <em>perspectiveTransform</em> is specified in addition to the transform on device context.
            </p>
            </remarks>
            <doc-id>hh847972</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawImage_(SharpDX.Direct2D1.Image,System.Nullable{SharpDX.Mathematics.Interop.RawVector2},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>
            <p>Draws the provided image to the command sink.  </p>
            </summary>
            <param name = "image"><dd>  <p>The image to be drawn to the command sink.</p> </dd></param>
            <param name = "targetOffset"><dd>  <p>This defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image will be rendered to the corresponding destination. If not specified, the destination origin will be (0, 0). The top-left corner of the image will be mapped to the target offset. This will not necessarily be the origin.</p> </dd></param>
            <param name = "imageRectangle"><dd>  <p>The corresponding rectangle in the image space will be mapped to the provided origins when processing the image.</p> </dd></param>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode to use to  scale the image if necessary.</p> </dd></param>
            <param name = "compositeMode"><dd>  <p>If specified, the composite mode that will be applied to the limits of the currently selected clip.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>Because the image can itself be a command list or contain an effect graph that in turn contains a command list, this method can result in recursive processing.</p>
            </remarks>
            <doc-id>hh404403</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.DrawGdiMetafile_(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawVector2})">
            <summary>
            <p>Draw a metafile to the device context.</p>
            </summary>
            <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
            <param name = "targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>
            <returns><p>This method does not return a value.</p></returns>
            <remarks>
            <p>The <em>targetOffset</em> defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image is rendered to the corresponding destination. If you don't specify the offset, the destination origin will be (0, 0). The top, left corner of the image will be mapped to the target offset. This will not necessarily be the origin.
            </p>
            </remarks>
            <doc-id>hh847973</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::DrawGdiMetafile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillMesh_(SharpDX.Direct2D1.Mesh,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Indicates a mesh to be filled by the command sink.</p>
            </summary>
            <param name = "mesh"><dd>  <p>The mesh object to be filled.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush with which to fill the mesh.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404413</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::FillMesh</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillOpacityMask_(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>
            <p>Fills an opacity mask on the command sink.</p>
            </summary>
            <param name = "opacityMask"><dd>  <p>The bitmap whose alpha channel will be sampled to define the opacity mask.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush with which to fill the mask.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The destination rectangle in which to fill the mask. If not specified, this is the origin.</p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>The source rectangle within the opacity mask. If not specified, this is the entire mask.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>The opacity mask bitmap must be considered to be clamped on each axis.</p>
            </remarks>
            <doc-id>hh404414</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::FillOpacityMask</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillGeometry_(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Indicates to the command sink a geometry to be filled.</p>
            </summary>
            <param name = "geometry"><dd>  <p>The geometry that should be filled.</p> </dd></param>
            <param name = "brush"><dd>  <p>The primary brush used to fill the geometry.</p> </dd></param>
            <param name = "opacityBrush"><dd>  <p>A brush whose alpha channel is used to modify the opacity of the primary fill brush.  </p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>If the opacity brush is specified, the primary brush will be a bitmap brush fixed on both the x-axis and the y-axis.</p><p>Ellipses and rounded rectangles are converted to the corresponding geometry before being passed to <strong>FillGeometry</strong>.</p>
            </remarks>
            <doc-id>hh404411</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::FillGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.FillRectangle_(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Indicates to the command sink a rectangle to be filled.</p>
            </summary>
            <param name = "rect"><dd>  <p>The rectangle to fill.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush with which to fill the rectangle.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404415</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::FillRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PushAxisAlignedClip_(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.AntialiasMode)">
            <summary>
            <p>Pushes a clipping rectangle onto the clip and layer stack.</p>
            </summary>
            <param name = "clipRect"><dd>  <p>The rectangle that defines the clip.</p> </dd></param>
            <param name = "antialiasMode"><dd>  <p>The antialias mode for the clip.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <remarks>
            <p>If the current world transform is not preserving the axis, <em>clipRectangle</em> is transformed and the bounds of the transformed rectangle are used instead.</p>
            </remarks>
            <doc-id>hh404418</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::PushAxisAlignedClip</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PushLayer_(SharpDX.Direct2D1.LayerParameters1@,SharpDX.Direct2D1.Layer)">
            <summary>
            <p>Pushes a layer onto the clip and layer stack.</p>
            </summary>
            <param name = "layerParameters1"><dd>  <p>The parameters that define the layer.</p> </dd></param>
            <param name = "layer"><dd>  <p>The layer resource that receives subsequent drawing operations.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404419</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>
            <unmanaged-short>ID2D1CommandSink::PushLayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PopAxisAlignedClip_">
            <summary>
            <p>Removes an axis-aligned clip from the layer and clip stack.</p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404416</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>
            <unmanaged-short>ID2D1CommandSink::PopAxisAlignedClip</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkNative.PopLayer_">
            <summary>
            <p>Removes  a layer from the layer and clip stack.</p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p></returns>
            <doc-id>hh404417</doc-id>
            <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>
            <unmanaged-short>ID2D1CommandSink::PopLayer</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow">
            <summary>
            Internal CommandSink Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkShadow.ToIntPtr(SharpDX.Direct2D1.CommandSink)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.BeginDrawImpl(System.IntPtr)">
            <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.EndDrawImpl(System.IntPtr)">
            <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetAntialiasModeDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetTagsDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetTextAntialiasModeDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetTextRenderingParamsDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetTransformDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetPrimitiveBlendDelegate">
            <summary>	
            Sets the blending for primitives.
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.SetUnitModeDelegate">
            <summary>	
            Sets the unit mode
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.ClearDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawGlyphRunDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawLineDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawGeometryDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawRectangleDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawBitmapDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawImageDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.DrawGdiMetafileDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.FillMeshDelegate">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="mesh"><para>The mesh object to be filled.</para></param>	
            <param name="brush"><para>The brush with which to fill the mesh.</para></param>	
            <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.FillOpacityMaskDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.FillGeometryDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.FillRectangleDelegate">
            <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.PushAxisAlignedClipDelegate">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="clipRect"><para>The rectangle that defines the clip.</para></param>	
            <param name="antialiasMode"><para>Whether the given clip should be antialiased.</para></param>	
            <remarks>	
            If the current world transform is not preserving the axis, clipRectangle is transformed and the bounds of the transformed rectangle are used instead.	
            </remarks>	
            <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.PushLayerDelegate">
            <summary>	
            No documentation.	
            </summary>	
            <param name="layerParameters1">No documentation.</param>	
            <param name="layer">No documentation.</param>	
            <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.PopAxisAlignedClipImpl(System.IntPtr)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CommandSinkShadow.CommandSinkVtbl.PopLayerImpl(System.IntPtr)">
            <summary>	
            No documentation.	
            </summary>	
            <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeInformation.SetConstantBuffer(SharpDX.DataStream)">
            <summary>
            Sets the constant buffer data from a <see cref="T:SharpDX.DataStream"/>.
            </summary>
            <param name="dataStream">The DataStream that contains the constant buffer data</param>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeInformation.SetConstantBuffer``1(``0)">
            <summary>
            Sets the constant buffer data from a struct value.
            </summary>
            <typeparam name="T">Type of the constant buffer</typeparam>
            <param name="value">Value of the constant buffer</param>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeInformation.SetConstantBuffer``1(``0@)">
            <summary>
            Sets the constant buffer data from a struct value.
            </summary>
            <typeparam name="T">Type of the constant buffer</typeparam>
            <param name="value">Value of the constant buffer</param>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.ComputeInformation.ComputeShader">
            <summary>
            <p>Sets the compute shader to the given shader resource.  The resource must be loaded before this call is made.</p>
            </summary>
            <doc-id>hh847967</doc-id>
            <unmanaged>SetComputeShader</unmanaged>
            <unmanaged-short>SetComputeShader</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeInformation.SetComputeShaderConstantBuffer(System.IntPtr,System.Int32)">
            <summary>
            <p>Establishes or changes the constant buffer data for this transform.</p>
            </summary>
            <param name = "buffer"><dd>  <p>The data applied to the constant buffer.</p> </dd></param>
            <param name = "bufferCount"><dd>  <p>The number of bytes of data in the constant buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh847968</doc-id>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const unsigned char* buffer,[In] unsigned int bufferCount)</unmanaged>
            <unmanaged-short>ID2D1ComputeInfo::SetComputeShaderConstantBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeInformation.SetComputeShader(System.Guid)">
            <summary>
            <p>Sets the compute shader to the given shader resource.  The resource must be loaded before this call is made.</p>
            </summary>
            <param name = "shaderId"><dd>  <p>The <see cref = "T:System.Guid"/> of the shader.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh847967</doc-id>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShader([In] const GUID&amp; shaderId)</unmanaged>
            <unmanaged-short>ID2D1ComputeInfo::SetComputeShader</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeInformation.SetResourceTexture(System.Int32,SharpDX.Direct2D1.ResourceTexture)">
            <summary>
            <p>Sets the resource texture corresponding to the given shader texture index to the given texture resource.  The texture resource must already have been loaded with <strong>ID2D1EffectContext::CreateResourceTexture</strong> method. This call will fail if the specified index overlaps with any input. The input indices always precede the texture LUT indices.
            </p>
            </summary>
            <param name = "textureIndex">No documentation.</param>
            <param name = "resourceTexture">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh847969</doc-id>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetResourceTexture([In] unsigned int textureIndex,[In] ID2D1ResourceTexture* resourceTexture)</unmanaged>
            <unmanaged-short>ID2D1ComputeInfo::SetResourceTexture</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransform.SetComputeInformation(SharpDX.Direct2D1.ComputeInformation)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="computeInfo">No documentation.</param>	
            <unmanaged>HRESULT ID2D1ComputeTransform::SetComputeInfo([In] ID2D1ComputeInfo* computeInfo)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransform.CalculateThreadgroups(SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="outputRect"><para>The output rectangle that will be filled by the compute transform.</para></param>
            <returns>An <see cref="!:Int3"/> containing the number of threads of x,y,z dimensions.</returns>	
            <remarks>	
            If this call fails, the corresponding <see cref="T:SharpDX.Direct2D1.Effect"/> instance is placed into an error state and fails to draw.	
            </remarks>	
            <unmanaged>HRESULT ID2D1ComputeTransform::CalculateThreadgroups([In] const RECT* outputRect,[Out] unsigned int* dimensionX,[Out] unsigned int* dimensionY,[Out] unsigned int* dimensionZ)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransformNative.SetComputeInformation(SharpDX.Direct2D1.ComputeInformation)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransformNative.CalculateThreadgroups(SharpDX.Mathematics.Interop.RawRectangle)">
            <inheritdoc/>
        </member>
        <member name="P:SharpDX.Direct2D1.ComputeTransformNative.ComputeInfo_">
            <summary>
            <p>Sets the render information used to specify the compute shader pass.</p>
            </summary>
            <remarks>
            <p>If this method fails, <strong>ID2D1TransformGraph::AddNode</strong> fails.</p>
            </remarks>
            <doc-id>hh404450</doc-id>
            <unmanaged>SetComputeInfo</unmanaged>
            <unmanaged-short>SetComputeInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransformNative.SetComputeInfo_(SharpDX.Direct2D1.ComputeInformation)">
            <summary>
            <p>Sets the render information used to specify the compute shader pass.</p>
            </summary>
            <param name = "computeInfo"><dd>  <p>The render information object to set.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If this method fails, <strong>ID2D1TransformGraph::AddNode</strong> fails.</p>
            </remarks>
            <doc-id>hh404450</doc-id>
            <unmanaged>HRESULT ID2D1ComputeTransform::SetComputeInfo([In] ID2D1ComputeInfo* computeInfo)</unmanaged>
            <unmanaged-short>ID2D1ComputeTransform::SetComputeInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransformNative.CalculateThreadgroups_(SharpDX.Mathematics.Interop.RawRectangle,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            <p>This method allows a compute-shader?based transform to select the number of thread groups to execute based on the number of output pixels it needs to fill.</p>
            </summary>
            <param name = "outputRect"><dd>  <p>The output rectangle that will be filled by the compute transform.</p> </dd></param>
            <param name = "dimensionX"><dd>  <p>The number of threads in the x dimension.</p> </dd></param>
            <param name = "dimensionY"><dd>  <p>The number of threads in the y dimension.</p> </dd></param>
            <param name = "dimensionZ"><dd>  <p>The number of threads in the z dimension.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If this call fails, the corresponding <strong><see cref = "T:SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>
            </remarks>
            <doc-id>hh404437</doc-id>
            <unmanaged>HRESULT ID2D1ComputeTransform::CalculateThreadgroups([In] const RECT* outputRect,[Out] unsigned int* dimensionX,[Out] unsigned int* dimensionY,[Out] unsigned int* dimensionZ)</unmanaged>
            <unmanaged-short>ID2D1ComputeTransform::CalculateThreadgroups</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ComputeTransformShadow">
            <summary>
            Internal ComputeTransform Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.ComputeTransformShadow.ToIntPtr(SharpDX.Direct2D1.ComputeTransform)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.ComputeTransformShadow.ComputeTransformVtbl.SetComputeInformationDelegate">
            <unmanaged>HRESULT ID2D1ComputeTransform::SetComputeInfo([In] ID2D1ComputeInfo* computeInfo)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.ComputeTransformShadow.ComputeTransformVtbl.CalculateThreadgroupsDelegate">
            <unmanaged>HRESULT ID2D1ComputeTransform::CalculateThreadgroups([In] const RECT* outputRect,[Out] unsigned int* dimensionX,[Out] unsigned int* dimensionY,[Out] unsigned int* dimensionZ)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffect">
            <summary>
            Custom Effect interface. Equivalent of C++ ID2D1EffectImpl.
            </summary>
            <unmanaged>ID2D1EffectImpl</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffect.Initialize(SharpDX.Direct2D1.EffectContext,SharpDX.Direct2D1.TransformGraph)">
            <summary>	
            Creates any resources used repeatedly during subsequent rendering calls.
            </summary>	
            <param name="effectContext"><para>An internal factory interface that creates and returns effect author centric types.</para></param>	
            <param name="transformGraph">No documentation.</param>	
            <remarks>	
            This moves resource creation cost to the CreateEffect call, rather than during rendering.If the implementation fails this call, the corresponding <see cref="M:SharpDX.Direct2D1.DeviceContext.CreateEffect(System.Guid,SharpDX.Direct2D1.Effect)"/> call also fails.The following example shows an effect implementing an initialize method.	
            </remarks>	
            <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffect.PrepareForRender(SharpDX.Direct2D1.ChangeType)">
            <summary>	
            Prepares an effect for the rendering process.	
            </summary>	
            <param name="changeType"><para>Indicates the type of change the effect should expect.</para></param>	
            <remarks>	
            This method is called by the renderer when the effect is within an effect graph that is drawn.The method will be called:If the effect has been initialized but has not previously been drawn. If an effect property has been set since the last draw call. If the context state has changed since the effect was last drawn.The method will not otherwise be called. The transforms created by the effect will be called to handle their input and output rectangles for every draw call.Most effects defer creating any resources or specifying a topology until this call is made. They store their properties and map them to a concrete set of rendering techniques when first drawn.	
            </remarks>	
            <unmanaged>HRESULT ID2D1EffectImpl::PrepareForRender([In] D2D1_CHANGE_TYPE changeType)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffect.SetGraph(SharpDX.Direct2D1.TransformGraph)">
            <summary>	
            The renderer calls this method to provide the effect implementation with a way to specify its transform graph and transform graph changes. 
            The renderer calls this method when: 1) When the effect is first initialized. 2) If the number of inputs to the effect changes.
            </summary>	
            <param name="transformGraph">The graph to which the effect describes its transform topology through the SetDescription call..</param>	
            <unmanaged>HRESULT ID2D1EffectImpl::SetGraph([In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectAttribute">
            <summary>
            Global attribute for <see cref="T:SharpDX.Direct2D1.CustomEffect"/> description.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.CustomEffectAttribute"/> class.
            </summary>
            <param name="description">Description of the custom effect</param>
            <param name="category">Category of the custom effect</param>
            <param name="author">Author of the custom effect</param>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomEffectAttribute.DisplayName">
            <summary>
            Gets the DisplayName name.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomEffectAttribute.Description">
            <summary>
            Gets the Description name.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomEffectAttribute.Category">
            <summary>
            Gets the Category name.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomEffectAttribute.Author">
            <summary>
            Gets the Author name.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectBase">
            <summary>
            Base abstract class for <see cref="T:SharpDX.Direct2D1.CustomEffect"/> interface.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectBase.Initialize(SharpDX.Direct2D1.EffectContext,SharpDX.Direct2D1.TransformGraph)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectBase.PrepareForRender(SharpDX.Direct2D1.ChangeType)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectBase.SetGraph(SharpDX.Direct2D1.TransformGraph)">
            <inheritdoc/>
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectFactoryDelegate">
            <summary>
            Delegate used by to create a custom effect.
            </summary>
            <returns>A new instance of custom effect</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectFactory">
            <summary>
            Internal class used to keep reference to factory.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectFactory.ToXml">
            <summary>
            Converts custom effect to an xml description
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectFactory.InitializeBindings">
            <summary>
            Initializes the property bindings
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectFactory.InitializeXml">
            <summary>
            Initializes the xml descriptor for this effect.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectFactory.CreateCustomEffectDelegate">
            <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectInputAttribute">
            <summary>
            Input attribute for <see cref="T:SharpDX.Direct2D1.CustomEffect"/> description.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectInputAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.CustomEffectInputAttribute"/> attribute.
            </summary>
            <param name="input"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomEffectInputAttribute.Input">
            <summary>
            Gets the Input name.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomEffectNative.Graph_">
            <summary>
            <p>The renderer calls this method to provide the effect implementation with a way to specify  its transform graph and transform graph changes. </p><p>The renderer calls this method when:</p><ul> <li>When the effect is first initialized.</li> <li>If the number of inputs to the effect changes.</li> </ul>
            </summary>
            <doc-id>hh871459</doc-id>
            <unmanaged>SetGraph</unmanaged>
            <unmanaged-short>SetGraph</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectNative.Initialize_(SharpDX.Direct2D1.EffectContext,SharpDX.Direct2D1.TransformGraph)">
            <summary>
            <p>The effect can use this method to do one time initialization tasks.  If this method is not needed, the method can just return <strong><see cref = "F:SharpDX.Result.Ok"/></strong>.</p>
            </summary>
            <param name = "effectContext"><dd>  <p>An internal context interface that creates and returns effect author?centric types.</p> </dd></param>
            <param name = "transformGraph"><dd>  <p>The effect can populate the transform graph with a topology and can update it later.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This moves resource creation cost to the <strong>CreateEffect</strong> call, rather than during rendering.</p><p>If the implementation fails this call, the corresponding <strong>ID2D1DeviceContext::CreateEffect</strong> call also fails.</p><p>The following example shows an effect implementing an initialize method.</p>
            </remarks>
            <doc-id>hh404570</doc-id>
            <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>
            <unmanaged-short>ID2D1EffectImpl::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectNative.PrepareForRender_(SharpDX.Direct2D1.ChangeType)">
            <summary>
            <p>Prepares an effect for the rendering process.</p>
            </summary>
            <param name = "changeType"><dd>  <p>Indicates the type of change the effect should expect.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method is called by the renderer when the effect is within an effect graph that is drawn.</p><p> The method will be called:</p><ul> <li>If the effect has been initialized but has not previously been drawn.</li> <li>If an effect property has been set since the last draw call.</li> <li>If the context state has changed since the effect was last drawn.</li> </ul><p>The method will not otherwise be called. The transforms created by the effect will be called to handle their input and output rectangles for every draw call.</p><p>Most effects defer creating any resources or specifying a topology until this call is made. They store their properties and map them to a concrete set of rendering techniques when first drawn.</p>
            </remarks>
            <doc-id>hh404572</doc-id>
            <unmanaged>HRESULT ID2D1EffectImpl::PrepareForRender([In] D2D1_CHANGE_TYPE changeType)</unmanaged>
            <unmanaged-short>ID2D1EffectImpl::PrepareForRender</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectNative.SetGraph_(SharpDX.Direct2D1.TransformGraph)">
            <summary>
            <p>The renderer calls this method to provide the effect implementation with a way to specify  its transform graph and transform graph changes. </p><p>The renderer calls this method when:</p><ul> <li>When the effect is first initialized.</li> <li>If the number of inputs to the effect changes.</li> </ul>
            </summary>
            <param name = "transformGraph"><dd>  <p>The graph to which the effect describes its transform topology through the SetDescription call.</p> </dd></param>
            <returns><p>An error that prevents the effect from being initialized if called as part of the CreateEffect call. If the effect fails a subsequent SetGraph call:</p><ul> <li>The error will be returned from the property method that caused the number of inputs to the effect to change.</li> <li>The effect object will be placed into an error state, if subsequently used to render, the context will be placed into a temporary error state, that particular effect will fail to render and the failure will be returned on the next EndDraw or Flush call.</li> </ul></returns>
            <doc-id>hh871459</doc-id>
            <unmanaged>HRESULT ID2D1EffectImpl::SetGraph([In] ID2D1TransformGraph* transformGraph)</unmanaged>
            <unmanaged-short>ID2D1EffectImpl::SetGraph</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectShadow">
            <summary>
            Internal CustomEffect Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomEffectShadow.ToIntPtr(SharpDX.Direct2D1.CustomEffect)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectShadow.CustomEffectVtbl.InitializeDelegate">
            <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectShadow.CustomEffectVtbl.PrepareForRenderDelegate">
            <unmanaged>HRESULT ID2D1EffectImpl::PrepareForRender([In] D2D1_CHANGE_TYPE changeType)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CustomEffectShadow.CustomEffectVtbl.SetGraphDelegate">
            <summary>	
            The renderer calls this method to provide the effect implementation with a way to specify its transform graph and transform graph changes. 
            The renderer calls this method when: 1) When the effect is first initialized. 2) If the number of inputs to the effect changes.
            </summary>	
            <param name="transformGraph">The graph to which the effect describes its transform topology through the SetDescription call..</param>	
            <unmanaged>HRESULT ID2D1EffectImpl::SetGraph([In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.CustomVertexBufferProperties">
            <summary>
            <p>Defines a vertex shader and the input element description to define the input layout. The combination is used to allow a custom vertex effect to create a custom vertex shader and pass it a custom layout.</p>
            </summary>
            <remarks>
            <p>The vertex shader will be loaded by the <strong>CreateVertexBuffer</strong> call that accepts the vertex buffer properties.</p><p>This structure does not need to be specified if one of the standard vertex shaders is used.</p>
            </remarks>
            <doc-id>hh404301</doc-id>
            <unmanaged>D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomVertexBufferProperties.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.CustomVertexBufferProperties"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.CustomVertexBufferProperties.#ctor(System.Byte[],SharpDX.Direct2D1.InputElement[],System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.CustomVertexBufferProperties"/> class.
            </summary>
            <param name="inputSignature"></param>
            <param name="inputElements"></param>
            <param name="stride"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.CustomVertexBufferProperties.InputSignature">
            <summary>	
            The vertex shader bytecode to use as a signature.
            </summary>	
            <unmanaged>const unsigned char* shaderBufferWithInputSignature</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.CustomVertexBufferProperties.InputElements">
            <summary>	
            The input elements in the vertex shader.
            </summary>	
            <unmanaged>const D2D1_INPUT_ELEMENT_DESC* inputElements</unmanaged>	
        </member>
        <member name="F:SharpDX.Direct2D1.CustomVertexBufferProperties.ShaderBufferWithInputSignature">
            <summary>
            <dd> <p>The unique ID of the vertex shader.</p> </dd>
            </summary>
            <doc-id>hh404301</doc-id>
            <unmanaged>shaderBufferWithInputSignature</unmanaged>
            <unmanaged-short>shaderBufferWithInputSignature</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CustomVertexBufferProperties.ShaderBufferSize">
            <summary>
            <dd> <p>An array of input assembler stage data types.</p> </dd>
            </summary>
            <doc-id>hh404301</doc-id>
            <unmanaged>shaderBufferSize</unmanaged>
            <unmanaged-short>shaderBufferSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CustomVertexBufferProperties.InputElementsPointer">
            <summary>
            <dd> <p>An array of input assembler stage data types.</p> </dd>
            </summary>
            <doc-id>hh404301</doc-id>
            <unmanaged>inputElements</unmanaged>
            <unmanaged-short>inputElements</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CustomVertexBufferProperties.ElementCount">
            <summary>
            <dd> <p>The number of input elements in the vertex shader.</p> </dd>
            </summary>
            <doc-id>hh404301</doc-id>
            <unmanaged>elementCount</unmanaged>
            <unmanaged-short>elementCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CustomVertexBufferProperties.Stride">
            <summary>
            <dd> <p>The vertex stride.</p> </dd>
            </summary>
            <doc-id>hh404301</doc-id>
            <unmanaged>stride</unmanaged>
            <unmanaged-short>stride</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.D2D1">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.Direct2D1.D2D1.DefaultFlatteningTolerance">
            <summary>
            The default tolerance for geometric flattening operations.
            http://msdn.microsoft.com/en-us/library/windows/desktop/dd370975%28v=vs.85%29.aspx
            </summary>
        </member>
        <member name="F:SharpDX.Direct2D1.D2D1.DefaultDpi">
            <summary>
            The default DPI value.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.ComputeFlatteningTolerance(SharpDX.Mathematics.Interop.RawMatrix3x2@,System.Single,System.Single,System.Single)">
            <summary>
            Computes the appropriate flattening tolerance to pass to APIs that take a flattening tolerance (for instance, <see cref="!:DeviceContext.CreateFilledGeometryRealization"/>).
            </summary>
            <param name="matrix">The matrix that will be applied subsequently to the geometry being flattened.</param>
            <param name="dpiX">The horizontal DPI of the render target that the geometry will be rendered onto (a choice of 96 implies no DPI correction).</param>
            <param name="dpiY">The vertical DPI of the render target that the geometry will be rendered onto (a choice of 96 implies no DPI correction).</param>
            <param name="maxZoomFactor">The maximum amount of additional scaling (on top of any scaling implied by the matrix or the DPI) that will be applied to the geometry.</param>
            <returns>The flattening tolerance.</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.CreateFactory(SharpDX.Direct2D1.FactoryType,System.Guid,System.Nullable{SharpDX.Direct2D1.FactoryOptions},System.IntPtr@)">
            <summary>
            <p>Creates a factory object  that can be used to create Direct2D resources.</p>
            </summary>
            <param name = "factoryType"><dd>  <p>The threading model of the factory and the resources it creates.</p> </dd></param>
            <param name = "riid"><dd>  <p>A reference to the IID of <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> that is obtained by using __uuidof(<see cref = "T:SharpDX.Direct2D1.Factory"/>).</p> </dd></param>
            <param name = "factoryOptionsRef"><dd>  <p>The level of detail provided to the debugging layer.</p> </dd></param>
            <param name = "iFactoryOut"><dd>  <p>When this method returns, contains the address to a reference to the new factory.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> interface provides the starting point for  Direct2D. In general, objects created from a single instance of a factory object can be used with other resources created from that instance, but not with resources created by other factory instances.   </p>
            </remarks>
            <doc-id>dd368034</doc-id>
            <unmanaged>HRESULT D2D1CreateFactory([In] D2D1_FACTORY_TYPE factoryType,[In] const GUID&amp; riid,[In, Optional] const D2D1_FACTORY_OPTIONS* pFactoryOptions,[Out] void** ppIFactory)</unmanaged>
            <unmanaged-short>D2D1CreateFactory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.MakeRotateMatrix(System.Single,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Creates a rotation transformation that rotates by the specified angle about the specified point.</p>
            </summary>
            <param name = "angle"><dd>  <p>The clockwise rotation angle, in degrees. </p> </dd></param>
            <param name = "center"><dd>  <p>The point about which to rotate.</p> </dd></param>
            <param name = "matrix"><dd>  <p>When this method returns, contains the new rotation transformation. You must allocate storage for this parameter.  </p> </dd></param>
            <remarks>
            <p>Rotation occurs in the plane of the 2-D surface.</p>
            </remarks>
            <doc-id>dd368049</doc-id>
            <unmanaged>void D2D1MakeRotateMatrix([In] float angle,[In] D2D_POINT_2F center,[Out] D2D_MATRIX_3X2_F* matrix)</unmanaged>
            <unmanaged-short>D2D1MakeRotateMatrix</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.MakeSkewMatrix(System.Single,System.Single,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Creates a skew transformation that has the specified x-axis angle, y-axis angle, and center point. </p>
            </summary>
            <param name = "angleX"><dd>  <p>The x-axis skew angle, which is measured in degrees counterclockwise from the y-axis.</p> </dd></param>
            <param name = "angleY"><dd>  <p>The y-axis skew angle, which is measured in degrees counterclockwise from the x-axis.</p> </dd></param>
            <param name = "center"><dd>  <p>The center point of the skew operation.</p> </dd></param>
            <param name = "matrix"><dd>  <p>When this method returns, contains the rotation transformation. You must allocate storate for this parameter.</p> </dd></param>
            <doc-id>dd368052</doc-id>
            <unmanaged>void D2D1MakeSkewMatrix([In] float angleX,[In] float angleY,[In] D2D_POINT_2F center,[Out] D2D_MATRIX_3X2_F* matrix)</unmanaged>
            <unmanaged-short>D2D1MakeSkewMatrix</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.IsMatrixInvertible(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Indicates whether the specified matrix is invertible.</p>
            </summary>
            <param name = "matrix"><dd>  <p>The matrix to test.</p> </dd></param>
            <returns><p><strong>true</strong> if the matrix was inverted; otherwise, <strong>false</strong>.</p></returns>
            <doc-id>dd368045</doc-id>
            <unmanaged>BOOL D2D1IsMatrixInvertible([In] const D2D_MATRIX_3X2_F* matrix)</unmanaged>
            <unmanaged-short>D2D1IsMatrixInvertible</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.InvertMatrix(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Tries to invert the specified matrix.</p>
            </summary>
            <param name = "matrix"><dd>  <p>The matrix to invert.</p> </dd></param>
            <returns><p><strong>true</strong> if the matrix was inverted; otherwise, <strong>false</strong>.</p></returns>
            <doc-id>dd368044</doc-id>
            <unmanaged>BOOL D2D1InvertMatrix([InOut] D2D_MATRIX_3X2_F* matrix)</unmanaged>
            <unmanaged-short>D2D1InvertMatrix</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.CreateDevice(SharpDX.DXGI.Device,System.Nullable{SharpDX.Direct2D1.CreationProperties},SharpDX.Direct2D1.Device)">
            <summary>
            <p>Creates a new Direct2D device associated with the provided DXGI device. </p>
            </summary>
            <param name = "dxgiDevice"><dd> <p>The DXGI device the Direct2D device is associated with.</p> </dd></param>
            <param name = "creationProperties"><dd> <p>The properties to apply to the Direct2D device.</p> </dd></param>
            <param name = "d2dDevice"><dd> <p>When this function returns, contains the address of a reference to a Direct2D device.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function will also create a new <strong><see cref = "T:SharpDX.Direct2D1.Factory1"/></strong> that can be retrieved through <strong>ID2D1Resource::GetFactory</strong>.</p><p>If the creation properties are not specified, then <em>d2dDevice</em> will inherit its threading mode from <em>dxgiDevice</em> and debug tracing will not be enabled.</p>
            </remarks>
            <doc-id>hh404272</doc-id>
            <unmanaged>HRESULT D2D1CreateDevice([In] IDXGIDevice* dxgiDevice,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out, Fast] ID2D1Device** d2dDevice)</unmanaged>
            <unmanaged-short>D2D1CreateDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.CreateDeviceContext(SharpDX.DXGI.Surface,System.Nullable{SharpDX.Direct2D1.CreationProperties},SharpDX.Direct2D1.DeviceContext)">
            <summary>
            <p>Creates a new Direct2D device context associated with a DXGI surface. </p>
            </summary>
            <param name = "dxgiSurface"><dd> <p>The DXGI surface the Direct2D device context is associated with.</p> </dd></param>
            <param name = "creationProperties"><dd> <p>The properties to apply to the Direct2D device context.</p> </dd></param>
            <param name = "d2dDeviceContext"><dd> <p>When this function returns, contains the address of a reference to a Direct2D device context.</p> </dd></param>
            <returns><p>The function returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This function will also create a new <strong><see cref = "T:SharpDX.Direct2D1.Factory1"/></strong> that can be retrieved through <strong>ID2D1Resource::GetFactory</strong>.</p><p>This function will also create a new <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> that can be retrieved through <strong>ID2D1DeviceContext::GetDevice</strong>.</p><p>The DXGI device will be specified implicitly through <em>dxgiSurface</em>.</p><p>If <em>creationProperties</em> are not specified, the Direct2D device will inherit its threading mode from the DXGI device implied by <em>dxgiSurface</em> and debug tracing will not be enabled.</p>
            </remarks>
            <doc-id>hh404273</doc-id>
            <unmanaged>HRESULT D2D1CreateDeviceContext([In] IDXGISurface* dxgiSurface,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out, Fast] ID2D1DeviceContext** d2dDeviceContext)</unmanaged>
            <unmanaged-short>D2D1CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.ConvertColorSpace(SharpDX.Direct2D1.ColorSpace,SharpDX.Direct2D1.ColorSpace,SharpDX.Mathematics.Interop.RawColor4)">
            <summary>
            <p>Converts the given color from one colorspace to another.</p>
            </summary>
            <param name = "sourceColorSpace"><dd>  <p>The source color space.</p> </dd></param>
            <param name = "destinationColorSpace"><dd>  <p>The destination color space.</p> </dd></param>
            <param name = "color"><dd>  <p>The source color.</p> </dd></param>
            <returns><p>The converted color.</p></returns>
            <doc-id>hh847939</doc-id>
            <unmanaged>D2D_COLOR_F D2D1ConvertColorSpace([In] D2D1_COLOR_SPACE sourceColorSpace,[In] D2D1_COLOR_SPACE destinationColorSpace,[In] const D2D_COLOR_F* color)</unmanaged>
            <unmanaged-short>D2D1ConvertColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.SinCos(System.Single,System.Single@,System.Single@)">
            <summary>
            <p>Returns the sine and cosine of an angle.</p>
            </summary>
            <param name = "angle"><dd>  <p>The angle to calculate.</p> </dd></param>
            <param name = "s"><dd>  <p>The sine of the angle.</p> </dd></param>
            <param name = "c"><dd>  <p>The cosine of the angle.</p> </dd></param>
            <doc-id>hh847940</doc-id>
            <unmanaged>void D2D1SinCos([In] float angle,[Out] float* s,[Out] float* c)</unmanaged>
            <unmanaged-short>D2D1SinCos</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.Tan(System.Single)">
            <summary>
            <p>Returns the tangent of an angle.</p>
            </summary>
            <param name = "angle"><dd>  <p>The angle to calculate the tangent for.</p> </dd></param>
            <returns><p>The tangent of the angle.</p></returns>
            <doc-id>hh847941</doc-id>
            <unmanaged>float D2D1Tan([In] float angle)</unmanaged>
            <unmanaged-short>D2D1Tan</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.Vec3Length(System.Single,System.Single,System.Single)">
            <summary>
            <p>Returns the length of a 3 dimensional vector.</p>
            </summary>
            <param name = "x"><dd>  <p>The  x value of the vector.</p> </dd></param>
            <param name = "y"><dd>  <p>The  y value of the vector.</p> </dd></param>
            <param name = "z"><dd>  <p>The  z value of the vector.</p> </dd></param>
            <returns><p>The length of the vector.</p></returns>
            <doc-id>hh847942</doc-id>
            <unmanaged>float D2D1Vec3Length([In] float x,[In] float y,[In] float z)</unmanaged>
            <unmanaged-short>D2D1Vec3Length</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.ComputeMaximumScaleFactor(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Computes the maximum factor by which a given transform can stretch any vector.</p>
            </summary>
            <param name = "matrix"><dd> <p>The input transform matrix.</p> </dd></param>
            <returns><p>The scale factor.</p></returns>
            <remarks>
            <p>Formally, if M is the input matrix, this method will return the maximum value of |V * M| / |V| for all vectors V, where |.| denotes length. </p><strong>Note</strong>??Since this describes how M affects vectors (rather than points), the translation components (_31 and _32) of M are ignored.?
            </remarks>
            <doc-id>dn280381</doc-id>
            <unmanaged>float D2D1ComputeMaximumScaleFactor([In] const D2D_MATRIX_3X2_F* matrix)</unmanaged>
            <unmanaged-short>D2D1ComputeMaximumScaleFactor</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.D2D1.GetGradientMeshInteriorPointsFromCoonsPatch(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2@,SharpDX.Mathematics.Interop.RawVector2@,SharpDX.Mathematics.Interop.RawVector2@,SharpDX.Mathematics.Interop.RawVector2@)">
            <summary>
            <p>Returns the interior points for a gradient mesh patch based on the points defining a Coons patch.</p><strong>Note</strong>??<p>This function is called by the <strong>GradientMeshPatchFromCoonsPatch</strong> function and is not intended to be used directly.</p>?
            </summary>
            <param name = "point0Ref">No documentation.</param>
            <param name = "point1Ref">No documentation.</param>
            <param name = "point2Ref">No documentation.</param>
            <param name = "point3Ref">No documentation.</param>
            <param name = "point4Ref">No documentation.</param>
            <param name = "point5Ref">No documentation.</param>
            <param name = "point6Ref">No documentation.</param>
            <param name = "point7Ref">No documentation.</param>
            <param name = "point8Ref">No documentation.</param>
            <param name = "point9Ref">No documentation.</param>
            <param name = "point10Ref">No documentation.</param>
            <param name = "point11Ref">No documentation.</param>
            <param name = "tensorPoint11Ref">No documentation.</param>
            <param name = "tensorPoint12Ref">No documentation.</param>
            <param name = "tensorPoint21Ref">No documentation.</param>
            <param name = "tensorPoint22Ref">No documentation.</param>
            <remarks>
            <p>This function is called by the <strong>GradientMeshPatchFromCoonsPatch</strong> function and is not intended to be used directly.</p>
            </remarks>
            <doc-id>mt149083</doc-id>
            <unmanaged>void D2D1GetGradientMeshInteriorPointsFromCoonsPatch([In] const D2D_POINT_2F* pPoint0,[In] const D2D_POINT_2F* pPoint1,[In] const D2D_POINT_2F* pPoint2,[In] const D2D_POINT_2F* pPoint3,[In] const D2D_POINT_2F* pPoint4,[In] const D2D_POINT_2F* pPoint5,[In] const D2D_POINT_2F* pPoint6,[In] const D2D_POINT_2F* pPoint7,[In] const D2D_POINT_2F* pPoint8,[In] const D2D_POINT_2F* pPoint9,[In] const D2D_POINT_2F* pPoint10,[In] const D2D_POINT_2F* pPoint11,[Out] D2D_POINT_2F* pTensorPoint11,[Out] D2D_POINT_2F* pTensorPoint12,[Out] D2D_POINT_2F* pTensorPoint21,[Out] D2D_POINT_2F* pTensorPoint22)</unmanaged>
            <unmanaged-short>D2D1GetGradientMeshInteriorPointsFromCoonsPatch</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.#ctor(SharpDX.DXGI.Device)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device"/> class.
            </summary>
            <param name="device">The device.</param>
            <unmanaged>HRESULT D2D1CreateDevice([In] IDXGIDevice* dxgiDevice,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out] ID2D1Device** d2dDevice)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.#ctor(SharpDX.DXGI.Device,SharpDX.Direct2D1.CreationProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device"/> class.
            </summary>
            <param name="device">The device.</param>
            <param name="creationProperties">The creation properties.</param>
            <unmanaged>HRESULT D2D1CreateDevice([In] IDXGIDevice* dxgiDevice,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out] ID2D1Device** d2dDevice)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.#ctor(SharpDX.Direct2D1.Factory1,SharpDX.DXGI.Device)">
            <summary>	
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device"/> class.
            </summary>	
            <param name="factory"><para>The <see cref="T:SharpDX.Direct2D1.Factory1"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device"/>. </para></param>	
            <param name="device"><para>The <see cref="T:SharpDX.DXGI.Device"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device"/>. </para></param>	
            <remarks>	
            Each call to CreateDevice returns a unique <see cref="T:SharpDX.Direct2D1.Device"/> object.The <see cref="T:SharpDX.DXGI.Device"/> object is obtained by calling QueryInterface on an ID3D10Device or an ID3D11Device.	
            </remarks>	
            <unmanaged>HRESULT ID2D1Factory1::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out] ID2D1Device** d2dDevice)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.Device.MaximumTextureMemory">
            <summary>
            <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>
            </summary>
            <doc-id>hh847984</doc-id>
            <unmanaged>GetMaximumTextureMemory / SetMaximumTextureMemory</unmanaged>
            <unmanaged-short>GetMaximumTextureMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions,SharpDX.Direct2D1.DeviceContext)">
            <summary>
            <p>Creates a new device context from a Direct2D device.</p>
            </summary>
            <param name = "options"><dd>  <p>The options to be applied to the created device context.</p> </dd></param>
            <param name = "deviceContext"><dd>  <p>When this method returns, contains the address of a reference to the new device context.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.</p>
            </remarks>
            <doc-id>hh404545</doc-id>
            <unmanaged>HRESULT ID2D1Device::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext** deviceContext)</unmanaged>
            <unmanaged-short>ID2D1Device::CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.CreatePrintControl(SharpDX.WIC.ImagingFactory,SharpDX.ComObject,System.Nullable{SharpDX.Direct2D1.PrintControlProperties},SharpDX.Direct2D1.PrintControl)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.PrintControl"/></strong> object that converts Direct2D primitives stored in <strong><see cref = "T:SharpDX.Direct2D1.CommandList"/></strong> into a fixed page representation.  The print sub-system then consumes the primitives.</p>
            </summary>
            <param name = "wicFactory">No documentation.</param>
            <param name = "documentTarget">No documentation.</param>
            <param name = "rintControlPropertiesRef">No documentation.</param>
            <param name = "rintControlRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_FAIL</td><td>Generic failure code.</td></tr> <tr><td><see cref = "!:PrintFormatNotSupported"/></td><td>The print format is not supported by the document target.</td></tr> </table><p>?</p></returns>
            <remarks>
            <strong>Note</strong>??This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation?factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.?
            </remarks>
            <doc-id>hh404550</doc-id>
            <unmanaged>HRESULT ID2D1Device::CreatePrintControl([In] IWICImagingFactory* wicFactory,[In] IPrintDocumentPackageTarget* documentTarget,[In, Optional] const D2D1_PRINT_CONTROL_PROPERTIES* printControlProperties,[Out, Fast] ID2D1PrintControl** printControl)</unmanaged>
            <unmanaged-short>ID2D1Device::CreatePrintControl</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.SetMaximumTextureMemory(System.Int64)">
            <summary>
            <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>
            </summary>
            <param name = "maximumInBytes"><dd>  <p>The new maximum texture memory in bytes.</p> </dd></param>
            <remarks>
            <strong>Note</strong>??Direct2D may exceed the  maximum texture memory you set with this method for a single frame if necessary to render the frame.?
            </remarks>
            <doc-id>hh847985</doc-id>
            <unmanaged>void ID2D1Device::SetMaximumTextureMemory([In] unsigned longlong maximumInBytes)</unmanaged>
            <unmanaged-short>ID2D1Device::SetMaximumTextureMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.GetMaximumTextureMemory">
            <summary>
            <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>
            </summary>
            <returns><p>The maximum amount of texture memory in bytes.</p></returns>
            <doc-id>hh847984</doc-id>
            <unmanaged>unsigned longlong ID2D1Device::GetMaximumTextureMemory()</unmanaged>
            <unmanaged-short>ID2D1Device::GetMaximumTextureMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device.ClearResources(System.Int32)">
            <summary>
            <p>Clears all of the rendering resources used by Direct2D. </p>
            </summary>
            <param name = "millisecondsSinceUse"><dd>  <p>Discards only resources that haven't been used for greater than the specified time in milliseconds. The default is 0 milliseconds.</p> </dd></param>
            <doc-id>hh404542</doc-id>
            <unmanaged>void ID2D1Device::ClearResources([In] unsigned int millisecondsSinceUse)</unmanaged>
            <unmanaged-short>ID2D1Device::ClearResources</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device1.#ctor(SharpDX.Direct2D1.Factory2,SharpDX.DXGI.Device)">
            <summary>	
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device1"/> class.
            </summary>	
            <param name="factory"><para>The <see cref="T:SharpDX.Direct2D1.Factory2"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device1"/>. </para></param>	
            <param name="device"><para>The <see cref="T:SharpDX.DXGI.Device"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device1"/>. </para></param>	
            <remarks>	
            Each call to CreateDevice returns a unique <see cref="T:SharpDX.Direct2D1.Device1"/> object.The <see cref="T:SharpDX.DXGI.Device"/> object is obtained by calling QueryInterface on an ID3D10Device or an ID3D11Device.	
            </remarks>	
            <unmanaged>HRESULT ID2D1Factory2::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out] ID2D1Device1** d2dDevice1)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.Device1.RenderingPriority">
            <summary>
            <p>Retrieves or sets the current rendering priority of the device.</p>
            </summary>
            <doc-id>dn280459</doc-id>
            <unmanaged>GetRenderingPriority / SetRenderingPriority</unmanaged>
            <unmanaged-short>GetRenderingPriority</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device1.GetRenderingPriority">
            <summary>
            <p>Retrieves the current rendering priority of the device.</p>
            </summary>
            <returns><p> The current rendering priority of the device.</p></returns>
            <doc-id>dn280459</doc-id>
            <unmanaged>D2D1_RENDERING_PRIORITY ID2D1Device1::GetRenderingPriority()</unmanaged>
            <unmanaged-short>ID2D1Device1::GetRenderingPriority</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device1.SetRenderingPriority(SharpDX.Direct2D1.RenderingPriority)">
            <summary>
            <p>Sets the priority of Direct2D rendering operations performed on any device context associated with the device.</p>
            </summary>
            <param name = "renderingPriority"><dd>  <p>The desired rendering priority for the device and associated contexts.</p> </dd></param>
            <remarks>
            <p>Calling this method affects the rendering priority of all device contexts associated with the device. This method can be called at any time, but is not guaranteed to take effect until the beginning of the next frame. The recommended usage is to call this method outside of <strong>BeginDraw</strong> and <strong>EndDraw</strong> blocks. Cycling this property frequently within drawing blocks will effectively reduce the benefits of any throttling that is applied.</p>
            </remarks>
            <doc-id>dn280460</doc-id>
            <unmanaged>void ID2D1Device1::SetRenderingPriority([In] D2D1_RENDERING_PRIORITY renderingPriority)</unmanaged>
            <unmanaged-short>ID2D1Device1::SetRenderingPriority</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device1.CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions,SharpDX.Direct2D1.DeviceContext1)">
            <summary>
            <p>Represents a resource domain whose objects and device contexts can be used together. This interface performs all the same functions as the existing <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> interface. It also enables control of the device's rendering priority.</p>
            </summary>
            <param name = "options">No documentation.</param>
            <param name = "deviceContext1">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>dn280458</doc-id>
            <unmanaged>HRESULT ID2D1Device1::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext1** deviceContext1)</unmanaged>
            <unmanaged-short>ID2D1Device1::CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device2.#ctor(SharpDX.Direct2D1.Factory3,SharpDX.DXGI.Device)">
            <summary>	
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device2"/> class.
            </summary>	
            <param name="factory"><para>The <see cref="T:SharpDX.Direct2D1.Factory3"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device2"/>. </para></param>	
            <param name="device"><para>The <see cref="T:SharpDX.DXGI.Device"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device2"/>. </para></param>	
            <remarks>	
            Each call to CreateDevice returns a unique <see cref="T:SharpDX.Direct2D1.Device2"/> object.The <see cref="T:SharpDX.DXGI.Device"/> object is obtained by calling QueryInterface on an ID3D10Device or an ID3D11Device.	
            </remarks>	
            <unmanaged>HRESULT ID2D1Factory3::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out] ID2D1Device2** d2dDevice2)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.Device2.DxgiDevice">
            <summary>
            <p>Returns the DXGI device associated with this Direct2D device.</p>
            </summary>
            <doc-id>dn917489</doc-id>
            <unmanaged>GetDxgiDevice</unmanaged>
            <unmanaged-short>GetDxgiDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device2.CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions,SharpDX.Direct2D1.DeviceContext2)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext2"/></strong> from a Direct2D device.</p>
            </summary>
            <param name = "options">No documentation.</param>
            <param name = "deviceContext2">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890787</doc-id>
            <unmanaged>HRESULT ID2D1Device2::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext2** deviceContext2)</unmanaged>
            <unmanaged-short>ID2D1Device2::CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device2.FlushDeviceContexts(SharpDX.Direct2D1.Bitmap)">
            <summary>
            <p>Flush all device contexts that reference a given bitmap.</p>
            </summary>
            <param name = "bitmap"><dd>  <p>The bitmap, created on this device, for which all referencing device contexts will be flushed. </p> </dd></param>
            <doc-id>dn890788</doc-id>
            <unmanaged>void ID2D1Device2::FlushDeviceContexts([In] ID2D1Bitmap* bitmap)</unmanaged>
            <unmanaged-short>ID2D1Device2::FlushDeviceContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device2.GetDxgiDevice(SharpDX.DXGI.Device@)">
            <summary>
            <p>Returns the DXGI device associated with this Direct2D device.</p>
            </summary>
            <param name = "dxgiDevice"><dd>  <p>The DXGI device associated with this Direct2D device.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn917489</doc-id>
            <unmanaged>HRESULT ID2D1Device2::GetDxgiDevice([Out] IDXGIDevice** dxgiDevice)</unmanaged>
            <unmanaged-short>ID2D1Device2::GetDxgiDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device3.#ctor(SharpDX.Direct2D1.Factory4,SharpDX.DXGI.Device)">
            <summary>	
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device3"/> class.
            </summary>	
            <param name="factory"><para>The <see cref="T:SharpDX.Direct2D1.Factory4"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device3"/>. </para></param>	
            <param name="device"><para>The <see cref="T:SharpDX.DXGI.Device"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device3"/>. </para></param>	
            <remarks>	
            Each call to CreateDevice returns a unique <see cref="T:SharpDX.Direct2D1.Device3"/> object.The <see cref="T:SharpDX.DXGI.Device"/> object is obtained by calling QueryInterface on an ID3D10Device or an ID3D11Device.	
            </remarks>	
            <unmanaged>HRESULT ID2D1Factory3::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out] ID2D1Device2** d2dDevice2)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Device3.CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions,SharpDX.Direct2D1.DeviceContext3)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext3"/></strong> from this Direct2D device.</p>
            </summary>
            <param name = "options">No documentation.</param>
            <param name = "deviceContext3">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt619825</doc-id>
            <unmanaged>HRESULT ID2D1Device3::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext3** deviceContext3)</unmanaged>
            <unmanaged-short>ID2D1Device3::CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device4.#ctor(SharpDX.Direct2D1.Factory5,SharpDX.DXGI.Device)">
            <summary>	
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device4"/> class.
            </summary>	
            <param name="factory"><para>The <see cref="T:SharpDX.Direct2D1.Factory5"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device3"/>. </para></param>	
            <param name="device"><para>The <see cref="T:SharpDX.DXGI.Device"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device4"/>. </para></param>	
            <remarks>	
            Each call to CreateDevice returns a unique <see cref="T:SharpDX.Direct2D1.Device4"/> object.The <see cref="T:SharpDX.DXGI.Device4"/> object is obtained by calling QueryInterface on an ID3D10Device or an ID3D11Device.	
            </remarks>	
            <unmanaged>HRESULT ID2D1Factory5::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out] ID2D1Device5** d2dDevice4)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.Device4.MaximumColorGlyphCacheMemory">
            <summary>
            <p>Gets or sets the maximum capacity of the color glyph cache.</p>
            </summary>
            <doc-id>mt736466</doc-id>
            <unmanaged>GetMaximumColorGlyphCacheMemory / SetMaximumColorGlyphCacheMemory</unmanaged>
            <unmanaged-short>GetMaximumColorGlyphCacheMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device4.CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions,SharpDX.Direct2D1.DeviceContext4)">
            <summary>
            <p>Creates a new device context from a Direct2D device.</p>
            </summary>
            <param name = "options"><dd>  <p>The options to be applied to the created device context.</p> </dd></param>
            <param name = "deviceContext4"><dd>  <p>When this method returns, contains the address of a reference to the new device context.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.</p>
            </remarks>
            <doc-id>hh404545</doc-id>
            <unmanaged>HRESULT ID2D1Device4::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext4** deviceContext4)</unmanaged>
            <unmanaged-short>ID2D1Device4::CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device4.SetMaximumColorGlyphCacheMemory(System.Int64)">
            <summary>
            <p>Sets the maximum capacity of the color glyph cache. </p>
            </summary>
            <param name = "maximumInBytes"><dd>  <p>The maximum capacity of the color glyph cache.</p> </dd></param>
            <remarks>
            <p>The color glyph cache is used to store color bitmap glyphs and SVG glyphs, enabling faster performance if the same glyphs are needed again. The capacity determines the amount of memory that D2D may use to store glyphs that the application does not already reference. If the application references a glyph using <strong>GetColorBitmapGlyphImage</strong> or <strong>GetSvgGlyphImage</strong>, after it has been evicted, this glyph does not count toward the cache capacity.</p>
            </remarks>
            <doc-id>mt736467</doc-id>
            <unmanaged>void ID2D1Device4::SetMaximumColorGlyphCacheMemory([In] unsigned longlong maximumInBytes)</unmanaged>
            <unmanaged-short>ID2D1Device4::SetMaximumColorGlyphCacheMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device4.GetMaximumColorGlyphCacheMemory">
            <summary>
            <p>Gets the maximum capacity of the color glyph cache.</p>
            </summary>
            <returns><p>Returns the maximum capacity of the color glyph cache in bytes.</p></returns>
            <doc-id>mt736466</doc-id>
            <unmanaged>unsigned longlong ID2D1Device4::GetMaximumColorGlyphCacheMemory()</unmanaged>
            <unmanaged-short>ID2D1Device4::GetMaximumColorGlyphCacheMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Device5.#ctor(SharpDX.Direct2D1.Factory6,SharpDX.DXGI.Device)">
            <summary>	
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Device5"/> class.
            </summary>	
            <param name="factory"><para>The <see cref="T:SharpDX.Direct2D1.Factory4"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device5"/>. </para></param>	
            <param name="device"><para>The <see cref="T:SharpDX.DXGI.Device"/> object used when creating  the <see cref="T:SharpDX.Direct2D1.Device5"/>. </para></param>	
            <remarks>	
            Each call to CreateDevice returns a unique <see cref="T:SharpDX.Direct2D1.Device5"/> object.The <see cref="T:SharpDX.DXGI.Device"/> object is obtained by calling QueryInterface on an ID3D10Device or an ID3D11Device.	
            </remarks>	
            <unmanaged>HRESULT ID2D1Factory3::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out] ID2D1Device2** d2dDevice2)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Device5.CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions,SharpDX.Direct2D1.DeviceContext5)">
            <summary>
            No documentation.
            </summary>
            <param name = "options">No documentation.</param>
            <param name = "deviceContext5">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1Device5::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext5** deviceContext5)</unmanaged>
            <unmanaged-short>ID2D1Device5::CreateDeviceContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.#ctor(SharpDX.DXGI.Surface)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext"/> class.
            </summary>
            <param name="surface">The surface.</param>
            <unmanaged>HRESULT D2D1CreateDeviceContext([In] IDXGISurface* dxgiSurface,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out] ID2D1DeviceContext** d2dDeviceContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.#ctor(SharpDX.DXGI.Surface,SharpDX.Direct2D1.CreationProperties)">
            <summary>
            Initializes a new instance of the <see cref="P:SharpDX.Direct2D1.DeviceContext.Device"/> class.
            </summary>
            <param name="surface">The surface.</param>
            <param name="creationProperties">The creation properties.</param>
            <unmanaged>HRESULT D2D1CreateDeviceContext([In] IDXGISurface* dxgiSurface,[In, Optional] const D2D1_CREATION_PROPERTIES* creationProperties,[Out] ID2D1DeviceContext** d2dDeviceContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.#ctor(SharpDX.Direct2D1.Device,SharpDX.Direct2D1.DeviceContextOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext"/> class using an existing <see cref="P:SharpDX.Direct2D1.DeviceContext.Device"/>.
            </summary>
            <param name="device">The device.</param>
            <param name="options">The options to be applied to the created device context.</param>
            <remarks>
            The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.
            </remarks>
            <unmanaged>HRESULT ID2D1Device::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out] ID2D1DeviceContext** deviceContext)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawImage(SharpDX.Direct2D1.Effect,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="effect">No documentation.</param>	
            <param name="targetOffset">No documentation.</param>	
            <param name="interpolationMode">No documentation.</param>	
            <param name="compositeMode">No documentation.</param>	
            <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawImage(SharpDX.Direct2D1.Effect,SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>
            No documentation.
            </summary>
            <param name="effect">No documentation.</param>
            <param name="interpolationMode">No documentation.</param>
            <param name="compositeMode">No documentation.</param>
            <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawImage(SharpDX.Direct2D1.Image,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="image">No documentation.</param>	
            <param name="targetOffset">No documentation.</param>	
            <param name="interpolationMode">No documentation.</param>	
            <param name="compositeMode">No documentation.</param>	
            <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawImage(SharpDX.Direct2D1.Image,SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>
            No documentation.
            </summary>
            <param name="image">No documentation.</param>
            <param name="interpolationMode">No documentation.</param>
            <param name="compositeMode">No documentation.</param>
            <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Single,SharpDX.Direct2D1.InterpolationMode)">
            <summary>
            Draws the bitmap.
            </summary>
            <param name="bitmap">The bitmap.</param>
            <param name="opacity">The opacity.</param>
            <param name="interpolationMode">The interpolation mode.</param>
            <unmanaged>void ID2D1DeviceContext::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Single,SharpDX.Direct2D1.InterpolationMode,SharpDX.Mathematics.Interop.RawMatrix)">
            <summary>
            Draws the bitmap.
            </summary>
            <param name="bitmap">The bitmap.</param>
            <param name="opacity">The opacity.</param>
            <param name="interpolationMode">The interpolation mode.</param>
            <param name="perspectiveTransformRef">The perspective transform ref.</param>
            <unmanaged>void ID2D1DeviceContext::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Single,SharpDX.Direct2D1.InterpolationMode,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Mathematics.Interop.RawMatrix)">
            <summary>
            Draws the bitmap.
            </summary>
            <param name="bitmap">The bitmap.</param>
            <param name="opacity">The opacity.</param>
            <param name="interpolationMode">The interpolation mode.</param>
            <param name="sourceRectangle">The source rectangle.</param>
            <param name="perspectiveTransformRef">The perspective transform ref.</param>
            <unmanaged>void ID2D1DeviceContext::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.PushLayer(SharpDX.Direct2D1.LayerParameters1,SharpDX.Direct2D1.Layer)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="layerParameters">No documentation.</param>	
            <param name="layer">No documentation.</param>	
            <unmanaged>void ID2D1DeviceContext::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetEffectInvalidRectangles(SharpDX.Direct2D1.Effect)">
            <summary>
            Gets the effect invalid rectangles.
            </summary>
            <param name="effect">The effect.</param>
            <returns></returns>
            <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangles([In] ID2D1Effect* effect,[Out, Buffer] D2D_RECT_F* rectangles,[In] unsigned int rectanglesCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetEffectRequiredInputRectangles(SharpDX.Direct2D1.Effect,SharpDX.Direct2D1.EffectInputDescription[])">
            <summary>
            Gets the effect required input rectangles.
            </summary>
            <param name="renderEffect">The render effect.</param>
            <param name="inputDescriptions">The input descriptions.</param>
            <returns></returns>
            <unmanaged>HRESULT ID2D1DeviceContext::GetEffectRequiredInputRectangles([In] ID2D1Effect* renderEffect,[In, Optional] const D2D_RECT_F* renderImageRectangle,[In, Buffer] const D2D1_EFFECT_INPUT_DESCRIPTION* inputDescriptions,[Out, Buffer] D2D_RECT_F* requiredInputRects,[In] unsigned int inputCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetEffectRequiredInputRectangles(SharpDX.Direct2D1.Effect,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.EffectInputDescription[])">
            <summary>
            Gets the effect required input rectangles.
            </summary>
            <param name="renderEffect">The render effect.</param>
            <param name="renderImageRectangle">The render image rectangle.</param>
            <param name="inputDescriptions">The input descriptions.</param>
            <returns></returns>
            <unmanaged>HRESULT ID2D1DeviceContext::GetEffectRequiredInputRectangles([In] ID2D1Effect* renderEffect,[In, Optional] const D2D_RECT_F* renderImageRectangle,[In, Buffer] const D2D1_EFFECT_INPUT_DESCRIPTION* inputDescriptions,[Out, Buffer] D2D_RECT_F* requiredInputRects,[In] unsigned int inputCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.FillOpacityMask(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="opacityMask">No documentation.</param>	
            <param name="brush">No documentation.</param>	
            <unmanaged>void ID2D1DeviceContext::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.DeviceContext.Device">
            <summary>
            <p>Gets the device associated with a device context.</p>
            </summary>
            <remarks>
            <p>The application can retrieve the device even if it is created from an earlier render target code-path. The application must use an <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext"/></strong> interface and then call <strong>GetDevice</strong>. Some functionality for controlling all of the resources for a set of device contexts is maintained only on an <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> object.</p>
            </remarks>
            <doc-id>hh404513</doc-id>
            <unmanaged>GetDevice</unmanaged>
            <unmanaged-short>GetDevice</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.DeviceContext.Target">
            <summary>
            <p>Gets or sets the target currently associated with the device context.</p>
            </summary>
            <remarks>
            <p>If a target is not associated with the device context, <em>target</em> will contain <strong><c>null</c></strong> when the methods returns.</p><p>If the currently selected target is a bitmap rather than a command list, the application can gain access to the initial bitmaps created by using one of the following methods:</p><ul> <li> <strong>CreateHwndRenderTarget</strong> </li> <li> <strong>CreateDxgiSurfaceRenderTarget</strong> </li> <li> <strong>CreateWicBitmapRenderTarget</strong> </li> <li> <strong>CreateDCRenderTarget</strong> </li> <li> <strong>CreateCompatibleRenderTarget</strong> </li> </ul><p>It is not possible for an application to destroy these bitmaps.  All of these bitmaps are bindable as bitmap targets.  However not all of these bitmaps can be used as bitmap sources for  <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> methods.</p><p> <strong>CreateDxgiSurfaceRenderTarget</strong> will create a bitmap that is usable as a bitmap source if the DXGI surface is bindable as a shader resource view.</p><p> <strong>CreateCompatibleRenderTarget</strong> will always create bitmaps that are usable as a bitmap source.</p><p> <strong>ID2D1RenderTarget::BeginDraw</strong> will copy from the <see cref = "T:System.IntPtr"/> to the original bitmap associated with it.  <strong>ID2D1RenderTarget::EndDraw</strong> will copy from the original bitmap to the <see cref = "T:System.IntPtr"/>.  </p><p> <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> objects will be locked in the following circumstances:</p><ul> <li>BeginDraw has been called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is set as the target of a device context after BeginDraw has been called and before EndDraw has been called.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p><see cref = "T:SharpDX.WIC.Bitmap"/> objects will be unlocked in the following circumstances:</p><ul> <li>EndDraw is called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is removed as the target of a device context between the calls to BeginDraw and EndDraw.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p>Direct2D will only lock bitmaps that are not currently locked.</p><p>Calling <strong>QueryInterface</strong> for <strong><see cref = "T:SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> will always succeed.  <strong>ID2D1GdiInteropRenderTarget::GetDC</strong> will return a device context corresponding to the currently bound target bitmap.  GetDC will fail if the target bitmap was not created with the GDI_COMPATIBLE flag set.</p><p> <strong>ID2D1HwndRenderTarget::Resize</strong> will return <strong><see cref = "!:InvalidCall"/></strong> if there are any outstanding references to the original target bitmap associated with the render target.</p><p>Although the target can be a command list, it cannot be any other type of image. It cannot be the output image of an effect.</p>
            </remarks>
            <doc-id>hh404523</doc-id>
            <unmanaged>GetTarget / SetTarget</unmanaged>
            <unmanaged-short>GetTarget</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.DeviceContext.RenderingControls">
            <summary>
            <p>Gets or sets the rendering controls that have been applied to the context.</p>
            </summary>
            <doc-id>hh404519</doc-id>
            <unmanaged>GetRenderingControls / SetRenderingControls</unmanaged>
            <unmanaged-short>GetRenderingControls</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.DeviceContext.PrimitiveBlend">
            <summary>
            <p>Returns or sets the currently set primitive blend used by the device context.  </p>
            </summary>
            <doc-id>hh404517</doc-id>
            <unmanaged>GetPrimitiveBlend / SetPrimitiveBlend</unmanaged>
            <unmanaged-short>GetPrimitiveBlend</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.DeviceContext.UnitMode">
            <summary>
            <p>Gets or sets the mode that  is being used to interpret values by the device context.</p>
            </summary>
            <doc-id>hh404525</doc-id>
            <unmanaged>GetUnitMode / SetUnitMode</unmanaged>
            <unmanaged-short>GetUnitMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateBitmap(SharpDX.Size2,System.IntPtr,System.Int32,SharpDX.Direct2D1.BitmapProperties1,SharpDX.Direct2D1.Bitmap1)">
            <summary>
            <p>Creates a bitmap that can be used as a target surface, for reading back to the CPU, or as a source for the <strong>DrawBitmap</strong> and <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> APIs. In addition, color context information can be passed to the bitmap.</p>
            </summary>
            <param name = "size">No documentation.</param>
            <param name = "sourceData">No documentation.</param>
            <param name = "pitch">No documentation.</param>
            <param name = "bitmapProperties">No documentation.</param>
            <param name = "bitmap">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The new bitmap can be used as a target for <strong>SetTarget</strong> if it is created with <strong>D2D1_BITMAP_OPTIONS_TARGET</strong>.</p>
            </remarks>
            <doc-id>hh404480</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateBitmapFromWicBitmap(SharpDX.WIC.BitmapSource,SharpDX.Direct2D1.BitmapProperties1,SharpDX.Direct2D1.Bitmap1@)">
            <summary>
            <p>Creates a Direct2D bitmap by copying a WIC bitmap.</p>
            </summary>
            <param name = "wicBitmapSource"><dd>  <p>The WIC bitmap source to copy from.</p> </dd></param>
            <param name = "bitmapProperties"><dd>  <p>A bitmap properties structure that specifies bitmap creation options.</p> </dd></param>
            <param name = "bitmap"><dd>  <p>The address of the newly created bitmap object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Starting with Windows?8.1, the  <em>bitmapProperties</em> parameter is optional. When it is not specified, the created bitmap inherits the pixel format and alpha mode from  <em>wicBitmapSource</em>. For a list of supported pixel formats and alpha modes, see Supported Pixel Formats and Alpha Modes.</p><p>When the <em>bitmapProperties</em> parameter is specified, the value in <em>bitmapProperties-&gt;pixelFormat</em> must either be <strong>DXGI_FORMAT_UNKNOWN</strong> or must match the WIC pixel format in <em>wicBitmapSource</em>.</p><p>When <em>bitmapProperties-&gt;pixelFormat.alphaMode</em> is set to <strong>D2D1_ALPHA_MODE_UNKNOWN</strong>, the newly created bitmap inherits the alpha mode from <em>wicBitmapSource</em>. When <em>bitmapProperties-&gt;pixelFormat.alphaMode</em> is set to <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong>, <strong>D2D1_ALPHA_MODE_STRAIGHT</strong>, or <strong>D2D1_ALPHA_MODE_IGNORE</strong>, this forces the newly created bitmap to use the specified alpha mode.</p>
            </remarks>
            <doc-id>hh847971</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out] ID2D1Bitmap1** bitmap)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateBitmapFromWicBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateColorContext(SharpDX.Direct2D1.ColorSpace,System.Byte[],System.Int32,SharpDX.Direct2D1.ColorContext)">
            <summary>
            <p>Creates a color context.</p>
            </summary>
            <param name = "space"><dd>  <p>The space  of color context to create.</p> </dd></param>
            <param name = "rofileRef"><dd>  <p>A buffer containing the ICC profile bytes used to initialize the color context when <em>space</em> is <strong>D2D1_COLOR_SPACE_CUSTOM</strong>.  For other types, the parameter is ignored and should be set to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "profileSize"><dd>  <p>The size in bytes of <em>Profile</em>.</p> </dd></param>
            <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The new color context can be used in <strong><see cref = "T:SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.</p><p>When <em>space</em> is <strong>D2D1_COLOR_SPACE_CUSTOM</strong>, <em>profile</em> and <em>profileSize</em> must be specified.  Otherwise, these parameters should be set to <strong><c>null</c></strong> and zero respectively.  When the space is D2D1_COLOR_SPACE_CUSTOM, the model field of the profile header is inspected to determine if this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space remains custom.</p>
            </remarks>
            <doc-id>hh404485</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateColorContextFromFilename(System.String,SharpDX.Direct2D1.ColorContext)">
            <summary>
            <p>Creates a color context by loading it from the specified filename.  The profile bytes are the contents of the file specified by <em>Filename</em>.</p>
            </summary>
            <param name = "filename"><dd>  <p>The path to the file containing the profile bytes to initialize the color context with.</p> </dd></param>
            <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The new color context can be used in <strong><see cref = "T:SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>
            </remarks>
            <doc-id>hh404488</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateColorContextFromFilename</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateColorContextFromWicColorContext(SharpDX.WIC.ColorContext,SharpDX.Direct2D1.ColorContext)">
            <summary>
            <p>Creates a color context from an <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong>.  The <strong>D2D1ColorContext</strong> space of the resulting context varies, see Remarks for more info.</p>
            </summary>
            <param name = "wicColorContext">No documentation.</param>
            <param name = "colorContext">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The new color context can be used in <strong><see cref = "T:SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>
            </remarks>
            <doc-id>hh404491</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateColorContextFromWicColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateBitmapFromDxgiSurface(SharpDX.DXGI.Surface,SharpDX.Direct2D1.BitmapProperties1,SharpDX.Direct2D1.Bitmap1)">
            <summary>
            <p> Creates a bitmap from a DXGI surface that can be set as a target surface or have additional color context information specified.</p>
            </summary>
            <param name = "surface"><dd>  <p>The DXGI surface from which the bitmap can be created.  </p> <strong>Note</strong>??The DXGI surface must have been created from the same Direct3D device that the Direct2D device context is associated with. ? </dd></param>
            <param name = "bitmapProperties"><dd>  <p>The bitmap properties specified in addition to the surface. </p> </dd></param>
            <param name = "bitmap"><dd>  <p>When this method returns, contains the address of a reference to a new bitmap object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>If the bitmap properties are not specified, the following information is assumed: </p><ul> <li>The bitmap DPI is 96.</li> <li>The pixel format matches that of the surface.</li> <li>The returned bitmap will inherit the bind flags of the DXGI surface.<ul> <li>However, only the subset of flags meaningful to Direct2D will be inherited. For example, D3D10_USAGE_DYNAMIC is not compatible with any public Direct2D flags.</li> </ul> </li> <li>The color context is unknown.</li> <li>The alpha mode of the bitmap will be premultiplied (common case) or straight (A8).
            </li> </ul><p>If the bitmap properties are specified, the bitmap properties will be used as follows:</p><ul> <li>The bitmap DPI will be specified by the bitmap properties.</li> <li>If both dpiX and dpiY are 0, the bitmap DPI will be 96.</li> <li>The pixel format must be compatible with the shader resource view or render target view of the surface.</li> <li>The bitmap options must be compatible with the bind flags of the DXGI surface. However, they may be a subset. This will influence what resource views are created by the bitmap.</li> <li>The color context information will be used from the bitmap properties, if specified.</li> </ul>
            </remarks>
            <doc-id>hh404482</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromDxgiSurface([In] IDXGISurface* surface,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateBitmapFromDxgiSurface</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateEffect(System.Guid,SharpDX.Direct2D1.Effect)">
            <summary>
            <p>Creates an effect for the specified class ID. </p>
            </summary>
            <param name = "effectId"><dd>  <p>The class ID of the effect to create. See Built-in Effects for a list of effect IDs.</p> </dd></param>
            <param name = "effect"><dd>  <p>When this method returns, contains the address of a reference to a new effect.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation. </td></tr> <tr><td><see cref = "!:EffectIsNotRegistered"/></td><td>The specified effect is not registered by the system.</td></tr> <tr><td><see cref = "!:InsufficientDeviceCapabilities"/> </td><td>The effect requires capabilities not supported by the D2D device.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the  created effect is a custom effect that is implemented in a DLL, this doesn't increment the reference count for that DLL.  If the application deletes an effect while that effect is loaded, the resulting behavior is unpredictable. </p>
            </remarks>
            <doc-id>hh404500</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateGradientStopCollection(SharpDX.Direct2D1.GradientStop[],System.Int32,SharpDX.Direct2D1.ColorSpace,SharpDX.Direct2D1.ColorSpace,SharpDX.Direct2D1.BufferPrecision,SharpDX.Direct2D1.ExtendMode,SharpDX.Direct2D1.ColorInterpolationMode,SharpDX.Direct2D1.GradientStopCollection1)">
            <summary>
            <p>Creates a gradient stop collection, enabling the gradient to contain color channels with values outside of [0,1] and also enabling rendering to a high-color render target with interpolation in sRGB space.</p>
            </summary>
            <param name = "straightAlphaGradientStops"><dd>  <p>An array of color values and offsets.</p> </dd></param>
            <param name = "straightAlphaGradientStopsCount"><dd>  <p>The number of elements in the <em>gradientStops</em> array.</p> </dd></param>
            <param name = "preInterpolationSpace"><dd>  <p>Specifies both the input color space and the space in which the color interpolation occurs.</p> </dd></param>
            <param name = "postInterpolationSpace"><dd>  <p>The color space that colors will be converted to after interpolation occurs.</p> </dd></param>
            <param name = "bufferPrecision"><dd>  <p>The precision of the texture used to hold interpolated values.</p> <strong>Note</strong>??This method will fail if the underlying Direct3D device does not support the requested buffer precision.  Use <strong>ID2D1DeviceContext::IsBufferPrecisionSupported</strong> to determine what is supported. ? </dd></param>
            <param name = "extendMode"><dd>  <p>Defines how colors outside of the range defined by the stop collection are determined.</p> </dd></param>
            <param name = "colorInterpolationMode"><dd>  <p>Defines how colors are interpolated.  D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED is the default, see Remarks for more info.</p> </dd></param>
            <param name = "gradientStopCollection1"><dd>  <p>The new gradient stop collection.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method linearly interpolates between the color stops. An optional color space conversion is applied post-interpolation. Whether and how this gamma conversion is applied is determined by the pre- and post-interpolation. This method will fail if the device context does not support the requested buffer precision.</p><p>In order to get the desired result, you need to ensure that the inputs are specified in the correct color space. 
            </p><p>You must always specify colors in straight alpha, regardless of interpolation mode being premultiplied or straight. The interpolation mode only affects the interpolated values. Likewise, the stops returned by <strong>ID2D1GradientStopCollection::GetGradientStops</strong> will always have straight alpha. </p><p>If you specify <strong>D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED</strong>, then all stops are premultiplied before interpolation, and then un-premultiplied before color conversion.
            </p><p>Starting with Windows?8, the interpolation behavior of this method has changed.  </p><p>The table here shows the behavior in Windows?7 and earlier.</p><table> <tr><th>Gamma</th><th>Before Interpolation Behavior</th><th>After Interpolation Behavior</th><th>GetColorInteroplationGamma
            (output color space)
            </th></tr> <tr><td>1.0</td><td>Clamps the inputs and then converts from sRGB to scRGB.</td><td>Converts from scRGB to sRGB post-interpolation.</td><td>1.0</td></tr> <tr><td>2.2</td><td>Clamps the inputs.</td><td>No Operation</td><td>2.2</td></tr> </table><p>?</p><p>The table here shows the behavior in Windows?8 and later.</p><table> <tr><th>Gamma</th><th>Before Interpolation Behavior</th><th>After Interpolation Behavior</th><th>GetColorInteroplationGamma
            (output color space)
            </th></tr> <tr><td>sRGB to scRGB</td><td>No Operation</td><td>Clamps the outputs and then converts from sRGB to scRGB.</td><td>1.0</td></tr> <tr><td>scRGB to sRGB</td><td>No Operation</td><td>Clamps the outputs and then converts from sRGB to scRGB.</td><td>2.2</td></tr> <tr><td>sRGB to sRGB</td><td>No Operation</td><td>No Operation</td><td>2.2</td></tr> <tr><td>scRGB to scRGB</td><td>No Operation</td><td>No Operation</td><td>1.0</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>hh404502</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* straightAlphaGradientStops,[In] unsigned int straightAlphaGradientStopsCount,[In] D2D1_COLOR_SPACE preInterpolationSpace,[In] D2D1_COLOR_SPACE postInterpolationSpace,[In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_EXTEND_MODE extendMode,[In] D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,[Out, Fast] ID2D1GradientStopCollection1** gradientStopCollection1)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateGradientStopCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateImageBrush(SharpDX.Direct2D1.Image,SharpDX.Direct2D1.ImageBrushProperties@,System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.ImageBrush)">
            <summary>
            <p>Creates an image brush. The input image can be any type of image, including a bitmap, effect, or a command list.
            </p>
            </summary>
            <param name = "image"><dd>  <p>The image to be used as a source for the image brush.</p> </dd></param>
            <param name = "imageBrushProperties"><dd>  <p>The properties specific to an image brush.</p> </dd></param>
            <param name = "brushProperties"><dd>  <p>Properties  common to all brushes.</p> </dd></param>
            <param name = "imageBrush"><dd>  <p>When this method returns, contains the address of a reference to the  input rectangles.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The image brush can be used to fill an arbitrary geometry, an opacity mask or text.</p><p>This sample illustrates drawing a rectangle with an image brush.</p><pre><see cref = "T:SharpDX.Result"/>
            CreatePatternBrush( __in <see cref = "T:SharpDX.Direct2D1.DeviceContext"/> *pDeviceContext, __deref_out <see cref = "T:SharpDX.Direct2D1.ImageBrush"/> **ppImageBrush )
            { <see cref = "T:SharpDX.Result"/> hr = <see cref = "F:SharpDX.Result.Ok"/>; <see cref = "T:SharpDX.Direct2D1.Image"/> *pOldTarget = <c>null</c>; pDeviceContext-&gt;GetTarget(&amp;pOldTarget); <see cref = "T:SharpDX.Direct2D1.CommandList"/> *pCommandList = <c>null</c>; hr = pDeviceContext-&gt;CreateCommandList(&amp;pCommandList); if (SUCCEEDED(hr)) {    pDeviceContext-&gt;SetTarget(pCommandList); hr = RenderPatternToCommandList(pDeviceContext); } pDeviceContext-&gt;SetTarget(pOldTarget); <see cref = "T:SharpDX.Direct2D1.ImageBrush"/> *pImageBrush = <c>null</c>; if (SUCCEEDED(hr)) {         hr = pDeviceContext-&gt;CreateImageBrush( pCommandList, D2D1::ImageBrushProperties( D2D1::RectF(198, 298, 370, 470), D2D1_EXTEND_MODE_WRAP, D2D1_EXTEND_MODE_WRAP, D2D1_INTERPOLATION_MODE_LINEAR ), &amp;pImageBrush ); } // Fill a rectangle with the image brush. if (SUCCEEDED(hr)) { pDeviceContext-&gt;FillRectangle( D2D1::RectF(0, 0, 100, 100), pImageBrush); } SafeRelease(&amp;pImageBrush); SafeRelease(&amp;pCommandList); SafeRelease(&amp;pOldTarget); return hr;
            }</pre>
            </remarks>
            <doc-id>hh404506</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateImageBrush([In, Optional] ID2D1Image* image,[In] const D2D1_IMAGE_BRUSH_PROPERTIES* imageBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1ImageBrush** imageBrush)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateImageBrush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateBitmapBrush(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Direct2D1.BitmapBrushProperties1},System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.BitmapBrush1)">
            <summary>
            <p>Creates a bitmap brush, the input image is a Direct2D bitmap object.</p>
            </summary>
            <param name = "bitmap"><dd>  <p>The bitmap to use as the brush.</p> </dd></param>
            <param name = "bitmapBrushProperties"><dd>  <p>A bitmap brush properties structure.</p> </dd></param>
            <param name = "brushProperties"><dd>  <p>A brush properties structure.</p> </dd></param>
            <param name = "bitmapBrush"><dd>  <p>The address of the newly created bitmap brush object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh847970</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In, Optional] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateBitmapBrush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.CreateCommandList(SharpDX.Direct2D1.CommandList)">
            <summary>
            <p>Creates a <strong><see cref = "T:SharpDX.Direct2D1.CommandList"/></strong> object.</p>
            </summary>
            <param name = "commandList">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A <strong><see cref = "T:SharpDX.Direct2D1.CommandList"/></strong> can store Direct2D commands to be displayed later through <strong>ID2D1DeviceContext::DrawImage</strong> or through an image brush.</p>
            </remarks>
            <doc-id>hh404494</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateCommandList([Out, Fast] ID2D1CommandList** commandList)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::CreateCommandList</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.IsDxgiFormatSupported(SharpDX.DXGI.Format)">
            <summary>
            <p> Indicates whether the format is supported by the device context.  The formats supported are usually determined by the underlying hardware.</p>
            </summary>
            <param name = "format"><dd>  <p>The DXGI format to check.</p> </dd></param>
            <returns><p>Returns TRUE if the format is supported.  Returns <see cref = "F:SharpDX.Result.False"/> if the format is not supported.</p></returns>
            <remarks>
            <p>You can use supported formats in the <strong><see cref = "T:SharpDX.Direct2D1.PixelFormat"/></strong> structure to create bitmaps and render targets. Direct2D doesn't support all DXGI formats, even though they may have some level of Direct3D support by the hardware.
            </p>
            </remarks>
            <doc-id>hh847982</doc-id>
            <unmanaged>BOOL ID2D1DeviceContext::IsDxgiFormatSupported([In] DXGI_FORMAT format)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::IsDxgiFormatSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.IsBufferPrecisionSupported(SharpDX.Direct2D1.BufferPrecision)">
            <summary>
            <p>Indicates whether the buffer precision is supported by the underlying Direct3D <strong>device.</strong> </p>
            </summary>
            <param name = "bufferPrecision">No documentation.</param>
            <returns><p>Returns TRUE if the buffer precision is supported.  Returns <see cref = "F:SharpDX.Result.False"/> if the buffer precision is not supported.</p></returns>
            <doc-id>dn441541</doc-id>
            <unmanaged>BOOL ID2D1DeviceContext::IsBufferPrecisionSupported([In] D2D1_BUFFER_PRECISION bufferPrecision)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::IsBufferPrecisionSupported</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetImageLocalBounds(SharpDX.Direct2D1.Image)">
            <summary>
            <p>Gets the bounds of an image without the world transform of the context applied.</p>
            </summary>
            <param name = "image"><dd>  <p>The image whose bounds will be calculated.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a reference to the bounds of the image in device independent pixels (DIPs) and in local space.</p> </dd></returns>
            <remarks>
            <p>The image bounds don't include multiplication by the world transform.  They do reflect the current DPI, unit mode, and interpolation mode of the context.   To get the bounds that include the world transform, use <strong>ID2D1DeviceContext::GetImageWorldBounds</strong>.</p><p>The returned bounds reflect which pixels would be impacted by calling <strong>DrawImage</strong> with a  target offset of (0,0) and an identity world transform matrix. They do not reflect the current clip rectangle set on the device context or the extent of the context's current target image.</p>
            </remarks>
            <doc-id>hh404515</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::GetImageLocalBounds([In] ID2D1Image* image,[Out] D2D_RECT_F* localBounds)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetImageLocalBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetImageWorldBounds(SharpDX.Direct2D1.Image)">
            <summary>
            <p>Gets the bounds of an image with the world transform of the context applied.</p>
            </summary>
            <param name = "image"><dd>  <p>The image whose bounds will be calculated.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a reference to the bounds of the image in device independent pixels (DIPs).</p> </dd></returns>
            <remarks>
            <p>The image bounds reflect the current DPI, unit mode, and world transform of the context.  To get bounds which don't include the world transform, use <strong>ID2D1DeviceContext::GetImageLocalBounds</strong>. </p><p>The returned bounds reflect which pixels would be impacted by calling <strong>DrawImage</strong> with the same image and a target offset of (0,0).  They do not reflect the current clip rectangle set on the device context or the extent of the context?s current target image.
            </p>
            </remarks>
            <doc-id>hh847979</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::GetImageWorldBounds([In] ID2D1Image* image,[Out] D2D_RECT_F* worldBounds)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetImageWorldBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetGlyphRunWorldBounds(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p> Gets the world-space bounds in DIPs of the glyph run using the device context DPI. </p>
            </summary>
            <param name = "baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>The glyph run to render.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>The DirectWrite measuring mode that indicates how glyph metrics are used to measure text when it is formatted.</p> </dd></param>
            <returns><dd>  <p>The bounds of the glyph run in DIPs and in world space.</p> </dd></returns>
            <remarks>
            <p>The image bounds reflect the current DPI, unit mode, and world transform of the context. </p>
            </remarks>
            <doc-id>hh847978</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::GetGlyphRunWorldBounds([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[Out] D2D_RECT_F* bounds)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetGlyphRunWorldBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetDevice(SharpDX.Direct2D1.Device@)">
            <summary>
            <p>Gets the device associated with a device context.</p>
            </summary>
            <param name = "device"><dd>  <p>When this method returns, contains the address of a reference to a Direct2D device associated with this device context.</p> </dd></param>
            <remarks>
            <p>The application can retrieve the device even if it is created from an earlier render target code-path. The application must use an <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext"/></strong> interface and then call <strong>GetDevice</strong>. Some functionality for controlling all of the resources for a set of device contexts is maintained only on an <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> object.</p>
            </remarks>
            <doc-id>hh404513</doc-id>
            <unmanaged>void ID2D1DeviceContext::GetDevice([Out] ID2D1Device** device)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.SetTarget(SharpDX.Direct2D1.Image)">
            <summary>
            <p>The bitmap or command list to which the Direct2D device context will now render.</p>
            </summary>
            <param name = "image">No documentation.</param>
            <remarks>
            <p>The target can be changed at any time, including while the context is drawing.</p><p>The target can be either a bitmap created with the <strong>D2D1_BITMAP_OPTIONS_TARGET</strong> flag, or it can be a command list. Other kinds of images cannot be set as a target. For example, you cannot set the output of an effect as target. If the target is not valid the context will enter the <strong><see cref = "!:InvalidTarget"/> </strong>error state.</p><p>You cannot  use <strong>SetTarget</strong> to render to a bitmap/command list from multiple device contexts simultaneously. An image is considered ?being rendered to? if it has ever been set on a device context within a <strong>BeginDraw</strong>/<strong>EndDraw</strong> timespan. If an attempt is made to render to an image through multiple device contexts, all subsequent device contexts after the first will enter an error state. </p><p>Callers wishing to attach an image to a second device context should first call <strong>EndDraw</strong> on the first device context.
            </p><p>Here is an example of the correct calling order.</p><pre>pDC1-&gt;BeginDraw();
            pDC1-&gt;SetTarget(pImage);
            // ?
            pDC1-&gt;EndDraw(); pDC2-&gt;BeginDraw();
            pDC2-&gt;SetTarget(pImage);
            // ?
            pDC2-&gt;EndDraw();
            </pre><p>Here is an example of the incorrect calling order.</p><pre>pDC1-&gt;BeginDraw();
            pDC2-&gt;BeginDraw(); pDC1-&gt;SetTarget(pImage); // ... pDC1-&gt;SetTarget(<c>null</c>); pDC2-&gt;SetTarget(pImage); // This call is invalid, even though pImage is no longer set on pDC1. // ... pDC1-&gt;EndDraw(); // This EndDraw SUCCEEDs.
            pDC2-&gt;EndDraw(); // This EndDraw FAILs </pre><strong>Note</strong>??Changing the target does not change the bitmap that an <see cref = "T:System.IntPtr"/> render target presents from, nor does it change the bitmap that a DC render target blts to/from.?<p>This API makes it easy for an application to use a bitmap as a source (like in <strong>DrawBitmap</strong>) and as a destination at the same time.  Attempting to use a bitmap as a source on the same device context to which it is bound as a target will put the device context into the <see cref = "!:BitmapBoundAsTarget"/> error state.</p><p>It is acceptable to have a bitmap bound as a target bitmap on multiple render targets at once.  Applications that do this must properly synchronize rendering with <strong>Flush</strong> or <strong>EndDraw</strong>.</p><p>You can change the target at any time, including while the context is drawing.</p><p>You can set the target to <c>null</c>, in which case drawing calls will put the device context into an error state with <see cref = "!:WrongState"/>.  Calling <strong>SetTarget</strong> with a <c>null</c> target does not restore the original target bitmap to the device context.</p><p>If the device context has an outstanding <see cref = "T:System.IntPtr"/>, the context will enter the <strong><see cref = "!:WrongState"/></strong> error state.  The target will not be changed.</p><p>If the bitmap and the device context are not in the same resource domain, the context will enter <strong>\</strong> error state.  The target will not be changed.</p><p> <strong>ID2D1RenderTarget::GetPixelSize</strong> returns the size of the current target bitmap (or 0, 0) if there is no bitmap bound).
            <strong>ID2D1RenderTarget::GetSize</strong> returns the pixel size of the current bitmap scaled by the DPI of the render target.
            <strong>SetTarget</strong> does not affect the DPI of the render target.
            </p><p> <strong>ID2D1RenderTarget::GetPixelFormat</strong> returns the pixel format of the current target bitmap (or <strong>DXGI_FORMAT_UNKNOWN</strong>, <strong>D2D1_ALPHA_MODE_UNKNOWN</strong> if there is none).</p><p> <strong>ID2D1Bitmap::CopyFromRenderTarget</strong> copies from the currently bound target bitmap.</p>
            </remarks>
            <doc-id>hh404533</doc-id>
            <unmanaged>void ID2D1DeviceContext::SetTarget([In, Optional] ID2D1Image* image)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::SetTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetTarget(SharpDX.Direct2D1.Image@)">
            <summary>
            <p>Gets the target currently associated with the device context.</p>
            </summary>
            <param name = "image"><dd>  <p>When this method returns, contains the address of a reference to the target currently associated with the device context.</p> </dd></param>
            <remarks>
            <p>If a target is not associated with the device context, <em>target</em> will contain <strong><c>null</c></strong> when the methods returns.</p><p>If the currently selected target is a bitmap rather than a command list, the application can gain access to the initial bitmaps created by using one of the following methods:</p><ul> <li> <strong>CreateHwndRenderTarget</strong> </li> <li> <strong>CreateDxgiSurfaceRenderTarget</strong> </li> <li> <strong>CreateWicBitmapRenderTarget</strong> </li> <li> <strong>CreateDCRenderTarget</strong> </li> <li> <strong>CreateCompatibleRenderTarget</strong> </li> </ul><p>It is not possible for an application to destroy these bitmaps.  All of these bitmaps are bindable as bitmap targets.  However not all of these bitmaps can be used as bitmap sources for  <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> methods.</p><p> <strong>CreateDxgiSurfaceRenderTarget</strong> will create a bitmap that is usable as a bitmap source if the DXGI surface is bindable as a shader resource view.</p><p> <strong>CreateCompatibleRenderTarget</strong> will always create bitmaps that are usable as a bitmap source.</p><p> <strong>ID2D1RenderTarget::BeginDraw</strong> will copy from the <see cref = "T:System.IntPtr"/> to the original bitmap associated with it.  <strong>ID2D1RenderTarget::EndDraw</strong> will copy from the original bitmap to the <see cref = "T:System.IntPtr"/>.  </p><p> <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> objects will be locked in the following circumstances:</p><ul> <li>BeginDraw has been called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is set as the target of a device context after BeginDraw has been called and before EndDraw has been called.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p><see cref = "T:SharpDX.WIC.Bitmap"/> objects will be unlocked in the following circumstances:</p><ul> <li>EndDraw is called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is removed as the target of a device context between the calls to BeginDraw and EndDraw.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p>Direct2D will only lock bitmaps that are not currently locked.</p><p>Calling <strong>QueryInterface</strong> for <strong><see cref = "T:SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> will always succeed.  <strong>ID2D1GdiInteropRenderTarget::GetDC</strong> will return a device context corresponding to the currently bound target bitmap.  GetDC will fail if the target bitmap was not created with the GDI_COMPATIBLE flag set.</p><p> <strong>ID2D1HwndRenderTarget::Resize</strong> will return <strong><see cref = "!:InvalidCall"/></strong> if there are any outstanding references to the original target bitmap associated with the render target.</p><p>Although the target can be a command list, it cannot be any other type of image. It cannot be the output image of an effect.</p>
            </remarks>
            <doc-id>hh404523</doc-id>
            <unmanaged>void ID2D1DeviceContext::GetTarget([Out, Optional] ID2D1Image** image)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.SetRenderingControls(SharpDX.Direct2D1.RenderingControls)">
            <summary>
            <p>Sets the rendering controls for the given device context. </p>
            </summary>
            <param name = "renderingControls"><dd>  <p>The rendering controls to be applied.</p> </dd></param>
            <remarks>
            <p> The rendering controls allow the  application to tune the precision, performance, and resource usage of rendering operations.</p>
            </remarks>
            <doc-id>hh404530</doc-id>
            <unmanaged>void ID2D1DeviceContext::SetRenderingControls([In] const D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::SetRenderingControls</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetRenderingControls(SharpDX.Direct2D1.RenderingControls@)">
            <summary>
            <p>Gets the rendering controls that have been applied to the context.</p>
            </summary>
            <param name = "renderingControls"><dd>  <p>When this method returns, contains a reference to the rendering controls for this context.</p> </dd></param>
            <doc-id>hh404519</doc-id>
            <unmanaged>void ID2D1DeviceContext::GetRenderingControls([Out] D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetRenderingControls</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.SetPrimitiveBlend(SharpDX.Direct2D1.PrimitiveBlend)">
            <summary>
            <p>Changes the primitive blend mode that is used for all rendering operations in the device context.</p>
            </summary>
            <param name = "primitiveBlend"><dd>  <p>The primitive blend to use.</p> </dd></param>
            <remarks>
            <p>The primitive blend will apply to all of the primitive drawn on the context, unless this is overridden with the <em>compositeMode</em> parameter on the <strong>DrawImage</strong> API.</p><p> The primitive blend applies to the interior of any primitives drawn on the context. In the case of <strong>DrawImage</strong>, this will be implied by the image rectangle, offset and world transform.</p><p>If the primitive blend is anything other than <strong>D2D1_PRIMITIVE_BLEND_SOURCE_OVER</strong> then ClearType rendering will be turned off. If the application explicitly forces ClearType rendering in these modes, the drawing context will be placed in an error state. <see cref = "!:WrongState"/> will be returned from either <strong>EndDraw</strong> or <strong>Flush</strong>.
            </p>
            </remarks>
            <doc-id>hh404527</doc-id>
            <unmanaged>void ID2D1DeviceContext::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::SetPrimitiveBlend</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetPrimitiveBlend">
            <summary>
            <p>Returns the currently set primitive blend used by the device context.  </p>
            </summary>
            <returns><p>The current primitive blend. The default value is <strong>D2D1_PRIMITIVE_BLEND_SOURCE_OVER</strong>.</p></returns>
            <doc-id>hh404517</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND ID2D1DeviceContext::GetPrimitiveBlend()</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetPrimitiveBlend</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.SetUnitMode(SharpDX.Direct2D1.UnitMode)">
            <summary>
            <p>Sets what units will be used to interpret values passed into the device context.</p><p></p>
            </summary>
            <param name = "unitMode"><dd>  <p>An enumeration defining how passed-in units will be interpreted by the device context.</p> </dd></param>
            <remarks>
            <p> This method will affect all properties and parameters affected by <strong>SetDpi</strong> and <strong>GetDpi</strong>. This affects all coordinates, lengths, and other properties that are  not explicitly defined as being in another unit. For example:</p><ul> <li><strong>SetUnitMode</strong> will affect a coordinate passed  into <strong>ID2D1DeviceContext::DrawLine</strong>, and the scaling of a  geometry passed into <strong>ID2D1DeviceContext::FillGeometry</strong>. </li> <li><strong>SetUnitMode</strong> will not affect the value returned by <strong>ID2D1Bitmap::GetPixelSize</strong>. </li> </ul>
            </remarks>
            <doc-id>hh404539</doc-id>
            <unmanaged>void ID2D1DeviceContext::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::SetUnitMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetUnitMode">
            <summary>
            <p>Gets the mode that  is being used to interpret values by the device context.</p>
            </summary>
            <returns><p>The  unit mode.</p></returns>
            <doc-id>hh404525</doc-id>
            <unmanaged>D2D1_UNIT_MODE ID2D1DeviceContext::GetUnitMode()</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetUnitMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p>Draws a series of glyphs to the device context.</p>
            </summary>
            <param name = "baselineOrigin"><dd>  <p>Origin of first glyph in the series.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
            <param name = "glyphRunDescription"><dd>  <p>Supplementary glyph series information.</p> </dd></param>
            <param name = "foregroundBrush"><dd>  <p>The brush that defines the text color.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>The measuring mode of the glyph series, used to determine the advances and offsets. The default value is DWRITE_MEASURING_MODE_NATURAL.</p> </dd></param>
            <remarks>
            <p>The <em>glyphRunDescription</em> is ignored when rendering, but can be useful for printing and serialization of rendering commands, such as to an XPS or SVG file. This extends <strong>ID2D1RenderTarget::DrawGlyphRun</strong>, which lacked the glyph run description.</p>
            </remarks>
            <doc-id>hh404508</doc-id>
            <unmanaged>void ID2D1DeviceContext::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::DrawGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawImage(SharpDX.Direct2D1.Image,System.Nullable{SharpDX.Mathematics.Interop.RawVector2},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},SharpDX.Direct2D1.InterpolationMode,SharpDX.Direct2D1.CompositeMode)">
            <summary>
            <p></p><p>A command list cannot reference effects which are part of effect graphs that consume the command list.</p>
            </summary>
            <param name = "image">No documentation.</param>
            <param name = "targetOffset">No documentation.</param>
            <param name = "imageRectangle">No documentation.</param>
            <param name = "interpolationMode">No documentation.</param>
            <param name = "compositeMode">No documentation.</param>
            <doc-id>jj835880</doc-id>
            <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::DrawImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawVector2})">
            <summary>
            <p>Draw a metafile to the device context.</p>
            </summary>
            <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
            <param name = "targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>
            <doc-id>jj841147</doc-id>
            <unmanaged>void ID2D1DeviceContext::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::DrawGdiMetafile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Single,SharpDX.Direct2D1.InterpolationMode,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawMatrix})">
            <summary>
            <p>Draws a bitmap to the render target.</p>
            </summary>
            <param name = "bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>
            <param name = "opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>
            <param name = "erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>
            <remarks>
            <p>The destinationRectangle parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If <c>null</c> is specified, then the destination rectangle is (left=0, top=0, right = width(sourceRectangle), bottom = height(sourceRectangle)). </p><p>The <em>sourceRectangle</em> parameter defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> will clip this rectangle to the size of the source bitmap, thus making it impossible to sample outside of the bitmap.  If <c>null</c> is specified, then the source rectangle is taken to be the size of the source bitmap. </p><p>If you specify <em>perspectiveTransform</em> it is applied to the rect in addition to the transform set on the render target.</p>
            </remarks>
            <doc-id>jj841144</doc-id>
            <unmanaged>void ID2D1DeviceContext::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::DrawBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.PushLayer(SharpDX.Direct2D1.LayerParameters1@,SharpDX.Direct2D1.Layer)">
            <summary>
            <p>Push a layer onto the clip and layer stack of the device context.</p>
            </summary>
            <param name = "layerParameters"><dd>  <p>The parameters that defines the layer.</p> </dd></param>
            <param name = "layer"><dd>  <p>The layer resource to push on the device context that receives subsequent drawing operations. </p> <strong>Note</strong>??If a layer is not specified, Direct2D manages the layer resource automatically. ? </dd></param>
            <doc-id>hh847983</doc-id>
            <unmanaged>void ID2D1DeviceContext::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::PushLayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.InvalidateEffectInputRectangle(SharpDX.Direct2D1.Effect,System.Int32,SharpDX.Mathematics.Interop.RawRectangleF)">
            <summary>
            <p>This indicates that a portion of an effect's input is invalid. This method can be called many times.</p><p>You can use this method to propagate invalid rectangles through an effect graph. You can query Direct2D using the <strong>GetEffectInvalidRectangles</strong> method.</p><strong>Note</strong>??Direct2D does not automatically use these invalid rectangles to reduce the region of an effect that is rendered.?<p>You can also use this method to invalidate caches that have accumulated while rendering effects that have the <strong>D2D1_PROPERTY_CACHED</strong> property set to true.</p>
            </summary>
            <param name = "effect">No documentation.</param>
            <param name = "input">No documentation.</param>
            <param name = "inputRectangle">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh847980</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::InvalidateEffectInputRectangle([In] ID2D1Effect* effect,[In] unsigned int input,[In] const D2D_RECT_F* inputRectangle)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::InvalidateEffectInputRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetEffectInvalidRectangleCount(SharpDX.Direct2D1.Effect)">
            <summary>
            <p> Gets the number of invalid output rectangles that have accumulated on the effect. </p>
            </summary>
            <param name = "effect"><dd>  <p>The effect to count the invalid rectangles on.</p> </dd></param>
            <returns><dd>  <p>The returned rectangle count.</p> </dd></returns>
            <doc-id>hh847975</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangleCount([In] ID2D1Effect* effect,[Out] unsigned int* rectangleCount)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetEffectInvalidRectangleCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetEffectInvalidRectangles(SharpDX.Direct2D1.Effect,SharpDX.Mathematics.Interop.RawRectangleF[],System.Int32)">
            <summary>
            <p>Gets the invalid rectangles that have accumulated since the last time the effect was drawn and <strong>EndDraw</strong> was then called on the device context.</p>
            </summary>
            <param name = "effect">No documentation.</param>
            <param name = "rectangles">No documentation.</param>
            <param name = "rectanglesCount">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p> </p><strong>Note</strong>??Direct2D does not automatically use these invalid rectangles to reduce the region of an effect that is rendered.?<p>You can use the <strong>InvalidateEffectInputRectangle</strong> method to specify invalidated rectangles for Direct2D to propagate through an effect graph.</p><p>If multiple invalid rectangles are requested, the rectangles that this method returns may overlap. When this is the case, the rectangle count might be lower than the count that <strong>GetEffectInvalidRectangleCount</strong>.</p>
            </remarks>
            <doc-id>hh847976</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangles([In] ID2D1Effect* effect,[Out, Buffer] D2D_RECT_F* rectangles,[In] unsigned int rectanglesCount)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetEffectInvalidRectangles</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.GetEffectRequiredInputRectangles(SharpDX.Direct2D1.Effect,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},SharpDX.Direct2D1.EffectInputDescription[],SharpDX.Mathematics.Interop.RawRectangleF[],System.Int32)">
            <summary>
            <p> Returns the input rectangles that are required to be supplied by the caller to produce the given output rectangle.  </p>
            </summary>
            <param name = "renderEffect"><dd>  <p>The image whose output is being rendered.</p> </dd></param>
            <param name = "renderImageRectangle"><dd>  <p>The portion of the output image whose inputs are being inspected.</p> </dd></param>
            <param name = "inputDescriptions"><dd>  <p> A list of the inputs whos rectangles are being queried. </p> </dd></param>
            <param name = "requiredInputRects"><dd>  <p>The input rectangles returned to the caller.</p> </dd></param>
            <param name = "inputCount"><dd>  <p>The number of inputs.</p> </dd></param>
            <returns><p> A failure code, this will typically only be because an effect in the chain returned some error. </p></returns>
            <remarks>
            <p>The caller should be very careful not to place a reliance on the required input rectangles returned.  Small changes for correctness to an effect's behavior can result in different rectangles being returned.  In addition, different kinds of optimization applied inside the render can also influence the result. </p>
            </remarks>
            <doc-id>hh847977</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext::GetEffectRequiredInputRectangles([In] ID2D1Effect* renderEffect,[In, Optional] const D2D_RECT_F* renderImageRectangle,[In, Buffer] const D2D1_EFFECT_INPUT_DESCRIPTION* inputDescriptions,[Out, Buffer] D2D_RECT_F* requiredInputRects,[In] unsigned int inputCount)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::GetEffectRequiredInputRectangles</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext.FillOpacityMask(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>
            <p>Fill using the alpha channel of the supplied opacity mask bitmap. The brush opacity will be modulated by the mask. The render target antialiasing mode must be set to aliased.</p>
            </summary>
            <param name = "opacityMask"><dd>  <p>The bitmap that acts as the opacity mask</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush to use for filling the primitive.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The destination rectangle to output to in the render target</p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>The source rectangle from the opacity mask bitmap.</p> </dd></param>
            <doc-id>hh847974</doc-id>
            <unmanaged>void ID2D1DeviceContext::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext::FillOpacityMask</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext1.#ctor(SharpDX.Direct2D1.Device1,SharpDX.Direct2D1.DeviceContextOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext1"/> class using an existing <see cref="T:SharpDX.Direct2D1.Device1"/>.
            </summary>
            <param name="device">The device.</param>
            <param name="options">The options to be applied to the created device context.</param>
            <remarks>
            The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.
            </remarks>
            <unmanaged>HRESULT ID2D1Device1::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out] ID2D1DeviceContext1** deviceContext1)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext1.CreateFilledGeometryRealization(SharpDX.Direct2D1.Geometry,System.Single,SharpDX.Direct2D1.GeometryRealization)">
            <summary>
            <p>Creates a device-dependent representation of the fill of the geometry that can be subsequently rendered.</p>
            </summary>
            <param name = "geometry"><dd>  <p>The geometry to realize.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>
            <param name = "geometryRealization"><dd>  <p>When this method returns, contains the address of a reference to a new geometry realization object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is used in conjunction with <strong>ID2D1DeviceContext1::DrawGeometryRealization</strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong>D2D1_STROKE_TRANSFORM_TYPE_NORMAL</strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>
            </remarks>
            <doc-id>dn280462</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext1::CreateFilledGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext1::CreateFilledGeometryRealization</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext1.CreateStrokedGeometryRealization(SharpDX.Direct2D1.Geometry,System.Single,System.Single,SharpDX.Direct2D1.StrokeStyle,SharpDX.Direct2D1.GeometryRealization)">
            <summary>
            <p>Creates a device-dependent representation of the stroke of a geometry that can be subsequently rendered.</p>
            </summary>
            <param name = "geometry"><dd>  <p>The geometry to realize.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The stroke style (optional).</p> </dd></param>
            <param name = "geometryRealization"><dd>  <p>When this method returns, contains the address of a reference to a new geometry realization object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This method is used in conjunction with <strong>ID2D1DeviceContext1::DrawGeometryRealization</strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong>D2D1_STROKE_TRANSFORM_TYPE_NORMAL</strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>
            </remarks>
            <doc-id>dn280463</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext1::CreateStrokedGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext1::CreateStrokedGeometryRealization</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext1.DrawGeometryRealization(SharpDX.Direct2D1.GeometryRealization,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Renders a given geometry realization to the target with the specified brush.</p>
            </summary>
            <param name = "geometryRealization"><dd>  <p>The geometry realization to be rendered.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush to render the realization with.</p> </dd></param>
            <remarks>
            <p> This method respects all currently set state (transform, DPI, unit mode, target image, clips, layers);  however, artifacts such as faceting may appear when rendering the realizations with a large effective scale (either via the transform or the DPI).  Callers should create their realizations with an appropriate flattening tolerance using either <strong>D2D1_DEFAULT_FLATTENING_TOLERANCE</strong> or <strong>ComputeFlatteningTolerance</strong> to compensate for this. </p><p>Additionally, callers should be aware of the safe render bounds when creating geometry realizations.  If a geometry extends outside of [-524,287, 524,287] DIPs in either the X- or the Y- direction in its original (pre-transform) coordinate space,  then it may be clipped to those bounds when it is realized. This clipping will be visible even if the realization is subsequently transformed to fit within the safe render bounds.</p>
            </remarks>
            <doc-id>dn280464</doc-id>
            <unmanaged>void ID2D1DeviceContext1::DrawGeometryRealization([In] ID2D1GeometryRealization* geometryRealization,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext1::DrawGeometryRealization</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.#ctor(SharpDX.Direct2D1.Device2,SharpDX.Direct2D1.DeviceContextOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext2"/> class using an existing <see cref="T:SharpDX.Direct2D1.Device2"/>.
            </summary>
            <param name="device">The device.</param>
            <param name="options">The options to be applied to the created device context.</param>
            <remarks>
            The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.
            </remarks>
            <unmanaged>HRESULT ID2D1Device2::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out] ID2D1DeviceContext2** deviceContext2)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateInk(SharpDX.Direct2D1.InkPoint,SharpDX.Direct2D1.Ink)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.Ink"/></strong> object that starts at the given point.</p>
            </summary>
            <param name = "startPoint">No documentation.</param>
            <param name = "ink">No documentation.</param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <doc-id>dn900368</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateInk([In] const D2D1_INK_POINT* startPoint,[Out, Fast] ID2D1Ink** ink)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateInk</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateInkStyle(System.Nullable{SharpDX.Direct2D1.InkStyleProperties},SharpDX.Direct2D1.InkStyle)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.InkStyle"/></strong> object, for use with ink  rendering methods such as <strong>DrawInk</strong>.</p>
            </summary>
            <param name = "inkStyleProperties">No documentation.</param>
            <param name = "inkStyle">No documentation.</param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <doc-id>dn900369</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateInkStyle([In, Optional] const D2D1_INK_STYLE_PROPERTIES* inkStyleProperties,[Out, Fast] ID2D1InkStyle** inkStyle)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateInkStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateGradientMesh(SharpDX.Direct2D1.GradientMeshPatch[],System.Int32,SharpDX.Direct2D1.GradientMesh)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.GradientMesh"/></strong> instance using the given array of patches.</p>
            </summary>
            <param name = "atchesRef">No documentation.</param>
            <param name = "patchesCount">No documentation.</param>
            <param name = "gradientMesh">No documentation.</param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <doc-id>dn890790</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateGradientMesh([In, Buffer] const D2D1_GRADIENT_MESH_PATCH* patches,[In] unsigned int patchesCount,[Out, Fast] ID2D1GradientMesh** gradientMesh)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateGradientMesh</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateImageSourceFromWic(SharpDX.WIC.BitmapSource,SharpDX.Direct2D1.ImageSourceLoadingOptions,SharpDX.Direct2D1.AlphaMode,SharpDX.Direct2D1.ImageSourceFromWic)">
            <summary>
            <p>Creates an image source object from a WIC bitmap source, while populating all pixel memory within the image source.   The image is loaded and stored while using a minimal amount of memory.</p>
            </summary>
            <param name = "wicBitmapSource"><dd>  <p>The WIC bitmap source to create the image source from.</p> </dd></param>
            <param name = "loadingOptions"><dd>  <p>Options for creating the image source.  Default options are used if <c>null</c>.</p> </dd></param>
            <param name = "alphaMode"><dd>  <p>Receives the new image source instance.</p> </dd></param>
            <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <remarks>
            <p> This method creates an image source which can be used to draw the image.  </p><p>This method supports images that exceed the maximum texture size.  Large images are internally stored within a sparse tile cache.   </p><p> This API supports the same set of pixel formats and alpha modes supported by <strong>CreateBitmapFromWicBitmap</strong>.   If the GPU does not support a given pixel format, this method will return <see cref = "!:UnsupportedPixelFormat"/>.  This method does not apply adjustments such as gamma  or alpha premultiplication which affect the appearance of the image. </p><p>This method automatically selects an appropriate storage format to minimize GPU memory usage., such as using separate  luminance and chrominance textures for JPEG images. </p><p>If the loadingOptions argument is <c>null</c>, D2D uses D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE.</p>
            </remarks>
            <doc-id>dn890793</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromWic([In] IWICBitmapSource* wicBitmapSource,[In] D2D1_IMAGE_SOURCE_LOADING_OPTIONS loadingOptions,[In] D2D1_ALPHA_MODE alphaMode,[Out, Fast] ID2D1ImageSourceFromWic** imageSource)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromWic</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateLookupTable3D(SharpDX.Direct2D1.BufferPrecision,System.Int32[],System.Byte[],System.Int32,System.Int32[],SharpDX.Direct2D1.LookupTable3D)">
            <summary>
            <p>Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output. The table data must be provided in 4-channel format.</p>
            </summary>
            <param name = "precision"><dd>  <p>Precision of the input lookup table data.</p> </dd></param>
            <param name = "extents"><dd>  <p>Number of lookup table elements per dimension (X, Y, Z).</p> </dd></param>
            <param name = "data"><dd>  <p>Buffer holding the lookup table data.</p> </dd></param>
            <param name = "dataCount"><dd>  <p>Size of the lookup table data buffer.</p> </dd></param>
            <param name = "strides"><dd>  <p>An array containing two values.  The first value is the size in bytes from one row (X dimension) of LUT data to the next.   The second value is the size in bytes from one LUT data plane (X and Y dimensions) to the next.</p> </dd></param>
            <param name = "lookupTable"><dd>  <p>Receives the new lookup table instance.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <doc-id>dn900373</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateLookupTable3D([In] D2D1_BUFFER_PRECISION precision,[In, Buffer] const unsigned int* extents,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount,[In, Buffer] const unsigned int* strides,[Out, Fast] ID2D1LookupTable3D** lookupTable)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateLookupTable3D</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateImageSourceFromDxgi(SharpDX.DXGI.Surface[],System.Int32,SharpDX.DXGI.ColorSpaceType,SharpDX.Direct2D1.ImageSourceFromDxgiOptions,SharpDX.Direct2D1.ImageSource)">
            <summary>
            <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>
            </summary>
            <param name = "surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>
            <param name = "surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>
            <param name = "colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>
            <param name = "options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>
            <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <remarks>
            <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td>DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li>DXGI_FORMAT_A8_UNORM</li> <li>DXGI_FORMAT_R8_UNORM</li> <li>DXGI_FORMAT_R8G8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8X8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> <li>DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>DXGI_FORMAT_R32G32B32A32_FLOAT</li> <li>DXGI_FORMAT_BC1_UNORM</li> <li>DXGI_FORMAT_BC2_UNORM</li> <li>DXGI_FORMAT_BC3_UNORM</li> </ul> </td></tr> <tr><td>DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li>DXGI_FORMAT_AYUV</li> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> <li>DXGI_FORMAT_V408</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> <tr><td> DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>
            </remarks>
            <doc-id>dn890791</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out, Fast] ID2D1ImageSource** imageSource)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.GetGradientMeshWorldBounds(SharpDX.Direct2D1.GradientMesh,SharpDX.Mathematics.Interop.RawRectangleF@)">
            <summary>
            <p>Returns the world bounds of a given gradient mesh.</p>
            </summary>
            <param name = "gradientMesh"><dd>  <p>The gradient mesh whose world bounds will be calculated.</p> </dd></param>
            <param name = "boundsRef"><dd>  <p>When this method returns, contains a reference to the bounds of the gradient mesh, in device independent pixels (DIPs).</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <remarks>
            <p>The world bounds reflect the current DPI, unit mode, and world transform of the context. They indicate which pixels would be impacted by calling DrawGradientMesh with the given gradient mesh. 
            They do not reflect the current clip rectangle set on the device context or the extent of the context?s current target.</p>
            </remarks>
            <doc-id>dn900380</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::GetGradientMeshWorldBounds([In] ID2D1GradientMesh* gradientMesh,[Out] D2D_RECT_F* pBounds)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::GetGradientMeshWorldBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.DrawInk(SharpDX.Direct2D1.Ink,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.InkStyle)">
            <summary>
            <p>Renders the given ink object using the given brush and ink style.</p>
            </summary>
            <param name = "ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>
            <param name = "inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>
            <doc-id>dn900379</doc-id>
            <unmanaged>void ID2D1DeviceContext2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::DrawInk</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.DrawGradientMesh(SharpDX.Direct2D1.GradientMesh)">
            <summary>
            <p>Renders a given gradient mesh to the target.</p>
            </summary>
            <param name = "gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>
            <doc-id>dn900378</doc-id>
            <unmanaged>void ID2D1DeviceContext2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::DrawGradientMesh</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>
            <p>Draws a metafile to the device context using the given source and destination rectangles.</p>
            </summary>
            <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs) of the render target.  If <c>null</c> is specified, the destination rectangle is {0, 0, w, h}, where w and h are the width and height of the metafile as reported by <strong>ID2D1GdiMetafile::GetBounds</strong>. </p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs) of the metafile.  If <c>null</c> is specified, the source rectangle is the value returned by <strong>ID2D1GdiMetafile1::GetSourceBounds</strong>.</p> </dd></param>
            <doc-id>dn900375</doc-id>
            <unmanaged>void ID2D1DeviceContext2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::DrawGdiMetafile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateTransformedImageSource(SharpDX.Direct2D1.ImageSource,SharpDX.Direct2D1.TransformedImageSourceProperties@,SharpDX.Direct2D1.TransformedImageSource)">
            <summary>
            <p>Creates an image source which shares resources with an original.</p>
            </summary>
            <param name = "imageSource"><dd>  <p>The original image.</p> </dd></param>
            <param name = "ropertiesRef"><dd>  <p>Properties for the source image.</p> </dd></param>
            <param name = "transformedImageSource"><dd>  <p>Receives the new image source.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn934381</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateTransformedImageSource([In] ID2D1ImageSource* imageSource,[In] const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties,[Out, Fast] ID2D1TransformedImageSource** transformedImageSource)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateTransformedImageSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateImageSourceFromDxgi(SharpDX.ComArray{SharpDX.DXGI.Surface},System.Int32,SharpDX.DXGI.ColorSpaceType,SharpDX.Direct2D1.ImageSourceFromDxgiOptions,SharpDX.Direct2D1.ImageSource)">
            <summary>
            <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>
            </summary>
            <param name = "surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>
            <param name = "surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>
            <param name = "colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>
            <param name = "options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>
            <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <remarks>
            <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td>DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li>DXGI_FORMAT_A8_UNORM</li> <li>DXGI_FORMAT_R8_UNORM</li> <li>DXGI_FORMAT_R8G8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8X8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> <li>DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>DXGI_FORMAT_R32G32B32A32_FLOAT</li> <li>DXGI_FORMAT_BC1_UNORM</li> <li>DXGI_FORMAT_BC2_UNORM</li> <li>DXGI_FORMAT_BC3_UNORM</li> </ul> </td></tr> <tr><td>DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li>DXGI_FORMAT_AYUV</li> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> <li>DXGI_FORMAT_V408</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> <tr><td> DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>
            </remarks>
            <doc-id>dn890791</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out, Fast] ID2D1ImageSource** imageSource)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext2.CreateImageSourceFromDxgi(System.IntPtr,System.Int32,SharpDX.DXGI.ColorSpaceType,SharpDX.Direct2D1.ImageSourceFromDxgiOptions,System.IntPtr)">
            <summary>
            <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>
            </summary>
            <param name = "surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>
            <param name = "surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>
            <param name = "colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>
            <param name = "options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>
            <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <remarks>
            <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td>DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li>DXGI_FORMAT_A8_UNORM</li> <li>DXGI_FORMAT_R8_UNORM</li> <li>DXGI_FORMAT_R8G8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8X8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> <li>DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>DXGI_FORMAT_R32G32B32A32_FLOAT</li> <li>DXGI_FORMAT_BC1_UNORM</li> <li>DXGI_FORMAT_BC2_UNORM</li> <li>DXGI_FORMAT_BC3_UNORM</li> </ul> </td></tr> <tr><td>DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li>DXGI_FORMAT_AYUV</li> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> <li>DXGI_FORMAT_V408</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> <tr><td> DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>
            </remarks>
            <doc-id>dn890791</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out, Fast] ID2D1ImageSource** imageSource)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext3.#ctor(SharpDX.Direct2D1.Device3,SharpDX.Direct2D1.DeviceContextOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext3"/> class using an existing <see cref="T:SharpDX.Direct2D1.Device3"/>.
            </summary>
            <param name="device">The device.</param>
            <param name="options">The options to be applied to the created device context.</param>
            <remarks>
            The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.
            </remarks>
            <unmanaged>HRESULT ID2D1Device3::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out] ID2D1DeviceContext3** deviceContext3)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext3.CreateSpriteBatch(SharpDX.Direct2D1.SpriteBatch)">
            <summary>
            <p>Creates a new, empty sprite batch. After creating a sprite batch, use <strong>ID2D1SpriteBatch::AddSprites</strong> to add sprites to it, then use <strong>ID2D1DeviceContext3::DrawSpriteBatch</strong> to draw it.</p>
            </summary>
            <param name = "spriteBatch">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt619827</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext3::CreateSpriteBatch([Out, Fast] ID2D1SpriteBatch** spriteBatch)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext3::CreateSpriteBatch</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext3.DrawSpriteBatch(SharpDX.Direct2D1.SpriteBatch,System.Int32,System.Int32,SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.BitmapInterpolationMode,SharpDX.Direct2D1.SpriteOptions)">
            <summary>
            <p>Renders all sprites in the given sprite batch to the device context using the specified drawing options.</p>
            </summary>
            <param name = "spriteBatch"><dd>  <p>The sprite batch to draw.</p> </dd></param>
            <param name = "startIndex"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>
            <param name = "spriteCount"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>
            <param name = "bitmap"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>
            <param name = "spriteOptions"><dd>  <p>The additional drawing options, if any, to be used for this sprite batch.</p> </dd></param>
            <doc-id>mt619829</doc-id>
            <unmanaged>void ID2D1DeviceContext3::DrawSpriteBatch([In] ID2D1SpriteBatch* spriteBatch,[In] unsigned int startIndex,[In] unsigned int spriteCount,[In] ID2D1Bitmap* bitmap,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In] D2D1_SPRITE_OPTIONS spriteOptions)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext3::DrawSpriteBatch</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.#ctor(SharpDX.Direct2D1.Device4,SharpDX.Direct2D1.DeviceContextOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext4"/> class using an existing <see cref="T:SharpDX.Direct2D1.Device4"/>.
            </summary>
            <param name="device">The device.</param>
            <param name="options">The options to be applied to the created device context.</param>
            <remarks>
            The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.
            </remarks>
            <unmanaged>HRESULT ID2D1Device4::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out] ID2D1DeviceContext4** DeviceContext4)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.CreateSvgGlyphStyle(SharpDX.Direct2D1.SvgGlyphStyle@)">
            <summary>
            <p>Creates an SVG glyph style object.</p>
            </summary>
            <param name = "svgGlyphStyle"><dd>  <p>On completion points to the created <strong><see cref = "T:SharpDX.Direct2D1.SvgGlyphStyle"/></strong> object.</p> </dd></param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt750183</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext4::CreateSvgGlyphStyle([Out] ID2D1SvgGlyphStyle** svgGlyphStyle)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::CreateSvgGlyphStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.DrawText(System.String,System.Int32,SharpDX.DirectWrite.TextFormat,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.SvgGlyphStyle,System.Int32,SharpDX.Direct2D1.DrawTextOptions,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p>Represents a set of state and command buffers that are used to render to a target.</p><p>The device context can render to a target bitmap or a command list.
            </p>
            </summary>
            <param name = "text">No documentation.</param>
            <param name = "stringLength">No documentation.</param>
            <param name = "textFormat">No documentation.</param>
            <param name = "layoutRect">No documentation.</param>
            <param name = "defaultFillBrush">No documentation.</param>
            <param name = "svgGlyphStyle">No documentation.</param>
            <param name = "colorPaletteIndex">No documentation.</param>
            <param name = "options">No documentation.</param>
            <param name = "measuringMode">No documentation.</param>
            <remarks>
            <p> Any resource created from a device context can be shared with any other resource created from a device context when both contexts are created on the same device. </p>
            </remarks>
            <doc-id>hh404479</doc-id>
            <unmanaged>void ID2D1DeviceContext4::DrawTextW([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D_RECT_F* layoutRect,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[In] D2D1_DRAW_TEXT_OPTIONS options,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::DrawTextW</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.DrawTextLayout(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.TextLayout,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.SvgGlyphStyle,System.Int32,SharpDX.Direct2D1.DrawTextOptions)">
            <summary>
            <p>Draws a text layout object. If the layout is not subsequently changed, this can be more efficient than DrawText when drawing the same layout repeatedly.</p>
            </summary>
            <param name = "origin"><dd>  <p>The point, described in device-independent pixels, at which the upper-left corner of the text described by <em>textLayout</em> is drawn.</p> </dd></param>
            <param name = "textLayout"><dd>  <p>The formatted text to draw. Any drawing effects that do not inherit from <strong><see cref = "T:SharpDX.Direct2D1.Resource"/></strong> are ignored. If there are drawing effects that inherit from <strong><see cref = "T:SharpDX.Direct2D1.Resource"/></strong> that are not brushes, this method fails and the render target is put in an error state. </p> </dd></param>
            <param name = "defaultFillBrush"><dd>  <p>The brush used to paint the text.</p> </dd></param>
            <param name = "svgGlyphStyle"><dd>  <p>The values for context-fill, context-stroke, and context-value that are used when rendering SVG glyphs.</p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p>The index used to select a color palette within a color font.</p> </dd></param>
            <param name = "options"><dd>  <p> A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle.  The default value is <strong>D2D1_DRAW_TEXT_OPTIONS_NONE</strong>,  which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle. </p> </dd></param>
            <doc-id>mt750187</doc-id>
            <unmanaged>void ID2D1DeviceContext4::DrawTextLayout([In] D2D_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[In] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::DrawTextLayout</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.DrawColorBitmapGlyphRun(SharpDX.Direct2D1.GlyphImageFormatS,SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.Direct2D1.MeasuringMode,SharpDX.Direct2D1.ColorBitmapGlyphSnapOption)">
            <summary>
            <p>Draws a color bitmap glyph run using one of the bitmap formats.</p>
            </summary>
            <param name = "glyphImageFormat"><dd>  <p>Specifies the format of the glyph image. Supported formats are DWRITE_GLYPH_IMAGE_FORMATS_PNG, DWRITE_GLYPH_IMAGE_FORMATS_JPEG, DWRITE_GLYPH_IMAGE_FORMATS_TIFF, or DWRITE_GLYPH_IMAGE_FORMATS_PREMULTIPLIED_B8G8R8A8.  This method will result in an error if the color glyph run does not contain the requested format. </p> <p>Only one format can be specified at a time, combinations of flags are not valid input.</p> </dd></param>
            <param name = "baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Indicates the measuring method.</p> </dd></param>
            <param name = "bitmapSnapOption"><dd>  <p>Specifies the pixel snapping policy when rendering color bitmap glyphs.</p> </dd></param>
            <doc-id>mt750184</doc-id>
            <unmanaged>void ID2D1DeviceContext4::DrawColorBitmapGlyphRun([In] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,[In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[In] D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION bitmapSnapOption)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::DrawColorBitmapGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.DrawSvgGlyphRun(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.SvgGlyphStyle,System.Int32,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p>Draws a color glyph run that has the format of DWRITE_GLYPH_IMAGE_FORMATS_SVG.</p>
            </summary>
            <param name = "baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
            <param name = "defaultFillBrush"><dd>  <p>The brush used to paint the specified glyphs.</p> </dd></param>
            <param name = "svgGlyphStyle"><dd>  <p>Values for context-fill, context-stroke, and context-value that are used when rendering SVG glyphs.</p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p>The index used to select a color palette within a color font. Note that this not the same as the paletteIndex in the <see cref = "T:SharpDX.DirectWrite.ColorGlyphRun"/> struct, which is not relevant for SVG glyphs.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Indicates the measuring method used for text layout.</p> </dd></param>
            <doc-id>mt750185</doc-id>
            <unmanaged>void ID2D1DeviceContext4::DrawSvgGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::DrawSvgGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.GetColorBitmapGlyphImage(SharpDX.Direct2D1.GlyphImageFormatS,SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.FontFace,System.Single,System.Int16,SharpDX.Mathematics.Interop.RawBool,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,System.Single,SharpDX.Mathematics.Interop.RawMatrix3x2@,SharpDX.Direct2D1.Image@)">
            <summary>
            <p> Retrieves an image of the color bitmap glyph from the color glyph cache. If the cache does not already contain the requested resource, it will be created. This method may be used to extend the lifetime of a glyph image even after it is evicted from the color glyph cache. </p>
            </summary>
            <param name = "glyphImageFormat"><dd>  <p>The format for the glyph image. If there is no image data in the requested format for the requested glyph, this method will return an error. </p> </dd></param>
            <param name = "glyphOrigin"><dd>  <p>The origin for the glyph.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>Reference to a font face which contains font face type, appropriate file references, face identification data and various font data such as metrics, names and glyph outlines.</p> </dd></param>
            <param name = "fontEmSize"><dd>  <p>The specified font size affects the choice of which bitmap to use from the font. It also affects the output glyphTransform, causing  it to properly scale the glyph.</p> </dd></param>
            <param name = "glyphIndex"><dd>  <p>Index of the glyph.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying isSideways as true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The transform to apply to the image. This input transform affects the choice of which bitmap to use from the font. It is also factored into the output glyphTransform.</p> </dd></param>
            <param name = "dpiX"><dd>  <p>Dots per inch along the x-axis.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>Dots per inch along the y-axis.</p> </dd></param>
            <param name = "glyphTransform"><dd>  <p>Output transform, which transforms from the glyph's space to the same output space as the worldTransform. This includes the input glyphOrigin, the glyph's offset from the glyphOrigin, and any other required transformations.</p> </dd></param>
            <param name = "glyphImage"><dd>  <p>On completion contains the retrieved glyph image.</p> </dd></param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt750189</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext4::GetColorBitmapGlyphImage([In] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,[In] D2D_POINT_2F glyphOrigin,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] unsigned short glyphIndex,[In] BOOL isSideways,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float dpiX,[In] float dpiY,[Out] D2D_MATRIX_3X2_F* glyphTransform,[Out] ID2D1Image** glyphImage)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::GetColorBitmapGlyphImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext4.GetSvgGlyphImage(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.FontFace,System.Single,System.Int16,SharpDX.Mathematics.Interop.RawBool,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.SvgGlyphStyle,System.Int32,SharpDX.Mathematics.Interop.RawMatrix3x2@,SharpDX.Direct2D1.CommandList@)">
            <summary>
            <p> Retrieves an image of the SVG glyph from the color glyph cache. If the cache  does not already contain the requested resource, it will be created. This method may be used to extend the lifetime of a glyph image even after it is evicted from the color glyph cache. </p>
            </summary>
            <param name = "glyphOrigin"><dd>  <p>Origin of the glyph.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>Reference to a font face which contains font face type, appropriate file references, face identification data and various font data such as metrics, names and glyph outlines.</p> </dd></param>
            <param name = "fontEmSize"><dd>  <p>The specified font size affects the output glyphTransform, causing it to properly scale the glyph.</p> </dd></param>
            <param name = "glyphIndex"><dd>  <p>Index of the glyph to retrieve.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying isSideways as true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The transform to apply to the image.</p> </dd></param>
            <param name = "defaultFillBrush"><dd>  <p>Describes how the area is painted.</p> </dd></param>
            <param name = "svgGlyphStyle"><dd>  <p>The values for context-fill, context-stroke, and context-value that are used when rendering SVG glyphs.</p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p>The index used to select a color palette within a color font.  Note that this not the same as the paletteIndex in the <see cref = "T:SharpDX.DirectWrite.ColorGlyphRun"/> struct, which is not relevant for SVG glyphs.</p> </dd></param>
            <param name = "glyphTransform"><dd>  <p>Output transform, which transforms from the glyph's space to the same output space as the worldTransform.  This includes the input glyphOrigin, the glyph's offset from the glyphOrigin, and any other required transformations.</p> </dd></param>
            <param name = "glyphImage"><dd>  <p>On completion, contains the retrieved glyph image.</p> </dd></param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt750190</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext4::GetSvgGlyphImage([In] D2D_POINT_2F glyphOrigin,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] unsigned short glyphIndex,[In] BOOL isSideways,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[Out] D2D_MATRIX_3X2_F* glyphTransform,[Out] ID2D1CommandList** glyphImage)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext4::GetSvgGlyphImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext5.#ctor(SharpDX.Direct2D1.Device5,SharpDX.Direct2D1.DeviceContextOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.DeviceContext5"/> class using an existing <see cref="T:SharpDX.Direct2D1.Device5"/>.
            </summary>
            <param name="device">The device.</param>
            <param name="options">The options to be applied to the created device context.</param>
            <remarks>
            The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.
            </remarks>
            <unmanaged>HRESULT ID2D1Device5::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out] ID2D1DeviceContext5** DeviceContext5)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext5.CreateSvgDocument(SharpDX.Win32.IStream,SharpDX.Size2F)">
            <summary>
            Creates an Svg document from an xml string
            </summary>
            <param name="stream"></param>
            <param name="viewportSize"></param>
            <returns>Svg document model</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext5.CreateSvgDocument(SharpDX.Win32.IStream,SharpDX.Size2F,SharpDX.Direct2D1.SvgDocument@)">
            <summary>
            No documentation.
            </summary>
            <param name = "inputXmlStream">No documentation.</param>
            <param name = "viewportSize">No documentation.</param>
            <param name = "svgDocument">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateSvgDocument([In, Optional] IStream* inputXmlStream,[In] D2D_SIZE_F viewportSize,[Out] ID2D1SvgDocument** svgDocument)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext5::CreateSvgDocument</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext5.DrawSvgDocument(SharpDX.Direct2D1.SvgDocument)">
            <summary>
            No documentation.
            </summary>
            <param name = "svgDocument">No documentation.</param>
            <unmanaged>void ID2D1DeviceContext5::DrawSvgDocument([In] ID2D1SvgDocument* svgDocument)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext5::DrawSvgDocument</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext5.CreateColorContextFromDxgiColorSpace(SharpDX.DXGI.ColorSpaceType,SharpDX.Direct2D1.ColorContext1)">
            <summary>
            <p>Creates a color context from a DXGI color space type. It is only valid to use this with the Color Management Effect in 'Best' mode.</p>
            </summary>
            <param name = "colorSpace"><dd>  <p>The color space to create the color context from.</p> </dd></param>
            <param name = "colorContext"><dd>  <p>The created color context.</p> </dd></param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt797807</doc-id>
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContext5.CreateColorContextFromSimpleColorProfile(SharpDX.Direct2D1.SimpleColorProfile@,SharpDX.Direct2D1.ColorContext1)">
            <summary>
            No documentation.
            </summary>
            <param name = "simpleProfile">No documentation.</param>
            <param name = "colorContext">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromSimpleColorProfile([In] const D2D1_SIMPLE_COLOR_PROFILE* simpleProfile,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
            <unmanaged-short>ID2D1DeviceContext5::CreateColorContextFromSimpleColorProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContextRenderTarget.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.RenderTargetProperties)">
            <summary>	
            Creates a render target that draws to a Windows Graphics Device Interface (GDI) device context.	
            </summary>	
            <remarks>	
            Before you can render with a DC render target, you must use the render target's {{BindDC}} method to associate it with a GDI DC.  Do this for each different DC and whenever there is a change in the size of the area you want to draw to.To enable the DC render target to work with GDI, set the render target's DXGI format to <see cref="F:SharpDX.DXGI.Format.B8G8R8A8_UNorm"/> and alpha mode to <see cref="F:SharpDX.Direct2D1.AlphaMode.Premultiplied"/> or D2D1_ALPHA_MODE_IGNORE.Your application should create render targets once and hold on to them for the life of the application or until the render target's  {{EndDraw}} method returns the {{D2DERR_RECREATE_TARGET}} error. When you receive this error, recreate the render target (and any resources it created).	
            </remarks>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="properties">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.  To enable the device context (DC) render target to work with GDI, set the DXGI format to <see cref="F:SharpDX.DXGI.Format.B8G8R8A8_UNorm"/> and the alpha mode to <see cref="F:SharpDX.Direct2D1.AlphaMode.Premultiplied"/> or D2D1_ALPHA_MODE_IGNORE. For more information about pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.DeviceContextRenderTarget.BindDeviceContext(System.IntPtr,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>
            <p> Binds the render target to the device context to which it issues drawing commands.</p>
            </summary>
            <param name = "hDC"><dd>  <p>The device context to which the render target issues drawing commands.</p> </dd></param>
            <param name = "subRectRef"><dd>  <p>The dimensions of the handle to a device context (<see cref = "T:System.IntPtr"/>) to which the render target is bound. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before you can render with the DC render target, you must use its <strong>BindDC</strong> method to associate it with a GDI DC.  You do this each time you  use a different DC, or the size of the area you want to draw to changes.</p>
            </remarks>
            <doc-id>dd371214</doc-id>
            <unmanaged>HRESULT ID2D1DCRenderTarget::BindDC([In] const HDC hDC,[In] const RECT* pSubRect)</unmanaged>
            <unmanaged-short>ID2D1DCRenderTarget::BindDC</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetVertexConstantBuffer(SharpDX.DataStream)">
            <summary>
            Sets the constant buffer data from a <see cref="T:SharpDX.DataStream"/> for the Vertex stage.
            </summary>
            <param name="dataStream">The DataStream that contains the constant buffer data</param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetVertexConstantBuffer``1(``0)">
            <summary>
            Sets the constant buffer data from a struct value for the Vertex stage.
            </summary>
            <typeparam name="T">Type of the constant buffer</typeparam>
            <param name="value">Value of the constant buffer</param>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetVertexConstantBuffer``1(``0@)">
            <summary>
            Sets the constant buffer data from a struct value for the Vertex Stage.
            </summary>
            <typeparam name="T">Type of the constant buffer</typeparam>
            <param name="value">Value of the constant buffer</param>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetPixelConstantBuffer(SharpDX.DataStream)">
            <summary>
            Sets the constant buffer data from a <see cref="T:SharpDX.DataStream"/> for the Pixel stage.
            </summary>
            <param name="dataStream">The DataStream that contains the constant buffer data</param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetPixelConstantBuffer``1(``0)">
            <summary>
            Sets the constant buffer data from a struct value for the Pixel stage.
            </summary>
            <typeparam name="T">Type of the constant buffer</typeparam>
            <param name="value">Value of the constant buffer</param>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetPixelConstantBuffer``1(``0@)">
            <summary>
            Sets the constant buffer data from a struct value for the Pixel Stage.
            </summary>
            <typeparam name="T">Type of the constant buffer</typeparam>
            <param name="value">Value of the constant buffer</param>
            <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const void* buffer,[In] unsigned int bufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetPixelShaderConstantBuffer(System.IntPtr,System.Int32)">
            <summary>
            <p>Sets the constant buffer for this transform's pixel shader.</p>
            </summary>
            <param name = "buffer"><dd>  <p>The data applied to the constant buffer.</p> </dd></param>
            <param name = "bufferCount"><dd>  <p>The number of bytes of data in the constant buffer</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh847988</doc-id>
            <unmanaged>HRESULT ID2D1DrawInfo::SetPixelShaderConstantBuffer([In, Buffer] const unsigned char* buffer,[In] unsigned int bufferCount)</unmanaged>
            <unmanaged-short>ID2D1DrawInfo::SetPixelShaderConstantBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetResourceTexture(System.Int32,SharpDX.Direct2D1.ResourceTexture)">
            <summary>
            <p>Sets the resource texture corresponding to the given shader texture index.</p>
            </summary>
            <param name = "textureIndex"><dd>  <p>The index of the texture to be bound to the pixel shader.</p> </dd></param>
            <param name = "resourceTexture"><dd>  <p>The created resource texture.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh847989</doc-id>
            <unmanaged>HRESULT ID2D1DrawInfo::SetResourceTexture([In] unsigned int textureIndex,[In] ID2D1ResourceTexture* resourceTexture)</unmanaged>
            <unmanaged-short>ID2D1DrawInfo::SetResourceTexture</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetVertexShaderConstantBuffer(System.IntPtr,System.Int32)">
            <summary>
            <p>Sets the constant buffer for this transform's vertex shader.</p>
            </summary>
            <param name = "buffer"><dd>  <p>The data applied to the constant buffer</p> </dd></param>
            <param name = "bufferCount"><dd>  <p>The number of bytes of data in the constant buffer.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh847991</doc-id>
            <unmanaged>HRESULT ID2D1DrawInfo::SetVertexShaderConstantBuffer([In, Buffer] const unsigned char* buffer,[In] unsigned int bufferCount)</unmanaged>
            <unmanaged-short>ID2D1DrawInfo::SetVertexShaderConstantBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetPixelShader(System.Guid,SharpDX.Direct2D1.PixelOptions)">
            <summary>
            <p>Set the shader instructions for this transform.</p>
            </summary>
            <param name = "shaderId"><dd>  <p>The resource id for the  shader.</p> </dd></param>
            <param name = "pixelOptions"><dd>  <p>Additional information provided to the renderer to indicate the operations the pixel shader does.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If this call fails, the corresponding <strong><see cref = "T:SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and will fail to Draw, it will place the context into an error state which can be retrieved through the <strong>ID2D1DeviceContext::EndDraw</strong> call. </p><p>Specifying <em>pixelOptions</em> other than D2D1_PIXEL_OPTIONS_NONE can enable the renderer to perform certain optimizations such as combining various parts of the effect graph together. If this information does not accurately describe the shader, indeterminate rendering artifacts can result.
            </p>
            </remarks>
            <doc-id>hh847987</doc-id>
            <unmanaged>HRESULT ID2D1DrawInfo::SetPixelShader([In] const GUID&amp; shaderId,[In] D2D1_PIXEL_OPTIONS pixelOptions)</unmanaged>
            <unmanaged-short>ID2D1DrawInfo::SetPixelShader</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawInformation.SetVertexProcessing(SharpDX.Direct2D1.VertexBuffer,SharpDX.Direct2D1.VertexOptions,System.Nullable{SharpDX.Direct2D1.BlendDescription},System.Nullable{SharpDX.Direct2D1.VertexRange},System.Nullable{System.Guid})">
            <summary>
            <p>Sets a vertex buffer, a corresponding vertex shader, and options to control how the vertices are to be handled by the Direct2D context.</p>
            </summary>
            <param name = "vertexBuffer"><dd>  <p>The vertex buffer, if this is cleared, the default vertex shader and mapping to the transform rectangles will be used.</p> </dd></param>
            <param name = "vertexOptions"><dd>  <p>Options that influence how the renderer will interact with the vertex shader.</p> </dd></param>
            <param name = "blendDescription"><dd>  <p>How the vertices will be blended with the output texture.</p> </dd></param>
            <param name = "vertexRange"><dd>  <p>The set of vertices to use from the buffer.</p> </dd></param>
            <param name = "vertexShader"><dd>  <p>The <see cref = "T:System.Guid"/> of the vertex shader.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The vertex shaders associated with the vertex buffer through the vertex shader <see cref = "T:System.Guid"/> must have been loaded through the <strong>ID2D1EffectContext::LoadVertexShader</strong> method before this call is made.</p><p>If you pass the vertex option <strong>D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR</strong>, then the method fails unless the blend description is exactly this: </p><pre><see cref = "T:SharpDX.Direct2D1.BlendDescription"/> blendDesc =  { D2D1_BLEND_ONE, D2D1_BLEND_ZERO, D2D1_BLEND_OPERATION_ADD, D2D1_BLEND_ONE, D2D1_BLEND_ZERO, D2D1_BLEND_OPERATION_ADD, { 1.0f, 1.0f, 1.0f, 1.0f } };</pre><p>If this call fails, the corresponding <strong><see cref = "T:SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p><p> If blendDescription is <c>null</c>, a foreground-over blend mode is used.</p>
            </remarks>
            <doc-id>hh847990</doc-id>
            <unmanaged>HRESULT ID2D1DrawInfo::SetVertexProcessing([In, Optional] ID2D1VertexBuffer* vertexBuffer,[In] D2D1_VERTEX_OPTIONS vertexOptions,[In, Optional] const D2D1_BLEND_DESCRIPTION* blendDescription,[In, Optional] const D2D1_VERTEX_RANGE* vertexRange,[In, Optional] const GUID* vertexShader)</unmanaged>
            <unmanaged-short>ID2D1DrawInfo::SetVertexProcessing</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.#ctor(SharpDX.Direct2D1.Factory)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.DrawingStateDescription)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="drawingStateDescription">A structure that contains antialiasing, transform, and tags  information.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.#ctor(SharpDX.Direct2D1.Factory,SharpDX.DirectWrite.RenderingParams)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="textRenderingParams">Optional text parameters that indicate how text should be rendered.  </param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.#ctor(SharpDX.Direct2D1.Factory,System.Nullable{SharpDX.Direct2D1.DrawingStateDescription},SharpDX.DirectWrite.RenderingParams)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="drawingStateDescription">A structure that contains antialiasing, transform, and tags  information.</param>
            <param name="textRenderingParams">Optional text parameters that indicate how text should be rendered.  </param>
        </member>
        <member name="P:SharpDX.Direct2D1.DrawingStateBlock.Description">
            <summary>
            <p>Retrieves or sets the antialiasing mode, transform, and tags portion of the drawing state.</p>
            </summary>
            <doc-id>dd371223</doc-id>
            <unmanaged>GetDescription / SetDescription</unmanaged>
            <unmanaged-short>GetDescription</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.DrawingStateBlock.TextRenderingParams">
            <summary>
            <p>Retrieves or sets the text-rendering configuration of the drawing state.</p>
            </summary>
            <doc-id>dd371227</doc-id>
            <unmanaged>GetTextRenderingParams / SetTextRenderingParams</unmanaged>
            <unmanaged-short>GetTextRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.GetDescription(SharpDX.Direct2D1.DrawingStateDescription@)">
            <summary>
            <p>Retrieves the antialiasing mode, transform, and tags portion of the drawing state.</p>
            </summary>
            <param name = "stateDescription"><dd>  <p>When this method returns, contains the antialiasing mode, transform, and tags portion of the drawing state. You must allocate storage for this parameter.</p> </dd></param>
            <doc-id>dd371223</doc-id>
            <unmanaged>void ID2D1DrawingStateBlock::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
            <unmanaged-short>ID2D1DrawingStateBlock::GetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.SetDescription(SharpDX.Direct2D1.DrawingStateDescription@)">
            <summary>
            <p>Specifies the antialiasing mode, transform, and tags portion of the drawing state.</p>
            </summary>
            <param name = "stateDescription"><dd>  <p>The antialiasing mode, transform, and tags portion of the drawing state.</p> </dd></param>
            <doc-id>dd371231</doc-id>
            <unmanaged>void ID2D1DrawingStateBlock::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
            <unmanaged-short>ID2D1DrawingStateBlock::SetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p>Specifies the text-rendering configuration of the drawing state.</p>
            </summary>
            <param name = "textRenderingParams"><dd>  <p>The text-rendering configuration of the drawing state, or <c>null</c> to use default settings.</p> </dd></param>
            <doc-id>dd371237</doc-id>
            <unmanaged>void ID2D1DrawingStateBlock::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
            <unmanaged-short>ID2D1DrawingStateBlock::SetTextRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock.GetTextRenderingParams(SharpDX.DirectWrite.RenderingParams@)">
            <summary>
            <p>Retrieves the text-rendering configuration of the drawing state.</p>
            </summary>
            <param name = "textRenderingParams"><dd>  <p>When this method returns, contains the address of a reference to an <strong><see cref = "T:SharpDX.DirectWrite.RenderingParams"/></strong> object that describes the text-rendering configuration of the drawing state.</p> </dd></param>
            <doc-id>dd371227</doc-id>
            <unmanaged>void ID2D1DrawingStateBlock::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
            <unmanaged-short>ID2D1DrawingStateBlock::GetTextRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock1.#ctor(SharpDX.Direct2D1.Factory1)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock1"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory1" /></param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock1.#ctor(SharpDX.Direct2D1.Factory1,SharpDX.Direct2D1.DrawingStateDescription1)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock1"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory1" /></param>
            <param name="drawingStateDescription">A structure that contains antialiasing, transform, and tags  information.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock1.#ctor(SharpDX.Direct2D1.Factory1,SharpDX.DirectWrite.RenderingParams)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock1"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory1" /></param>
            <param name="textRenderingParams">Optional text parameters that indicate how text should be rendered.  </param>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock1.#ctor(SharpDX.Direct2D1.Factory1,SharpDX.Direct2D1.DrawingStateDescription1,SharpDX.DirectWrite.RenderingParams)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.DrawingStateBlock1"/> that can be used with the {{SaveDrawingState}} and {{RestoreDrawingState}} methods of a render target.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory1" /></param>
            <param name="drawingStateDescription">A structure that contains antialiasing, transform, and tags  information.</param>
            <param name="textRenderingParams">Optional text parameters that indicate how text should be rendered.  </param>
        </member>
        <member name="P:SharpDX.Direct2D1.DrawingStateBlock1.Description">
            <summary>
            <p>Gets or sets the antialiasing mode, transform, tags, primitive blend, and unit mode portion of the drawing state.</p>
            </summary>
            <doc-id>hh871453</doc-id>
            <unmanaged>GetDescription / SetDescription</unmanaged>
            <unmanaged-short>GetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock1.GetDescription(SharpDX.Direct2D1.DrawingStateDescription1@)">
            <summary>
            <p>Gets the antialiasing mode, transform, tags, primitive blend, and unit mode portion of the drawing state.</p>
            </summary>
            <param name = "stateDescription"><dd>  <p>When this method returns, contains the antialiasing mode, transform, tags, primitive blend, and unit mode portion of the drawing state. You must allocate storage for this parameter.</p> </dd></param>
            <doc-id>hh871453</doc-id>
            <unmanaged>void ID2D1DrawingStateBlock1::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>
            <unmanaged-short>ID2D1DrawingStateBlock1::GetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawingStateBlock1.SetDescription(SharpDX.Direct2D1.DrawingStateDescription1@)">
            <summary>
            <p>Sets the <strong><see cref = "T:SharpDX.Direct2D1.DrawingStateDescription1"/></strong> associated with this drawing state block.</p>
            </summary>
            <param name = "stateDescription">No documentation.</param>
            <doc-id>hh871454</doc-id>
            <unmanaged>void ID2D1DrawingStateBlock1::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>
            <unmanaged-short>ID2D1DrawingStateBlock1::SetDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawTransform.SetDrawInformation(SharpDX.Direct2D1.DrawInformation)">
            <summary>	
            Sets the GPU render information for the transform.
            </summary>	
            <param name="drawInfo">The interface to specify the GPU-based transform pass..</param>	
            <unmanaged>HRESULT ID2D1DrawTransform::SetDrawInfo([In] ID2D1DrawInfo* drawInfo)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.DrawTransformNative.DrawInfo_">
            <summary>
            <p> Provides the GPU render info interface to the transform implementation.</p>
            </summary>
            <remarks>
            <p>The transform can maintain a  reference to this interface for its lifetime. If any properties change on the transform, it can apply these changes to the corresponding <em>drawInfo</em> interface. </p><p>This is also used to determine that the corresponding nodes in the graph are dirty.</p>
            </remarks>
            <doc-id>hh847993</doc-id>
            <unmanaged>SetDrawInfo</unmanaged>
            <unmanaged-short>SetDrawInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawTransformNative.SetDrawInfo_(SharpDX.Direct2D1.DrawInformation)">
            <summary>
            <p> Provides the GPU render info interface to the transform implementation.</p>
            </summary>
            <param name = "drawInfo"><dd>  <p>The interface supplied back to the calling method to allow it to specify the GPU based transform pass.</p> </dd></param>
            <returns><p>Any <see cref = "T:SharpDX.Result"/> value can be returned when implementing this method. A failure will be returned from the corresponding <strong>ID2D1DeviceContext::EndDraw</strong> call.</p></returns>
            <remarks>
            <p>The transform can maintain a  reference to this interface for its lifetime. If any properties change on the transform, it can apply these changes to the corresponding <em>drawInfo</em> interface. </p><p>This is also used to determine that the corresponding nodes in the graph are dirty.</p>
            </remarks>
            <doc-id>hh847993</doc-id>
            <unmanaged>HRESULT ID2D1DrawTransform::SetDrawInfo([In] ID2D1DrawInfo* drawInfo)</unmanaged>
            <unmanaged-short>ID2D1DrawTransform::SetDrawInfo</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DrawTransformShadow">
            <summary>
            Internal DrawTransform Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.DrawTransformShadow.ToIntPtr(SharpDX.Direct2D1.DrawTransform)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.DrawTransformShadow.DrawTransformVtbl.SetDrawInfoDelegate">
            <unmanaged>HRESULT ID2D1DrawTransform::SetDrawInfo([In] ID2D1DrawInfo* drawInfo)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.#ctor(SharpDX.Direct2D1.DeviceContext,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Effect"/> class.
            </summary>
            <param name="deviceContext">The device context.</param>
            <param name="effectId"><para>The class ID of the effect to create.</para></param>	
            <exception cref="T:SharpDX.SharpDXException">If no sufficient memory to complete the call, or if it does not have enough display memory to perform the operation, or if the specified effect is not registered by the system.</exception>
            <remarks>
            The created effect does not increment the reference count for the dynamic-link library (DLL) from which the effect was created. If the application deletes an effect while that effect is loaded, the resulting behavior will be unpredictable.	
            </remarks>	
            <unmanaged>HRESULT ID2D1DeviceContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.#ctor(SharpDX.Direct2D1.EffectContext,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Effect" /> class.
            </summary>
            <param name="effectContext">The effect context.</param>
            <param name="effectId"><para>The class ID of the effect to create.</para></param>	
            <returns>No documentation.</returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1EffectContext::CreateEffect']/*" />	
            <unmanaged>HRESULT ID2D1EffectContext::CreateEffect([In] const GUID&amp; effectId,[Out] ID2D1Effect** effect)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.SetInputEffect(System.Int32,SharpDX.Direct2D1.Effect,System.Boolean)">
            <summary>
            Sets the input by using the output of a given effect.
            </summary>
            <param name="index">Index of the input</param>
            <param name="effect">Effect output to use as input</param>
            <param name="invalidate">To invalidate</param>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.ArithmeticComposite">
            <summary>Constant ArithmeticComposite</summary>
            <unmanaged>CLSID_D2D1ArithmeticComposite</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Atlas">
            <summary>Constant Atlas</summary>
            <unmanaged>CLSID_D2D1Atlas</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.BitmapSource">
            <summary>Constant BitmapSource</summary>
            <unmanaged>CLSID_D2D1BitmapSource</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Blend">
            <summary>Constant Blend</summary>
            <unmanaged>CLSID_D2D1Blend</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Border">
            <summary>Constant Border</summary>
            <unmanaged>CLSID_D2D1Border</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Brightness">
            <summary>Constant Brightness</summary>
            <unmanaged>CLSID_D2D1Brightness</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.ColorManagement">
            <summary>Constant ColorManagement</summary>
            <unmanaged>CLSID_D2D1ColorManagement</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.ColorMatrix">
            <summary>Constant ColorMatrix</summary>
            <unmanaged>CLSID_D2D1ColorMatrix</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Composite">
            <summary>Constant Composite</summary>
            <unmanaged>CLSID_D2D1Composite</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.ConvolveMatrix">
            <summary>Constant ConvolveMatrix</summary>
            <unmanaged>CLSID_D2D1ConvolveMatrix</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Crop">
            <summary>Constant Crop</summary>
            <unmanaged>CLSID_D2D1Crop</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.DirectionalBlur">
            <summary>Constant DirectionalBlur</summary>
            <unmanaged>CLSID_D2D1DirectionalBlur</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.DiscreteTransfer">
            <summary>Constant DiscreteTransfer</summary>
            <unmanaged>CLSID_D2D1DiscreteTransfer</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.DisplacementMap">
            <summary>Constant DisplacementMap</summary>
            <unmanaged>CLSID_D2D1DisplacementMap</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.DistantDiffuse">
            <summary>Constant DistantDiffuse</summary>
            <unmanaged>CLSID_D2D1DistantDiffuse</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.DistantSpecular">
            <summary>Constant DistantSpecular</summary>
            <unmanaged>CLSID_D2D1DistantSpecular</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.DpiCompensation">
            <summary>Constant DpiCompensation</summary>
            <unmanaged>CLSID_D2D1DpiCompensation</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Flood">
            <summary>Constant Flood</summary>
            <unmanaged>CLSID_D2D1Flood</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.GammaTransfer">
            <summary>Constant GammaTransfer</summary>
            <unmanaged>CLSID_D2D1GammaTransfer</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.GaussianBlur">
            <summary>Constant GaussianBlur</summary>
            <unmanaged>CLSID_D2D1GaussianBlur</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Scale">
            <summary>Constant Scale</summary>
            <unmanaged>CLSID_D2D1Scale</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Histogram">
            <summary>Constant Histogram</summary>
            <unmanaged>CLSID_D2D1Histogram</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.HueRotation">
            <summary>Constant HueRotation</summary>
            <unmanaged>CLSID_D2D1HueRotation</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.LinearTransfer">
            <summary>Constant LinearTransfer</summary>
            <unmanaged>CLSID_D2D1LinearTransfer</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.LuminanceToAlpha">
            <summary>Constant LuminanceToAlpha</summary>
            <unmanaged>CLSID_D2D1LuminanceToAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Morphology">
            <summary>Constant Morphology</summary>
            <unmanaged>CLSID_D2D1Morphology</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.OpacityMetadata">
            <summary>Constant OpacityMetadata</summary>
            <unmanaged>CLSID_D2D1OpacityMetadata</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.PointDiffuse">
            <summary>Constant PointDiffuse</summary>
            <unmanaged>CLSID_D2D1PointDiffuse</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.PointSpecular">
            <summary>Constant PointSpecular</summary>
            <unmanaged>CLSID_D2D1PointSpecular</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Premultiply">
            <summary>Constant Premultiply</summary>
            <unmanaged>CLSID_D2D1Premultiply</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Saturation">
            <summary>Constant Saturation</summary>
            <unmanaged>CLSID_D2D1Saturation</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Shadow">
            <summary>Constant Shadow</summary>
            <unmanaged>CLSID_D2D1Shadow</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.SpotDiffuse">
            <summary>Constant SpotDiffuse</summary>
            <unmanaged>CLSID_D2D1SpotDiffuse</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.SpotSpecular">
            <summary>Constant SpotSpecular</summary>
            <unmanaged>CLSID_D2D1SpotSpecular</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.TableTransfer">
            <summary>Constant TableTransfer</summary>
            <unmanaged>CLSID_D2D1TableTransfer</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Tile">
            <summary>Constant Tile</summary>
            <unmanaged>CLSID_D2D1Tile</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Turbulence">
            <summary>Constant Turbulence</summary>
            <unmanaged>CLSID_D2D1Turbulence</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.UnPremultiply">
            <summary>Constant UnPremultiply</summary>
            <unmanaged>CLSID_D2D1UnPremultiply</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.YCbCr">
            <summary>Constant YCbCr</summary>
            <unmanaged>CLSID_D2D1YCbCr</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Contrast">
            <summary>Constant Contrast</summary>
            <unmanaged>CLSID_D2D1Contrast</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.RgbToHue">
            <summary>Constant RgbToHue</summary>
            <unmanaged>CLSID_D2D1RgbToHue</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.HueToRgb">
            <summary>Constant HueToRgb</summary>
            <unmanaged>CLSID_D2D1HueToRgb</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.ChromaKey">
            <summary>Constant ChromaKey</summary>
            <unmanaged>CLSID_D2D1ChromaKey</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Emboss">
            <summary>Constant Emboss</summary>
            <unmanaged>CLSID_D2D1Emboss</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Exposure">
            <summary>Constant Exposure</summary>
            <unmanaged>CLSID_D2D1Exposure</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Grayscale">
            <summary>Constant Grayscale</summary>
            <unmanaged>CLSID_D2D1Grayscale</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Invert">
            <summary>Constant Invert</summary>
            <unmanaged>CLSID_D2D1Invert</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Posterize">
            <summary>Constant Posterize</summary>
            <unmanaged>CLSID_D2D1Posterize</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Sepia">
            <summary>Constant Sepia</summary>
            <unmanaged>CLSID_D2D1Sepia</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Sharpen">
            <summary>Constant Sharpen</summary>
            <unmanaged>CLSID_D2D1Sharpen</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Straighten">
            <summary>Constant Straighten</summary>
            <unmanaged>CLSID_D2D1Straighten</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.TemperatureTint">
            <summary>Constant TemperatureTint</summary>
            <unmanaged>CLSID_D2D1TemperatureTint</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Vignette">
            <summary>Constant Vignette</summary>
            <unmanaged>CLSID_D2D1Vignette</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.EdgeDetection">
            <summary>Constant EdgeDetection</summary>
            <unmanaged>CLSID_D2D1EdgeDetection</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.HighlightsShadows">
            <summary>Constant HighlightsShadows</summary>
            <unmanaged>CLSID_D2D1HighlightsShadows</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.LookupTable3D">
            <summary>Constant LookupTable3D</summary>
            <unmanaged>CLSID_D2D1LookupTable3D</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Opacity">
            <summary>Constant Opacity</summary>
            <unmanaged>CLSID_D2D1Opacity</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.AlphaMask">
            <summary>Constant AlphaMask</summary>
            <unmanaged>CLSID_D2D1AlphaMask</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.CrossFade">
            <summary>Constant CrossFade</summary>
            <unmanaged>CLSID_D2D1CrossFade</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Tint">
            <summary>Constant Tint</summary>
            <unmanaged>CLSID_D2D1Tint</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.AffineTransform2D">
            <summary>Constant AffineTransform2D</summary>
            <unmanaged>CLSID_D2D12DAffineTransform</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.PerspectiveTransform3D">
            <summary>Constant PerspectiveTransform3D</summary>
            <unmanaged>CLSID_D2D13DPerspectiveTransform</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.Effect.Transform3D">
            <summary>Constant Transform3D</summary>
            <unmanaged>CLSID_D2D13DTransform</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.Effect.InputCount">
            <summary>
            <p>Gets or sets the number of inputs to the effect. </p>
            </summary>
            <doc-id>hh404582</doc-id>
            <unmanaged>GetInputCount / SetInputCount</unmanaged>
            <unmanaged-short>GetInputCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Effect.Output">
            <summary>
            <p>Gets the output image from the effect. </p>
            </summary>
            <remarks>
            <p>The output image  can be set as an input to another effect, or can be directly passed into the <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext"/></strong> in order to render the effect. </p><p>It is  also possible to use <strong>QueryInterface</strong> to retrieve the same output image.</p>
            </remarks>
            <doc-id>hh404585</doc-id>
            <unmanaged>GetOutput</unmanaged>
            <unmanaged-short>GetOutput</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.SetInput(System.Int32,SharpDX.Direct2D1.Image,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Sets the given input image by index. </p>
            </summary>
            <param name = "index"><dd>  <p>The index of the image to set.</p> </dd></param>
            <param name = "input"><dd>  <p>The input image to set.</p> </dd></param>
            <param name = "invalidate"><dd>  <p>Whether to invalidate the graph at the location of the effect input</p> </dd></param>
            <remarks>
            <p>If the input index is out of range, the input image is ignored. </p>
            </remarks>
            <doc-id>hh404591</doc-id>
            <unmanaged>void ID2D1Effect::SetInput([In] unsigned int index,[In, Optional] ID2D1Image* input,[In] BOOL invalidate)</unmanaged>
            <unmanaged-short>ID2D1Effect::SetInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.SetInputCount(System.Int32)">
            <summary>
            <p>Allows the application to change the number of inputs to an effect.</p>
            </summary>
            <param name = "inputCount"><dd>  <p>The number of inputs to the effect.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Most effects do not support a variable number of inputs. Use <strong>ID2D1Properties::GetValue</strong> with the <strong>D2D1_PROPERTY_MIN_INPUTS</strong> and <strong>D2D1_PROPERTY_MAX_INPUTS</strong> values to determine the number of inputs supported by an effect.</p><p>If the input count is less than the minimum or more than the maximum supported inputs, the call will fail.</p><p>If the input count is unchanged, the call will succeed with <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. </p><p>Any inputs currently selected on the effect will be unaltered by this call unless the number of inputs is made smaller. If the number of inputs is made smaller, inputs beyond the selected range will be released.</p><p>If the method fails, the existing input and input count will remain unchanged.</p>
            </remarks>
            <doc-id>hh404594</doc-id>
            <unmanaged>HRESULT ID2D1Effect::SetInputCount([In] unsigned int inputCount)</unmanaged>
            <unmanaged-short>ID2D1Effect::SetInputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.GetInput(System.Int32)">
            <summary>
            <p>Represents a basic image-processing construct in Direct2D.</p>
            </summary>
            <param name = "index">No documentation.</param>
            <remarks>
            <p>An effect takes zero or more input images, and has an output image. The images that are input into and output from an effect are lazily evaluated. This definition is sufficient to allow an arbitrary graph of effects to be created from the application by feeding output images into the input image of the next effect in the chain.</p>
            </remarks>
            <doc-id>hh404566</doc-id>
            <unmanaged>void ID2D1Effect::GetInput([In] unsigned int index,[Out, Optional] ID2D1Image** input)</unmanaged>
            <unmanaged-short>ID2D1Effect::GetInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.GetInputCount">
            <summary>
            <p>Gets the number of inputs to the effect. </p>
            </summary>
            <returns><p>This method returns the number of inputs to the effect. </p></returns>
            <doc-id>hh404582</doc-id>
            <unmanaged>unsigned int ID2D1Effect::GetInputCount()</unmanaged>
            <unmanaged-short>ID2D1Effect::GetInputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Effect.GetOutput(SharpDX.Direct2D1.Image@)">
            <summary>
            <p>Gets the output image from the effect. </p>
            </summary>
            <param name = "outputImage"><dd>  <p>When this method returns, contains the address of a reference to the output image for the effect.</p> </dd></param>
            <remarks>
            <p>The output image  can be set as an input to another effect, or can be directly passed into the <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext"/></strong> in order to render the effect. </p><p>It is  also possible to use <strong>QueryInterface</strong> to retrieve the same output image.</p>
            </remarks>
            <doc-id>hh404585</doc-id>
            <unmanaged>void ID2D1Effect::GetOutput([Out] ID2D1Image** outputImage)</unmanaged>
            <unmanaged-short>ID2D1Effect::GetOutput</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Effect`1">
            <summary>
            Class used to instantiate custom effects.
            </summary>
            <typeparam name="T">Type of the custom effect</typeparam>
        </member>
        <member name="M:SharpDX.Direct2D1.Effect`1.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of a custom <see cref="T:SharpDX.Direct2D1.Effect"/> class.
            </summary>
            <param name="deviceContext">The device context.</param>
            <exception cref="T:SharpDX.SharpDXException">If no sufficient memory to complete the call, or if it does not have enough display memory to perform the operation, or if the specified effect is not registered by the system.</exception>
            <remarks>
            The created effect does not increment the reference count for the dynamic-link library (DLL) from which the effect was created. If the application deletes an effect while that effect is loaded, the resulting behavior will be unpredictable.	
            </remarks>	
            <unmanaged>HRESULT ID2D1DeviceContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Effect`1.#ctor(SharpDX.Direct2D1.DeviceContext,System.Guid)">
            <summary>
            Initializes a new instance of a custom <see cref="T:SharpDX.Direct2D1.Effect"/> class.
            </summary>
            <param name="deviceContext">The device context.</param>
            <param name="effectId">Effect ID.</param>
            <exception cref="T:SharpDX.SharpDXException">If no sufficient memory to complete the call, or if it does not have enough display memory to perform the operation, or if the specified effect is not registered by the system.</exception>
            <remarks>
            The created effect does not increment the reference count for the dynamic-link library (DLL) from which the effect was created. If the application deletes an effect while that effect is loaded, the resulting behavior will be unpredictable.	
            </remarks>	
            <unmanaged>HRESULT ID2D1DeviceContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Effect`1.#ctor(SharpDX.Direct2D1.EffectContext)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Effect" /> class.
            </summary>
            <param name="effectContext">The effect context.</param>
            <returns>No documentation.</returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1EffectContext::CreateEffect']/*" />	
            <unmanaged>HRESULT ID2D1EffectContext::CreateEffect([In] const GUID&amp; effectId,[Out] ID2D1Effect** effect)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.EffectContext.Dpi">
            <summary>
            Gets the DPI.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.GetMaximumSupportedFeatureLevel(SharpDX.Direct3D.FeatureLevel[])">
            <summary>
            Gets the maximum feature level supported by this instance.
            </summary>
            <param name="featureLevels">An array of feature levels</param>
            <returns>The maximum feature level selected from the array</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.LoadPixelShader(System.Guid,System.Byte[])">
            <summary>	
            Loads a pixel shader.
            </summary>	
            <param name="shaderId">An unique identifier associated with the shader bytecode.</param>	
            <param name="shaderBytecode">The bytecode of the shader.</param>	
            <unmanaged>HRESULT ID2D1EffectContext::LoadPixelShader([In] const GUID&amp; shaderId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.LoadVertexShader(System.Guid,System.Byte[])">
            <summary>	
            Loads a vertex shader.
            </summary>	
            <param name="shaderId">An unique identifier associated with the shader bytecode.</param>	
            <param name="shaderBytecode">The bytecode of the shader.</param>	
            <unmanaged>HRESULT ID2D1EffectContext::LoadVertexShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.LoadComputeShader(System.Guid,System.Byte[])">
            <summary>	
            Loads a compute shader.
            </summary>	
            <param name="shaderId">An unique identifier associated with the shader bytecode.</param>	
            <param name="shaderBytecode">The bytecode of the shader.</param>	
            <unmanaged>HRESULT ID2D1EffectContext::LoadComputeShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CheckFeatureSupport(SharpDX.Direct2D1.Feature)">
            <summary>
            Check if this device is supporting a feature.
            </summary>
            <param name="feature">The feature to check.</param>
            <returns>
            Returns true if this device supports this feature, otherwise false.
            </returns>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.GetDpi(System.Single@,System.Single@)">
            <summary>
            <p>Gets the unit mapping that an effect will use for properties that could be in either dots per inch (dpi) or pixels.</p>
            </summary>
            <param name = "dpiX"><dd>  <p>The dpi on the x-axis.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>The dpi on the y-axis.</p> </dd></param>
            <remarks>
            <p> If the <strong><see cref = "T:SharpDX.Direct2D1.UnitMode"/></strong> is <strong>D2D1_UNIT_MODE_PIXELS</strong>, both <em>dpiX</em> and <em>dpiY</em> will be set to 96.</p>
            </remarks>
            <doc-id>hh404472</doc-id>
            <unmanaged>void ID2D1EffectContext::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::GetDpi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateEffect(System.Guid,SharpDX.Direct2D1.Effect)">
            <summary>
            <p> Creates a Direct2D effect for the specified  class ID. This is the same as <strong>ID2D1DeviceContext::CreateEffect</strong> so custom effects can create other effects and wrap them in a transform. </p>
            </summary>
            <param name = "effectId">No documentation.</param>
            <param name = "effect">No documentation.</param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation. </td></tr> <tr><td><see cref = "!:EffectIsNotRegistered"/></td><td>The specified effect is not registered by the system.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The created effect does not reference count the DLL from which the effect was created. If the caller unregisters an effect while this effect is loaded, the resulting behavior is unpredictable.</p>
            </remarks>
            <doc-id>hh404467</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.GetMaximumSupportedFeatureLevel(SharpDX.Direct3D.FeatureLevel[],System.Int32)">
            <summary>
            <p>This indicates the maximum feature level from the provided list which is supported by the device. If none of the provided levels are supported, then this API fails with <see cref = "!:InsufficientDeviceCapabilities"/>.</p>
            </summary>
            <param name = "featureLevels"><dd>  <p>The feature levels provided by the application.</p> </dd></param>
            <param name = "featureLevelsCount"><dd>  <p>The count of feature levels provided by the application</p> </dd></param>
            <returns><dd>  <p>The maximum feature level from the <em>featureLevels</em> list which is supported by the D2D device.</p> </dd></returns>
            <doc-id>hh404473</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::GetMaximumSupportedFeatureLevel([In, Buffer] const D3D_FEATURE_LEVEL* featureLevels,[In] unsigned int featureLevelsCount,[Out] D3D_FEATURE_LEVEL* maximumSupportedFeatureLevel)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::GetMaximumSupportedFeatureLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateTransformNodeFromEffect(SharpDX.Direct2D1.Effect)">
            <summary>
            <p>Wraps an effect graph into a single transform node and then inserted into a transform graph. This allows an effect to aggregate other effects. This will typically be done in order to allow the effect properties to be re-expressed with a different contract, or to allow different components to integrate each-other?s effects.</p>
            </summary>
            <param name = "effect"><dd>  <p>The effect to be wrapped in a transform node.</p> </dd></param>
            <returns><dd>  <p>The returned transform node that encapsulates the effect graph.</p> </dd></returns>
            <doc-id>hh404470</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateTransformNodeFromEffect([In] ID2D1Effect* effect,[Out] ID2D1TransformNode** transformNode)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateTransformNodeFromEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateBlendTransform(System.Int32,SharpDX.Direct2D1.BlendDescription@,SharpDX.Direct2D1.BlendTransform)">
            <summary>
            <p>This creates a blend transform that can be inserted into a transform graph.  </p>
            </summary>
            <param name = "numInputs"><dd>  <p>The number of inputs to the blend transform.</p> </dd></param>
            <param name = "blendDescription"><dd>  <p>Describes the blend transform that is to be created.</p> </dd></param>
            <param name = "transform"><dd>  <p>The returned blend transform.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404461</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateBlendTransform([In] unsigned int numInputs,[In] const D2D1_BLEND_DESCRIPTION* blendDescription,[Out, Fast] ID2D1BlendTransform** transform)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateBlendTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateBorderTransform(SharpDX.Direct2D1.ExtendMode,SharpDX.Direct2D1.ExtendMode,SharpDX.Direct2D1.BorderTransform)">
            <summary>
            <p>Creates a transform that extends its input infinitely in every direction based on the passed in extend mode.</p>
            </summary>
            <param name = "extendModeX"><dd>  <p>The extend mode in the X-axis direction.</p> </dd></param>
            <param name = "extendModeY"><dd>  <p>The extend mode in the Y-axis direction.</p> </dd></param>
            <param name = "transform"><dd>  <p>The returned transform.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404463</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateBorderTransform([In] D2D1_EXTEND_MODE extendModeX,[In] D2D1_EXTEND_MODE extendModeY,[Out, Fast] ID2D1BorderTransform** transform)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateBorderTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateOffsetTransform(SharpDX.Mathematics.Interop.RawPoint,SharpDX.Direct2D1.OffsetTransform)">
            <summary>
            <p>Creates and returns an offset transform.</p>
            </summary>
            <param name = "offset"><dd>  <p>The offset amount.</p> </dd></param>
            <param name = "transform"><dd>  <p>When this method returns, contains the address of a reference to an offset transform object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>An offset transform is used to offset an input bitmap without having to insert a rendering pass. An offset transform is automatically inserted by an Affine transform if the transform evaluates to a pixel-aligned transform.</p>
            </remarks>
            <doc-id>hh404468</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateOffsetTransform([In] POINT offset,[Out, Fast] ID2D1OffsetTransform** transform)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateOffsetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateBoundsAdjustmentTransform(SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Direct2D1.BoundsAdjustmentTransform)">
            <summary>
            <p>Creates and returns a bounds adjustment  transform.</p>
            </summary>
            <param name = "outputRectangle"><dd>  <p>The initial output rectangle for the bounds adjustment transform.</p> </dd></param>
            <param name = "transform"><dd>  <p>The returned bounds adjustment transform.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A support transform can be used for two different reasons.</p><ul> <li>To indicate that a region of its input image is already transparent black. This can increase efficiency for rendering bitmaps. <strong>Note</strong>??If the indicated region does NOT contain only transparent black pixels, then rendering results are undefined. ? </li> <li>To increase the size of the input image. The expanded area will be treated as transparent black
            </li> </ul>
            </remarks>
            <doc-id>hh871456</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateBoundsAdjustmentTransform([In] const RECT* outputRectangle,[Out, Fast] ID2D1BoundsAdjustmentTransform** transform)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateBoundsAdjustmentTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.LoadPixelShader(System.Guid,System.Byte[],System.Int32)">
            <summary>
            <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>
            </summary>
            <param name = "shaderId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
            <param name = "shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>
            <param name = "shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>
            </remarks>
            <doc-id>hh404476</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::LoadPixelShader([In] const GUID&amp; shaderId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::LoadPixelShader</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.LoadVertexShader(System.Guid,System.Byte[],System.Int32)">
            <summary>
            <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>
            </summary>
            <param name = "resourceId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
            <param name = "shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>
            <param name = "shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>
            </remarks>
            <doc-id>hh404477</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::LoadVertexShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::LoadVertexShader</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.LoadComputeShader(System.Guid,System.Byte[],System.Int32)">
            <summary>
            <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>
            </summary>
            <param name = "resourceId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
            <param name = "shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>
            <param name = "shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>
            </remarks>
            <doc-id>hh404475</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::LoadComputeShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::LoadComputeShader</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.IsShaderLoaded(System.Guid)">
            <summary>
            <p>This tests to see if the given shader is loaded.</p>
            </summary>
            <param name = "shaderId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
            <returns><p>Whether the shader is loaded.</p></returns>
            <doc-id>hh404474</doc-id>
            <unmanaged>BOOL ID2D1EffectContext::IsShaderLoaded([In] const GUID&amp; shaderId)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::IsShaderLoaded</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateResourceTexture(System.Nullable{System.Guid},System.IntPtr,System.Byte[],System.Int32[],System.Int32,SharpDX.Direct2D1.ResourceTexture)">
            <summary>
            <p>Creates or finds the given resource texture, depending on whether a resource id is specified. It also optionally initializes the texture with the specified data.</p>
            </summary>
            <param name = "resourceId"><dd>  <p>An optional reference to the unique id that identifies the lookup table.</p> </dd></param>
            <param name = "resourceTextureProperties"><dd>  <p>The properties used to create the resource texture.</p> </dd></param>
            <param name = "data"><dd>  <p>The optional data to be loaded into the resource texture.</p> </dd></param>
            <param name = "strides"><dd>  <p>An optional reference to the stride to advance through the resource texture, according to dimension.</p> </dd></param>
            <param name = "dataSize"><dd>  <p>The size, in bytes, of the data.</p> </dd></param>
            <param name = "resourceTexture"><dd>  <p>The returned texture that can be used as a resource in a Direct2D effect.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404469</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateResourceTexture([In, Optional] const GUID* resourceId,[In] const D2D1_RESOURCE_TEXTURE_PROPERTIES* resourceTextureProperties,[In, Buffer, Optional] const unsigned char* data,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dataSize,[Out, Fast] ID2D1ResourceTexture** resourceTexture)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateResourceTexture</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.FindResourceTexture(System.Guid)">
            <summary>
            <p>Finds the given resource texture if it has already been created with <strong>ID2D1EffectContext::CreateResourceTexture</strong> with the same <see cref = "T:System.Guid"/>.</p>
            </summary>
            <param name = "resourceId">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh871457</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::FindResourceTexture([In] const GUID* resourceId,[Out] ID2D1ResourceTexture** resourceTexture)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::FindResourceTexture</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateVertexBuffer(SharpDX.Direct2D1.VertexBufferProperties,System.Nullable{System.Guid},System.IntPtr,SharpDX.Direct2D1.VertexBuffer)">
            <summary>
            <p>Creates a vertex buffer or finds a standard vertex buffer and optionally initializes it with vertices. The returned buffer can be specified in the render info to specify both a vertex shader and or to pass custom vertices to the standard vertex shader used by Direct2D. </p>
            </summary>
            <param name = "vertexBufferProperties">No documentation.</param>
            <param name = "resourceId">No documentation.</param>
            <param name = "customVertexBufferProperties">No documentation.</param>
            <param name = "buffer">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404471</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateVertexBuffer([In] const D2D1_VERTEX_BUFFER_PROPERTIES* vertexBufferProperties,[In, Optional] const GUID* resourceId,[In, Optional] const D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES* customVertexBufferProperties,[Out, Fast] ID2D1VertexBuffer** buffer)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateVertexBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.FindVertexBuffer(System.Guid)">
            <summary>
            <p>This finds the given vertex buffer if it has already been created with <strong>ID2D1EffectContext::CreateVertexBuffer</strong> with the same <see cref = "T:System.Guid"/>.</p>
            </summary>
            <param name = "resourceId">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh871458</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::FindVertexBuffer([In] const GUID* resourceId,[Out] ID2D1VertexBuffer** buffer)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::FindVertexBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateColorContext(SharpDX.Direct2D1.ColorSpace,System.Byte[],System.Int32,SharpDX.Direct2D1.ColorContext)">
            <summary>
            <p>Creates a color context from a color space.  </p><p>If the color space is Custom, the context is initialized from the <em>profile</em> and <em>profileSize</em> parameters.</p><p>If the color space is not Custom, the context is       initialized with the profile bytes associated with the color space. The <em>profile</em> and <em>profileSize</em> parameters are ignored.</p>
            </summary>
            <param name = "space"><dd>  <p>The space  of color context to create.</p> </dd></param>
            <param name = "rofileRef"><dd>  <p>A buffer containing the ICC profile bytes used to initialize the color context when <em>space</em> is <strong>D2D1_COLOR_SPACE_CUSTOM</strong>.  For other types, the parameter is ignored and should be set to <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "profileSize"><dd>  <p>The size in bytes of <em>Profile</em>.</p> </dd></param>
            <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context object.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404464</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateColorContextFromFilename(System.String,SharpDX.Direct2D1.ColorContext)">
            <summary>
            <p>Creates a color context by loading it from the specified filename.  The profile bytes are the contents of the file specified by <em>filename</em>.</p>
            </summary>
            <param name = "filename"><dd>  <p>The path to the file containing the profile bytes to initialize the color context with.</p> </dd></param>
            <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404465</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateColorContextFromFilename</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CreateColorContextFromWicColorContext(SharpDX.WIC.ColorContext,SharpDX.Direct2D1.ColorContext)">
            <summary>
            <p>Creates a color context from an <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong>.  The <strong>D2D1ColorContext</strong> space of the resulting context varies, see Remarks for more info.</p>
            </summary>
            <param name = "wicColorContext">No documentation.</param>
            <param name = "colorContext">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The new color context can be used in <strong><see cref = "T:SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>
            </remarks>
            <doc-id>hh404466</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CreateColorContextFromWicColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.CheckFeatureSupport(SharpDX.Direct2D1.Feature,System.IntPtr,System.Int32)">
            <summary>
            <p>This indicates whether an optional capability is supported by the D3D device.</p>
            </summary>
            <param name = "feature"><dd>  <p>The feature to query support for.</p> </dd></param>
            <param name = "featureSupportData"><dd>  <p>A structure indicating information about how or if the feature is supported.</p> </dd></param>
            <param name = "featureSupportDataSize"><dd>  <p>The size of the <em>featureSupportData</em> parameter.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <doc-id>hh871455</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext::CheckFeatureSupport([In] D2D1_FEATURE feature,[Out, Buffer] void* featureSupportData,[In] unsigned int featureSupportDataSize)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::CheckFeatureSupport</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext.IsBufferPrecisionSupported(SharpDX.Direct2D1.BufferPrecision)">
            <summary>
            <p> Indicates whether the buffer precision is supported by the underlying Direct2D <strong>device.</strong> </p>
            </summary>
            <param name = "bufferPrecision">No documentation.</param>
            <returns><p>Returns TRUE if the buffer precision is supported.  Returns <see cref = "F:SharpDX.Result.False"/> if the buffer precision is not supported.</p></returns>
            <doc-id>hh847981</doc-id>
            <unmanaged>BOOL ID2D1EffectContext::IsBufferPrecisionSupported([In] D2D1_BUFFER_PRECISION bufferPrecision)</unmanaged>
            <unmanaged-short>ID2D1EffectContext::IsBufferPrecisionSupported</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.AffineTransform2D">
            <summary>
            Built in AffineTransform2D effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.AffineTransform2D.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.AffineTransform2D"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.AffineTransform2D.InterpolationMode">
            <summary>
            The interpolation mode used to scale the image. There are 6 scale modes that range in quality and speed. 
            If you don't select a mode, the effect uses the interpolation mode of the device context. 
            See <see cref="P:SharpDX.Direct2D1.Effects.AffineTransform2D.InterpolationMode"/> for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.AffineTransform2D.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See <see cref="P:SharpDX.Direct2D1.Effects.AffineTransform2D.BorderMode"/> modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.AffineTransform2D.TransformMatrix">
            <summary>
            The 3x2 matrix to transform the image using the Direct2D matrix transform. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.AffineTransform2D.Sharpness">
            <summary>
            In the high quality cubic interpolation mode, the sharpness level of the scaling filter as a float between 0 and 1. 
            The values are unitless. You can use sharpness to adjust the quality of an image when you scale the image.
            The sharpness factor affects the shape of the kernel. The higher the sharpness factor, the smaller the kernel.
            </summary>
            <remarks>
            This property affects only the high quality cubic interpolation mode.
            </remarks>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.ArithmeticComposite">
            <summary>
            Built in ArithmeticComposite effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.ArithmeticComposite.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.ArithmeticComposite"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ArithmeticComposite.Coefficients">
            <summary>
            The coefficients for the equation used to composite the two input images. The coefficients are unitless and unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ArithmeticComposite.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha.
            if you set this to TRUE the effect will clamp the values. If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Atlas">
            <summary>
            Built in Atlas effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Atlas.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Atlas"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Atlas.InputRectangle">
            <summary>
            The portion of the image passed to the next effect.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Atlas.InputPaddingRectangle">
            <summary>
            The portion of the image passed to the next effect.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.BitmapSource">
            <summary>
            Built in BitmapSource effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.BitmapSource.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.BitmapSource"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.BitmapSource.WicBitmapSource">
            <summary>
            The <see cref="T:SharpDX.WIC.BitmapSource"/> containing the image data to be loaded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.BitmapSource.ScaleSource">
            <summary>
            The scale amount in the X and Y direction. 
            The effect multiplies the width by the X value and the height by the Y value. 
            This property is a <see cref="!:Vector2"/> defined as: (X scale, Y scale). The scale amounts are FLOAT, unitless, and must be positive or 0.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.BitmapSource.InterpolationMode">
            <summary>
            The interpolation mode used to scale the image. See Interpolation modes for more info.
            If the mode disables the mipmap, then BitmapSouce will cache the image at the resolution determined by the Scale and EnableDPICorrection properties. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.BitmapSource.EnableDpiCorrection">
            <summary>
            If you set this to true, the effect will scale the input image to convert the DPI reported by IWICBitmapSource to the DPI of the device context. 
            The effect uses the interpolation mode you set with the InterpolationMode property. 
            If you set this to false, the effect uses a DPI of 96.0 for the output image.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.BitmapSource.AlphaMode">
            <summary>
            The alpha mode of the output. This can be either premultiplied or straight. See Alpha modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.BitmapSource.Orientation">
            <summary>
            A flip and/or rotation operation to be performed on the image. See Orientation for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Blend">
            <summary>
            Built in Blend effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Blend.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Blend"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Blend.Mode">
            <summary>
            The blend mode used for the effect. See Blend modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Border">
            <summary>
            Built in Border effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Border.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Border"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Border.EdgeModeX">
            <summary>
            The edge mode in the X direction for the effect. You can set this to clamp, wrap, or mirror. See Edge modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Border.EdgeModeY">
            <summary>
            The edge mode in the Y direction for the effect. You can set this to clamp, wrap, or mirror. See Edge modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Brightness">
            <summary>
            Built in Brightness effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Brightness.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Brightness"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Brightness.WhitePoint">
            <summary>
            The upper portion of the brightness transfer curve. The white point adjusts the appearance of the brighter portions of the image. This property is for both the x value and the y value, in that order. Each of the values of this property are between 0 and 1, inclusive.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Brightness.BlackPoint">
            <summary>
            The lower portion of the brightness transfer curve. The black point adjusts the appearance of the darker portions of the image. This property is for both the x value and the y value, in that order. Each of the values of this property are between 0 and 1, inclusive.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.ColorManagement">
            <summary>
            Built in ColorManagement effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.ColorManagement.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.ColorManagement"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorManagement.SourceContext">
            <summary>
            The source color context. Default null
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorManagement.SourceIntent">
            <summary>
            The rendering intent for the source context.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorManagement.DestinationContext">
            <summary>
            The destination color context. Default null
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorManagement.DestinationIntent">
            <summary>
            The rendering intent for the destination context.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorManagement.AlphaMode">
            <summary>
            The alpha mode of this color management.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.ColorMatrix">
            <summary>
            Built in ColorMatrix effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.ColorMatrix.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="!:ColorMatrixEffect"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorMatrix.Matrix">
            <summary>
            A 5x4 matrix of float values. The elements in the matrix are not bounded and are unitless.
            The default is the identity matrix.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorMatrix.AlphaMode">
            <summary>
            The alpha mode of the output. This can be either premultiplied or straight. See Alpha modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ColorMatrix.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha .
            if you set this to TRUE the effect will clamp the values. 
            If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Composite">
            <summary>
            Built in Composite effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Composite.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Composite"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Composite.Mode">
            <summary>
            The mode used for the effect.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.ConvolveMatrix">
            <summary>
            Built in ConvolveMatrix effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.ConvolveMatrix.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="!:ConvolveMatrixEffect"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.KernelUnitLength">
            <summary>
            The size of one unit in the kernel. The units are in (DIPs/kernel unit), where a kernel unit is the size of the element in the convolution kernel. A value of 1 (DIP/kernel unit) corresponds to one pixel in a image at 96 DPI.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. There are six scale modes that range in quality and speed. If you don't select a mode, the effect uses the interpolation mode of the device context. See Scale modes for more info
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.KernelSizeX">
            <summary>
            The width of the kernel matrix. The units are specified in kernel units.       
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.KernelSizeY">
            <summary>
            The height of the kernel matrix. The units are specified in kernel units.        
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.KernelMatrix">
            <summary>
            The kernel matrix to be applied to the image. The kernel elements aren't bounded and are specified as floats.
            The first set of KernelSizeX numbers in the FLOAT[] corresponds to the first row in the kernel. 
            The second set of KernelSizeX numbers correspond to the second row, and so on up to KernelSizeY rows.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.Divisor">
            <summary>
            The kernel matrix is applied to a pixel and then the result is divided by this value. 0 behaves as a value of float epsilon.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.Bias">
            <summary>
            The effect applies the kernel matrix, the divisor, and then the bias is added to the result. The bias is unbounded and unitless.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.KernelOffset">
            <summary>
            Shifts the convolution kernel from a centered position on the output pixel to a position you specify left/right and up/down. The offset is defined in kernel units.
            With some offsets and kernel sizes, the convolution kernels samples won't land on a pixel image center. The pixel values for the kernel sample are computed by bilinear interpolation.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.PreserveAlpha">
            <summary>
            Specifies whether the convolution kernel is applied to the alpha channel or only the color channels.
            If you set this to TRUE the convolution kernel is applied only to the color channels.
            If you set this to FALSE the convolution kernel is applied to all channels.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See <see cref="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.BorderMode"/> modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.ConvolveMatrix.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha .
            if you set this to TRUE the effect will clamp the values. 
            If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Crop">
            <summary>
            Built in Crop effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Crop.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Crop"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Crop.Rectangle">
            <summary>
            The region to be cropped specified as a vector in the form (left, top, width, height). The units are in DIPs.
            </summary>
            <remarks>
            The rectangle will be truncated if it overlaps the edge boundaries of the input image.
            </remarks>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.DirectionalBlur">
            <summary>
            Built in DirectionalBlur effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.DirectionalBlur.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.DirectionalBlur"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DirectionalBlur.StandardDeviation">
            <summary>
            Gets or sets the amount of blur to be applied to the image. Default: 1.0f
            </summary>
            <remarks>
            You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. 
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DirectionalBlur.Angle">
            <summary>
            The angle of the blur relative to the x-axis, in the counterclockwise direction. The units are specified in degrees.
            The blur kernel is first generated using the same process as for the Gaussian Blur effect. The kernel values are then transformed according to the blur angle using this equation and then applied to the bitmap.
            offset2D  amount of transformation introduced in the blur kernel as a result of the blur angle.
            dist  distance from the center of the kernel to the current position in the kernel. offset2d = (dist * cos(), dist * sin() ) 
            </summary>
            <remarks>
            You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. 
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DirectionalBlur.Optimization">
            <summary>
            The optimization mode. See <see cref="T:SharpDX.Direct2D1.DirectionalBlurOptimization"/> modes for more info.
            </summary>
            <remarks>
            Default value is <see cref="F:SharpDX.Direct2D1.DirectionalBlurOptimization.Balanced"/>.
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DirectionalBlur.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See <see cref="P:SharpDX.Direct2D1.Effects.DirectionalBlur.BorderMode"/> modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.DiscreteTransfer">
            <summary>
            Built in DiscreteTransfer effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.DiscreteTransfer.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.DiscreteTransfer"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.RedTable">
            <summary>
            The list of values used to define the transfer function for the Red channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.RedDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Red channel. If you set this to FALSE the effect applies the RedDiscreteTransfer function to the Red channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.GreenTable">
            <summary>
            The list of values that define the transfer function for the Green channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.GreenDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Green channel. If you set this to FALSE the effect applies the GreenDiscreteTransfer function to the Green channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.BlueTable">
            <summary>
            The list of values that define the transfer function for the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.BlueDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Blue channel. If you set this to FALSE the effect applies the BlueDiscreteTransfer function to the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.AlphaTable">
            <summary>
            The list of values that define the transfer function for the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.AlphaDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Alpha channel. If you set this to FALSE the effect applies the AlphaDiscreteTransfer function to the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DiscreteTransfer.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha .
            if you set this to TRUE the effect will clamp the values. 
            If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.DisplacementMap">
            <summary>
            Built in DisplacementMap effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.DisplacementMap.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.DisplacementMap"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DisplacementMap.Scale">
            <summary>
            Multiplies the intensity of the selected channel from the displacement image. The higher you set this property, the more the effect displaces the pixels
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DisplacementMap.XChannelSelect">
            <summary>
            The effect extracts the intensity from this color channel and uses it to spatially displace the image in the X direction. See Color channels for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DisplacementMap.YChannelSelect">
            <summary>
            The effect extracts the intensity from this color channel and uses it to spatially displace the image in the Y direction. See Color channels for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.DistantDiffuse">
            <summary>
            Built in DistantDiffuse effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.DistantDiffuse.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.DistantDiffuse"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.Azimuth">
            <summary>
            The direction angle of the light source in the XY plane relative to the X-axis in the counter clock wise direction. The units are in degrees and must be between 0 and 360 degrees.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.Elevation">
            <summary>
            The direction angle of the light source in the YZ plane relative to the Y-axis in the counter clock wise direction. The units are in degrees and must be between 0 and 360 degrees.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.DiffuseConstant">
            <summary>
            The ratio of diffuse reflection to amount of incoming light. This property must be between 0 and 10,000 and is unitless. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.SurfaceScale">
            <summary>
            The scale factor in the Z direction. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.Color">
            <summary>
            The color of the incoming light. This property is exposed as a <see cref="!:Vector3"/>  (R, G, B) and used to compute LR, LG, LB. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.KernelUnitLength">
            <summary>
            The size of an element in the Sobel kernel used to generate the surface normal in the X and Y direction. 
            This property maps to the dx and dy values in the Sobel gradient. 
            This property is a <see cref="!:Vector2"/> (Kernel Unit Length X, Kernel Unit Length Y) and is defined in (device-independent pixels (DIPs)/Kernel Unit). 
            The effect uses bilinear interpolation to scale the bitmap to match size of kernel elements.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantDiffuse.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. 
            There are six scale modes that range in quality and speed. 
            If you don't select a mode, the effect uses the interpolation mode of the device context. 
            See Scale modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.DistantSpecular">
            <summary>
            Built in DistantSpecular effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.DistantSpecular.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.DistantSpecular"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.Azimuth">
            <summary>
            The direction angle of the light source in the XY plane relative to the X-axis in the counter clock wise direction. The units are in degrees and must be between 0 and 360 degrees.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.Elevation">
            <summary>
            The direction angle of the light source in the YZ plane relative to the Y-axis in the counter clock wise direction. The units are in degrees and must be between 0 and 360 degrees.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.SpecularExponent">
            <summary>
            The exponent for the specular term in the Phong lighting equation. A larger value corresponds to a more reflective surface. The value is unitless and must be between 1.0 and 128. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.SpecularConstant">
            <summary>
            The ratio of specular reflection to the incoming light. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.SurfaceScale">
            <summary>
            The scale factor in the Z direction. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.Color">
            <summary>
            The color of the incoming light. This property is exposed as a <see cref="!:Vector3"/>  (R, G, B) and used to compute LR, LG, LB. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.KernelUnitLength">
            <summary>
            The size of an element in the Sobel kernel used to generate the surface normal in the X and Y direction. 
            This property maps to the dx and dy values in the Sobel gradient. 
            This property is a <see cref="!:Vector2"/> (Kernel Unit Length X, Kernel Unit Length Y) and is defined in (device-independent pixels (DIPs)/Kernel Unit). 
            The effect uses bilinear interpolation to scale the bitmap to match size of kernel elements.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DistantSpecular.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. There are six scale modes that range in quality and speed. If you don't select a mode, the effect uses the interpolation mode of the device context. See Scale modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.DpiCompensation">
            <summary>
            Built in DpiCompensation effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.DpiCompensation.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.DpiCompensation"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DpiCompensation.InterpolationMode">
            <summary>
            The Dpi interpolation mode.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DpiCompensation.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See <see cref="P:SharpDX.Direct2D1.Effects.DpiCompensation.BorderMode"/> modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.DpiCompensation.InputDpi">
            <summary>
            The input dpi.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Flood">
            <summary>
            Built in Flood effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Flood.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Flood"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Flood.Color">
            <summary>
            The color and opacity of the bitmap. This property is a <see cref="!:Color4"/>. 
            The individual values for each channel are of type FLOAT, unbounded and unitless. 
            The effect doesn't modify the values for the channels.
            The RGBA values for each channel range from 0 to 1.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.GammaTransfer">
            <summary>
            Built in GammaTransfer effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.GammaTransfer.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.GammaTransfer"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.RedAmplitude">
            <summary>
            The amplitude of the gamma transfer function for the Red channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.RedExponent">
            <summary>
            The exponent of the gamma transfer function for the Red channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.RedOffset">
            <summary>
            The offset of the gamma transfer function for the Red channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.RedDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Red channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Red channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.GreenAmplitude">
            <summary>
            The amplitude of the gamma transfer function for the Green channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.GreenExponent">
            <summary>
            The exponent of the gamma transfer function for the Green channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.GreenOffset">
            <summary>
            The offset of the gamma transfer function for the Green channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.GreenDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Green channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Green channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.BlueAmplitude">
            <summary>
            The amplitude of the gamma transfer function for the Blue channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.BlueExponent">
            <summary>
            The exponent of the gamma transfer function for the Blue channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.BlueOffset">
            <summary>
            The offset of the gamma transfer function for the Blue channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.BlueDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Blue channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.AlphaAmplitude">
            <summary>
            The amplitude of the gamma transfer function for the Alpha channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.AlphaExponent">
            <summary>
            The exponent of the gamma transfer function for the Alpha channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.AlphaOffset">
            <summary>
            The offset of the gamma transfer function for the Alpha channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.AlphaDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Alpha channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GammaTransfer.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha .
            if you set this to TRUE the effect will clamp the values. 
            If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.GaussianBlur">
            <summary>
            Built in GaussianBlur effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.GaussianBlur.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.GaussianBlur"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GaussianBlur.StandardDeviation">
            <summary>
            Gets or sets the amount of blur to be applied to the image. Default: 1.0f
            </summary>
            <remarks>
            You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs. A value of zero DIPs disables this effect entirely. 
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GaussianBlur.Optimization">
            <summary>
            The optimization mode. See <see cref="T:SharpDX.Direct2D1.GaussianBlurOptimization"/> modes for more info.
            </summary>
            <remarks>
            Default value is <see cref="F:SharpDX.Direct2D1.GaussianBlurOptimization.Balanced"/>.
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.GaussianBlur.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See <see cref="P:SharpDX.Direct2D1.Effects.GaussianBlur.BorderMode"/> modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Histogram">
            <summary>
            Built in Histogram effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Histogram.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Histogram"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Histogram.NumBins">
            <summary>
            Specifies the number of bins used for the histogram. The range of intensity values that fall into a particular bucket depend on the number of specified buckets. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Histogram.ChannelSelect">
            <summary>
            Specifies the channel used to generate the histogram. This effect has a single data output corresponding to the specified channel. See Channel selectors for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Histogram.HistogramOutput">
            <summary>
            The output array.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.HueRotation">
            <summary>
            Built in HueRotate effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.HueRotation.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.HueRotation"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.HueRotation.Angle">
            <summary>
            The angle to rotate the hue, in degrees.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.LinearTransfer">
            <summary>
            Built in LinearTransfer effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.LinearTransfer.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.LinearTransfer"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.RedYIntercept">
            <summary>
            TThe Y-intercept of the linear function for the Red channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.RedSlope">
            <summary>
            The slope of the linear function for the Red channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.RedDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Red channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Red channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.GreenYIntercept">
            <summary>
            The Y-intercept of the linear function for the Green channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.GreenSlope">
            <summary>
            The slope of the linear function for the Green channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.GreenDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Green channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Green channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.BlueYIntercept">
            <summary>
            The Y-intercept of the linear function for the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.BlueSlope">
            <summary>
            The slope of the linear function for the Blue channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.BlueDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Blue channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.AlphaYIntercept">
            <summary>
            The Y-intercept of the linear function for the Alpha channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.AlphaSlope">
            <summary>
            The slope of the linear function for the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.AlphaDisable">
            <summary>
            If you set this to TRUE it does not apply the transfer function to the Alpha channel. An identity transfer function is used. If you set this to FALSE it applies the gamma transfer function to the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.LinearTransfer.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha .
            if you set this to TRUE the effect will clamp the values. 
            If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.LuminanceToAlpha">
            <summary>
            Built in LuminanceToAlpha effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.LuminanceToAlpha.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.LuminanceToAlpha"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Morphology">
            <summary>
            Built in Morphology effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Morphology.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="!:MorphologyEffect"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Morphology.Mode">
            <summary>
            The morphology mode. The available modes are erode (flatten) and dilate (thicken).
            See Morphology modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Morphology.Width">
            <summary>
            Size of the kernel in the X direction. The units are in DIPs.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Morphology.Height">
            <summary>
            Size of the kernel in the Y direction. The units are in DIPs.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.Direct2D1.Effects"/> namespace provides a managed Direct2D1 built in Effects API.
            </summary>
            <msdn-id>hh706327</msdn-id>
            <unmanaged>Direct2D1 Effects</unmanaged>	
            <unmanaged-short>Direct2D1 Effects</unmanaged-short>	
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.OpacityMetadata">
            <summary>
            Marks an area of an input image as opaque, so internal rendering optimizations to the graph are possible.
            </summary>
            <remarks>
            This effect doesn't modify the image itself to be opaque. It modifies data associated with the image so the renderer assumes the specified region is opaque.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.OpacityMetadata.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.Direct2D1.Effects.OpacityMetadata"/> class.
            </summary>
            <param name="deviceContext">The device context where this effect is attached to.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.OpacityMetadata.OpaqueRectangle">
            <summary>
            The portion of the source image that is opaque. The default is the entire input image.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.PerspectiveTransform3D">
            <summary>
            Rotates the image in 3 dimensions as if viewed from a distance.
            </summary>
            <remarks>
            The <see cref="T:SharpDX.Direct2D1.Effects.PerspectiveTransform3D"/> is more convenient than the <see cref="T:SharpDX.Direct2D1.Effects.Transform3D"/> effect, but only exposes a subset of the functionality. You can compute a full 3D transformation matrix and apply a more arbitrary transform matrix to an image using the <see cref="T:SharpDX.Direct2D1.Effects.Transform3D"/> effect.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.Direct2D1.Effects.PerspectiveTransform3D"/> class.
            </summary>
            <param name="deviceContext">The device context where this effect is attached to.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.InterpolationMode">
            <summary>
            Image interpolation mode.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.BorderMode">
            <summary>
            The border mode.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.Depth">
            <summary>
            The perspective depth.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.PerspectiveOrigin">
            <summary>
            The perspective origin.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.LocalOffset">
            <summary>
            The transformation local offset.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.GlobalOffset">
            <summary>
            The transformation global offset.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.RotationOrigin">
            <summary>
            The transformation rotation origin.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PerspectiveTransform3D.Rotation">
            <summary>
            The transformation rotation.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.PointDiffuse">
            <summary>
            Built in PointDiffuse effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.PointDiffuse.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.PointDiffuse"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointDiffuse.LightPosition">
            <summary>
            The light position of the point light source. The property is a D2D1_VECTOR_3F defined as (x, y, z). The units are in device-independent pixels (DIPs) and the values are unitless and unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointDiffuse.DiffuseConstant">
            <summary>
            The ratio of diffuse reflection to amount of incoming light. This property must be between 0 and 10,000 and is unitless. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointDiffuse.SurfaceScale">
            <summary>
            The scale factor in the Z direction. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointDiffuse.Color">
            <summary>
            The color of the incoming light. This property is exposed as a <see cref="!:Vector3"/>  (R, G, B) and used to compute LR, LG, LB. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointDiffuse.KernelUnitLength">
            <summary>
            The size of an element in the Sobel kernel used to generate the surface normal in the X and Y direction. 
            This property maps to the dx and dy values in the Sobel gradient. 
            This property is a <see cref="!:Vector2"/> (Kernel Unit Length X, Kernel Unit Length Y) and is defined in (device-independent pixels (DIPs)/Kernel Unit). 
            The effect uses bilinear interpolation to scale the bitmap to match size of kernel elements.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointDiffuse.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. 
            There are six scale modes that range in quality and speed. 
            If you don't select a mode, the effect uses the interpolation mode of the device context. 
            See Scale modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.PointSpecular">
            <summary>
            Built in PointSpecular effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.PointSpecular.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.PointSpecular"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.LightPosition">
            <summary>
            The light position of the point light source. The property is a D2D1_VECTOR_3F defined as (x, y, z). The units are in device-independent pixels (DIPs) and the values are unitless and unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.SpecularExponent">
            <summary>
            The exponent for the specular term in the Phong lighting equation. A larger value corresponds to a more reflective surface. The value is unitless and must be between 1.0 and 128. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.SpecularConstant">
            <summary>
            The ratio of specular reflection to the incoming light. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.SurfaceScale">
            <summary>
            The scale factor in the Z direction. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.Color">
            <summary>
            The color of the incoming light. This property is exposed as a <see cref="!:Vector3"/>  (R, G, B) and used to compute LR, LG, LB. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.KernelUnitLength">
            <summary>
            The size of an element in the Sobel kernel used to generate the surface normal in the X and Y direction. 
            This property maps to the dx and dy values in the Sobel gradient. 
            This property is a <see cref="!:Vector2"/> (Kernel Unit Length X, Kernel Unit Length Y) and is defined in (device-independent pixels (DIPs)/Kernel Unit). 
            The effect uses bilinear interpolation to scale the bitmap to match size of kernel elements.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.PointSpecular.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. There are six scale modes that range in quality and speed. If you don't select a mode, the effect uses the interpolation mode of the device context. See Scale modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Premultiply">
            <summary>
            Built in Premultiply effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Premultiply.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Premultiply"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Saturation">
            <summary>
            Built in Saturation effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Saturation.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Saturation"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Saturation.Value">
            <summary>
            The saturation of the image. You can set the saturation to a value between 0 and 1. If you set it to 1 the output image is fully saturated. If you set it to 0 the output image is monochrome. The saturation value is unitless.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Scale">
            <summary>
            Built in Scale effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Scale.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Scale"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Scale.ScaleAmount">
            <summary>
            The scale amount in the X and Y direction as a ratio of the output size to the input size. This property a <see cref="!:Vector2"/> defined as: (X scale, Y scale). The scale amounts are FLOAT, unitless, and must be positive or 0.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Scale.CenterPoint">
            <summary>
            The image scaling center point. This property is a <see cref="!:Vector2"/> defined as: (point X, point Y). The units are in DIPs.
            Use the center point property to scale around a point other than the upper-left corner.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Scale.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See Border modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Scale.Sharpness">
            <summary>
            In the high quality cubic interpolation mode, the sharpness level of the scaling filter as a float between 0 and 1. The values are unitless. You can use sharpness to adjust the quality of an image when you scale the image down.
            The sharpness factor affects the shape of the kernel. The higher the sharpness factor, the smaller the kernel.
            </summary>
            <remarks>
            This property affects only the high quality cubic interpolation mode.
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Scale.InterpolationMode">
            <summary>
            The interpolation mode the effect uses to scale the image. 
            There are 6 scale modes that range in quality and speed. 
            If you don't select a mode, the effect uses the interpolation mode of the device context. See Interpolation modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Shadow">
            <summary>
            Built in Shadow effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Shadow.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Shadow"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Shadow.BlurStandardDeviation">
            <summary>
            The amount of blur to be applied to the alpha channel of the image. You can compute the blur radius of the kernel by multiplying the standard deviation by 3. The units of both the standard deviation and blur radius are DIPs.
            This property is the same as the Gaussian Blur standard deviation property.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Shadow.Color">
            <summary>
            The color of the drop shadow. This property is a <see cref="T:SharpDX.Mathematics.Interop.RawColor4"/> defined as: (R, G, B, A). 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Shadow.Optimization">
            <summary>
            The level of performance optimization.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.SpotDiffuse">
            <summary>
            Builtin SpotDiffuse effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.SpotDiffuse.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.SpotDiffuse"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.LightPosition">
            <summary>
            The light position of the point light source. The property is a <see cref="!:Vector3"/> defined as (x, y, z). The units are in device-independent pixels (DIPs) and the values are unitless and unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.PointsAt">
            <summary>
            Where the spot light is focused. The property is exposed as a <see cref="!:Vector3"/>  with  (x, y, z). The units are in DIPs and the values are unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.Focus">
            <summary>
            The focus of the spot light. This property is unitless and is defined between 0 and 200.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.LimitingConeAngle">
            <summary>
            The cone angle that restricts the region where the light is projected. No light is projected outside the cone. The limiting cone angle is the angle between the spot light axis (the axis between the LightPosition and PointsAt properties) and the spot light cone. This property is defined in degrees and must be between 0 to 90 degrees.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.DiffuseConstant">
            <summary>
            The ratio of diffuse reflection to amount of incoming light. This property must be between 0 and 10,000 and is unitless. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.SurfaceScale">
            <summary>
            The scale factor in the Z direction. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.Color">
            <summary>
            The color of the incoming light. This property is exposed as a <see cref="!:Vector3"/>  (R, G, B) and used to compute LR, LG, LB. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.KernelUnitLength">
            <summary>
            The size of an element in the Sobel kernel used to generate the surface normal in the X and Y direction. 
            This property maps to the dx and dy values in the Sobel gradient. 
            This property is a <see cref="!:Vector2"/> (Kernel Unit Length X, Kernel Unit Length Y) and is defined in (device-independent pixels (DIPs)/Kernel Unit). 
            The effect uses bilinear interpolation to scale the bitmap to match size of kernel elements.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotDiffuse.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. 
            There are six scale modes that range in quality and speed. 
            If you don't select a mode, the effect uses the interpolation mode of the device context. 
            See Scale modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.SpotSpecular">
            <summary>
            Built in SpotSpecular effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.SpotSpecular.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.SpotSpecular"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.LightPosition">
            <summary>
            The light position of the point light source. The property is a D2D1_VECTOR_3F defined as (x, y, z). The units are in device-independent pixels (DIPs) and the values are unitless and unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.PointsAt">
            <summary>
            Where the spot light is focused. The property is exposed as a <see cref="!:Vector3"/>  with  (x, y, z). The units are in DIPs and the values are unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.Focus">
            <summary>
            The focus of the spot light. This property is unitless and is defined between 0 and 200.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.LimitingConeAngle">
            <summary>
            The cone angle that restricts the region where the light is projected. No light is projected outside the cone. The limiting cone angle is the angle between the spot light axis (the axis between the LightPosition and PointsAt properties) and the spot light cone. This property is defined in degrees and must be between 0 to 90 degrees.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.SpecularExponent">
            <summary>
            The exponent for the specular term in the Phong lighting equation. A larger value corresponds to a more reflective surface. The value is unitless and must be between 1.0 and 128. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.SpecularConstant">
            <summary>
            The ratio of specular reflection to the incoming light. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.SurfaceScale">
            <summary>
            The scale factor in the Z direction. The value is unitless and must be between 0 and 10,000.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.Color">
            <summary>
            The color of the incoming light. This property is exposed as a <see cref="!:Vector3"/>  (R, G, B) and used to compute LR, LG, LB. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.KernelUnitLength">
            <summary>
            The size of an element in the Sobel kernel used to generate the surface normal in the X and Y direction. 
            This property maps to the dx and dy values in the Sobel gradient. 
            This property is a <see cref="!:Vector2"/> (Kernel Unit Length X, Kernel Unit Length Y) and is defined in (device-independent pixels (DIPs)/Kernel Unit). 
            The effect uses bilinear interpolation to scale the bitmap to match size of kernel elements.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.SpotSpecular.ScaleMode">
            <summary>
            The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. There are six scale modes that range in quality and speed. If you don't select a mode, the effect uses the interpolation mode of the device context. See Scale modes for more info.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.TableTransfer">
            <summary>
            Built in TableTransfer effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.TableTransfer.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.TableTransfer"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.RedTable">
            <summary>
            The list of values used to define the transfer function for the Red channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.RedDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Red channel. If you set this to FALSE the effect applies the RedTableTransfer function to the Red channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.GreenTable">
            <summary>
            The list of values that define the transfer function for the Green channel.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.GreenDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Green channel. If you set this to FALSE the effect applies the GreenTableTransfer function to the Green channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.BlueTable">
            <summary>
            The list of values that define the transfer function for the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.BlueDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Blue channel. If you set this to FALSE the effect applies the BlueTableTransfer function to the Blue channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.AlphaTable">
            <summary>
            The list of values that define the transfer function for the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.AlphaDisable">
            <summary>
            If you set this to TRUE the effect does not apply the transfer function to the Alpha channel. If you set this to FALSE the effect applies the AlphaTableTransfer function to the Alpha channel. 
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.TableTransfer.ClampOutput">
            <summary>
            Whether the effect clamps color values to between 0 and 1 before the effect passes the values to the next effect in the graph. The effect clamps the values before it premultiplies the alpha .
            if you set this to TRUE the effect will clamp the values. 
            If you set this to FALSE, the effect will not clamp the color values, but other effects and the output surface may clamp the values if they are not of high enough precision.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Tile">
            <summary>
            Built in Tile effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Tile.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Tile"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Tile.Rectangle">
            <summary>
            The region to be tiled specified as a vector in the form (left, top, width, height). The units are in DIPs.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Transform3D">
            <summary>
            Built in Transform3D effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Transform3D.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Transform3D"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Transform3D.InterpolationMode">
            <summary>
            The interpolation mode used to scale the image. There are 6 scale modes that range in quality and speed. 
            If you don't select a mode, the effect uses the interpolation mode of the device context. 
            See <see cref="P:SharpDX.Direct2D1.Effects.Transform3D.InterpolationMode"/> for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Transform3D.BorderMode">
            <summary>
            The mode used to calculate the border of the image, soft or hard. See <see cref="P:SharpDX.Direct2D1.Effects.Transform3D.BorderMode"/> modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Transform3D.TransformMatrix">
            <summary>
            A 4x4 transform matrix applied to the projection plane.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.Turbulence">
            <summary>
            Built in Turbulence effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.Turbulence.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Turbulence"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Turbulence.Offset">
            <summary>
            The coordinates where the turbulence output is generated.
            The algorithm used to generate the Perlin noise is position dependent, so a different offset results in a different output. This property is not bounded and the units are specified in DIPs
            </summary>
            <remarks>
            The offset does not have the same effect as a translation because the noise function output is infinite and the function will wrap around the tile.
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Turbulence.BaseFrequency">
            <summary>
            The base frequencies in the X and Y direction.. This property is a float and must be greater than 0. The units are specified in 1/DIPs.
            A value of 1 (1/DIPs) for the base frequency results in the Perlin noise completing an entire cycle between two pixels. The ease interpolation for these pixels results in completely random pixels, since there is no correlation between the pixels.
            A value of 0.1(1/DIPs) for the base frequency, the Perlin noise function repeats every 10 DIPs. This results in correlation between pixels and the typical turbulence effect is visible
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Turbulence.OctaveCount">
            <summary>
            The number of octaves for the noise function. This property is an int and must be greater than 0.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Turbulence.Seed">
            <summary>
            The seed for the pseudo random generator. This property is unbounded.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Turbulence.Noise">
            <summary>
            The turbulence noise mode. This property can be either fractal sum or turbulence. Indicates whether to generate a bitmap based on Fractal Noise or the Turbulence function. See Noise modes for more info.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.Turbulence.Stitchable">
            <summary>
            Turns stitching on or off. The base frequency is adjusted so that output bitmap can be stitched. This is useful if you want to tile multiple copies of the turbulence effect output.
            true: The output bitmap can be tiled (using the tile effect) without the appearance of seams. The base frequency is adjusted so that output bitmap can be stitched. 
            false: The base frequency is not adjusted, so seams may appear between tiles if the bitmap is tiled.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.UnPremultiply">
            <summary>
            Built in Premultiply effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.UnPremultiply.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.Effects.Premultiply"/> effect.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:SharpDX.Direct2D1.Effects.YCbCr">
            <summary>
            The built-in YCbCr effect.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Effects.YCbCr.#ctor(SharpDX.Direct2D1.DeviceContext)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Effects.YCbCr"/> effect.
            </summary>
            <param name="context">The device context where this effect instance is attached to.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.YCbCr.ChromaSubSampling">
            <summary>
            Gets or sets the chroma subsampling of the input chroma image.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.YCbCr.Transform">
            <summary>
            Gets or sets the axis-aligned affine transform of the image. Axis aligned transforms include Scale, Flips, and 90 degree rotations.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Effects.YCbCr.InterpolationMode">
            <summary>
            Gets or sets the interpolation mode.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.Ellipse">
            <summary>
            <p> Contains the center point, x-radius, and y-radius of an ellipse.</p>
            </summary>
            <doc-id>dd368097</doc-id>
            <unmanaged>D2D1_ELLIPSE</unmanaged>
            <unmanaged-short>D2D1_ELLIPSE</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ellipse.#ctor(SharpDX.Mathematics.Interop.RawVector2,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Ellipse"/> struct.
            </summary>
            <param name="center">The center.</param>
            <param name="radiusX">The radius X.</param>
            <param name="radiusY">The radius Y.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.Ellipse.Point">
            <summary>
            <dd> <p>The center point of the ellipse.</p> </dd>
            </summary>
            <doc-id>dd368097</doc-id>
            <unmanaged>point</unmanaged>
            <unmanaged-short>point</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Ellipse.RadiusX">
            <summary>
            <dd> <p>The X-radius of the ellipse.</p> </dd>
            </summary>
            <doc-id>dd368097</doc-id>
            <unmanaged>radiusX</unmanaged>
            <unmanaged-short>radiusX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Ellipse.RadiusY">
            <summary>
            <dd> <p>The Y-radius of the ellipse.</p> </dd>
            </summary>
            <doc-id>dd368097</doc-id>
            <unmanaged>radiusY</unmanaged>
            <unmanaged-short>radiusY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EllipseGeometry.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.Ellipse)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.EllipseGeometry"/>. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="ellipse">A value that describes the center point, x-radius, and y-radius of the ellipse geometry.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.EllipseGeometry.Ellipse">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.Direct2D1.Ellipse"/></strong> structure that describes this ellipse geometry. </p>
            </summary>
            <doc-id>dd371243</doc-id>
            <unmanaged>GetEllipse</unmanaged>
            <unmanaged-short>GetEllipse</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EllipseGeometry.GetEllipse(SharpDX.Direct2D1.Ellipse@)">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.Direct2D1.Ellipse"/></strong> structure that describes this ellipse geometry. </p>
            </summary>
            <param name = "ellipse">No documentation.</param>
            <doc-id>dd371243</doc-id>
            <unmanaged>void ID2D1EllipseGeometry::GetEllipse([Out] D2D1_ELLIPSE* ellipse)</unmanaged>
            <unmanaged-short>ID2D1EllipseGeometry::GetEllipse</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.#ctor">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory" />.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.#ctor(SharpDX.Direct2D1.FactoryType)">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory" />.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.#ctor(SharpDX.Direct2D1.FactoryType,SharpDX.Direct2D1.DebugLevel)">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory" />.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Factory.DesktopDpi">
            <summary>	
            Retrieves the current desktop dots per inch (DPI). To refresh this value, call {{ReloadSystemMetrics}}.	
            </summary>	
            <remarks>	
            Use this method to obtain the system DPI when setting physical pixel values, such as when you specify the size of a window. 	
            </remarks>	
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.ReloadSystemMetrics">
            <summary>
            <p>Forces the factory to refresh any system defaults that it might have changed since factory creation.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You should call this method before calling the <strong>GetDesktopDpi</strong> method, to ensure that the system DPI is current.</p>
            </remarks>
            <doc-id>dd371319</doc-id>
            <unmanaged>HRESULT ID2D1Factory::ReloadSystemMetrics()</unmanaged>
            <unmanaged-short>ID2D1Factory::ReloadSystemMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.GetDesktopDpi(System.Single@,System.Single@)">
            <summary>
            <p>Retrieves the current desktop dots per inch (DPI). To refresh this value, call <strong>ReloadSystemMetrics</strong>.</p>
            </summary>
            <param name = "dpiX">No documentation.</param>
            <param name = "dpiY">No documentation.</param>
            <remarks>
            <p>Use this method to obtain the system DPI when setting physical pixel values, such as when you specify the size of a window.</p>
            </remarks>
            <doc-id>dd371316</doc-id>
            <unmanaged>void ID2D1Factory::GetDesktopDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
            <unmanaged-short>ID2D1Factory::GetDesktopDpi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateRectangleGeometry(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.RectangleGeometry)">
            <summary>
            <p> Creates an <strong><see cref = "T:SharpDX.Direct2D1.RectangleGeometry"/></strong>. </p>
            </summary>
            <param name = "rectangle">No documentation.</param>
            <param name = "rectangleGeometry">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371289</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateRectangleGeometry([In] const D2D_RECT_F* rectangle,[Out, Fast] ID2D1RectangleGeometry** rectangleGeometry)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateRectangleGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateRoundedRectangleGeometry(SharpDX.Direct2D1.RoundedRectangle@,SharpDX.Direct2D1.RoundedRectangleGeometry)">
            <summary>
            <p> Creates an <strong><see cref = "T:SharpDX.Direct2D1.RoundedRectangleGeometry"/></strong>. </p>
            </summary>
            <param name = "roundedRectangle">No documentation.</param>
            <param name = "roundedRectangleGeometry">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371293</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateRoundedRectangleGeometry([In] const D2D1_ROUNDED_RECT* roundedRectangle,[Out, Fast] ID2D1RoundedRectangleGeometry** roundedRectangleGeometry)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateRoundedRectangleGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateEllipseGeometry(SharpDX.Direct2D1.Ellipse,SharpDX.Direct2D1.EllipseGeometry)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.EllipseGeometry"/></strong>. </p>
            </summary>
            <param name = "ellipse">No documentation.</param>
            <param name = "ellipseGeometry">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371270</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateEllipseGeometry([In] const D2D1_ELLIPSE* ellipse,[Out, Fast] ID2D1EllipseGeometry** ellipseGeometry)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateEllipseGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateGeometryGroup(SharpDX.Direct2D1.FillMode,SharpDX.Direct2D1.Geometry[],System.Int32,SharpDX.Direct2D1.GeometryGroup)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>
            </summary>
            <param name = "fillMode">No documentation.</param>
            <param name = "geometries">No documentation.</param>
            <param name = "geometriesCount">No documentation.</param>
            <param name = "geometryGroup">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) and <strong>D2D1_FILL_MODE_WINDING</strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>
            </remarks>
            <doc-id>dd371273</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateTransformedGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Mathematics.Interop.RawMatrix3x2@,SharpDX.Direct2D1.TransformedGeometry)">
            <summary>
            <p>Transforms the specified geometry and stores the result as an <strong><see cref = "T:SharpDX.Direct2D1.TransformedGeometry"/></strong> object.  </p>
            </summary>
            <param name = "sourceGeometry">No documentation.</param>
            <param name = "transform">No documentation.</param>
            <param name = "transformedGeometry">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Like other resources, a transformed geometry inherits the resource space and threading policy of the factory that created it. This object is immutable.</p><p>When stroking a transformed geometry with the <strong>DrawGeometry</strong> method, the stroke width is not affected by the transform applied to the geometry.  The stroke width is only affected by the world transform.</p>
            </remarks>
            <doc-id>dd371307</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateTransformedGeometry([In] ID2D1Geometry* sourceGeometry,[In] const D2D_MATRIX_3X2_F* transform,[Out, Fast] ID2D1TransformedGeometry** transformedGeometry)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateTransformedGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreatePathGeometry(SharpDX.Direct2D1.PathGeometry)">
            <summary>
            <p>Creates an empty <strong><see cref = "T:SharpDX.Direct2D1.PathGeometry"/></strong>.</p>
            </summary>
            <param name = "athGeometryRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371282</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreatePathGeometry([Out, Fast] ID2D1PathGeometry** pathGeometry)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreatePathGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateStrokeStyle(SharpDX.Direct2D1.StrokeStyleProperties@,System.Single[],System.Int32,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p> Creates an <strong><see cref = "T:SharpDX.Direct2D1.StrokeStyle"/></strong> that describes start cap, dash pattern, and other features of a stroke.</p>
            </summary>
            <param name = "strokeStyleProperties">No documentation.</param>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "strokeStyle">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371301</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle** strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateStrokeStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateDrawingStateBlock(System.Nullable{SharpDX.Direct2D1.DrawingStateDescription},SharpDX.DirectWrite.RenderingParams,SharpDX.Direct2D1.DrawingStateBlock)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.DrawingStateBlock"/></strong> that can be used with the <strong>SaveDrawingState</strong> and <strong>RestoreDrawingState</strong> methods of a render target.</p>
            </summary>
            <param name = "drawingStateDescription">No documentation.</param>
            <param name = "textRenderingParams">No documentation.</param>
            <param name = "drawingStateBlock">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371253</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out, Fast] ID2D1DrawingStateBlock** drawingStateBlock)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateDrawingStateBlock</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateWicBitmapRenderTarget(SharpDX.WIC.Bitmap,SharpDX.Direct2D1.RenderTargetProperties@,SharpDX.Direct2D1.RenderTarget)">
            <summary>
            <p>Creates a render target that renders to a Microsoft Windows Imaging Component (WIC)  bitmap.</p>
            </summary>
            <param name = "target"><dd>  <p>The bitmap that receives the rendering output of the render target.</p> </dd></param>
            <param name = "renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>
            <param name = "renderTarget"><dd>  <p>When this method returns, contains the address of the reference to the <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> object created by this method. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You must use <strong>D2D1_FEATURE_LEVEL_DEFAULT</strong> for the <strong>minLevel</strong> member of the  <em>renderTargetProperties</em> parameter with this method.</p><p>Your application should create render targets once and hold onto them for the life of the application or until the <strong><see cref = "!:RecreateTarget"/></strong> error is received. When you receive this error, you need to recreate the render target (and any resources it created).</p><ul> <li></li> </ul>  <p><strong>Note</strong>??  This method isn't supported on Windows Phone and will fail when called on a device with error code 0x8899000b  (?There is no hardware rendering device available for this operation?). Because the Windows Phone Emulator supports WARP rendering,  this method will fail when called on the emulator with a different error code, 0x88982f80  (wincodec_err_unsupportedpixelformat).</p>
            </remarks>
            <doc-id>dd371309</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateWicBitmapRenderTarget([In] IWICBitmap* target,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1RenderTarget** renderTarget)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateWicBitmapRenderTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateHwndRenderTarget(SharpDX.Direct2D1.RenderTargetProperties@,SharpDX.Direct2D1.HwndRenderTargetProperties@,SharpDX.Direct2D1.WindowRenderTarget)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong>, a render target that renders to a window.</p>
            </summary>
            <param name = "renderTargetProperties">No documentation.</param>
            <param name = "hwndRenderTargetProperties">No documentation.</param>
            <param name = "hwndRenderTarget">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the <strong><see cref = "!:RecreateTarget"/></strong> error is received. When you receive this error, you need to recreate the render target (and any resources it created).</p>
            </remarks>
            <doc-id>dd371279</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateHwndRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[In] const D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,[Out, Fast] ID2D1HwndRenderTarget** hwndRenderTarget)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateHwndRenderTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateDxgiSurfaceRenderTarget(SharpDX.DXGI.Surface,SharpDX.Direct2D1.RenderTargetProperties@,SharpDX.Direct2D1.RenderTarget)">
            <summary>
            <p>Creates a render target that draws to a DirectX Graphics Infrastructure (DXGI) surface.  </p>
            </summary>
            <param name = "dxgiSurface"><dd>  <p>The <see cref = "T:SharpDX.DXGI.Surface"/> to which the render target will draw.</p> </dd></param>
            <param name = "renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>
            <param name = "renderTarget"><dd>  <p>When this method returns, contains the address of the reference to the <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> object created by this method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To write to a Direct3D surface, you obtain an <see cref = "T:SharpDX.DXGI.Surface"/> and pass it to the <strong>CreateDxgiSurfaceRenderTarget</strong> method to create a DXGI surface render target; you can then use the DXGI surface render target to draw 2-D content to the DXGI surface.  </p><p>A DXGI surface render target is a type of <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong>. Like other Direct2D render targets, you can use it to create resources and issue drawing commands. </p><p>The DXGI surface render target and the DXGI surface must use the same DXGI format. If you specify the DXGI_FORMAT_UNKOWN format when you create the render target, it will automatically use the surface's format.</p><p>The DXGI surface render target does not perform DXGI surface synchronization. </p><p>For more information about creating and using DXGI surface render targets, see the Direct2D and Direct3D Interoperability Overview.</p><p>To work with Direct2D, the Direct3D device that provides the <see cref = "T:SharpDX.DXGI.Surface"/> must be created with the <strong>D3D10_CREATE_DEVICE_BGRA_SUPPORT</strong> flag.</p><p>When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the render target's <strong>EndDraw</strong> method returns the <strong><see cref = "!:RecreateTarget"/></strong> error. When you receive this error, you need to recreate the render target (and any resources it created). </p><p></p>
            </remarks>
            <doc-id>dd371264</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateDxgiSurfaceRenderTarget([In] IDXGISurface* dxgiSurface,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1RenderTarget** renderTarget)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateDxgiSurfaceRenderTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateDCRenderTarget(SharpDX.Direct2D1.RenderTargetProperties@,SharpDX.Direct2D1.DeviceContextRenderTarget)">
            <summary>
            <p>Creates a render target that draws to a Windows Graphics Device Interface (GDI) device context.</p>
            </summary>
            <param name = "renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.  To enable the device context (DC) render target to work with GDI, set the DXGI format to DXGI_FORMAT_B8G8R8A8_UNORM and the alpha mode to <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong> or <strong>D2D1_ALPHA_MODE_IGNORE</strong>. For more information about pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>
            <param name = "dcRenderTarget"><dd>  <p>When this method returns, <em>dcRenderTarget</em> contains the address of the reference to the  <strong><see cref = "T:SharpDX.Direct2D1.DeviceContextRenderTarget"/></strong> created by the method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before you can render with a DC render target, you must use the render target's <strong>BindDC</strong> method to associate it with a GDI DC.  Do this for each different DC and whenever there is a change in the size of the area you want to draw to.</p><p>To enable the DC render target to work with GDI, set the render target's DXGI format to DXGI_FORMAT_B8G8R8A8_UNORM and alpha mode to <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong> or <strong>D2D1_ALPHA_MODE_IGNORE</strong>.</p><p>Your application should create render targets once and hold on to them for the life of the application or until the render target's  <strong>EndDraw</strong> method returns the <strong><see cref = "!:RecreateTarget"/></strong> error. When you receive this error, recreate the render target (and any resources it created).</p>
            </remarks>
            <doc-id>dd371248</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateDCRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1DCRenderTarget** dcRenderTarget)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateDCRenderTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateGeometryGroup(SharpDX.Direct2D1.FillMode,SharpDX.ComArray{SharpDX.Direct2D1.Geometry},System.Int32,SharpDX.Direct2D1.GeometryGroup)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>
            </summary>
            <param name = "fillMode">No documentation.</param>
            <param name = "geometries">No documentation.</param>
            <param name = "geometriesCount">No documentation.</param>
            <param name = "geometryGroup">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) and <strong>D2D1_FILL_MODE_WINDING</strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>
            </remarks>
            <doc-id>dd371273</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory.CreateGeometryGroup(SharpDX.Direct2D1.FillMode,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>
            </summary>
            <param name = "fillMode">No documentation.</param>
            <param name = "geometries">No documentation.</param>
            <param name = "geometriesCount">No documentation.</param>
            <param name = "geometryGroup">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) and <strong>D2D1_FILL_MODE_WINDING</strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>
            </remarks>
            <doc-id>dd371273</doc-id>
            <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>
            <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.#ctor">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory1" />.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.#ctor(SharpDX.Direct2D1.FactoryType)">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory1" />.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.#ctor(SharpDX.Direct2D1.FactoryType,SharpDX.Direct2D1.DebugLevel)">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory1" />.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Factory1.RegisteredEffects">
            <summary>	
            Get the effects registered
            </summary>	
            <unmanaged>HRESULT ID2D1Factory1::GetRegisteredEffects([Out, Buffer, Optional] GUID* effects,[In] unsigned int effectsCount,[Out, Optional] unsigned int* effectsReturned,[Out, Optional] unsigned int* effectsRegistered)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.RegisterEffect``1(System.Func{``0})">
            <summary>
            Register a <see cref="T:SharpDX.Direct2D1.CustomEffect"/> factory.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="effectFactory"></param>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.RegisterEffect``1(System.Func{``0},System.Guid)">
            <summary>
            Register a <see cref="T:SharpDX.Direct2D1.CustomEffect"/> factory.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="effectFactory"></param>
            <param name="effectId"></param>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.RegisterEffect``1">
            <summary>
            Register a <see cref="T:SharpDX.Direct2D1.CustomEffect"/>.
            </summary>
            <typeparam name="T">Type of </typeparam>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.RegisterEffect``1(System.Guid)">
            <summary>
            Register a <see cref="T:SharpDX.Direct2D1.CustomEffect"/>.
            </summary>
            <typeparam name="T">Type of </typeparam>
            <param name="effectId"></param>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.UnRegisterEffect``1">
            <summary>
            Unregister a <see cref="T:SharpDX.Direct2D1.CustomEffect"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.CreateDevice(SharpDX.DXGI.Device,SharpDX.Direct2D1.Device)">
            <summary>
            <p>Creates a <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> object.</p>
            </summary>
            <param name = "dxgiDevice">No documentation.</param>
            <param name = "d2dDevice">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The Direct2D device defines a resource domain in which a set of Direct2D objects and Direct2D device contexts can be used together.  Each call to <strong>CreateDevice</strong> returns a unique <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> object, even if you pass the same <strong><see cref = "T:SharpDX.DXGI.Device"/></strong> multiple times.</p>
            </remarks>
            <doc-id>hh404599</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device** d2dDevice)</unmanaged>
            <unmanaged-short>ID2D1Factory1::CreateDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.CreateStrokeStyle(SharpDX.Direct2D1.StrokeStyleProperties1@,System.Single[],System.Int32,SharpDX.Direct2D1.StrokeStyle1)">
            <summary>
            <p>Creates a <strong><see cref = "T:SharpDX.Direct2D1.StrokeStyle1"/></strong> object.</p>
            </summary>
            <param name = "strokeStyleProperties">No documentation.</param>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "strokeStyle">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>It is valid to specify a dash array only if D2D1_DASH_STYLE_CUSTOM is also specified.</p>
            </remarks>
            <doc-id>hh404605</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle1** strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1Factory1::CreateStrokeStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.CreatePathGeometry(SharpDX.Direct2D1.PathGeometry1)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.PathGeometry1"/></strong> object.</p>
            </summary>
            <param name = "athGeometryRef">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
            <doc-id>hh404602</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::CreatePathGeometry([Out, Fast] ID2D1PathGeometry1** pathGeometry)</unmanaged>
            <unmanaged-short>ID2D1Factory1::CreatePathGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.CreateDrawingStateBlock(System.Nullable{SharpDX.Direct2D1.DrawingStateDescription1},SharpDX.DirectWrite.RenderingParams,SharpDX.Direct2D1.DrawingStateBlock1)">
            <summary>
            <p> Creates a new drawing state block, this can be used in subsequent SaveDrawingState and RestoreDrawingState operations on the render target. </p>
            </summary>
            <param name = "drawingStateDescription"><dd>  <p>The drawing state description structure.</p> </dd></param>
            <param name = "textRenderingParams"><dd>  <p>The address of the newly created drawing state block.</p> </dd></param>
            <param name = "drawingStateBlock"><dd>  <p>The address of the newly created drawing state block.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <doc-id>jj841162</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION1* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out, Fast] ID2D1DrawingStateBlock1** drawingStateBlock)</unmanaged>
            <unmanaged-short>ID2D1Factory1::CreateDrawingStateBlock</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.CreateGdiMetafile(SharpDX.Win32.IStream,SharpDX.Direct2D1.GdiMetafile@)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.GdiMetafile"/></strong> object that you can use to replay metafile content. </p>
            </summary>
            <param name = "metafileStream">No documentation.</param>
            <param name = "metafile">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <doc-id>hh847995</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::CreateGdiMetafile([In] IStream* metafileStream,[Out] ID2D1GdiMetafile** metafile)</unmanaged>
            <unmanaged-short>ID2D1Factory1::CreateGdiMetafile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.RegisterEffectFromStream(System.Guid,SharpDX.Win32.IStream,SharpDX.Direct2D1.PropertyBinding[],System.Int32,SharpDX.FunctionCallback)">
            <summary>
            <p>Registers an effect within the factory instance with the property XML specified as a stream.</p>
            </summary>
            <param name = "classId"><dd>  <p>The identifier of the effect to be registered.</p> </dd></param>
            <param name = "ropertyXmlRef"><dd>  <p>A list of the effect properties, types, and metadata.</p> </dd></param>
            <param name = "bindings"><dd>  <p>An array of properties and methods.</p> <p> This binds a property by name to a particular method implemented by the effect author to handle the property.  The name must be found in the corresponding <em>propertyXml</em>. </p> </dd></param>
            <param name = "bindingsCount"><dd>  <p>The number of bindings in the binding array.</p> </dd></param>
            <param name = "effectFactory"><dd>  <p>The static factory that is used to create the corresponding effect.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Direct2D effects must define their properties at registration time via registration XML. An effect declares several required system properties,  and can also declare custom properties. See Custom effects for more information about formatting the <em>propertyXml</em> parameter. </p><p> <strong>RegisterEffect</strong> is both atomic and reference counted. To unregister an effect,  call <strong>UnregisterEffect</strong> with the  <em>classId</em> of the effect. </p><strong>Important</strong>??<strong>RegisterEffect</strong> does not hold a reference to the DLL or executable file in which  the effect is contained. The application must independently  make sure that the lifetime of the DLL or executable file completely contains all instances of each registered and created effect.?<p>Aside from the built-in effects that are globally registered, this API registers effects only for this factory, derived device,  and device context interfaces.</p>
            </remarks>
            <doc-id>hh847996</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::RegisterEffectFromStream([In] const GUID&amp; classId,[In] IStream* propertyXml,[In, Buffer, Optional] const D2D1_PROPERTY_BINDING* bindings,[In] unsigned int bindingsCount,[In] const __function__stdcall* effectFactory)</unmanaged>
            <unmanaged-short>ID2D1Factory1::RegisterEffectFromStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.RegisterEffectFromString(System.Guid,System.String,SharpDX.Direct2D1.PropertyBinding[],System.Int32,SharpDX.FunctionCallback)">
            <summary>
            <p>Registers an effect within the factory instance with the property XML specified as a string.</p>
            </summary>
            <param name = "classId"><dd>  <p>The identifier of the effect to be registered.</p> </dd></param>
            <param name = "ropertyXmlRef"><dd>  <p>A list of the effect properties, types, and metadata.</p> </dd></param>
            <param name = "bindings"><dd>  <p>An array of properties and methods.</p> <p> This binds a property by name to a particular method implemented by the effect author to handle the property.  The name must be found in the corresponding <em>propertyXml</em>. </p> </dd></param>
            <param name = "bindingsCount"><dd>  <p>The number of bindings in the binding array.</p> </dd></param>
            <param name = "effectFactory"><dd>  <p>The static factory that is used to create the corresponding effect.</p> </dd></param>
            <returns><p> The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Direct2D effects must define their properties at registration time via registration XML. An effect declares several required system properties,  and can also declare custom properties. See Custom effects for more information about formatting the <em>propertyXml</em> parameter. </p><p><strong>RegisterEffect</strong> is both atomic and reference counted. To unregister an effect,  call <strong>UnregisterEffect</strong> with the  <em>classId</em> of the effect. </p><strong>Important</strong>??<strong>RegisterEffect</strong> does not hold a reference to the DLL or executable file in which  the effect is contained. The application must independently  make sure that the lifetime of the DLL or executable file completely contains all instances of each registered and created effect.?<p>Aside from the built-in effects that are globally registered, this API registers effects only for  this factory and derived device and device context interfaces.</p>
            </remarks>
            <doc-id>hh404614</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::RegisterEffectFromString([In] const GUID&amp; classId,[In] const wchar_t* propertyXml,[In, Buffer, Optional] const D2D1_PROPERTY_BINDING* bindings,[In] unsigned int bindingsCount,[In] const __function__stdcall* effectFactory)</unmanaged>
            <unmanaged-short>ID2D1Factory1::RegisterEffectFromString</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.UnregisterEffect(System.Guid)">
            <summary>
            <p>Unregisters an  effect within the factory instance that corresponds to the <em>classId</em> provided. </p>
            </summary>
            <param name = "classId"><dd>  <p>The identifier of the effect to be unregistered.</p> </dd></param>
            <returns><p><see cref = "!:EffectIsNotRegistered"/> if the effect is not registered, <see cref = "F:SharpDX.Result.Ok"/> otherwise.</p></returns>
            <remarks>
            <p>In order for the effect to be fully unloaded, you must call <strong>UnregisterEffect</strong> the same number of times that you have registered the effect.</p><p>The <strong>UnregisterEffect</strong> method unregisters only those effects that are registered on the same factory. It cannot be used to unregister a built-in effect.</p>
            </remarks>
            <doc-id>hh404617</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::UnregisterEffect([In] const GUID&amp; classId)</unmanaged>
            <unmanaged-short>ID2D1Factory1::UnregisterEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.GetRegisteredEffects(System.Guid[],System.Int32,System.Int32@,System.Int32@)">
            <summary>
            <p>Returns the class IDs of the currently registered effects and global effects on this factory.</p>
            </summary>
            <param name = "effects"><dd>  <p>When this method returns, contains an array of effects. <strong><c>null</c></strong> if no effects are retrieved.</p> </dd></param>
            <param name = "effectsCount"><dd>  <p>The capacity of the <em>effects</em> array.</p> </dd></param>
            <param name = "effectsReturned"><dd>  <p>When this method returns, contains the  number of effects copied into <em>effects</em>.</p> </dd></param>
            <param name = "effectsRegistered"><dd>  <p>When this method returns, contains the number of effects currently registered in the system.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)</td><td><em>effectsRegistered</em> is larger than <em>effectCount</em>.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The set of class IDs will be atomically returned by the API. The set will not be interrupted by other threads registering or unregistering effects.</p><p>If <em>effectsRegistered</em> is larger than <em>effectCount</em>, the supplied array will still be filled to capacity with the current set of registered effects. This method returns the CLSIDs for all global effects and all effects registered to this factory.</p>
            </remarks>
            <doc-id>hh404612</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::GetRegisteredEffects([Out, Buffer, Optional] GUID* effects,[In] unsigned int effectsCount,[Out, Optional] unsigned int* effectsReturned,[Out, Optional] unsigned int* effectsRegistered)</unmanaged>
            <unmanaged-short>ID2D1Factory1::GetRegisteredEffects</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory1.GetEffectProperties(System.Guid)">
            <summary>
            <p>Retrieves the properties of an effect.</p>
            </summary>
            <param name = "effectId"><dd>  <p>The ID of the effect to retrieve properties from.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of a reference to the property interface that can be used to query the metadata of the effect.</p> </dd></returns>
            <remarks>
            <p>The returned effect properties will have all the mutable properties for the effect set to a default of <strong><c>null</c></strong>, or an  empty value. </p><ul> <li>Value types will be zero-filled.</li> <li>Blob and string types will be zero-length.</li> <li>Array types will have length 1 and the element of the array will conform to the previous rules.</li> </ul><p>This method cannot be used to return the properties for any effect not visible to <strong>ID2D1DeviceContext::CreateEffect</strong>.</p>
            </remarks>
            <doc-id>hh404608</doc-id>
            <unmanaged>HRESULT ID2D1Factory1::GetEffectProperties([In] const GUID&amp; effectId,[Out] ID2D1Properties** properties)</unmanaged>
            <unmanaged-short>ID2D1Factory1::GetEffectProperties</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory2.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.Direct2D1.Factory2"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory2.#ctor(SharpDX.Direct2D1.FactoryType)">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.Direct2D1.Factory2"/> class with the specified <see cref="T:SharpDX.Direct2D1.FactoryType"/>.
            </summary>
            <param name="factoryType">The factory threading type.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory2.#ctor(SharpDX.Direct2D1.FactoryType,SharpDX.Direct2D1.DebugLevel)">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.Direct2D1.Factory2"/> class with the specified <see cref="T:SharpDX.Direct2D1.FactoryType"/> and <see cref="T:SharpDX.Direct2D1.DebugLevel"/>.
            </summary>
            <param name="factoryType">The factory threading type.</param>
            <param name="debugLevel">The factory debug level.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory2.CreateDevice(SharpDX.DXGI.Device,SharpDX.Direct2D1.Device1)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.Device1"/></strong> object.  </p>
            </summary>
            <param name = "dxgiDevice">No documentation.</param>
            <param name = "d2dDevice1">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The Direct2D device defines a resource domain in which a set of Direct2D objects and Direct2D device contexts can be used together.  Each call to <strong>CreateDevice</strong> returns a unique <strong><see cref = "T:SharpDX.Direct2D1.Device1"/></strong> object, even if you pass the same <strong><see cref = "T:SharpDX.DXGI.Device"/></strong> multiple times.</p>
            </remarks>
            <doc-id>dn280482</doc-id>
            <unmanaged>HRESULT ID2D1Factory2::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device1** d2dDevice1)</unmanaged>
            <unmanaged-short>ID2D1Factory2::CreateDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiInteropRenderTarget.ReleaseDC">
            <summary>	
            Indicates that drawing with the device context retrieved using the {{GetDC}} method is finished.  	
            </summary>	
            <remarks>	
            ReleaseDC must be called once for each call to {{GetDC}}. 	
            </remarks>	
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::ReleaseDC([In, Optional] const RECT* update)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiInteropRenderTarget.GetDC(SharpDX.Direct2D1.DeviceContextInitializeMode)">
            <summary>
            <p>Retrieves the device context associated with this render target. </p>
            </summary>
            <param name = "mode"><dd>  <p>A value that specifies whether the device context should be cleared.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the device context associated with this render target. You must allocate storage for this parameter.  </p> </dd></returns>
            <remarks>
            <p>Calling this method flushes the render target.</p><p>This command can be called only after <strong>BeginDraw</strong> and before <strong>EndDraw</strong>. </p><strong>Note</strong>??In Windows?7 and earlier, you should not call <strong>GetDC</strong> between <strong>PushAxisAlignedClip</strong>/<strong>PopAxisAlignedClip</strong> commands or between <strong>PushLayer</strong>/<strong>PopLayer</strong>.  However, this restriction does not apply to Windows?8 and later.?<p> <strong>ReleaseDC</strong> must be called once for each call to <strong>GetDC</strong>.</p>
            </remarks>
            <doc-id>dd371323</doc-id>
            <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::GetDC([In] D2D1_DC_INITIALIZE_MODE mode,[Out] HDC* hdc)</unmanaged>
            <unmanaged-short>ID2D1GdiInteropRenderTarget::GetDC</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiInteropRenderTarget.ReleaseDC(System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p>Indicates that drawing with the device context retrieved using the <strong>GetDC</strong> method is finished.  </p>
            </summary>
            <param name = "update">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>ReleaseDC</strong> must be called once for each call to <strong>GetDC</strong>.</p>
            </remarks>
            <doc-id>dd371327</doc-id>
            <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::ReleaseDC([In, Optional] const RECT* update)</unmanaged>
            <unmanaged-short>ID2D1GdiInteropRenderTarget::ReleaseDC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Geometry.DefaultFlatteningTolerance">
            <summary>
            Default flattening tolerance used for all methods that are not explicitly using it. Default is set to 0.25f.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Geometry.FlatteningTolerance">
            <summary>
            Get or set the default flattening tolerance used for all methods that are not explicitly using it. Default is set to 0.25f.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Combine(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.CombineMode,SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Combines this geometry with the specified geometry and stores the result in an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/>.  	
            </summary>	
            <param name="inputGeometry">The geometry to combine with this instance.</param>
            <param name="combineMode">The type of combine operation to perform.</param>
            <param name="geometrySink">The result of the combine operation.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT CombineWithGeometry([In] ID2D1Geometry* inputGeometry,[None] D2D1_COMBINE_MODE combineMode,[In, Optional] const D2D1_MATRIX_3X2_F* inputGeometryTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Combine(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.CombineMode,System.Single,SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Combines this geometry with the specified geometry and stores the result in an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/>.  	
            </summary>	
            <param name="inputGeometry">The geometry to combine with this instance.</param>
            <param name="combineMode">The type of combine operation to perform.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. </param>
            <param name="geometrySink">The result of the combine operation.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT CombineWithGeometry([In] ID2D1Geometry* inputGeometry,[None] D2D1_COMBINE_MODE combineMode,[In, Optional] const D2D1_MATRIX_3X2_F* inputGeometryTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Compare(SharpDX.Direct2D1.Geometry)">
            <summary>	
            Describes the intersection between this geometry and the specified geometry. The comparison is performed by using the specified flattening tolerance.	
            </summary>	
            <remarks>	
            When interpreting the returned relation value, it is important to remember that the member <see cref="F:SharpDX.Direct2D1.GeometryRelation.IsContained" /> of the  D2D1_GEOMETRY_RELATION enumeration type means that this geometry is contained  inside inputGeometry, not that this geometry contains inputGeometry.  For  more information about how to interpret other possible return values, see <see cref="T:SharpDX.Direct2D1.GeometryRelation" />. 	
            </remarks>	
            <param name="inputGeometry">The geometry to test.  </param>
            <returns>When this method returns, contains a reference to a value that describes how this geometry is related to inputGeometry. You must allocate storage for this parameter.   </returns>
            <unmanaged>HRESULT ID2D1Geometry::CompareWithGeometry([In] ID2D1Geometry* inputGeometry,[In, Optional] const D2D1_MATRIX_3X2_F* inputGeometryTransform,[None] float flatteningTolerance,[Out] D2D1_GEOMETRY_RELATION* relation)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Compare(SharpDX.Direct2D1.Geometry,System.Single)">
            <summary>	
            Describes the intersection between this geometry and the specified geometry. The comparison is performed by using the specified flattening tolerance.	
            </summary>	
            <remarks>	
            When interpreting the returned relation value, it is important to remember that the member <see cref="F:SharpDX.Direct2D1.GeometryRelation.IsContained" /> of the  D2D1_GEOMETRY_RELATION enumeration type means that this geometry is contained  inside inputGeometry, not that this geometry contains inputGeometry.  For  more information about how to interpret other possible return values, see <see cref="T:SharpDX.Direct2D1.GeometryRelation" />. 	
            </remarks>	
            <param name="inputGeometry">The geometry to test.  </param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains a reference to a value that describes how this geometry is related to inputGeometry. You must allocate storage for this parameter.   </returns>
            <unmanaged>HRESULT ID2D1Geometry::CompareWithGeometry([In] ID2D1Geometry* inputGeometry,[In, Optional] const D2D1_MATRIX_3X2_F* inputGeometryTransform,[None] float flatteningTolerance,[Out] D2D1_GEOMETRY_RELATION* relation)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputeArea">
            <summary>	
            Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <returns>When this this method returns, contains a reference to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::ComputeArea([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] float* area)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputeArea(System.Single)">
            <summary>	
            Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this this method returns, contains a reference to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::ComputeArea([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] float* area)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputeLength">
            <summary>	
            Calculates the length of the geometry as though each segment were unrolled into a line. 	
            </summary>	
            <returns>When this method returns, contains a reference to the length of the geometry. For closed geometries, the length includes an implicit closing segment. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::ComputeLength([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] float* length)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputeLength(System.Single)">
            <summary>	
            Calculates the length of the geometry as though each segment were unrolled into a line. 	
            </summary>	
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains a reference to the length of the geometry. For closed geometries, the length includes an implicit closing segment. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::ComputeLength([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] float* length)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputePointAtLength(System.Single,SharpDX.Mathematics.Interop.RawVector2@)">
            <summary>	
            Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <param name="length">The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry. </param>
            <param name="unitTangentVector">When this method returns, contains a reference to the tangent vector at the specified distance along the geometry. If the geometry is empty,  this vector contains NaN as its x and y values. You must allocate storage for this parameter. </param>
            <returns>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values. </returns>
            <unmanaged>HRESULT ID2D1Geometry::ComputePointAtLength([None] float length,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out, Optional] D2D1_POINT_2F* point,[Out, Optional] D2D1_POINT_2F* unitTangentVector)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputePointAtLength(System.Single,System.Single,SharpDX.Mathematics.Interop.RawVector2@)">
            <summary>	
            Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <param name="length">The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry. </param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
            <param name="unitTangentVector">When this method returns, contains a reference to the tangent vector at the specified distance along the geometry. If the geometry is empty,  this vector contains NaN as its x and y values. You must allocate storage for this parameter. </param>
            <returns>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values. </returns>
            <unmanaged>HRESULT ID2D1Geometry::ComputePointAtLength([None] float length,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out, Optional] D2D1_POINT_2F* point,[Out, Optional] D2D1_POINT_2F* unitTangentVector)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.FillContainsPoint(SharpDX.Mathematics.Interop.RawPoint)">
            <summary>	
            Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. 	
            </summary>	
            <param name="point">The point to test. </param>
            <returns>When this method returns, contains a bool value that is true if the area filled by the geometry contains point; otherwise, false.You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([None] D2D1_POINT_2F point,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.FillContainsPoint(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>	
            Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. 	
            </summary>	
            <param name="point">The point to test. </param>
            <returns>When this method returns, contains a bool value that is true if the area filled by the geometry contains point; otherwise, false.You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([None] D2D1_POINT_2F point,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.FillContainsPoint(SharpDX.Mathematics.Interop.RawPoint,System.Single)">
            <summary>	
            Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. 	
            </summary>	
            <param name="point">The point to test. </param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains a bool value that is true if the area filled by the geometry contains point; otherwise, false.You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([None] D2D1_POINT_2F point,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.FillContainsPoint(SharpDX.Mathematics.Interop.RawVector2,System.Single)">
            <summary>	
            Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. 	
            </summary>	
            <param name="point">The point to test. </param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains a bool value that is true if the area filled by the geometry contains point; otherwise, false.You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([None] D2D1_POINT_2F point,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.FillContainsPoint(SharpDX.Mathematics.Interop.RawPoint,SharpDX.Mathematics.Interop.RawMatrix3x2,System.Single)">
            <summary>	
            Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. 	
            </summary>	
            <param name="point">The point to test. </param>
            <param name="worldTransform">The transform to apply to the geometry prior to testing for containment, or NULL. </param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains a bool value that is true if the area filled by the geometry contains point; otherwise, false.You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([None] D2D1_POINT_2F point,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.GetBounds">
            <summary>	
            Retrieves the bounds of the geometry.	
            </summary>	
            <returns>When this method returns, contains the bounds of this geometry. If the bounds are empty, this will be a rect where bounds.left &gt; bounds.right. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::GetBounds([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[Out] D2D1_RECT_F* bounds)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.GetWidenedBounds(System.Single)">
            <summary>	
            Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.	
            </summary>	
            <param name="strokeWidth">The amount by which to widen the geometry by stroking its outline. </param>
            <returns>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] D2D1_RECT_F* bounds)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.GetWidenedBounds(System.Single,System.Single)">
            <summary>	
            Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.	
            </summary>	
            <param name="strokeWidth">The amount by which to widen the geometry by stroking its outline. </param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] D2D1_RECT_F* bounds)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.GetWidenedBounds(System.Single,SharpDX.Direct2D1.StrokeStyle,System.Single)">
            <summary>	
            Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.	
            </summary>	
            <param name="strokeWidth">The amount by which to widen the geometry by stroking its outline. </param>
            <param name="strokeStyle">The style of the stroke that widens the geometry. </param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.  </param>
            <returns>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] D2D1_RECT_F* bounds)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Outline(SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Computes the outline of the geometry and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/>.	
            </summary>	
            <remarks>	
            The {{Outline}} method allows the caller to produce a geometry with an equivalent fill to the input geometry, with the following additional properties: The output geometry contains no transverse intersections; that is, segments may touch, but they never cross.The outermost figures in the output geometry are all oriented counterclockwise. The output geometry is fill-mode invariant; that is, the fill of the geometry does not depend on the choice of the fill mode. For more information about the fill mode, see <see cref="T:SharpDX.Direct2D1.FillMode"/>.Additionally, the  {{Outline}} method can be useful in removing redundant portions of said geometries to simplify complex geometries. It can also be useful in combination with <see cref="T:SharpDX.Direct2D1.GeometryGroup"/> to create unions among several geometries simultaneously.	
            </remarks>	
            <param name="geometrySink">The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the geometry's transformed outline is appended. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Outline([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Outline(System.Single,SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Computes the outline of the geometry and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/>.	
            </summary>	
            <remarks>	
            The {{Outline}} method allows the caller to produce a geometry with an equivalent fill to the input geometry, with the following additional properties: The output geometry contains no transverse intersections; that is, segments may touch, but they never cross.The outermost figures in the output geometry are all oriented counterclockwise. The output geometry is fill-mode invariant; that is, the fill of the geometry does not depend on the choice of the fill mode. For more information about the fill mode, see <see cref="T:SharpDX.Direct2D1.FillMode"/>.Additionally, the  {{Outline}} method can be useful in removing redundant portions of said geometries to simplify complex geometries. It can also be useful in combination with <see cref="T:SharpDX.Direct2D1.GeometryGroup"/> to create unions among several geometries simultaneously.	
            </remarks>	
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
            <param name="geometrySink">The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the geometry's transformed outline is appended. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Outline([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Simplify(SharpDX.Direct2D1.GeometrySimplificationOption,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>	
            Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/>.	
            </summary>	
            <param name="simplificationOption">A value that specifies whether the simplified geometry should contain curves.</param>
            <param name="geometrySink"> The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the simplified geometry is appended. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Simplify([None] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Simplify(SharpDX.Direct2D1.GeometrySimplificationOption,System.Single,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>	
            Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/>.	
            </summary>	
            <param name="simplificationOption">A value that specifies whether the simplified geometry should contain curves.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
            <param name="geometrySink"> The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the simplified geometry is appended. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Simplify([None] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawPoint,System.Single)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawVector2,System.Single)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawPoint,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <param name="strokeStyle">The style of stroke to apply. </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawVector2,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <param name="strokeStyle">The style of stroke to apply. </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawPoint,System.Single,SharpDX.Direct2D1.StrokeStyle,SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <param name="strokeStyle">The style of stroke to apply. </param>
            <param name="transform">The transform to apply to the stroked geometry.  </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawVector2,System.Single,SharpDX.Direct2D1.StrokeStyle,SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <param name="strokeStyle">The style of stroke to apply. </param>
            <param name="transform">The transform to apply to the stroked geometry.  </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawPoint,System.Single,SharpDX.Direct2D1.StrokeStyle,SharpDX.Mathematics.Interop.RawMatrix3x2,System.Single)">
            <summary>	
            Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. 	
            </summary>	
            <param name="point">The point to test for containment. </param>
            <param name="strokeWidth">The thickness of the stroke to apply. </param>
            <param name="strokeStyle">The style of stroke to apply. </param>
            <param name="transform">The transform to apply to the stroked geometry.  </param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the stroke by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution. </param>
            <returns>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter. </returns>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([None] D2D1_POINT_2F point,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Tessellate(SharpDX.Direct2D1.TessellationSink)">
            <summary>	
            Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the specified tolerance	
            </summary>	
            <param name="tessellationSink">The <see cref="T:SharpDX.Direct2D1.TessellationSink" /> to which the tessellated is appended.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Tessellate([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1TessellationSink* tessellationSink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Tessellate(System.Single,SharpDX.Direct2D1.TessellationSink)">
            <summary>	
            Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the specified tolerance	
            </summary>	
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. </param>
            <param name="tessellationSink">The <see cref="T:SharpDX.Direct2D1.TessellationSink"/> to which the tessellated is appended.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Tessellate([In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1TessellationSink* tessellationSink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Widen(System.Single,SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Widens the geometry by the specified stroke and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <param name="strokeWidth">The amount by which to widen the geometry.</param>
            <param name="geometrySink">The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the widened geometry is appended.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Widen([None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Widen(System.Single,System.Single,SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Widens the geometry by the specified stroke and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <param name="strokeWidth">The amount by which to widen the geometry.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
            <param name="geometrySink">The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the widened geometry is appended.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Widen([None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Widen(System.Single,SharpDX.Direct2D1.StrokeStyle,System.Single,SharpDX.Direct2D1.GeometrySink)">
            <summary>	
            Widens the geometry by the specified stroke and writes the result to an <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> after it has been transformed by the specified matrix and flattened using the specified tolerance.	
            </summary>	
            <param name="strokeWidth">The amount by which to widen the geometry.</param>
            <param name="strokeStyle">The style of stroke to apply to the geometry, or NULL.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
            <param name="geometrySink">The <see cref="T:SharpDX.Direct2D1.SimplifiedGeometrySink"/> to which the widened geometry is appended.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Widen([None] FLOAT strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D1_MATRIX_3X2_F* worldTransform,[None] FLOAT flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.GetBounds(System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2})">
            <summary>
            Retrieves the bounds of the geometry.
            </summary>
            <param name = "worldTransform">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>dd742751</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::GetBounds([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[Out] D2D_RECT_F* bounds)</unmanaged>
            <unmanaged-short>ID2D1Geometry::GetBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.GetWidenedBounds(System.Single,SharpDX.Direct2D1.StrokeStyle,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single)">
            <summary>
            <p>Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.</p>
            </summary>
            <param name = "strokeWidth"><dd>  <p>The amount by which to widen the geometry by stroking its outline.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of the stroke that widens the geometry.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>A transform to apply to the geometry after the geometry is transformed and after the geometry has been stroked.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</p> </dd></returns>
            <doc-id>dd316714</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] D2D_RECT_F* bounds)</unmanaged>
            <unmanaged-short>ID2D1Geometry::GetWidenedBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.StrokeContainsPoint(SharpDX.Mathematics.Interop.RawVector2,System.Single,SharpDX.Direct2D1.StrokeStyle,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single)">
            <summary>
            <p>Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. </p>
            </summary>
            <param name = "point"><dd>  <p>The point to test for containment.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The thickness of the stroke to apply.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of stroke to apply.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The transform to apply to the stroked geometry. </p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the stroke by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter.</p> </dd></returns>
            <doc-id>dd316744</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([In] D2D_POINT_2F point,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
            <unmanaged-short>ID2D1Geometry::StrokeContainsPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.FillContainsPoint(SharpDX.Mathematics.Interop.RawVector2,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single)">
            <summary>
            <p>Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. </p>
            </summary>
            <param name = "point"><dd>  <p>The point to test.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The transform to apply to the geometry prior to testing for containment, or <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution. </p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a <strong><see cref = "T:SharpDX.Mathematics.Interop.RawBool"/></strong> value that is <strong>TRUE</strong> if the area filled by the geometry contains <em>point</em>; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.You must allocate storage for this parameter.</p> </dd></returns>
            <doc-id>dd316687</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([In] D2D_POINT_2F point,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
            <unmanaged-short>ID2D1Geometry::FillContainsPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Compare(SharpDX.Direct2D1.Geometry,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single)">
            <summary>
            <p>Describes the intersection between this geometry and the specified geometry. The comparison is performed by using the specified flattening tolerance.</p>
            </summary>
            <param name = "inputGeometry"><dd>  <p>The geometry to test. </p> </dd></param>
            <param name = "inputGeometryTransform"><dd>  <p>The transform to apply to <em>inputGeometry</em>, or <strong><c>null</c></strong>.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a reference to a value that describes how this geometry is related to <em>inputGeometry</em>. You must allocate storage for this parameter.  </p> </dd></returns>
            <remarks>
            <p>When interpreting the returned <em>relation</em> value, it is important to remember that the member <strong>D2D1_GEOMETRY_RELATION_IS_CONTAINED</strong> of the  <strong><see cref = "T:SharpDX.Direct2D1.GeometryRelation"/></strong> enumeration type means that this geometry is contained  inside <em>inputGeometry</em>, not that this geometry contains <em>inputGeometry</em>. </p><p>For  more information about how to interpret other possible return values, see <strong><see cref = "T:SharpDX.Direct2D1.GeometryRelation"/></strong>.</p>
            </remarks>
            <doc-id>dd316630</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::CompareWithGeometry([In] ID2D1Geometry* inputGeometry,[In, Optional] const D2D_MATRIX_3X2_F* inputGeometryTransform,[In] float flatteningTolerance,[Out] D2D1_GEOMETRY_RELATION* relation)</unmanaged>
            <unmanaged-short>ID2D1Geometry::CompareWithGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Simplify(SharpDX.Direct2D1.GeometrySimplificationOption,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            <p>Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>
            </summary>
            <param name = "simplificationOption">No documentation.</param>
            <param name = "worldTransform">No documentation.</param>
            <param name = "flatteningTolerance">No documentation.</param>
            <param name = "geometrySink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316730</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::Simplify([In] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>ID2D1Geometry::Simplify</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Tessellate(System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.TessellationSink)">
            <summary>
            <p>Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the default tolerance.</p>
            </summary>
            <param name = "worldTransform"><dd>  <p>The transform to apply to this geometry.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The <strong><see cref = "T:SharpDX.Direct2D1.TessellationSink"/></strong> to which the tessellated is appended.</p> </dd></param>
            <param name = "tessellationSink"><dd>  <p>The <strong><see cref = "T:SharpDX.Direct2D1.TessellationSink"/></strong> to which the tessellated is appended.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316762</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::Tessellate([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1TessellationSink* tessellationSink)</unmanaged>
            <unmanaged-short>ID2D1Geometry::Tessellate</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Combine(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.CombineMode,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            <p>Combines this geometry with the specified geometry and stores the result in an <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.  </p>
            </summary>
            <param name = "inputGeometry">No documentation.</param>
            <param name = "combineMode">No documentation.</param>
            <param name = "inputGeometryTransform">No documentation.</param>
            <param name = "flatteningTolerance">No documentation.</param>
            <param name = "geometrySink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316617</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::CombineWithGeometry([In] ID2D1Geometry* inputGeometry,[In] D2D1_COMBINE_MODE combineMode,[In, Optional] const D2D_MATRIX_3X2_F* inputGeometryTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>ID2D1Geometry::CombineWithGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Outline(System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            <p>Computes the outline of the geometry and writes the result to an <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>
            </summary>
            <param name = "worldTransform">No documentation.</param>
            <param name = "flatteningTolerance">No documentation.</param>
            <param name = "geometrySink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316722</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::Outline([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>ID2D1Geometry::Outline</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputeArea(System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single)">
            <summary>
            <p>Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>
            </summary>
            <param name = "worldTransform"><dd>  <p>The transform to apply to this geometry before computing its area.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution. </p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a reference to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter.</p> </dd></returns>
            <doc-id>dd316648</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::ComputeArea([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] float* area)</unmanaged>
            <unmanaged-short>ID2D1Geometry::ComputeArea</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputeLength(System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single)">
            <summary>
            Calculates the length of the geometry as though each segment were unrolled into a line.
            </summary>
            <param name = "worldTransform">No documentation.</param>
            <param name = "flatteningTolerance">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>dd742744</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::ComputeLength([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] float* length)</unmanaged>
            <unmanaged-short>ID2D1Geometry::ComputeLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.ComputePointAtLength(System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Mathematics.Interop.RawVector2@)">
            <summary>
            <p>Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the default tolerance.</p>
            </summary>
            <param name = "length"><dd>  <p>The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The transform to apply to the geometry before calculating the specified point and tangent.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values.</p> </dd></param>
            <param name = "unitTangentVector"><dd>  <p>When this method returns, contains a reference to the tangent vector at the specified distance along the geometry. If the geometry is empty,  this vector contains NaN as its x and y values. You must allocate storage for this parameter.</p> </dd></param>
            <returns><dd>  <p>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values.</p> </dd></returns>
            <doc-id>dd316686</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::ComputePointAtLength([In] float length,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out, Optional] D2D_POINT_2F* point,[Out, Optional] D2D_POINT_2F* unitTangentVector)</unmanaged>
            <unmanaged-short>ID2D1Geometry::ComputePointAtLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Geometry.Widen(System.Single,SharpDX.Direct2D1.StrokeStyle,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            <p>Widens the geometry by the specified stroke and writes the result to an <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>
            </summary>
            <param name = "strokeWidth">No documentation.</param>
            <param name = "strokeStyle">No documentation.</param>
            <param name = "worldTransform">No documentation.</param>
            <param name = "flatteningTolerance">No documentation.</param>
            <param name = "geometrySink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316766</doc-id>
            <unmanaged>HRESULT ID2D1Geometry::Widen([In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>ID2D1Geometry::Widen</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryGroup.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.FillMode,SharpDX.Direct2D1.Geometry[])">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.GeometryGroup"/>, which is an object that holds other geometries.	
            </summary>	
            <remarks>	
            Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <see cref="T:SharpDX.Direct2D1.GeometryGroup"/> object, call  the CreateGeometryGroup method on the <see cref="T:SharpDX.Direct2D1.Factory"/> object, passing in the fillMode with possible values of   <see cref="F:SharpDX.Direct2D1.FillMode.Alternate"/> (alternate) and D2D1_FILL_MODE_WINDING, an array of geometry objects to add to the geometry group, and the number of elements in this array. 	
            </remarks>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="fillMode">A value that specifies the rule that a composite shape uses to determine whether a given point is part of the geometry. </param>
            <param name="geometries">An array containing the geometry objects to add to the geometry group. The number of elements in this array is indicated by the geometriesCount parameter.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryGroup.GetSourceGeometry">
            <summary>	
            Retrieves the geometries in the geometry group. 	
            </summary>	
            <remarks>	
            The returned geometries are referenced and  counted, and the caller must release them. 	
            </remarks>	
            <returns>an array of geometries to be filled by this method. The length of the array is specified by the geometryCount parameter.</returns>
            <unmanaged>void ID2D1GeometryGroup::GetSourceGeometries([Out, Buffer] ID2D1Geometry** geometries,[None] int geometriesCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryGroup.GetSourceGeometry(System.Int32)">
            <summary>	
            Retrieves the geometries in the geometry group. 	
            </summary>	
            <remarks>	
            The returned geometries are referenced and  counted, and the caller must release them. 	
            </remarks>	
            <param name="geometriesCount">A value indicating the number of geometries to return in the geometries array. If this value is less than the number of geometries in the geometry group, the remaining geometries are omitted. If this value is larger than the number of geometries in the geometry group, the extra geometries are set to NULL. To obtain the number of geometries currently in the geometry group, use the {{GetSourceGeometryCount}} method. </param>
            <returns>an array of geometries to be filled by this method. The length of the array is specified by the geometryCount parameter.</returns>
            <unmanaged>void ID2D1GeometryGroup::GetSourceGeometries([Out, Buffer] ID2D1Geometry** geometries,[None] int geometriesCount)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.GeometryGroup.FillMode">
            <summary>
            <p>Indicates how the intersecting areas of the geometries contained in this geometry group are combined.</p>
            </summary>
            <doc-id>dd316583</doc-id>
            <unmanaged>GetFillMode</unmanaged>
            <unmanaged-short>GetFillMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GeometryGroup.SourceGeometryCount">
            <summary>
            <p>Indicates the number of geometry objects in the geometry group. </p>
            </summary>
            <doc-id>dd316589</doc-id>
            <unmanaged>GetSourceGeometryCount</unmanaged>
            <unmanaged-short>GetSourceGeometryCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryGroup.GetFillMode">
            <summary>
            <p>Indicates how the intersecting areas of the geometries contained in this geometry group are combined.</p>
            </summary>
            <returns><p> A value that indicates how the intersecting areas of the geometries contained in this geometry group are combined.  </p></returns>
            <doc-id>dd316583</doc-id>
            <unmanaged>D2D1_FILL_MODE ID2D1GeometryGroup::GetFillMode()</unmanaged>
            <unmanaged-short>ID2D1GeometryGroup::GetFillMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryGroup.GetSourceGeometryCount">
            <summary>
            <p>Indicates the number of geometry objects in the geometry group. </p>
            </summary>
            <returns><p>The number of geometries in the <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong>.</p></returns>
            <doc-id>dd316589</doc-id>
            <unmanaged>unsigned int ID2D1GeometryGroup::GetSourceGeometryCount()</unmanaged>
            <unmanaged-short>ID2D1GeometryGroup::GetSourceGeometryCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryGroup.GetSourceGeometries(SharpDX.Direct2D1.Geometry[],System.Int32)">
            <summary>
            <p>Retrieves the geometries in the geometry group. </p>
            </summary>
            <param name = "geometries"><dd>  <p>When this method returns, contains the address of a reference to an array of geometries to be filled by this method. The length of the array is specified by the <em>geometryCount</em> parameter. If the array is <strong><c>null</c></strong>, then this method performs no operation. You must allocate the memory for this array.</p> </dd></param>
            <param name = "geometriesCount"><dd>  <p>A value indicating the number of geometries to return in the <em>geometries</em> array. If this value is less than the number of geometries in the geometry group, the remaining geometries are omitted. If this value is larger than the number of geometries in the geometry group, the extra geometries are set to <strong><c>null</c></strong>. To obtain the number of geometries currently in the geometry group, use the <strong>GetSourceGeometryCount</strong> method.</p> </dd></param>
            <remarks>
            <p>The returned geometries are referenced and  counted, and the caller must release them.</p>
            </remarks>
            <doc-id>dd316586</doc-id>
            <unmanaged>void ID2D1GeometryGroup::GetSourceGeometries([Out, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount)</unmanaged>
            <unmanaged-short>ID2D1GeometryGroup::GetSourceGeometries</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GeometryRealization">
            <summary>	
            <p>Encapsulates a device- and transform-dependent representation of a filled or stroked geometry.  Callers should consider creating a geometry realization when they wish to accelerate repeated rendering of a given geometry. This interface exposes no methods.</p>	
            </summary>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1GeometryRealization']/*" />	
            <msdn-id>dn280515</msdn-id>	
            <unmanaged>ID2D1GeometryRealization</unmanaged>	
            <unmanaged-short>ID2D1GeometryRealization</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryRealization.#ctor(SharpDX.Direct2D1.DeviceContext1,SharpDX.Direct2D1.Geometry,System.Single)">
            <summary>	
            <p>Creates a device-dependent representation of the fill of the geometry that can be subsequently rendered.</p>	
            </summary>
            <param name="context">The device context where the created instance should be attached to.</param>
            <param name="geometry"><dd>  <p>The geometry to realize.</p> </dd></param>	
            <param name="flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>	
            <returns><p>The method returns an <strong><see cref="T:SharpDX.Result" /></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="T:SharpDX.Result" /></th><th>Description</th></tr> <tr><td><see cref="F:SharpDX.Result.Ok" /></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>This method is used in conjunction with <strong><see cref="M:SharpDX.Direct2D1.DeviceContext1.DrawGeometryRealization(SharpDX.Direct2D1.GeometryRealization,SharpDX.Direct2D1.Brush)" /></strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong><see cref="F:SharpDX.Direct2D1.StrokeTransformType.Normal" /></strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1DeviceContext1::CreateFilledGeometryRealization']/*" />	
            <msdn-id>dn280462</msdn-id>	
            <unmanaged>HRESULT ID2D1DeviceContext1::CreateFilledGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>	
            <unmanaged-short>ID2D1DeviceContext1::CreateFilledGeometryRealization</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.GeometryRealization.#ctor(SharpDX.Direct2D1.DeviceContext1,SharpDX.Direct2D1.Geometry,System.Single,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            <p>Creates a device-dependent representation of the stroke of a geometry that can be subsequently rendered.</p>	
            </summary>	
            <param name="context">The device context where the created instance should be attached to.</param>
            <param name="geometry"><dd>  <p>The geometry to realize.</p> </dd></param>	
            <param name="flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>	
            <param name="strokeWidth"><dd>  <p>The width of the stroke. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>	
            <param name="strokeStyle"><dd>  <p>The stroke style (optional).</p> </dd></param>	
            <returns><p>The method returns an <strong><see cref="T:SharpDX.Result" /></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref="T:SharpDX.Result" /></th><th>Description</th></tr> <tr><td><see cref="F:SharpDX.Result.Ok" /></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>	
            <remarks>	
            <p>This method is used in conjunction with <strong><see cref="M:SharpDX.Direct2D1.DeviceContext1.DrawGeometryRealization(SharpDX.Direct2D1.GeometryRealization,SharpDX.Direct2D1.Brush)" /></strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong><see cref="F:SharpDX.Direct2D1.StrokeTransformType.Normal" /></strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file=".\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1DeviceContext1::CreateStrokedGeometryRealization']/*" />	
            <msdn-id>dn280463</msdn-id>	
            <unmanaged>HRESULT ID2D1DeviceContext1::CreateStrokedGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>	
            <unmanaged-short>ID2D1DeviceContext1::CreateStrokedGeometryRealization</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySink.AddLine(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>	
            Creates a line segment between the current point and the specified end point and adds it to the geometry sink. 	
            </summary>	
            <param name="point">The end point of the line to draw.</param>
            <unmanaged>void AddLine([None] D2D1_POINT_2F point)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySink.AddBezier(SharpDX.Direct2D1.BezierSegment)">
            <summary>	
             Creates  a cubic Bezier curve between the current point and the specified endpoint.	
            </summary>	
            <param name="bezier">A structure that describes the control points and endpoint of the Bezier curve to add. </param>
            <unmanaged>void AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySink.AddQuadraticBezier(SharpDX.Direct2D1.QuadraticBezierSegment)">
            <summary>	
            Creates  a quadratic Bezier curve between the current point and the specified endpoint.	
            </summary>	
            <param name="bezier">A structure that describes the control point and the endpoint of the quadratic Bezier curve to add.</param>
            <unmanaged>void AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySink.AddQuadraticBeziers(SharpDX.Direct2D1.QuadraticBezierSegment[])">
            <summary>	
            Adds a sequence of quadratic Bezier segments as an array in a single call.	
            </summary>	
            <param name="beziers">An array of a sequence of quadratic Bezier segments.</param>
            <unmanaged>void AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[None] UINT beziersCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySink.AddArc(SharpDX.Direct2D1.ArcSegment)">
            <summary>	
            Adds a single arc to the path geometry.	
            </summary>	
            <param name="arc">The arc segment to add to the figure.</param>
            <unmanaged>void AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySinkNative.AddLine_(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            <p>Creates a line segment between the current point and the specified end point and adds it to the geometry sink. </p>
            </summary>
            <param name = "point"><dd>  <p>The end point of the line to draw.</p> </dd></param>
            <doc-id>dd316604</doc-id>
            <unmanaged>void ID2D1GeometrySink::AddLine([In] D2D_POINT_2F point)</unmanaged>
            <unmanaged-short>ID2D1GeometrySink::AddLine</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySinkNative.AddBezier_(SharpDX.Direct2D1.BezierSegment@)">
            <summary>
            Creates  a cubic Bezier curve between the current point and the specified end point and adds it to the geometry sink.
            </summary>
            <param name = "bezier">No documentation.</param>
            <doc-id>dd742735</doc-id>
            <unmanaged>void ID2D1GeometrySink::AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>
            <unmanaged-short>ID2D1GeometrySink::AddBezier</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySinkNative.AddQuadraticBezier_(SharpDX.Direct2D1.QuadraticBezierSegment)">
            <summary>
            <p>Creates  a quadratic Bezier curve between the current point and the specified end point.</p>
            </summary>
            <param name = "bezier"><dd>  <p>A structure that describes the control point and the end point of the quadratic Bezier curve to add.</p> </dd></param>
            <doc-id>dd316614</doc-id>
            <unmanaged>void ID2D1GeometrySink::AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>
            <unmanaged-short>ID2D1GeometrySink::AddQuadraticBezier</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySinkNative.AddQuadraticBeziers_(SharpDX.Direct2D1.QuadraticBezierSegment[],System.Int32)">
            <summary>
            <p>Adds a sequence of quadratic Bezier segments as an array in a single call.</p>
            </summary>
            <param name = "beziers"><dd>  <p>An array of a sequence of quadratic Bezier segments.</p> </dd></param>
            <param name = "beziersCount"><dd>  <p>A value indicating the number of quadratic Bezier segments in <em>beziers</em>. </p> </dd></param>
            <doc-id>dd316608</doc-id>
            <unmanaged>void ID2D1GeometrySink::AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>
            <unmanaged-short>ID2D1GeometrySink::AddQuadraticBeziers</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySinkNative.AddArc_(SharpDX.Direct2D1.ArcSegment@)">
            <summary>
            <p>Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves. </p>
            </summary>
            <param name = "arc">No documentation.</param>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.Direct2D1.GeometrySink"/></strong> interface extends the <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> interface to add support for arcs and quadratic beziers, as well as functions for adding single lines and cubic beziers.</p><p>A geometry sink consists of one or more figures. Each figure is made up of one or more line, curve, or arc segments. To create a figure, call the <strong>BeginFigure</strong> method, specify the figure's start point, and then use its Add methods (such as AddLine and AddBezier) to add segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method.</p>
            </remarks>
            <doc-id>dd316592</doc-id>
            <unmanaged>void ID2D1GeometrySink::AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>
            <unmanaged-short>ID2D1GeometrySink::AddArc</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GeometrySinkShadow">
            <summary>
            Internal GeometrySink Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.GeometrySinkShadow.ToIntPtr(SharpDX.Direct2D1.GeometrySink)">
            <summary>
            Get a native callback pointer from a managed callback.
            </summary>
            <param name="geometrySink">The geometry sink.</param>
            <returns>A pointer to the unmanaged geometry sink counterpart</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientMesh.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.Direct2D1.GradientMeshPatch[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.GradientMesh"/>.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientMesh.PatchCount">
            <summary>
            <p>Returns the number of patches that make up this gradient mesh.</p>
            </summary>
            <doc-id>dn900411</doc-id>
            <unmanaged>GetPatchCount</unmanaged>
            <unmanaged-short>GetPatchCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientMesh.GetPatchCount">
            <summary>
            <p>Returns the number of patches that make up this gradient mesh.</p>
            </summary>
            <returns><p>Returns the number of patches that make up this gradient mesh.</p></returns>
            <doc-id>dn900411</doc-id>
            <unmanaged>unsigned int ID2D1GradientMesh::GetPatchCount()</unmanaged>
            <unmanaged-short>ID2D1GradientMesh::GetPatchCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientMesh.GetPatches(System.Int32,SharpDX.Direct2D1.GradientMeshPatch[],System.Int32)">
            <summary>
            <p>Returns a subset of the patches that make up this gradient mesh.</p>
            </summary>
            <param name = "startIndex"><dd>  <p>Index of the first patch to return.</p> </dd></param>
            <param name = "atchesRef"><dd>  <p>A reference to the array to be filled with the patch data.</p> </dd></param>
            <param name = "patchesCount"><dd>  <p>The number of patches to be returned.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <doc-id>dn900412</doc-id>
            <unmanaged>HRESULT ID2D1GradientMesh::GetPatches([In] unsigned int startIndex,[Out, Buffer] D2D1_GRADIENT_MESH_PATCH* patches,[In] unsigned int patchesCount)</unmanaged>
            <unmanaged-short>ID2D1GradientMesh::GetPatches</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.GradientStop[])">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.GradientStopCollection"/> from the specified gradient stops, a Gamma StandardRgb, and ExtendMode.Clamp.  	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <unmanaged>HRESULT CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[None] UINT gradientStopsCount,[None] D2D1_GAMMA colorInterpolationGamma,[None] D2D1_EXTEND_MODE extendMode,[Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.GradientStop[],SharpDX.Direct2D1.ExtendMode)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.GradientStopCollection"/> from the specified gradient stops, color Gamma.StandardRgb, and extend mode.  	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <unmanaged>HRESULT CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[None] UINT gradientStopsCount,[None] D2D1_GAMMA colorInterpolationGamma,[None] D2D1_EXTEND_MODE extendMode,[Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.GradientStop[],SharpDX.Direct2D1.Gamma)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.GradientStopCollection"/> from the specified gradient stops, color interpolation gamma, and ExtendMode.Clamp.  	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <unmanaged>HRESULT CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[None] UINT gradientStopsCount,[None] D2D1_GAMMA colorInterpolationGamma,[None] D2D1_EXTEND_MODE extendMode,[Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.GradientStop[],SharpDX.Direct2D1.Gamma,SharpDX.Direct2D1.ExtendMode)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.GradientStopCollection"/> from the specified gradient stops, color interpolation gamma, and extend mode.  	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <unmanaged>HRESULT CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[None] UINT gradientStopsCount,[None] D2D1_GAMMA colorInterpolationGamma,[None] D2D1_EXTEND_MODE extendMode,[Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection.GradientStopCount">
            <summary>
            <p>Retrieves the number of gradient stops in the collection.</p>
            </summary>
            <doc-id>dd371454</doc-id>
            <unmanaged>GetGradientStopCount</unmanaged>
            <unmanaged-short>GetGradientStopCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection.ColorInterpolationGamma">
            <summary>
            <p>Indicates the gamma space in which the gradient stops are interpolated. </p>
            </summary>
            <doc-id>dd316786</doc-id>
            <unmanaged>GetColorInterpolationGamma</unmanaged>
            <unmanaged-short>GetColorInterpolationGamma</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection.ExtendMode">
            <summary>
            <p>Indicates the behavior of the gradient outside the normalized gradient range. </p>
            </summary>
            <doc-id>dd316789</doc-id>
            <unmanaged>GetExtendMode</unmanaged>
            <unmanaged-short>GetExtendMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.GetGradientStopCount">
            <summary>
            <p>Retrieves the number of gradient stops in the collection.</p>
            </summary>
            <returns><p>The number of gradient stops in the collection.</p></returns>
            <doc-id>dd371454</doc-id>
            <unmanaged>unsigned int ID2D1GradientStopCollection::GetGradientStopCount()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection::GetGradientStopCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.GetGradientStops(SharpDX.Direct2D1.GradientStop[],System.Int32)">
            <summary>
            <p>Copies the gradient stops from the collection into an array of <strong><see cref = "T:SharpDX.Direct2D1.GradientStop"/></strong> structures.</p>
            </summary>
            <param name = "gradientStops">No documentation.</param>
            <param name = "gradientStopsCount">No documentation.</param>
            <remarks>
            <p>Gradient stops are copied in order of position, starting with the gradient stop with the smallest position value and progressing to the gradient stop with the largest position value.</p>
            </remarks>
            <doc-id>dd371457</doc-id>
            <unmanaged>void ID2D1GradientStopCollection::GetGradientStops([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount)</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection::GetGradientStops</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.GetColorInterpolationGamma">
            <summary>
            <p>Indicates the gamma space in which the gradient stops are interpolated. </p>
            </summary>
            <returns><p>The gamma space in which the gradient stops are interpolated. </p></returns>
            <doc-id>dd316786</doc-id>
            <unmanaged>D2D1_GAMMA ID2D1GradientStopCollection::GetColorInterpolationGamma()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection::GetColorInterpolationGamma</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection.GetExtendMode">
            <summary>
            <p>Indicates the behavior of the gradient outside the normalized gradient range. </p>
            </summary>
            <returns><p>The behavior of the gradient outside the [0,1] normalized gradient range.</p></returns>
            <doc-id>dd316789</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1GradientStopCollection::GetExtendMode()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection::GetExtendMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection1.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.GradientStop[],SharpDX.Direct2D1.ColorSpace,SharpDX.Direct2D1.ColorSpace,SharpDX.Direct2D1.BufferPrecision,SharpDX.Direct2D1.ExtendMode,SharpDX.Direct2D1.ColorInterpolationMode)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.GradientStopCollection1"/> class.
            </summary>
            <param name="context">The context.</param>
            <param name="straightAlphaGradientStops">An array of color values and offsets.</param>
            <param name="preInterpolationSpace">Specifies both the input color space and the space in which the color interpolation occurs.</param>
            <param name="postInterpolationSpace">The color space that colors will be converted to after interpolation occurs.</param>
            <param name="bufferPrecision">The precision of the texture used to hold interpolated values.</param>
            <param name="extendMode">Defines how colors outside of the range defined by the stop collection are determined.</param>
            <param name="colorInterpolationMode">The new gradient stop collection.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* straightAlphaGradientStops,[In] unsigned int straightAlphaGradientStopsCount,[In] D2D1_COLOR_SPACE preInterpolationSpace,[In] D2D1_COLOR_SPACE postInterpolationSpace,[In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_EXTEND_MODE extendMode,[In] D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,[Out, Fast] ID2D1GradientStopCollection1** gradientStopCollection1)</unmanaged>
            <remarks>
            This method linearly interpolates between the color stops. An optional color space conversion is applied after interpolation. Whether and how this gamma conversion is applied is determined before and after interpolation. This method will fail if the device context does not support the requested buffer precision.Additional ReferencesD2D1_GRADIENT_STOP, D2D1_GAMMA_CONVERSION, <see cref="T:SharpDX.Direct2D1.BufferPrecision"/>, <see cref="T:SharpDX.Direct2D1.ExtendMode"/>, <see cref="T:SharpDX.Direct2D1.GradientStopCollection"/>RequirementsMinimum supported operating systemSame as Interface / Class Highest IRQL levelN/A (user mode) Callable from DlllMain()No Callable from services and session 0Yes Callable from UI threadYes?
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection1.PreInterpolationSpace">
            <summary>
            <p>Gets the color space of the input colors as well as the space in which gradient stops are interpolated.</p>
            </summary>
            <remarks>
            <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method  returns the color space related to the color interpolation gamma. </p>
            </remarks>
            <doc-id>hh446802</doc-id>
            <unmanaged>GetPreInterpolationSpace</unmanaged>
            <unmanaged-short>GetPreInterpolationSpace</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection1.PostInterpolationSpace">
            <summary>
            <p>Gets the color space after interpolation has occurred.</p>
            </summary>
            <remarks>
            <p>If you create using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns <strong>D2D1_COLOR_SPACE_SRGB</strong>. </p>
            </remarks>
            <doc-id>hh446800</doc-id>
            <unmanaged>GetPostInterpolationSpace</unmanaged>
            <unmanaged-short>GetPostInterpolationSpace</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection1.BufferPrecision">
            <summary>
            <p>Gets the precision of the gradient buffer.</p>
            </summary>
            <remarks>
            <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns D2D1_BUFFER_PRECISION_8BPC_UNORM. </p>
            </remarks>
            <doc-id>hh446796</doc-id>
            <unmanaged>GetBufferPrecision</unmanaged>
            <unmanaged-short>GetBufferPrecision</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GradientStopCollection1.ColorInterpolationMode">
            <summary>
            <p>Retrieves the color interpolation mode that the gradient stop collection uses.</p>
            </summary>
            <doc-id>hh871465</doc-id>
            <unmanaged>GetColorInterpolationMode</unmanaged>
            <unmanaged-short>GetColorInterpolationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection1.GetGradientStops1(SharpDX.Direct2D1.GradientStop[],System.Int32)">
            <summary>
            <p>Copies the gradient stops from the collection into memory.</p>
            </summary>
            <param name = "gradientStops"><dd>  <p>When this method returns, contains a reference to a one-dimensional array of <strong><see cref = "T:SharpDX.Direct2D1.GradientStop"/></strong> structures.</p> </dd></param>
            <param name = "gradientStopsCount"><dd>  <p>The number of gradient stops to copy. </p> </dd></param>
            <remarks>
            <p>If the <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection1"/></strong> object was created using <strong>ID2D1DeviceContext::CreateGradientStopCollection</strong>, this method returns the same values specified in the creation method. If the <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection1"/></strong> object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, the stops returned here will first be transformed into the gamma space specified by the <em>colorInterpolationGamma</em> parameter. See the <strong>ID2D1DeviceContext::CreateGradientStopCollection</strong> method for more info about color space and gamma space.</p><p>If <em>gradientStopsCount</em> is less than the number of gradient stops in the collection, the remaining gradient stops are omitted. If <em>gradientStopsCount</em> is larger than the number of gradient stops in the collection, the extra gradient stops are set to <strong><c>null</c></strong>. To obtain the number of gradient stops in the collection, use the <strong>GetGradientStopCount</strong> method.</p>
            </remarks>
            <doc-id>hh446798</doc-id>
            <unmanaged>void ID2D1GradientStopCollection1::GetGradientStops1([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount)</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection1::GetGradientStops1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection1.GetPreInterpolationSpace">
            <summary>
            <p>Gets the color space of the input colors as well as the space in which gradient stops are interpolated.</p>
            </summary>
            <returns><p>This method returns the color space.</p></returns>
            <remarks>
            <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method  returns the color space related to the color interpolation gamma. </p>
            </remarks>
            <doc-id>hh446802</doc-id>
            <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPreInterpolationSpace()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection1::GetPreInterpolationSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection1.GetPostInterpolationSpace">
            <summary>
            <p>Gets the color space after interpolation has occurred.</p>
            </summary>
            <returns><p>This method returns the color space.</p></returns>
            <remarks>
            <p>If you create using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns <strong>D2D1_COLOR_SPACE_SRGB</strong>. </p>
            </remarks>
            <doc-id>hh446800</doc-id>
            <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPostInterpolationSpace()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection1::GetPostInterpolationSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection1.GetBufferPrecision">
            <summary>
            <p>Gets the precision of the gradient buffer.</p>
            </summary>
            <returns><p>The buffer precision of the gradient buffer.</p></returns>
            <remarks>
            <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns D2D1_BUFFER_PRECISION_8BPC_UNORM. </p>
            </remarks>
            <doc-id>hh446796</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION ID2D1GradientStopCollection1::GetBufferPrecision()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection1::GetBufferPrecision</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GradientStopCollection1.GetColorInterpolationMode">
            <summary>
            <p>Retrieves the color interpolation mode that the gradient stop collection uses.</p>
            </summary>
            <returns><p>The color interpolation mode.</p></returns>
            <doc-id>hh871465</doc-id>
            <unmanaged>D2D1_COLOR_INTERPOLATION_MODE ID2D1GradientStopCollection1::GetColorInterpolationMode()</unmanaged>
            <unmanaged-short>ID2D1GradientStopCollection1::GetColorInterpolationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.Image,SharpDX.Direct2D1.ImageBrushProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.ImageBrush"/> class.
            </summary>
            <param name="context">The context.</param>
            <param name="image">The image.</param>
            <param name="imageBrushProperties">The image brush properties.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateImageBrush([In] ID2D1Image* image,[In] const D2D1_IMAGE_BRUSH_PROPERTIES* imageBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1ImageBrush** imageBrush)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.#ctor(SharpDX.Direct2D1.DeviceContext,SharpDX.Direct2D1.Image,SharpDX.Direct2D1.ImageBrushProperties,SharpDX.Direct2D1.BrushProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.ImageBrush"/> class.
            </summary>
            <param name="context">The context.</param>
            <param name="image">The image.</param>
            <param name="imageBrushProperties">The image brush properties.</param>
            <param name="brushProperties">The brush properties.</param>
            <unmanaged>HRESULT ID2D1DeviceContext::CreateImageBrush([In] ID2D1Image* image,[In] const D2D1_IMAGE_BRUSH_PROPERTIES* imageBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1ImageBrush** imageBrush)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.ImageBrush.Image">
            <summary>
            <p>Gets or sets the image associated with the image brush.</p>
            </summary>
            <doc-id>hh446807</doc-id>
            <unmanaged>GetImage / SetImage</unmanaged>
            <unmanaged-short>GetImage</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ImageBrush.ExtendModeX">
            <summary>
            <p>Gets or sets the extend mode of the image brush on the x-axis.</p>
            </summary>
            <doc-id>hh446805</doc-id>
            <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>
            <unmanaged-short>GetExtendModeX</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ImageBrush.ExtendModeY">
            <summary>
            <p>Gets or sets the extend mode of the image brush on the y-axis of the image.</p>
            </summary>
            <doc-id>hh446806</doc-id>
            <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>
            <unmanaged-short>GetExtendModeY</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ImageBrush.InterpolationMode">
            <summary>
            <p>Gets or sets the interpolation mode of the image brush.</p>
            </summary>
            <doc-id>hh446808</doc-id>
            <unmanaged>GetInterpolationMode / SetInterpolationMode</unmanaged>
            <unmanaged-short>GetInterpolationMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ImageBrush.SourceRectangle">
            <summary>
            <p>Gets or sets the rectangle that will be used as the bounds of the image when drawn as an image brush.</p>
            </summary>
            <doc-id>hh446809</doc-id>
            <unmanaged>GetSourceRectangle / SetSourceRectangle</unmanaged>
            <unmanaged-short>GetSourceRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.SetImage(SharpDX.Direct2D1.Image)">
            <summary>
            <p>Sets the image associated with the provided image brush.</p>
            </summary>
            <param name = "image"><dd>  <p>The image to be associated with the image brush.</p> </dd></param>
            <doc-id>hh446812</doc-id>
            <unmanaged>void ID2D1ImageBrush::SetImage([In, Optional] ID2D1Image* image)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::SetImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.SetExtendModeX(SharpDX.Direct2D1.ExtendMode)">
            <summary>
            <p>Sets how the content inside the source rectangle in the image brush will be extended on the x-axis.</p>
            </summary>
            <param name = "extendModeX"><dd>  <p>The extend mode on the x-axis of the image.</p> </dd></param>
            <doc-id>hh446810</doc-id>
            <unmanaged>void ID2D1ImageBrush::SetExtendModeX([In] D2D1_EXTEND_MODE extendModeX)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::SetExtendModeX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.SetExtendModeY(SharpDX.Direct2D1.ExtendMode)">
            <summary>
            <p>Sets the extend mode on the y-axis.</p>
            </summary>
            <param name = "extendModeY"><dd>  <p>The extend mode on the y-axis of the image.</p> </dd></param>
            <doc-id>hh446811</doc-id>
            <unmanaged>void ID2D1ImageBrush::SetExtendModeY([In] D2D1_EXTEND_MODE extendModeY)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::SetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.SetInterpolationMode(SharpDX.Direct2D1.InterpolationMode)">
            <summary>
            <p>Sets the interpolation mode for the image brush.</p>
            </summary>
            <param name = "interpolationMode"><dd>  <p>How the contents of the image will be interpolated to handle the brush transform.</p> </dd></param>
            <doc-id>hh446813</doc-id>
            <unmanaged>void ID2D1ImageBrush::SetInterpolationMode([In] D2D1_INTERPOLATION_MODE interpolationMode)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::SetInterpolationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.SetSourceRectangle(SharpDX.Mathematics.Interop.RawRectangleF)">
            <summary>
            <p>Sets the source rectangle in the image brush.</p>
            </summary>
            <param name = "sourceRectangle"><dd>  <p>The source rectangle that defines the portion of the image to tile.</p> </dd></param>
            <remarks>
            <p>The top left corner of the <em>sourceRectangle</em> parameter maps to the brush space origin. That is, if the  brush and world transforms are both identity, the portion of the image in the top left corner of the source rectangle will be rendered at (0,0) in the render target.</p><p>The source rectangle will be expanded differently depending on whether the input image is based on   pixels (a bitmap or effect) or by a command list. </p><ul> <li>If the input image is a bitmap or an effect, the rectangle will be expanded to encapsulate a full input pixel before being additionally down-scaled to ensure that the projected rectangle will be correct in the final scene-space.</li> <li>If the input image is a command list, the command list will be slightly expanded to encapsulate a full input pixel.
            </li> </ul>
            </remarks>
            <doc-id>hh446815</doc-id>
            <unmanaged>void ID2D1ImageBrush::SetSourceRectangle([In] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::SetSourceRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.GetImage(SharpDX.Direct2D1.Image@)">
            <summary>
            <p>Gets the image associated with the image brush.</p>
            </summary>
            <param name = "image"><dd>  <p> When this method returns, contains the address of a reference to the image associated with  this brush. </p> </dd></param>
            <doc-id>hh446807</doc-id>
            <unmanaged>void ID2D1ImageBrush::GetImage([Out, Optional] ID2D1Image** image)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::GetImage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.GetExtendModeX">
            <summary>
            <p>Gets the extend mode of the image brush on the x-axis.</p>
            </summary>
            <returns><p>This method returns the x-extend mode.</p></returns>
            <doc-id>hh446805</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeX()</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::GetExtendModeX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.GetExtendModeY">
            <summary>
            <p>Gets the extend mode of the image brush on the y-axis of the image.</p>
            </summary>
            <returns><p>This method returns the  y-extend mode.</p></returns>
            <doc-id>hh446806</doc-id>
            <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeY()</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::GetExtendModeY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.GetInterpolationMode">
            <summary>
            <p>Gets the interpolation mode of the image brush.</p>
            </summary>
            <returns><p>This method returns the  interpolation mode.</p></returns>
            <doc-id>hh446808</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE ID2D1ImageBrush::GetInterpolationMode()</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::GetInterpolationMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageBrush.GetSourceRectangle(SharpDX.Mathematics.Interop.RawRectangleF@)">
            <summary>
            <p>Gets the rectangle that will be used as the bounds of the image when drawn as an image brush.</p>
            </summary>
            <param name = "sourceRectangle"><dd>  <p>When this method returns, contains the address of the output source rectangle.</p> </dd></param>
            <doc-id>hh446809</doc-id>
            <unmanaged>void ID2D1ImageBrush::GetSourceRectangle([Out] D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1ImageBrush::GetSourceRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSource.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.DXGI.Surface[],System.Int32,SharpDX.DXGI.ColorSpaceType,SharpDX.Direct2D1.ImageSourceFromDxgiOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.ImageSource"/>.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSource.OfferResources">
            <summary>
            <p>Allows the operating system to free the video memory of resources by discarding their content.</p>
            </summary>
            <returns><p><strong>OfferResources</strong> returns: </p><ul> <li><strong><see cref = "F:SharpDX.Result.Ok"/></strong> if resources were successfully offered </li> <li><strong>E_INVALIDARG</strong> if a resource in the array or the priority is invalid </li> </ul></returns>
            <doc-id>mt591933</doc-id>
            <unmanaged>HRESULT ID2D1ImageSource::OfferResources()</unmanaged>
            <unmanaged-short>ID2D1ImageSource::OfferResources</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSource.TryReclaimResources(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> Restores access to resources that were previously offered by calling <strong>OfferResources</strong>. </p>
            </summary>
            <param name = "resourcesDiscarded">No documentation.</param>
            <returns><p><strong>ReclaimResources</strong> returns: </p><ul> <li><strong><see cref = "F:SharpDX.Result.Ok"/></strong> if resources were successfully reclaimed </li> <li><strong>E_INVALIDARG</strong> if the resources are invalid </li> </ul></returns>
            <remarks>
            <p> After you call <strong>OfferResources</strong> to offer one or more resources, 
            you must call <strong>TryReclaimResources</strong> before you can use those resources again. 
            You must check the value in the <strong>resourcesDiscarded</strong> to determine whether the resource?s content was discarded. 
            If a resource?s content was discarded while it was offered, its current content is undefined. Therefore, you must overwrite the resource?s content before you use the resource. </p>
            </remarks>
            <doc-id>dn952190</doc-id>
            <unmanaged>HRESULT ID2D1ImageSource::TryReclaimResources([Out] BOOL* resourcesDiscarded)</unmanaged>
            <unmanaged-short>ID2D1ImageSource::TryReclaimResources</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSourceFromWic.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.WIC.BitmapSource,SharpDX.Direct2D1.ImageSourceLoadingOptions,SharpDX.Direct2D1.AlphaMode)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.ImageSourceFromWic"/>.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.ImageSourceFromWic.Source">
            <summary>
            <p>Retrieves the underlying bitmap image source from the Windows Imaging Component (WIC).</p>
            </summary>
            <doc-id>dn900422</doc-id>
            <unmanaged>GetSource</unmanaged>
            <unmanaged-short>GetSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSourceFromWic.EnsureCached(System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p> Ensures that a specified region of the image source cache is populated. This method can be used to minimize glitches by performing expensive work to populate caches outside of a rendering loop. This method can also be used to speculatively load image data before it is needed by drawing routines. </p>
            </summary>
            <param name = "rectangleToFill"><dd>  <p>Specifies the region of the image, in pixels, that should be populated in the cache. By default, this is the entire extent of the image.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This API loads image data into caches of image sources, if that data was not already cached.  It does not trim pre-existing caches, if any.   More areas within the cache can be populated than actually requested.</p><p> ? </p><p>The provided region must be constructed to include the scale with which the image source will subsequently be drawn.   These coordinates must be provided in local coordinates.   This means that they must be adjusted prior to calling the API according to the DPI and other relevant transforms, which can include the world transform and brush transforms.</p><p>This operation is only supported when the image source has been initialized using the D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND option.</p>
            </remarks>
            <doc-id>dn900420</doc-id>
            <unmanaged>HRESULT ID2D1ImageSourceFromWic::EnsureCached([In, Optional] const D2D_RECT_U* rectangleToFill)</unmanaged>
            <unmanaged-short>ID2D1ImageSourceFromWic::EnsureCached</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSourceFromWic.TrimCache(System.Nullable{SharpDX.Mathematics.Interop.RawRectangle})">
            <summary>
            <p>This method trims the populated regions of the image source cache to just the specified rectangle.</p>
            </summary>
            <param name = "rectangleToPreserve"><dd>  <p>Specifies the region of the image, in pixels, which should be preserved in the image source cache.  Regions which are outside of the rectangle are evicted from the cache. By default, this is an empty rectangle,  meaning that the entire image is evicted from the cache.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The provided region must be constructed to include the scale at which the image source will be drawn at.  These coordinates must be provided in local coordinates.   This means that they must be adjusted prior to calling the API according to the DPI and other relevant transforms, which can include the world transform and brush transforms.</p><p> ? </p><p>This method will fail if on-demand caching was not requested when the image source was created.</p><p> ? </p><p>As with <strong>ID2D1Device::ClearResources</strong>, the caller can need to subsequently issue a D3D flush before memory usage is reduced.</p><p>This operation is only supported when the image source has been initialized using the D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND option.</p>
            </remarks>
            <doc-id>dn900424</doc-id>
            <unmanaged>HRESULT ID2D1ImageSourceFromWic::TrimCache([In, Optional] const D2D_RECT_U* rectangleToPreserve)</unmanaged>
            <unmanaged-short>ID2D1ImageSourceFromWic::TrimCache</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ImageSourceFromWic.GetSource(SharpDX.WIC.BitmapSource@)">
            <summary>
            <p>Retrieves the underlying bitmap image source from the Windows Imaging Component (WIC).</p>
            </summary>
            <param name = "wicBitmapSource"><dd>  <p>On return contains the bitmap image source.</p> </dd></param>
            <doc-id>dn900422</doc-id>
            <unmanaged>void ID2D1ImageSourceFromWic::GetSource([Out, Optional] IWICBitmapSource** wicBitmapSource)</unmanaged>
            <unmanaged-short>ID2D1ImageSourceFromWic::GetSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.Direct2D1.InkPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.Ink"/>.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.Ink.StartPoint">
            <summary>
            <p>Retrieves or sets the starting point for this ink object.</p>
            </summary>
            <doc-id>dn900438</doc-id>
            <unmanaged>GetStartPoint / SetStartPoint</unmanaged>
            <unmanaged-short>GetStartPoint</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Ink.SegmentAtEnd">
            <summary>
            <p>Updates the last segment in this ink object with new control points.</p>
            </summary>
            <doc-id>dn900440</doc-id>
            <unmanaged>SetSegmentAtEnd</unmanaged>
            <unmanaged-short>SetSegmentAtEnd</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Ink.SegmentCount">
            <summary>
            <p>Returns the number of segments in this ink object.</p>
            </summary>
            <doc-id>dn900436</doc-id>
            <unmanaged>GetSegmentCount</unmanaged>
            <unmanaged-short>GetSegmentCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.SetStartPoint(SharpDX.Direct2D1.InkPoint)">
            <summary>
            <p>Sets the starting point for this ink object. This determines where this ink object will start rendering.</p>
            </summary>
            <param name = "startPoint"><dd>  <p>The new starting point for this ink object.</p> </dd></param>
            <doc-id>dn900445</doc-id>
            <unmanaged>void ID2D1Ink::SetStartPoint([In] const D2D1_INK_POINT* startPoint)</unmanaged>
            <unmanaged-short>ID2D1Ink::SetStartPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.GetStartPoint">
            <summary>
            <p>Retrieves the starting point for this ink object.</p>
            </summary>
            <returns><p>The starting point for this ink object.</p></returns>
            <doc-id>dn900438</doc-id>
            <unmanaged>D2D1_INK_POINT ID2D1Ink::GetStartPoint()</unmanaged>
            <unmanaged-short>ID2D1Ink::GetStartPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.AddSegments(SharpDX.Direct2D1.InkBezierSegment[],System.Int32)">
            <summary>
            <p>Adds the given segments to the end of this ink object.</p>
            </summary>
            <param name = "segments"><dd>  <p>A reference to an array of segments to be added to this ink object.</p> </dd></param>
            <param name = "segmentsCount"><dd>  <p>The number of segments to be added to this ink object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900434</doc-id>
            <unmanaged>HRESULT ID2D1Ink::AddSegments([In, Buffer] const D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>
            <unmanaged-short>ID2D1Ink::AddSegments</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.RemoveSegmentsAtEnd(System.Int32)">
            <summary>
            <p>Removes the given number of segments from the end of this ink object.</p>
            </summary>
            <param name = "segmentsCount"><dd>  <p>The number of segments to be removed from the end of this ink object. Note that segmentsCount must be less or equal to the number of segments in the ink object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900439</doc-id>
            <unmanaged>HRESULT ID2D1Ink::RemoveSegmentsAtEnd([In] unsigned int segmentsCount)</unmanaged>
            <unmanaged-short>ID2D1Ink::RemoveSegmentsAtEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.SetSegments(System.Int32,SharpDX.Direct2D1.InkBezierSegment[],System.Int32)">
            <summary>
            <p>Updates the specified segments in this ink object with new control points.</p>
            </summary>
            <param name = "startSegment"><dd>  <p>The index of the first segment in this ink object to update.</p> </dd></param>
            <param name = "segments"><dd>  <p>A reference to the array of segment data to be used in the update.</p> </dd></param>
            <param name = "segmentsCount"><dd>  <p>The number of segments in this ink object that will be updated with new data. Note that segmentsCount must be less than or equal to the number of segments in the ink object minus startSegment.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900443</doc-id>
            <unmanaged>HRESULT ID2D1Ink::SetSegments([In] unsigned int startSegment,[In, Buffer] const D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>
            <unmanaged-short>ID2D1Ink::SetSegments</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.SetSegmentAtEnd(SharpDX.Direct2D1.InkBezierSegment@)">
            <summary>
            <p>Updates the last segment in this ink object with new control points.</p>
            </summary>
            <param name = "segment"><dd>  <p>A reference to the segment data with which to overwrite this ink object's last segment. Note that if there are currently no segments in the ink object, SetSegmentsAtEnd will return an error.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900440</doc-id>
            <unmanaged>HRESULT ID2D1Ink::SetSegmentAtEnd([In] const D2D1_INK_BEZIER_SEGMENT* segment)</unmanaged>
            <unmanaged-short>ID2D1Ink::SetSegmentAtEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.GetSegmentCount">
            <summary>
            <p>Returns the number of segments in this ink object.</p>
            </summary>
            <returns><p>Returns the number of segments in this ink object.</p></returns>
            <doc-id>dn900436</doc-id>
            <unmanaged>unsigned int ID2D1Ink::GetSegmentCount()</unmanaged>
            <unmanaged-short>ID2D1Ink::GetSegmentCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.GetSegments(System.Int32,SharpDX.Direct2D1.InkBezierSegment[],System.Int32)">
            <summary>
            <p>Retrieves the specified subset of segments stored in this ink object.</p>
            </summary>
            <param name = "startSegment"><dd>  <p>The index of the first segment in this ink object to retrieve.</p> </dd></param>
            <param name = "segments"><dd>  <p>When this method returns, contains a reference to an array of retrieved segments.</p> </dd></param>
            <param name = "segmentsCount"><dd>  <p>The number of segments to retrieve. Note that segmentsCount must be less than or equal to the number of segments in the ink object minus startSegment.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900437</doc-id>
            <unmanaged>HRESULT ID2D1Ink::GetSegments([In] unsigned int startSegment,[Out, Buffer] D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>
            <unmanaged-short>ID2D1Ink::GetSegments</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.StreamAsGeometry(SharpDX.Direct2D1.InkStyle,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            <p>Retrieves a geometric representation of this ink object.</p>
            </summary>
            <param name = "inkStyle"><dd>  <p>The ink style to be used in determining the geometric representation.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The world transform to be used in determining the geometric representation.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to be used in determining the geometric representation.</p> </dd></param>
            <param name = "geometrySink"><dd>  <p>The geometry sink to which the geometry representation will be streamed.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900449</doc-id>
            <unmanaged>HRESULT ID2D1Ink::StreamAsGeometry([In, Optional] ID2D1InkStyle* inkStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>ID2D1Ink::StreamAsGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Ink.GetBounds(SharpDX.Direct2D1.InkStyle,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawRectangleF@)">
            <summary>
            <p>Retrieve the bounds of the geometry, with an optional applied transform.</p>
            </summary>
            <param name = "inkStyle"><dd>  <p>The ink style to be used in determining the bounds of this ink object.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The world transform to be used in determining the bounds of this ink object.</p> </dd></param>
            <param name = "bounds"><dd>  <p>When this method returns, contains the bounds of this ink object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900435</doc-id>
            <unmanaged>HRESULT ID2D1Ink::GetBounds([In, Optional] ID2D1InkStyle* inkStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[Out] D2D_RECT_F* bounds)</unmanaged>
            <unmanaged-short>ID2D1Ink::GetBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.InkStyle.#ctor(SharpDX.Direct2D1.DeviceContext2)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.InkStyle"/>.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.InkStyle.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.Direct2D1.InkStyleProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.InkStyle"/>.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.InkStyle.NibTransform">
            <summary>
            <p>Retrieves or sets the transform to be applied to this style's nib shape.</p>
            </summary>
            <doc-id>dn900429</doc-id>
            <unmanaged>GetNibTransform / SetNibTransform</unmanaged>
            <unmanaged-short>GetNibTransform</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.InkStyle.NibShape">
            <summary>
            <p>Retrieves or sets the pre-transform nib shape for this style.</p>
            </summary>
            <doc-id>dn900428</doc-id>
            <unmanaged>GetNibShape / SetNibShape</unmanaged>
            <unmanaged-short>GetNibShape</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.InkStyle.SetNibTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Sets the transform to apply to this style's nib shape.</p>
            </summary>
            <param name = "transform"><dd>  <p>The transform to apply to this style?s nib shape. Note that the translation components of the transform matrix are ignored for the purposes of rendering.</p> </dd></param>
            <doc-id>dn900431</doc-id>
            <unmanaged>void ID2D1InkStyle::SetNibTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1InkStyle::SetNibTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.InkStyle.GetNibTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Retrieves the transform to be applied to this style's nib shape.</p>
            </summary>
            <param name = "transform"><dd>  <p>When this method returns, contains a reference to the transform to be applied to this style's nib shape.</p> </dd></param>
            <doc-id>dn900429</doc-id>
            <unmanaged>void ID2D1InkStyle::GetNibTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1InkStyle::GetNibTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.InkStyle.SetNibShape(SharpDX.Direct2D1.InkNibShape)">
            <summary>
            <p>Sets the pre-transform nib shape for this style.</p>
            </summary>
            <param name = "nibShape"><dd>  <p>The pre-transform nib shape to use in this style.</p> </dd></param>
            <doc-id>dn900430</doc-id>
            <unmanaged>void ID2D1InkStyle::SetNibShape([In] D2D1_INK_NIB_SHAPE nibShape)</unmanaged>
            <unmanaged-short>ID2D1InkStyle::SetNibShape</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.InkStyle.GetNibShape">
            <summary>
            <p>Retrieves the pre-transform nib shape for this style.</p>
            </summary>
            <returns><p>Returns the pre-transform nib shape for this style.</p></returns>
            <doc-id>dn900428</doc-id>
            <unmanaged>D2D1_INK_NIB_SHAPE ID2D1InkStyle::GetNibShape()</unmanaged>
            <unmanaged-short>ID2D1InkStyle::GetNibShape</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InputDescription">
            <summary>
            <p>Describes the options that transforms may set on input textures.</p>
            </summary>
            <doc-id>hh404310</doc-id>
            <unmanaged>D2D1_INPUT_DESCRIPTION</unmanaged>
            <unmanaged-short>D2D1_INPUT_DESCRIPTION</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.InputDescription.#ctor(SharpDX.Direct2D1.Filter,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.InputDescription"/> struct.
            </summary>
            <param name="filter">The type of filter to apply to the input texture</param>
            <param name="levelOfDetail">The mip level to retrieve from the upstream transform, if specified.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.InputDescription.Filter">
            <summary>
            <dd> <p>The type of filter to apply to the input texture.</p> </dd>
            </summary>
            <doc-id>hh404310</doc-id>
            <unmanaged>filter</unmanaged>
            <unmanaged-short>filter</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InputDescription.LevelOfDetailCount">
            <summary>
            <dd> <p>The mip level to retrieve from the upstream transform, if specified.</p> </dd>
            </summary>
            <doc-id>hh404310</doc-id>
            <unmanaged>levelOfDetailCount</unmanaged>
            <unmanaged-short>levelOfDetailCount</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InputElement">
            <summary>
            <p>A description of a single element to the vertex layout.</p>
            </summary>
            <remarks>
            <p>This structure is a subset of <strong><see cref = "!:SharpDX.Direct3D11.InputElement"/></strong> that omits fields required to define a vertex layout.</p><p>If the <strong>D2D1_APPEND_ALIGNED_ELEMENT</strong> constant is used for  <strong>alignedByteOffset</strong>, the elements will be packed contiguously for convenience.
            </p>
            </remarks>
            <doc-id>hh404312</doc-id>
            <unmanaged>D2D1_INPUT_ELEMENT_DESC</unmanaged>
            <unmanaged-short>D2D1_INPUT_ELEMENT_DESC</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.InputElement.AppendAligned">
            <summary>
              Returns a value that can be used for the offset parameter of an InputElement to indicate that the element
              should be aligned directly after the previous element, including any packing if necessary.
            </summary>
            <returns>A value used to align input elements.</returns>
            <unmanaged>D2D1_APPEND_ALIGNED_ELEMENT</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.#ctor(System.String,System.Int32,SharpDX.DXGI.Format,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref = "T:SharpDX.Direct2D11.InputElement" /> struct.
            </summary>
            <param name = "name">The HLSL semantic associated with this element in a shader input-signature.</param>
            <param name = "index">The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix, however each of the four component would have different semantic indices (0, 1, 2, and 3).</param>
            <param name = "format">The data type of the element data.</param>
            <param name = "slot">An integer value that identifies the input-assembler. Valid values are between 0 and 15.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.#ctor(System.String,System.Int32,SharpDX.DXGI.Format,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref = "T:SharpDX.Direct2D11.InputElement" /> struct.
            </summary>
            <param name = "name">The HLSL semantic associated with this element in a shader input-signature.</param>
            <param name = "index">The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix, however each of the four component would have different semantic indices (0, 1, 2, and 3).</param>
            <param name = "format">The data type of the element data.</param>
            <param name = "offset">Offset (in bytes) between each element. Use AppendAligned for convenience to define the current element directly after the previous one, including any packing if necessary.</param>
            <param name = "slot">An integer value that identifies the input-assembler. Valid values are between 0 and 15.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.Equals(SharpDX.Direct2D1.InputElement)">
            <summary>
            Determines whether the specified <see cref="T:SharpDX.Direct2D1.InputElement"/> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:SharpDX.Direct2D1.InputElement"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:SharpDX.Direct2D1.InputElement"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.op_Equality(SharpDX.Direct2D1.InputElement,SharpDX.Direct2D1.InputElement)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="M:SharpDX.Direct2D1.InputElement.op_Inequality(SharpDX.Direct2D1.InputElement,SharpDX.Direct2D1.InputElement)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>
            The result of the operator.
            </returns>
        </member>
        <member name="F:SharpDX.Direct2D1.InputElement.SemanticName">
            <summary>
            <dd> <p>The HLSL semantic associated with this element in a shader input-signature.</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>semanticName</unmanaged>
            <unmanaged-short>semanticName</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InputElement.SemanticIndex">
            <summary>
            <dd> <p>The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix; however, each of the four components would have different semantic indices (0, 1, 2, and 3).</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>semanticIndex</unmanaged>
            <unmanaged-short>semanticIndex</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InputElement.Format">
            <summary>
            <dd> <p>The data type of the element data.</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>format</unmanaged>
            <unmanaged-short>format</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InputElement.Slot">
            <summary>
            <dd> <p>An integer value that identifies the input-assembler. Valid values are between 0 and 15.</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>inputSlot</unmanaged>
            <unmanaged-short>inputSlot</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InputElement.AlignedByteOffset">
            <summary>
            <dd> <p>The offset in bytes between each element.</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>alignedByteOffset</unmanaged>
            <unmanaged-short>alignedByteOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Layer.#ctor(SharpDX.Direct2D1.RenderTarget)">
            <summary>	
            Creates a layer resource that can be used with this render target and its compatible render targets. The new layer has the specified initial size. The layer resource is allocated to the minimum size when {{PushLayer}} is called.
            </summary>	
            <remarks>	
            Regardless of whether a size is initially specified, the layer automatically resizes as needed.	
            </remarks>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <unmanaged>HRESULT CreateLayer([In, Optional] const D2D1_SIZE_F* size,[Out] ID2D1Layer** layer)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Layer.#ctor(SharpDX.Direct2D1.RenderTarget,System.Nullable{SharpDX.Size2F})">
            <summary>	
            Creates a layer resource that can be used with this render target and its compatible render targets. The new layer has the specified initial size.  	
            </summary>	
            <remarks>	
            Regardless of whether a size is initially specified, the layer automatically resizes as needed.	
            </remarks>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="size">If (0, 0) is specified, no backing store is created behind the layer resource. The layer resource is allocated to the minimum size when {{PushLayer}} is called.</param>
            <unmanaged>HRESULT CreateLayer([In, Optional] const D2D1_SIZE_F* size,[Out] ID2D1Layer** layer)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.Layer.Size">
            <summary>
            <p>Gets the size of the layer in device-independent pixels. </p>
            </summary>
            <doc-id>dd371485</doc-id>
            <unmanaged>GetSize</unmanaged>
            <unmanaged-short>GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Layer.GetSize">
            <summary>
            <p>Gets the size of the layer in device-independent pixels. </p>
            </summary>
            <returns><p>The size of the layer in device-independent pixels.</p></returns>
            <doc-id>dd371485</doc-id>
            <unmanaged>D2D_SIZE_F ID2D1Layer::GetSize()</unmanaged>
            <unmanaged-short>ID2D1Layer::GetSize</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.LayerParameters">
            <summary>
            <p> Contains the content bounds, mask information, opacity settings, and other options for a layer resource. </p>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>D2D1_LAYER_PARAMETERS</unmanaged>
            <unmanaged-short>D2D1_LAYER_PARAMETERS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.ContentBounds">
            <summary>
            <dd> <p>The content bounds of the layer. Content outside these bounds is not guaranteed to render.</p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>contentBounds</unmanaged>
            <unmanaged-short>contentBounds</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.GeometricMask">
            <summary>
            <dd> <p>The geometric mask specifies the area of the layer that is composited into the render target. </p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>geometricMask</unmanaged>
            <unmanaged-short>geometricMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.MaskAntialiasMode">
            <summary>
            <dd> <p>A value that specifies the antialiasing mode for the geometricMask.  </p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>maskAntialiasMode</unmanaged>
            <unmanaged-short>maskAntialiasMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.MaskTransform">
            <summary>
            <dd> <p> A value that specifies the transform that is applied to the geometric mask when composing the layer.</p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>maskTransform</unmanaged>
            <unmanaged-short>maskTransform</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.Opacity">
            <summary>
            <dd> <p>An opacity value that is applied uniformly to all resources in the layer when compositing to the target.</p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>opacity</unmanaged>
            <unmanaged-short>opacity</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.OpacityBrush">
            <summary>
            <dd> <p>A brush that is used to modify the opacity of the layer. The brush 
            is mapped to the layer, and the alpha channel of each mapped brush pixel is multiplied against the corresponding layer pixel. </p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>opacityBrush</unmanaged>
            <unmanaged-short>opacityBrush</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters.LayerOptions">
            <summary>
            <dd> <p> A value that specifies whether the layer intends to render text with ClearType antialiasing.</p> </dd>
            </summary>
            <doc-id>dd368127</doc-id>
            <unmanaged>layerOptions</unmanaged>
            <unmanaged-short>layerOptions</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.LayerParameters1">
            <summary>
            <p>Contains the content bounds, mask information, opacity settings, and other options for a layer resource.</p>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>D2D1_LAYER_PARAMETERS1</unmanaged>
            <unmanaged-short>D2D1_LAYER_PARAMETERS1</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LayerParameters1.#ctor(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.AntialiasMode,SharpDX.Mathematics.Interop.RawMatrix3x2,System.Single,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.LayerOptions1)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.LayerParameters1"/> struct.
            </summary>
            <param name="contentBounds">The content bounds.</param>
            <param name="geometryMask">The geometry mask.</param>
            <param name="maskAntialiasMode">The mask antialias mode.</param>
            <param name="maskTransform">The mask transform.</param>
            <param name="opacity">The opacity.</param>
            <param name="opacityBrush">The opacity brush.</param>
            <param name="layerOptions">The layer options.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.ContentBounds">
            <summary>
            <dd> <p>The content bounds of the layer. Content outside these bounds is not guaranteed to render.</p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>contentBounds</unmanaged>
            <unmanaged-short>contentBounds</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.GeometricMask">
            <summary>
            <dd> <p>The geometric mask specifies the area of the layer that is composited into the render target. </p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>geometricMask</unmanaged>
            <unmanaged-short>geometricMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.MaskAntialiasMode">
            <summary>
            <dd> <p>A value that specifies the antialiasing mode for the geometricMask.  </p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>maskAntialiasMode</unmanaged>
            <unmanaged-short>maskAntialiasMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.MaskTransform">
            <summary>
            <dd> <p> A value that specifies the transform that is applied to the geometric mask when composing the layer.</p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>maskTransform</unmanaged>
            <unmanaged-short>maskTransform</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.Opacity">
            <summary>
            <dd> <p>An opacity value that is applied uniformly to all resources in the layer when compositing to the target.</p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>opacity</unmanaged>
            <unmanaged-short>opacity</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.OpacityBrush">
            <summary>
            <dd> <p>A brush that is used to modify the opacity of the layer. The brush 
            is mapped to the layer, and the alpha channel of each mapped brush pixel is multiplied against the corresponding layer pixel. </p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>opacityBrush</unmanaged>
            <unmanaged-short>opacityBrush</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerParameters1.LayerOptions">
            <summary>
            <dd> <p>Additional options for the layer creation.</p> </dd>
            </summary>
            <doc-id>hh847947</doc-id>
            <unmanaged>layerOptions</unmanaged>
            <unmanaged-short>layerOptions</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.LinearGradientBrushProperties,SharpDX.Direct2D1.GradientStopCollection)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.LinearGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="linearGradientBrushProperties">The start and end points of the gradient.</param>
            <param name="gradientStopCollection">A collection of <see cref="T:SharpDX.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient line.</param>
            <unmanaged>HRESULT CreateLinearGradientBrush([In] const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1LinearGradientBrush** linearGradientBrush)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.LinearGradientBrushProperties,System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.GradientStopCollection)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.LinearGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="linearGradientBrushProperties">The start and end points of the gradient.</param>
            <param name="brushProperties">The transform and base opacity of the new brush, or NULL. If this value is NULL, the brush defaults to a base opacity of 1.0f and the identity matrix as its transformation.</param>
            <param name="gradientStopCollection">A collection of <see cref="T:SharpDX.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient line.</param>
            <unmanaged>HRESULT CreateLinearGradientBrush([In] const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1LinearGradientBrush** linearGradientBrush)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.LinearGradientBrush.StartPoint">
            <summary>
            <p>Retrieves or sets the starting coordinates of the linear gradient. </p>
            </summary>
            <remarks>
            <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
            </remarks>
            <doc-id>dd371497</doc-id>
            <unmanaged>GetStartPoint / SetStartPoint</unmanaged>
            <unmanaged-short>GetStartPoint</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.LinearGradientBrush.EndPoint">
            <summary>
            <p>Retrieves or sets the ending coordinates of the linear gradient. </p>
            </summary>
            <remarks>
            <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
            </remarks>
            <doc-id>dd371492</doc-id>
            <unmanaged>GetEndPoint / SetEndPoint</unmanaged>
            <unmanaged-short>GetEndPoint</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.LinearGradientBrush.GradientStopCollection">
            <summary>
            <p> Retrieves the <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this linear gradient brush.</p>
            </summary>
            <remarks>
            <p> <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "T:SharpDX.Direct2D1.GradientStop"/></strong> structures and information, such as the extend mode and the color interpolation mode.</p>
            </remarks>
            <doc-id>dd371496</doc-id>
            <unmanaged>GetGradientStopCollection</unmanaged>
            <unmanaged-short>GetGradientStopCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.SetStartPoint(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            <p>Sets the starting coordinates of the linear gradient in the brush's coordinate space.  </p>
            </summary>
            <param name = "startPoint"><dd>  <p>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p> </dd></param>
            <remarks>
            <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
            </remarks>
            <doc-id>dd371505</doc-id>
            <unmanaged>void ID2D1LinearGradientBrush::SetStartPoint([In] D2D_POINT_2F startPoint)</unmanaged>
            <unmanaged-short>ID2D1LinearGradientBrush::SetStartPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.SetEndPoint(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            <p>Sets the ending coordinates of the linear gradient in the brush's coordinate space.</p>
            </summary>
            <param name = "endPoint"><dd>  <p>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p> </dd></param>
            <remarks>
            <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
            </remarks>
            <doc-id>dd371501</doc-id>
            <unmanaged>void ID2D1LinearGradientBrush::SetEndPoint([In] D2D_POINT_2F endPoint)</unmanaged>
            <unmanaged-short>ID2D1LinearGradientBrush::SetEndPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.GetStartPoint">
            <summary>
            <p>Retrieves the starting coordinates of the linear gradient. </p>
            </summary>
            <returns><p>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p></returns>
            <remarks>
            <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
            </remarks>
            <doc-id>dd371497</doc-id>
            <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetStartPoint()</unmanaged>
            <unmanaged-short>ID2D1LinearGradientBrush::GetStartPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.GetEndPoint">
            <summary>
            <p>Retrieves the ending coordinates of the linear gradient. </p>
            </summary>
            <returns><p>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p></returns>
            <remarks>
            <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
            </remarks>
            <doc-id>dd371492</doc-id>
            <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetEndPoint()</unmanaged>
            <unmanaged-short>ID2D1LinearGradientBrush::GetEndPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LinearGradientBrush.GetGradientStopCollection(SharpDX.Direct2D1.GradientStopCollection@)">
            <summary>
            <p> Retrieves the <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this linear gradient brush.</p>
            </summary>
            <param name = "gradientStopCollection">No documentation.</param>
            <remarks>
            <p> <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "T:SharpDX.Direct2D1.GradientStop"/></strong> structures and information, such as the extend mode and the color interpolation mode.</p>
            </remarks>
            <doc-id>dd371496</doc-id>
            <unmanaged>void ID2D1LinearGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
            <unmanaged-short>ID2D1LinearGradientBrush::GetGradientStopCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.LookupTable3D.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.Direct2D1.BufferPrecision,System.Int32[],System.Byte[],System.Int32,System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.LookupTable3D"/>.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Mesh.#ctor(SharpDX.Direct2D1.RenderTarget)">
            <summary>	
            Create a mesh that uses triangles to describe a shape.	
            </summary>	
            <remarks>	
            To populate a mesh, use its {{Open}} method to obtain an <see cref="T:SharpDX.Direct2D1.TessellationSink"/>. To draw the mesh, use the render target's {{FillMesh}} method.	
            </remarks>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <unmanaged>HRESULT CreateMesh([Out] ID2D1Mesh** mesh)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Mesh.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.Triangle[])">
            <summary>	
            Create a mesh that uses triangles to describe a shape and populates it with triangles.
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="triangles">An array of <see cref="T:SharpDX.Direct2D1.Triangle"/> structures that describe the triangles to add to this mesh.</param>
            <unmanaged>HRESULT CreateMesh([Out] ID2D1Mesh** mesh)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Mesh.Open">
            <summary>	
            Opens the mesh for population.	
            </summary>	
            <returns>When this method returns, contains a pointer to a pointer to an <see cref="T:SharpDX.Direct2D1.TessellationSink"/> that is used to populate the mesh. This parameter is passed uninitialized.</returns>
            <unmanaged>HRESULT Open([Out] ID2D1TessellationSink** tessellationSink)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Mesh.Open_(SharpDX.Direct2D1.TessellationSink@)">
            <summary>
            <p>Opens the mesh for population.</p>
            </summary>
            <param name = "tessellationSink"><dd>  <p>When this method returns, contains a reference to a reference to an <strong><see cref = "T:SharpDX.Direct2D1.TessellationSink"/></strong> that is used to populate the mesh. This parameter is passed uninitialized.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371510</doc-id>
            <unmanaged>HRESULT ID2D1Mesh::Open([Out] ID2D1TessellationSink** tessellationSink)</unmanaged>
            <unmanaged-short>ID2D1Mesh::Open</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ModuleInit">
            <summary>
            Internal class used to initialize this assembly.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.ModuleInit.Setup">
            <summary>
            Initializes this assembly.
            </summary>
            <remarks>
            This method is called when the assembly is loaded.
            </remarks>
        </member>
        <member name="T:SharpDX.Direct2D1.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.Direct2D1"/> namespace provides a managed Direct2D API.
            </summary>
            <msdn-id>dd370990</msdn-id>
            <unmanaged>Direct2D1</unmanaged>	
            <unmanaged-short>Direct2D1</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.OffsetTransform.#ctor(SharpDX.Direct2D1.EffectContext,SharpDX.Mathematics.Interop.RawPoint)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.OffsetTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="offset">The offset transformation</param>
            <unmanaged>HRESULT ID2D1EffectContext::CreateOffsetTransform([In] POINT offset,[Out, Fast] ID2D1OffsetTransform** transform)</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.OffsetTransform.Offset">
            <summary>
            <p>Gets or sets the offset currently in the offset transform.</p>
            </summary>
            <doc-id>hh446822</doc-id>
            <unmanaged>GetOffset / SetOffset</unmanaged>
            <unmanaged-short>GetOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.OffsetTransform.SetOffset(SharpDX.Mathematics.Interop.RawPoint)">
            <summary>
            <p>Sets the offset in the current offset transform.</p>
            </summary>
            <param name = "offset"><dd>  <p>The new offset to apply to the offset transform.</p> </dd></param>
            <doc-id>hh446824</doc-id>
            <unmanaged>void ID2D1OffsetTransform::SetOffset([In] POINT offset)</unmanaged>
            <unmanaged-short>ID2D1OffsetTransform::SetOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.OffsetTransform.GetOffset">
            <summary>
            <p>Gets the offset currently in the offset transform.</p>
            </summary>
            <returns><p>The current transform offset.</p></returns>
            <doc-id>hh446822</doc-id>
            <unmanaged>POINT ID2D1OffsetTransform::GetOffset()</unmanaged>
            <unmanaged-short>ID2D1OffsetTransform::GetOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry.#ctor(SharpDX.Direct2D1.Factory)">
            <summary>	
            Creates an empty <see cref="T:SharpDX.Direct2D1.PathGeometry"/>.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
        </member>
        <member name="P:SharpDX.Direct2D1.PathGeometry.SegmentCount">
            <summary>
            <p>Retrieves the number of segments in the path geometry. </p>
            </summary>
            <doc-id>dd371520</doc-id>
            <unmanaged>GetSegmentCount</unmanaged>
            <unmanaged-short>GetSegmentCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.PathGeometry.FigureCount">
            <summary>
            <p>Retrieves the number of figures in the path geometry. </p>
            </summary>
            <doc-id>dd371515</doc-id>
            <unmanaged>GetFigureCount</unmanaged>
            <unmanaged-short>GetFigureCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry.Open">
            <summary>
            <p>Retrieves the geometry sink that is used to populate the path geometry with figures and segments. </p>
            </summary>
            <returns><dd>  <p>When this method returns, <em>geometrySink</em> contains the address of a reference to the geometry sink that is used to populate the path geometry with figures and segments. This parameter is passed uninitialized.</p> </dd></returns>
            <remarks>
            <p>Because path geometries are immutable and can only be populated once, it is an error to call <strong>Open</strong> on a path geometry more than once.</p><p>Note that the fill mode defaults to <strong>D2D1_FILL_MODE_ALTERNATE</strong>. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Failure to do so will put the geometry sink in an error state. </p>
            </remarks>
            <doc-id>dd371522</doc-id>
            <unmanaged>HRESULT ID2D1PathGeometry::Open([Out] ID2D1GeometrySink** geometrySink)</unmanaged>
            <unmanaged-short>ID2D1PathGeometry::Open</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry.Stream(SharpDX.Direct2D1.GeometrySink)">
            <summary>
            <p>Copies the contents of the path geometry to the specified <strong><see cref = "T:SharpDX.Direct2D1.GeometrySink"/></strong>.</p>
            </summary>
            <param name = "geometrySink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371525</doc-id>
            <unmanaged>HRESULT ID2D1PathGeometry::Stream([In] ID2D1GeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>ID2D1PathGeometry::Stream</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry.GetSegmentCount(System.Int32@)">
            <summary>
            <p>Retrieves the number of segments in the path geometry. </p>
            </summary>
            <param name = "count"><dd>  <p>A reference that receives the number of segments in the path geometry when this method returns. You must allocate storage for this parameter.   </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371520</doc-id>
            <unmanaged>HRESULT ID2D1PathGeometry::GetSegmentCount([Out] unsigned int* count)</unmanaged>
            <unmanaged-short>ID2D1PathGeometry::GetSegmentCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry.GetFigureCount(System.Int32@)">
            <summary>
            <p>Retrieves the number of figures in the path geometry. </p>
            </summary>
            <param name = "count"><dd>  <p>A reference that receives the number of figures in the path geometry when this method returns. You must allocate storage for this parameter.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371515</doc-id>
            <unmanaged>HRESULT ID2D1PathGeometry::GetFigureCount([Out] unsigned int* count)</unmanaged>
            <unmanaged-short>ID2D1PathGeometry::GetFigureCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry1.#ctor(SharpDX.Direct2D1.Factory1)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.PathGeometry1"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <unmanaged>HRESULT ID2D1Factory1::CreatePathGeometry([Out, Fast] ID2D1PathGeometry1** pathGeometry)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.PathGeometry1.ComputePointAndSegmentAtLength(System.Single,System.Int32,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Single,SharpDX.Direct2D1.PointDescription@)">
            <summary>
            <p> Computes the point that exists at a given distance along the path geometry along with the index of the segment the point is on and the directional vector at that point. </p>
            </summary>
            <param name = "length"><dd>  <p>The distance to walk along the path.</p> </dd></param>
            <param name = "startSegment"><dd>  <p>The index of the segment at which to begin walking. Note: This index is global to the entire path, not just a particular figure.</p> </dd></param>
            <param name = "worldTransform"><dd>  <p>The transform to apply to the path prior to walking.</p> </dd></param>
            <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to use when walking along an arc or Bezier segment. The flattening tolerance is the maximum  error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge  from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>
            <param name = "ointDescriptionRef"><dd>  <p>When this method returns, contains a description of the point that can be found at the given location.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>One of the inputs was in an invalid range.</td></tr> </table><p>?</p></returns>
            <doc-id>dn900454</doc-id>
            <unmanaged>HRESULT ID2D1PathGeometry1::ComputePointAndSegmentAtLength([In] float length,[In] unsigned int startSegment,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] D2D1_POINT_DESCRIPTION* pointDescription)</unmanaged>
            <unmanaged-short>ID2D1PathGeometry1::ComputePointAndSegmentAtLength</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PixelFormat">
            <summary>
            <p> Contains the data format and alpha mode for a bitmap or render target. </p>
            </summary>
            <remarks>
            <p>For more information about the pixel formats and alpha modes supported by each render target, see Supported Pixel Formats and Alpha Modes.</p>
            </remarks>
            <doc-id>dd368138</doc-id>
            <unmanaged>D2D1_PIXEL_FORMAT</unmanaged>
            <unmanaged-short>D2D1_PIXEL_FORMAT</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PixelFormat.#ctor(SharpDX.DXGI.Format,SharpDX.Direct2D1.AlphaMode)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.PixelFormat"/> struct.
            </summary>
            <param name="format">A value that specifies the size and arrangement of channels in each pixel.</param>
            <param name="alphaMode">A value that specifies whether the alpha channel is using pre-multiplied alpha, straight alpha, whether it should be ignored and considered opaque, or whether it is unknown.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.PixelFormat.Format">
            <summary>
            <dd> <p>A value that specifies the size and arrangement of channels in each pixel.</p> </dd>
            </summary>
            <doc-id>dd368138</doc-id>
            <unmanaged>format</unmanaged>
            <unmanaged-short>format</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PixelFormat.AlphaMode">
            <summary>
            <dd> <p>A value that specifies whether the alpha channel is using pre-multiplied alpha, straight alpha, whether it should be ignored and considered opaque, or whether it is unkown.  </p> </dd>
            </summary>
            <doc-id>dd368138</doc-id>
            <unmanaged>alphaMode</unmanaged>
            <unmanaged-short>alphaMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PrintControl.#ctor(SharpDX.Direct2D1.Device,SharpDX.WIC.ImagingFactory,SharpDX.ComObject)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.PrintControl"/> class.
            </summary>
            <param name="device">The device.</param>
            <param name="wicFactory">The WIC factory.</param>
            <param name="documentTarget">The document target.</param>
            <unmanaged>HRESULT ID2D1Device::CreatePrintControl([In] IWICImagingFactory* wicFactory,[In] IPrintDocumentPackageTarget* documentTarget,[In, Optional] const D2D1_PRINT_CONTROL_PROPERTIES* printControlProperties,[Out] ID2D1PrintControl** printControl)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.PrintControl.#ctor(SharpDX.Direct2D1.Device,SharpDX.WIC.ImagingFactory,SharpDX.ComObject,SharpDX.Direct2D1.PrintControlProperties)">
            <unmanaged>HRESULT ID2D1Device::CreatePrintControl([In] IWICImagingFactory* wicFactory,[In] IPrintDocumentPackageTarget* documentTarget,[In, Optional] const D2D1_PRINT_CONTROL_PROPERTIES* printControlProperties,[Out] ID2D1PrintControl** printControl)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.PrintControl.AddPage(SharpDX.Direct2D1.CommandList,SharpDX.Size2F)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>TBD</p>	
            </summary>	
            <param name="commandList">No documentation.</param>	
            <param name="pageSize">No documentation.</param>	
            <returns>No documentation.</returns>	
            <msdn-id>hh847997</msdn-id>	
            <unmanaged>HRESULT ID2D1PrintControl::AddPage([In] ID2D1CommandList* commandList,[In] D2D_SIZE_F pageSize,[In, Optional] IStream* pagePrintTicketStream,[Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
            <unmanaged-short>ID2D1PrintControl::AddPage</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.PrintControl.AddPage(SharpDX.Direct2D1.CommandList,SharpDX.Size2F,System.Int64@,System.Int64@)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>TBD</p>	
            </summary>	
            <param name="commandList">No documentation.</param>	
            <param name="pageSize">No documentation.</param>	
            <param name="tag1">No documentation.</param>	
            <param name="tag2">No documentation.</param>	
            <returns>No documentation.</returns>	
            <msdn-id>hh847997</msdn-id>	
            <unmanaged>HRESULT ID2D1PrintControl::AddPage([In] ID2D1CommandList* commandList,[In] D2D_SIZE_F pageSize,[In, Optional] IStream* pagePrintTicketStream,[Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
            <unmanaged-short>ID2D1PrintControl::AddPage</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.PrintControl.AddPage(SharpDX.Direct2D1.CommandList,SharpDX.Size2F,SharpDX.Win32.IStream,System.Int64@,System.Int64@)">
            <summary>
            <p>Converts Direct2D primitives in the passed-in command list into a fixed page representation for use  by the print subsystem. </p>
            </summary>
            <param name = "commandList"><dd>  <p>The command list that contains the rendering operations.</p> </dd></param>
            <param name = "pageSize"><dd>  <p>The size of the page to add.</p> </dd></param>
            <param name = "agePrintTicketStreamRef"><dd>  <p>The print ticket stream.</p> </dd></param>
            <param name = "tag1"><dd>  <p>Contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If <c>null</c> is specified, no value is retrieved for this parameter.</p> </dd></param>
            <param name = "tag2"><dd>  <p>Contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If <c>null</c> is specified, no value is retrieved for this parameter.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td><see cref = "!:PrintJobClosed"/></td><td>The print job is already finished.</td></tr> </table><p>?</p></returns>
            <doc-id>hh847998</doc-id>
            <unmanaged>HRESULT ID2D1PrintControl::AddPage([In] ID2D1CommandList* commandList,[In] D2D_SIZE_F pageSize,[In, Optional] IStream* pagePrintTicketStream,[Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
            <unmanaged-short>ID2D1PrintControl::AddPage</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.PrintControl.Close">
            <summary>
            <p>Passes all remaining resources to the print sub-system, then clean up and close the current print job. </p>
            </summary>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td><see cref = "!:PrintJobClosed"/></td><td>The print job is already finished.</td></tr> </table><p>?</p></returns>
            <doc-id>hh848001</doc-id>
            <unmanaged>HRESULT ID2D1PrintControl::Close()</unmanaged>
            <unmanaged-short>ID2D1PrintControl::Close</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Properties.Cached">
            <summary>
            Gets or sets Cached property.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetPropertyName(System.Int32)">
            <summary>	
            Gets the number of characters for the given property name.
            </summary>	
            <param name="index"><para>The index of the property for which the name is being returned.</para></param>	
            <returns>The name of the property</returns>	
            <remarks>	
            This method returns an empty string if index is invalid.
            </remarks>	
            <unmanaged>HRESULT ID2D1Properties::GetPropertyName([In] unsigned int index,[Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetIntValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetUIntValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetFloatValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetBoolValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetGuidValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetVector2Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetVector3Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetColor3Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetVector4Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetRectangleFValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetColor4Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetMatrixValue(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetMatrix3x2Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetMatrix5x4Value(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetEnumValue``1(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetComObjectValue``1(System.Int32)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetValue``1(System.Int32,SharpDX.Direct2D1.PropertyType)">
            <summary>	
            Gets the value of the specified property by index.
            </summary>	
            <param name="index"><para>The index of the property from which the data is to be obtained.</para></param>	
            <returns>The value of the specified property by index.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetUIntValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetFloatValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetBoolValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetGuidValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetVector2ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetVector3ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetColor3ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetVector4ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetRectangleFValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetColor4ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetMatrixValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetMatrix3x2ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetMatrix5x4ValueByName(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetEnumValueByName``1(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetComObjectValueByName``1(System.String)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>	
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetValue``1(System.String,SharpDX.Direct2D1.PropertyType)">
            <summary>	
            Gets the value of the specified property by name.
            </summary>	
            <param name="name">The name of the property.</param>
            <param name="type">Specifies the type of property to get.</param>
            <returns>The value of the specified property by name.</returns>	
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] void* data,[In] unsigned int dataSize)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,System.Int32)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,System.UInt32)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,System.Boolean)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,System.Guid)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,System.Single)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawColor3)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawVector4)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawRectangleF)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawColor4)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawMatrix)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Mathematics.Interop.RawMatrix5x4)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,System.String)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName``1(System.String,``0)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName``1(System.String,SharpDX.Direct2D1.PropertyType,``0)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="name">Name of the property</param>
            <param name="type">Specifies the type of property to set.</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,System.Int32)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,System.UInt32)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,System.Boolean)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,System.Guid)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,System.Single)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawVector3)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawColor3)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawVector4)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawRectangleF)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawColor4)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawMatrix)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Mathematics.Interop.RawMatrix5x4)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,System.String)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetEnumValue``1(System.Int32,``0)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue``1(System.Int32,``0)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue``1(System.Int32,SharpDX.Direct2D1.PropertyType,``0)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name="index">Index of the property</param>
            <param name="type">Specifies the type of property to set.</param>
            <param name="value">Value of the property</param>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const void* data,[In] unsigned int dataSize)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.Properties.PropertyCount">
            <summary>
            <p>Gets the number of top-level properties. </p>
            </summary>
            <remarks>
            <p>This method returns the number of custom properties on the <strong><see cref = "T:SharpDX.Direct2D1.Properties"/></strong> interface. System properties and sub-properties are part of a closed set, and are enumerable by iterating over this closed set.</p>
            </remarks>
            <doc-id>hh446857</doc-id>
            <unmanaged>GetPropertyCount</unmanaged>
            <unmanaged-short>GetPropertyCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetPropertyCount">
            <summary>
            <p>Gets the number of top-level properties. </p>
            </summary>
            <returns><p>This method returns the number of custom (non-system) properties that can be accessed by the object.</p></returns>
            <remarks>
            <p>This method returns the number of custom properties on the <strong><see cref = "T:SharpDX.Direct2D1.Properties"/></strong> interface. System properties and sub-properties are part of a closed set, and are enumerable by iterating over this closed set.</p>
            </remarks>
            <doc-id>hh446857</doc-id>
            <unmanaged>unsigned int ID2D1Properties::GetPropertyCount()</unmanaged>
            <unmanaged-short>ID2D1Properties::GetPropertyCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetPropertyName(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Gets the property name that corresponds to the given index.
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "name">No documentation.</param>
            <param name = "nameCount">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>jj151735</doc-id>
            <unmanaged>HRESULT ID2D1Properties::GetPropertyName([In] unsigned int index,[Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetPropertyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetPropertyNameLength(System.Int32)">
            <summary>
            <p>Gets  the number of characters for the given property name.  This is a template overload. See Remarks.</p>
            </summary>
            <param name = "index"><dd>  <p>The index of the property name to retrieve.</p> </dd></param>
            <returns><p>This method returns the size in characters of the name corresponding to the given property index, or zero if the property index does not exist. </p></returns>
            <remarks>
            <p>The value returned by this method can be used to ensure that the buffer size for <strong>GetPropertyName</strong> is appropriate. </p><p> </p>template&lt;typename U&gt; UINT32 GetPropertyNameLength( U index ) CONST;
            </remarks>
            <doc-id>jj151733</doc-id>
            <unmanaged>unsigned int ID2D1Properties::GetPropertyNameLength([In] unsigned int index)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetPropertyNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetTypeInfo(System.Int32)">
            <summary>
            <p>Gets the <strong><see cref = "T:SharpDX.Direct2D1.PropertyType"/></strong> of the selected property. </p>
            </summary>
            <param name = "index">No documentation.</param>
            <returns><p>This method returns a <strong><see cref = "T:SharpDX.Direct2D1.PropertyType"/></strong>-typed value for the type of the selected property.</p></returns>
            <remarks>
            <p>If the property does not exist, the method returns <strong>D2D1_PROPERTY_TYPE_UNKNOWN</strong>.</p>
            </remarks>
            <doc-id>hh446873</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE ID2D1Properties::GetType([In] unsigned int index)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetPropertyIndex(System.String)">
            <summary>
            <p>Gets the index corresponding to the given property name. </p>
            </summary>
            <param name = "name"><dd>  <p>The name of the property to retrieve.</p> </dd></param>
            <returns><p>The index of the corresponding property name.</p></returns>
            <remarks>
            <p> If the property does not exist, this method returns <strong>D2D1_INVALID_PROPERTY_INDEX</strong>. This reserved value will never map to a valid index and will cause <strong><c>null</c></strong> or sentinel values to be returned from other parts of the property interface.</p>
            </remarks>
            <doc-id>hh446861</doc-id>
            <unmanaged>unsigned int ID2D1Properties::GetPropertyIndex([In] const wchar_t* name)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetPropertyIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValueByName(System.String,SharpDX.Direct2D1.PropertyType,System.IntPtr,System.Int32)">
            <summary>
            Sets the named property to the given value.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "type">No documentation.</param>
            <param name = "data">No documentation.</param>
            <param name = "dataSize">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>hh997717</doc-id>
            <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const unsigned char* data,[In] unsigned int dataSize)</unmanaged>
            <unmanaged-short>ID2D1Properties::SetValueByName</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.SetValue(System.Int32,SharpDX.Direct2D1.PropertyType,System.IntPtr,System.Int32)">
            <summary>
            <p>Sets the corresponding  property by index. This is a template overload. See Remarks.</p>
            </summary>
            <param name = "index"><dd> <p>The index of the property to set.</p> </dd></param>
            <param name = "type"><dd> <p>The data to set.</p> </dd></param>
            <param name = "data">No documentation.</param>
            <param name = "dataSize">No documentation.</param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "!:InvalidProperty"/></td><td>The specified property does not exist.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> <tr><td>D3DERR_OUT_OF_VIDEO_MEMORY</td><td>Failed to allocate required video memory.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_FAIL</td><td>Unspecified failure.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p> </p>template&lt;typename T, typename U&gt; <see cref = "T:SharpDX.Result"/> SetValue( U index, _In_ const T &amp;value );
            </remarks>
            <doc-id>jj151751</doc-id>
            <unmanaged>HRESULT ID2D1Properties::SetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const unsigned char* data,[In] unsigned int dataSize)</unmanaged>
            <unmanaged-short>ID2D1Properties::SetValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetValueByName(System.String,SharpDX.Direct2D1.PropertyType,System.IntPtr,System.Int32)">
            <summary>
            <p>Gets the property value by name. This is a template overload. See Remarks.</p>
            </summary>
            <param name = "name"><dd>  <p>The property name to get.</p> </dd></param>
            <param name = "type">No documentation.</param>
            <param name = "data">No documentation.</param>
            <param name = "dataSize">No documentation.</param>
            <returns><p>Returns the value requested.</p></returns>
            <remarks>
            <p>If <em>propertyName</em> does not exist, no information is retrieved.</p><p>Any error not in the standard set returned by a property implementation will be mapped into the standard error range.</p><p> </p>template&lt;typename T&gt; T GetValueByName( _In_ PCWSTR propertyName ) const;
            </remarks>
            <doc-id>jj151746</doc-id>
            <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] unsigned char* data,[In] unsigned int dataSize)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetValueByName</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetValue(System.Int32,SharpDX.Direct2D1.PropertyType,System.IntPtr,System.Int32)">
            <summary>
            <p>Gets  the value of the property by index. This is a template overload. See Remarks.</p>
            </summary>
            <param name = "index"><dd>  <p>The index of the property from which the value is to be obtained.</p> </dd></param>
            <param name = "type">No documentation.</param>
            <param name = "data">No documentation.</param>
            <param name = "dataSize">No documentation.</param>
            <returns><p>Returns the value requested.</p></returns>
            <remarks>
            <p> </p>template&lt;typename T, typename U&gt; T GetValue( U index ) const;
            </remarks>
            <doc-id>jj151743</doc-id>
            <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] unsigned char* data,[In] unsigned int dataSize)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetValueSize(System.Int32)">
            <summary>
            <p>Gets the size of the property value in bytes, using the property index. This is a template overload. See Remarks.</p>
            </summary>
            <param name = "index"><dd>  <p>The index of the property.</p> </dd></param>
            <returns><p>This method returns size of the value in bytes, using the property index </p></returns>
            <remarks>
            <p>This method returns zero if <em>index</em> does not exist. </p><p> </p>template&lt;typename U&gt; UINT32 GetValueSize( U index ) CONST;
            </remarks>
            <doc-id>jj151748</doc-id>
            <unmanaged>unsigned int ID2D1Properties::GetValueSize([In] unsigned int index)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetValueSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Properties.GetSubProperties(System.Int32)">
            <summary>
            <p>Gets the sub-properties of the provided property by index. This is a template overload.  See Remarks. </p>
            </summary>
            <param name = "index"><dd>  <p>The index of the  sub-properties to be retrieved.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of a reference to the sub-properties.</p> </dd></returns>
            <remarks>
            <p> If there are no sub-properties, <em>subProperties</em> will be <strong><c>null</c></strong>, and <strong><see cref = "!:NoSubProperties"/></strong> will be returned. </p><p> </p>template&lt;typename U&gt; <see cref = "T:SharpDX.Result"/> GetSubProperties( U index, _Outptr_opt_ <see cref = "T:SharpDX.Direct2D1.Properties"/> **subProperties ) CONST;
            </remarks>
            <doc-id>jj151736</doc-id>
            <unmanaged>HRESULT ID2D1Properties::GetSubProperties([In] unsigned int index,[Out, Optional] ID2D1Properties** subProperties)</unmanaged>
            <unmanaged-short>ID2D1Properties::GetSubProperties</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PropertyBinding">
            <summary>
            <p>Defines a property binding to a pair of functions which get and set the corresponding property. </p>
            </summary>
            <remarks>
            <p>The <strong>propertyName</strong> is used to cross-correlate the property binding with the registration XML. The <strong>propertyName</strong> must be present in the XML call or the registration will fail. All properties must be bound.</p>
            </remarks>
            <doc-id>hh404320</doc-id>
            <unmanaged>D2D1_PROPERTY_BINDING</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_BINDING</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBinding.TypeName">
            <summary>
            Gets the type of the property.
            </summary>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyBinding.PropertyName">
            <summary>
            <dd> <p> The name of the property.</p> </dd>
            </summary>
            <doc-id>hh404320</doc-id>
            <unmanaged>propertyName</unmanaged>
            <unmanaged-short>propertyName</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyBinding.SetFunction">
            <summary>
            <dd> <p> The function that will receive the data to set.</p> </dd>
            </summary>
            <doc-id>hh404320</doc-id>
            <unmanaged>setFunction</unmanaged>
            <unmanaged-short>setFunction</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyBinding.GetFunction">
            <summary>
            <dd> <p>The function that will be asked to write the output data.</p> </dd>
            </summary>
            <doc-id>hh404320</doc-id>
            <unmanaged>getFunction</unmanaged>
            <unmanaged-short>getFunction</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PropertyBindingAttribute">
            <summary>
            Metadata description for <see cref="T:SharpDX.Direct2D1.CustomEffect"/> property binding.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.PropertyBindingAttribute.#ctor(System.Int32,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.PropertyBindingAttribute"/> attribute.
            </summary>
            <param name="order">Order of the property</param>
            <param name="min">Minimum value of this property</param>
            <param name="max">Maximum value of this property</param>
            <param name="defaultValue">Default value of this property</param>
        </member>
        <member name="M:SharpDX.Direct2D1.PropertyBindingAttribute.#ctor(SharpDX.Direct2D1.PropertyType,System.Int32,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.PropertyBindingAttribute"/> attribute.
            </summary>
            <param name="bindingType">Type of binding</param>
            <param name="order">Order of the property</param>
            <param name="min">Minimum value of this property</param>
            <param name="max">Maximum value of this property</param>
            <param name="defaultValue">Default value of this property</param>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.BindingType">
            <summary>
            Gets binding type.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.Order">
            <summary>
            Gets the order of this property.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.DisplayName">
            <summary>
            Gets the DisplayName.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.Type">
            <summary>
            Gets the Type of the property.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.Min">
            <summary>
            Gets the Min value.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.Max">
            <summary>
            Gets the Max value.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.PropertyBindingAttribute.Default">
            <summary>
            Gets the Default value.
            </summary>
        </member>
        <member name="T:SharpDX.Direct2D1.PropertyTypeHelper">
            <summary>
            Helper functions for <see cref="T:SharpDX.Direct2D1.PropertyType"/>.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.PropertyTypeHelper.ConvertToString(SharpDX.Direct2D1.PropertyType)">
            <summary>
            Converts a property type to a text.
            </summary>
            <param name="propertyType">The property type</param>
            <returns>A string representing this property type.</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.RadialGradientBrushProperties@,SharpDX.Direct2D1.GradientStopCollection)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.RadialGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="radialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
            <param name="gradientStopCollection">A collection of <see cref="T:SharpDX.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient.</param>
            <unmanaged>HRESULT CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.RadialGradientBrushProperties,SharpDX.Direct2D1.GradientStopCollection)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.RadialGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="radialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
            <param name="gradientStopCollection">A collection of <see cref="T:SharpDX.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient.</param>
            <unmanaged>HRESULT CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.RadialGradientBrushProperties,SharpDX.Direct2D1.BrushProperties,SharpDX.Direct2D1.GradientStopCollection)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.RadialGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="radialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
            <param name="brushProperties">The transform and base opacity of the new brush, or NULL. If this value is NULL, the brush defaults to a base opacity of 1.0f and the identity matrix as its transformation.</param>
            <param name="gradientStopCollection">A collection of <see cref="T:SharpDX.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient.</param>
            <unmanaged>HRESULT CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Direct2D1.RadialGradientBrushProperties@,System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.GradientStopCollection)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.RadialGradientBrush"/> that contains the specified gradient stops and has the specified transform and base opacity. 	
            </summary>
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="radialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
            <param name="brushProperties">The transform and base opacity of the new brush, or NULL. If this value is NULL, the brush defaults to a base opacity of 1.0f and the identity matrix as its transformation.</param>
            <param name="gradientStopCollection">A collection of <see cref="T:SharpDX.Direct2D1.GradientStop"/> structures that describe the colors in the brush's gradient and their locations along the gradient.</param>
            <unmanaged>HRESULT CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.RadialGradientBrush.Center">
            <summary>
            <p>Retrieves or sets the center of the gradient ellipse.  </p>
            </summary>
            <doc-id>dd371532</doc-id>
            <unmanaged>GetCenter / SetCenter</unmanaged>
            <unmanaged-short>GetCenter</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RadialGradientBrush.GradientOriginOffset">
            <summary>
            <p>Retrieves or sets the offset of the gradient origin relative to the gradient ellipse's center. </p>
            </summary>
            <doc-id>dd371535</doc-id>
            <unmanaged>GetGradientOriginOffset / SetGradientOriginOffset</unmanaged>
            <unmanaged-short>GetGradientOriginOffset</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RadialGradientBrush.RadiusX">
            <summary>
            <p>Retrieves or sets the x-radius of the gradient ellipse. </p>
            </summary>
            <doc-id>dd371542</doc-id>
            <unmanaged>GetRadiusX / SetRadiusX</unmanaged>
            <unmanaged-short>GetRadiusX</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RadialGradientBrush.RadiusY">
            <summary>
            <p>Retrieves or sets the y-radius of the gradient ellipse. </p>
            </summary>
            <doc-id>dd371544</doc-id>
            <unmanaged>GetRadiusY / SetRadiusY</unmanaged>
            <unmanaged-short>GetRadiusY</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RadialGradientBrush.GradientStopCollection">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this radial gradient brush object.</p>
            </summary>
            <remarks>
            <p> <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "T:SharpDX.Direct2D1.GradientStop"/></strong> structures and additional information, such as the extend mode and the color interpolation mode.</p>
            </remarks>
            <doc-id>dd371539</doc-id>
            <unmanaged>GetGradientStopCollection</unmanaged>
            <unmanaged-short>GetGradientStopCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.SetCenter(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            <p>Specifies the center of the gradient ellipse in the brush's coordinate space. </p>
            </summary>
            <param name = "center"><dd>  <p>The center of the gradient ellipse, in the brush's coordinate space.</p> </dd></param>
            <doc-id>dd371547</doc-id>
            <unmanaged>void ID2D1RadialGradientBrush::SetCenter([In] D2D_POINT_2F center)</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::SetCenter</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.SetGradientOriginOffset(SharpDX.Mathematics.Interop.RawVector2)">
            <summary>
            <p>Specifies the offset of the gradient origin relative to the gradient ellipse's center.</p>
            </summary>
            <param name = "gradientOriginOffset"><dd>  <p>The offset of the gradient origin from the center of the gradient ellipse.</p> </dd></param>
            <doc-id>dd371550</doc-id>
            <unmanaged>void ID2D1RadialGradientBrush::SetGradientOriginOffset([In] D2D_POINT_2F gradientOriginOffset)</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::SetGradientOriginOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.SetRadiusX(System.Single)">
            <summary>
            <p> Specifies the x-radius of the gradient ellipse, in the brush's coordinate space.</p>
            </summary>
            <param name = "radiusX"><dd>  <p>The x-radius of the gradient ellipse. This value is in the brush's coordinate space.</p> </dd></param>
            <doc-id>dd371553</doc-id>
            <unmanaged>void ID2D1RadialGradientBrush::SetRadiusX([In] float radiusX)</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::SetRadiusX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.SetRadiusY(System.Single)">
            <summary>
            <p>Specifies the y-radius of the gradient ellipse, in the brush's coordinate space. </p>
            </summary>
            <param name = "radiusY"><dd>  <p>The y-radius of the gradient ellipse. This value is in the brush's coordinate space.</p> </dd></param>
            <doc-id>dd371557</doc-id>
            <unmanaged>void ID2D1RadialGradientBrush::SetRadiusY([In] float radiusY)</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::SetRadiusY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.GetCenter">
            <summary>
            <p>Retrieves the center of the gradient ellipse.  </p>
            </summary>
            <returns><p>The center of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
            <doc-id>dd371532</doc-id>
            <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetCenter()</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::GetCenter</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.GetGradientOriginOffset">
            <summary>
            <p>Retrieves the offset of the gradient origin relative to the gradient ellipse's center. </p>
            </summary>
            <returns><p>The offset of the gradient origin from the center of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
            <doc-id>dd371535</doc-id>
            <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetGradientOriginOffset()</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::GetGradientOriginOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.GetRadiusX">
            <summary>
            <p>Retrieves the x-radius of the gradient ellipse. </p>
            </summary>
            <returns><p>The x-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
            <doc-id>dd371542</doc-id>
            <unmanaged>float ID2D1RadialGradientBrush::GetRadiusX()</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::GetRadiusX</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.GetRadiusY">
            <summary>
            <p>Retrieves the y-radius of the gradient ellipse. </p>
            </summary>
            <returns><p>The y-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
            <doc-id>dd371544</doc-id>
            <unmanaged>float ID2D1RadialGradientBrush::GetRadiusY()</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::GetRadiusY</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RadialGradientBrush.GetGradientStopCollection(SharpDX.Direct2D1.GradientStopCollection@)">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this radial gradient brush object.</p>
            </summary>
            <param name = "gradientStopCollection">No documentation.</param>
            <remarks>
            <p> <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "T:SharpDX.Direct2D1.GradientStop"/></strong> structures and additional information, such as the extend mode and the color interpolation mode.</p>
            </remarks>
            <doc-id>dd371539</doc-id>
            <unmanaged>void ID2D1RadialGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
            <unmanaged-short>ID2D1RadialGradientBrush::GetGradientStopCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RectangleGeometry.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Mathematics.Interop.RawRectangleF)">
            <summary>	
             Creates an <see cref="T:SharpDX.Direct2D1.RectangleGeometry"/>. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="rectangle">The coordinates of the rectangle geometry. </param>
        </member>
        <member name="P:SharpDX.Direct2D1.RectangleGeometry.Rectangle">
            <summary>
            <p> Retrieves the rectangle that describes the rectangle geometry's dimensions.</p>
            </summary>
            <doc-id>dd371762</doc-id>
            <unmanaged>GetRect</unmanaged>
            <unmanaged-short>GetRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RectangleGeometry.GetRectangle(SharpDX.Mathematics.Interop.RawRectangleF@)">
            <summary>
            <p> Retrieves the rectangle that describes the rectangle geometry's dimensions.</p>
            </summary>
            <param name = "rect"><dd>  <p>Contains a reference to a rectangle that describes the rectangle geometry's dimensions when this method returns. You must allocate storage for this parameter. </p> </dd></param>
            <doc-id>dd371762</doc-id>
            <unmanaged>void ID2D1RectangleGeometry::GetRect([Out] D2D_RECT_F* rect)</unmanaged>
            <unmanaged-short>ID2D1RectangleGeometry::GetRect</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTarget.DefaultStrokeWidth">
            <summary>
            Default stroke width used for all methods that are not explicitly using it. Default is set to 1.0f.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.StrokeWidth">
            <summary>
            Get or set the default stroke width used for all methods that are not explicitly using it. Default is set to 1.0f.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.#ctor(SharpDX.Direct2D1.Factory,SharpDX.DXGI.Surface,SharpDX.Direct2D1.RenderTargetProperties)">
            <summary>	
            Creates a render target that draws to a DirectX Graphics Infrastructure (DXGI) surface. 	
            </summary>	
            <remarks>	
            To write to a Direct3D surface, you obtain an <see cref="T:SharpDX.DXGI.Surface"/> and pass it to the {{CreateDxgiSurfaceRenderTarget}} method to create a DXGI surface render target; you can then use the DXGI surface render target to draw 2-D content to the DXGI surface.  A DXGI surface render target is a type of <see cref="T:SharpDX.Direct2D1.RenderTarget"/>. Like other Direct2D render targets, you can use it to create resources and issue drawing commands. The DXGI surface render target and the DXGI surface must use the same DXGI format. If you specify the {{DXGI_FORMAT_UNKOWN}} format when you create the render target, it will automatically use the surface's format.The DXGI surface render target does not perform DXGI surface synchronization. To work with Direct2D, the Direct3D device that provides the <see cref="T:SharpDX.DXGI.Surface"/> must be created with the D3D10_CREATE_DEVICE_BGRA_SUPPORT flag.For more information about creating and using DXGI surface render targets, see the {{Direct2D and Direct3D Interoperability Overview}}.When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the render target's {{EndDraw}} method returns the {{D2DERR_RECREATE_TARGET}} error. When you receive this error, you need to recreate the render target (and any resources it created). 	
            </remarks>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="dxgiSurface">The DXGI surface to bind this render target to</param>
            <param name="properties">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Single,SharpDX.Direct2D1.BitmapInterpolationMode)">
            <summary>	
            Draws the specified bitmap after scaling it to the size of the specified rectangle. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawBitmap}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="bitmap">The bitmap to render. </param>
            <param name="opacity">A value between 0.0f and 1.0f, inclusive, that specifies an opacity value to apply to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  The default value is 1.0f. </param>
            <param name="interpolationMode">The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear" />.  </param>
            <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_RECT_F* destinationRectangle,[None] float opacity,[None] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D1_RECT_F* sourceRectangle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawBitmap(SharpDX.Direct2D1.Bitmap,SharpDX.Mathematics.Interop.RawRectangleF,System.Single,SharpDX.Direct2D1.BitmapInterpolationMode)">
            <summary>	
            Draws the specified bitmap after scaling it to the size of the specified rectangle. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawBitmap}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw"/> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush"/> methods.  	
            </remarks>	
            <param name="bitmap">The bitmap to render. </param>
            <param name="destinationRectangle">The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn; NULL to draw the selected portion of the bitmap at the origin of the render target.  If the rectangle is specified but not well-ordered, nothing is drawn, but the render target does not enter an error state. </param>
            <param name="opacity">A value between 0.0f and 1.0f, inclusive, that specifies an opacity value to apply to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  The default value is 1.0f. </param>
            <param name="interpolationMode">The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear"/>.  </param>
            <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_RECT_F* destinationRectangle,[None] float opacity,[None] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D1_RECT_F* sourceRectangle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Single,SharpDX.Direct2D1.BitmapInterpolationMode,SharpDX.Mathematics.Interop.RawRectangleF)">
            <summary>	
            Draws the specified bitmap after scaling it to the size of the specified rectangle. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawBitmap}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="bitmap">The bitmap to render. </param>
            <param name="opacity">A value between 0.0f and 1.0f, inclusive, that specifies an opacity value to apply to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  The default value is 1.0f. </param>
            <param name="interpolationMode">The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <see cref="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear" />.  </param>
            <param name="sourceRectangle">The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to be drawn; NULL to draw the entire bitmap.  </param>
            <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_RECT_F* destinationRectangle,[None] float opacity,[None] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D1_RECT_F* sourceRectangle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawEllipse(SharpDX.Direct2D1.Ellipse,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws the outline of the specified ellipse using the specified stroke style. 	
            </summary>	
            <remarks>	
            The {{DrawEllipse}} method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawEllipse) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="ellipse">The position and radius of the ellipse to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the ellipse's outline. </param>
            <unmanaged>void ID2D1RenderTarget::DrawEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawEllipse(SharpDX.Direct2D1.Ellipse,SharpDX.Direct2D1.Brush,System.Single)">
            <summary>	
            Draws the outline of the specified ellipse using the specified stroke style. 	
            </summary>	
            <remarks>	
            The {{DrawEllipse}} method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawEllipse) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="ellipse">The position and radius of the ellipse to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the ellipse's outline. </param>
            <param name="strokeWidth">The thickness of the ellipse's stroke. The stroke is centered on the ellipse's outline. </param>
            <unmanaged>void ID2D1RenderTarget::DrawEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws the outline of the specified geometry. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawGeometry) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="geometry">The geometry to draw. </param>
            <param name="brush">The brush used to paint the geometry's stroke. </param>
            <unmanaged>void ID2D1RenderTarget::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,System.Single)">
            <summary>	
            Draws the outline of the specified geometry. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawGeometry) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="geometry">The geometry to draw. </param>
            <param name="brush">The brush used to paint the geometry's stroke. </param>
            <param name="strokeWidth">The thickness of the geometry's stroke. The stroke is centered on the geometry's outline. </param>
            <unmanaged>void ID2D1RenderTarget::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawLine(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws a line between the specified points. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawLine) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="point0">The start point of the line, in device-independent pixels. </param>
            <param name="point1">The end point of the line, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the line's stroke. </param>
            <unmanaged>void ID2D1RenderTarget::DrawLine([None] D2D1_POINT_2F point0,[None] D2D1_POINT_2F point1,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawLine(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.Brush,System.Single)">
            <summary>	
            Draws a line between the specified points. 	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawLine) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="point0">The start point of the line, in device-independent pixels. </param>
            <param name="point1">The end point of the line, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the line's stroke. </param>
            <param name="strokeWidth">A value greater than or equal to 0.0f that specifies the width of the stroke. If this parameter isn't specified, it defaults to 1.0f.  The stroke is centered on the line. </param>
            <unmanaged>void ID2D1RenderTarget::DrawLine([None] D2D1_POINT_2F point0,[None] D2D1_POINT_2F point1,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws the outline of a rectangle that has the specified dimensions. 	
            </summary>	
            <remarks>	
            When this method fails, it does not return an error code. To determine whether a drawing method (such as {{DrawRectangle}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> method.  	
            </remarks>	
            <param name="rect">The dimensions of the rectangle to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the rectangle's stroke. </param>
            <unmanaged>void ID2D1RenderTarget::DrawRectangle([In] const D2D1_RECT_F* rect,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,System.Single)">
            <summary>	
            Draws the outline of a rectangle that has the specified dimensions and stroke style. 	
            </summary>	
            <remarks>	
            When this method fails, it does not return an error code. To determine whether a drawing method (such as {{DrawRectangle}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> method.  	
            </remarks>	
            <param name="rect">The dimensions of the rectangle to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the rectangle's stroke. </param>
            <param name="strokeWidth">A value greater than or equal to 0.0f that specifies the width of the rectangle's stroke. The stroke is centered on the rectangle's outline. </param>
            <unmanaged>void ID2D1RenderTarget::DrawRectangle([In] const D2D1_RECT_F* rect,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRoundedRectangle(SharpDX.Direct2D1.RoundedRectangle,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws the outline of the specified rounded rectangle.	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawRoundedRectangle}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="roundedRect">The dimensions of the rounded rectangle to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the rounded rectangle's outline.  </param>
            <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRoundedRectangle(SharpDX.Direct2D1.RoundedRectangle,SharpDX.Direct2D1.Brush,System.Single)">
            <summary>	
            Draws the outline of the specified rounded rectangle.	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawRoundedRectangle}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="roundedRect">The dimensions of the rounded rectangle to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the rounded rectangle's outline.  </param>
            <param name="strokeWidth">The width of the rounded rectangle's stroke. The stroke is centered on the rounded rectangle's outline. The default value is 1.0f.  </param>
            <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRoundedRectangle(SharpDX.Direct2D1.RoundedRectangle,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>	
            Draws the outline of the specified rounded rectangle using the specified stroke style.	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawRoundedRectangle}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="roundedRect">The dimensions of the rounded rectangle to draw, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the rounded rectangle's outline.  </param>
            <param name="strokeWidth">The width of the rounded rectangle's stroke. The stroke is centered on the rounded rectangle's outline. The default value is 1.0f.  </param>
            <param name="strokeStyle">The style of the rounded rectangle's stroke, or NULL to paint a solid stroke. The default value is NULL. </param>
            <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[None] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawText(System.String,SharpDX.DirectWrite.TextFormat,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws the specified text using the format information provided by an <see cref="T:SharpDX.DirectWrite.TextFormat" /> object. 	
            </summary>	
            <remarks>	
            To create an <see cref="T:SharpDX.DirectWrite.TextFormat" /> object, create an <see cref="T:SharpDX.DirectWrite.Factory" /> and call its {{CreateTextFormat}} method. This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawText}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="text">A reference to an array of Unicode characters to draw.  </param>
            <param name="textFormat">An object that describes formatting details of the text to draw, such as the font, the font size, and flow direction.   </param>
            <param name="layoutRect">The size and position of the area in which the text is drawn.  </param>
            <param name="defaultForegroundBrush">The brush used to paint the text. </param>
            <unmanaged>void ID2D1RenderTarget::DrawTextA([In, Buffer] const wchar_t* string,[None] int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D1_RECT_F* layoutRect,[In] ID2D1Brush* defaultForegroundBrush,[None] D2D1_DRAW_TEXT_OPTIONS options,[None] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawText(System.String,SharpDX.DirectWrite.TextFormat,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.DrawTextOptions)">
            <summary>	
            Draws the specified text using the format information provided by an <see cref="T:SharpDX.DirectWrite.TextFormat" /> object. 	
            </summary>	
            <remarks>	
            To create an <see cref="T:SharpDX.DirectWrite.TextFormat" /> object, create an <see cref="T:SharpDX.DirectWrite.Factory" /> and call its {{CreateTextFormat}} method. This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawText}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="text">A reference to an array of Unicode characters to draw.  </param>
            <param name="textFormat">An object that describes formatting details of the text to draw, such as the font, the font size, and flow direction.   </param>
            <param name="layoutRect">The size and position of the area in which the text is drawn.  </param>
            <param name="defaultForegroundBrush">The brush used to paint the text. </param>
            <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is <see cref="F:SharpDX.Direct2D1.DrawTextOptions.None" />, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle. </param>
            <unmanaged>void ID2D1RenderTarget::DrawTextA([In, Buffer] const wchar_t* string,[None] int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D1_RECT_F* layoutRect,[In] ID2D1Brush* defaultForegroundBrush,[None] D2D1_DRAW_TEXT_OPTIONS options,[None] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawText(System.String,SharpDX.DirectWrite.TextFormat,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.DrawTextOptions,SharpDX.Direct2D1.MeasuringMode)">
            <summary>	
            Draws the specified text using the format information provided by an <see cref="T:SharpDX.DirectWrite.TextFormat" /> object. 	
            </summary>	
            <remarks>	
            To create an <see cref="T:SharpDX.DirectWrite.TextFormat" /> object, create an <see cref="T:SharpDX.DirectWrite.Factory" /> and call its {{CreateTextFormat}} method. This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{DrawText}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="text">A reference to an array of Unicode characters to draw.  </param>
            <param name="textFormat">An object that describes formatting details of the text to draw, such as the font, the font size, and flow direction.   </param>
            <param name="layoutRect">The size and position of the area in which the text is drawn.  </param>
            <param name="defaultForegroundBrush">The brush used to paint the text. </param>
            <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is <see cref="F:SharpDX.Direct2D1.DrawTextOptions.None" />, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle. </param>
            <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted.  The default value is DWRITE_MEASURING_MODE_NATURAL.  </param>
            <unmanaged>void ID2D1RenderTarget::DrawTextA([In, Buffer] const wchar_t* string,[None] int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D1_RECT_F* layoutRect,[In] ID2D1Brush* defaultForegroundBrush,[None] D2D1_DRAW_TEXT_OPTIONS options,[None] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawTextLayout(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.TextLayout,SharpDX.Direct2D1.Brush)">
            <summary>	
            Draws the formatted text described by the specified <see cref="T:SharpDX.DirectWrite.TextLayout" /> object.	
            </summary>	
            <remarks>	
            When drawing the same text repeatedly, using the DrawTextLayout method is more efficient than using the {{DrawText}} method because the text doesn't need to be formatted and the layout processed with each call. This method doesn't return an error code if it fails. To determine whether a drawing operation (such as DrawTextLayout) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="origin">The point, described in device-independent pixels, at which the upper-left corner of the text described by textLayout is drawn. </param>
            <param name="textLayout">The formatted text to draw. Any drawing effects that do not inherit from <see cref="T:SharpDX.Direct2D1.Resource" /> are ignored. If there are drawing effects that inherit from ID2D1Resource that are not brushes, this method fails and the render target is put in an error state.  </param>
            <param name="defaultForegroundBrush">The brush used to paint any text in textLayout that does not already have a brush associated with it as a drawing effect (specified by the <see cref="M:SharpDX.DirectWrite.TextLayout.SetDrawingEffect(SharpDX.ComObject,SharpDX.DirectWrite.TextRange)" /> method).  </param>
            <unmanaged>void ID2D1RenderTarget::DrawTextLayout([None] D2D1_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In] ID2D1Brush* defaultForegroundBrush,[None] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)">
            <summary>	
            <p>Ends drawing operations  on the render target and indicates the current error state and associated tags. </p>	
            </summary>	
            <param name="tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>	
            <param name="tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>	
            <returns><p>If the method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. </p></returns>	
            <remarks>	
            <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p> <strong>BeginDraw</strong> and <strong>EndDraw</strong> are use to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref="T:SharpDX.Direct2D1.RenderTarget" /></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref="T:SharpDX.Direct2D1.BitmapRenderTarget" /></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref="T:SharpDX.Direct2D1.WindowRenderTarget" /></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The <strong>BeginDraw</strong> method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <strong><see cref="T:SharpDX.Result" /></strong> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <strong><see cref="T:SharpDX.Result" /></strong>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <strong><see cref="T:SharpDX.Result" /></strong> and error information when <strong>EndDraw</strong> is called.	
            </p>	
            </remarks>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1RenderTarget::EndDraw']/*" />	
            <msdn-id>dd371924</msdn-id>	
            <unmanaged>HRESULT ID2D1RenderTarget::EndDraw([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>	
            <unmanaged-short>ID2D1RenderTarget::EndDraw</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.EndDraw">
            <summary>	
            Ends drawing operations  on the render target and indicates the current error state and associated tags. 	
            </summary>	
            <remarks>	
            Drawing operations can only be issued between a {{BeginDraw}} and EndDraw call.BeginDraw and EndDraw are use to indicate that a render target is in use by the Direct2D system. Different implementations of <see cref="T:SharpDX.Direct2D1.RenderTarget"/> might behave differently when {{BeginDraw}} is called. An <see cref="T:SharpDX.Direct2D1.BitmapRenderTarget"/> may be locked between BeginDraw/EndDraw calls, a DXGI surface render target might be acquired on BeginDraw and released on EndDraw, while an <see cref="T:SharpDX.Direct2D1.WindowRenderTarget"/> may begin batching at BeginDraw and may present on EndDraw, for example. The BeginDraw method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of {{BeginDraw}}/EndDraw. After {{BeginDraw}} is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the {{Flush}} method is called, or until EndDraw is called. The EndDraw method causes any batched drawing operations to complete, and then returns an HRESULT indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The EndDraw method always succeeds: it should not be called twice even if a previous EndDraw resulted in a failing HRESULT. If EndDraw is called without a matched call to {{BeginDraw}}, it returns an error indicating that BeginDraw must be called before EndDraw. Calling BeginDraw twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate HRESULT and error information when EndDraw is called.	
            </remarks>	
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code and sets tag1 and tag2 to the tags that were active when the error occurred. </returns>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush)">
            <summary>	
            Paints the interior of the specified geometry. 	
            </summary>	
            <remarks>	
            If the opacityBrush parameter is not NULL, the alpha value of each pixel of the mapped opacityBrush is used to determine the resulting opacity of each corresponding pixel of the geometry. Only the alpha value of each color in the brush is used for this processing; all other color information is ignored.  The alpha value specified by the brush is multiplied by the alpha value of the geometry after the geometry has been painted by brush.  	
            When this method fails, it does not return an error code. To determine whether a drawing operation (such as FillGeometry) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw"/> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush"/> method. 	
            </remarks>	
            <param name="geometry">The geometry to paint.</param>
            <param name="brush">The brush used to paint the geometry's interior.</param>
            <unmanaged>void FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillOpacityMask(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.OpacityMaskContent)">
            <summary>	
            Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.    	
            </summary>	
            <remarks>	
            For this method to work properly, the render target must be using the <see cref="F:SharpDX.Direct2D1.AntialiasMode.Aliased" /> antialiasing mode. You can set the antialiasing mode by calling the <see cref="M:SharpDX.Direct2D1.RenderTarget.SetAntialiasMode(SharpDX.Direct2D1.AntialiasMode)" /> method. This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{FillOpacityMask}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="opacityMask">The opacity mask to apply to the brush. The alpha value of each pixel in the  region specified by sourceRectangle is multiplied with the alpha value of the brush after the brush has been mapped to the area defined by destinationRectangle. </param>
            <param name="brush">The brush used to paint the region of the render target specified by destinationRectangle. </param>
            <param name="content">The type of content the opacity mask contains. The value is used to determine the color space in which the opacity mask is blended. </param>
            <unmanaged>void ID2D1RenderTarget::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[None] D2D1_OPACITY_MASK_CONTENT content,[In, Optional] const D2D1_RECT_F* destinationRectangle,[In, Optional] const D2D1_RECT_F* sourceRectangle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillRoundedRectangle(SharpDX.Direct2D1.RoundedRectangle,SharpDX.Direct2D1.Brush)">
            <summary>	
            Paints the interior of the specified rounded rectangle.	
            </summary>	
            <remarks>	
            This method doesn't return an error code if it fails. To determine whether a drawing operation (such as {{FillRoundedRectangle}}) failed, check the result returned by the <see cref="M:SharpDX.Direct2D1.RenderTarget.EndDraw(System.Int64@,System.Int64@)" /> or <see cref="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)" /> methods.  	
            </remarks>	
            <param name="roundedRect">The dimensions of the rounded rectangle to paint, in device-independent pixels. </param>
            <param name="brush">The brush used to paint the interior of the rounded rectangle. </param>
            <unmanaged>void ID2D1RenderTarget::FillRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.Flush">
            <summary>	
            Executes all pending drawing commands. 	
            </summary>	
            <remarks>	
            This command does not flush the device that is associated with the render target.   Calling this method resets the error state of the render target. 	
            </remarks>	
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code and sets tag1 and tag2 to the tags that were active when the error occurred. If no error occurred, this method sets the error tag state to be (0,0). </returns>
            <unmanaged>HRESULT ID2D1RenderTarget::Flush([Out, Optional] D2D1_TAG* tag1,[Out, Optional] D2D1_TAG* tag2)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.DotsPerInch">
            <summary>	
            Get or sets the dots per inch (DPI) of the render target. 	
            </summary>	
            <remarks>	
            This method specifies the mapping from pixel space to device-independent space  for the render target.  If both dpiX and dpiY are 0, the factory-read system DPI is chosen. If one parameter is zero and the other unspecified, the DPI is not changed. For <see cref="T:SharpDX.Direct2D1.WindowRenderTarget"/>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.   	
            </remarks>	
            <unmanaged>void ID2D1RenderTarget::SetDpi([None] float dpiX,[None] float dpiY)</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.Transform">
            <summary>
            <p>Gets or sets the current transform of the render target. </p>
            </summary>
            <doc-id>dd316845</doc-id>
            <unmanaged>GetTransform / SetTransform</unmanaged>
            <unmanaged-short>GetTransform</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.AntialiasMode">
            <summary>
            <p>Retrieves or sets the current antialiasing mode for nontext drawing operations.</p>
            </summary>
            <doc-id>dd316805</doc-id>
            <unmanaged>GetAntialiasMode / SetAntialiasMode</unmanaged>
            <unmanaged-short>GetAntialiasMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.TextAntialiasMode">
            <summary>
            <p>Gets or sets the current antialiasing mode for text and glyph drawing operations. </p>
            </summary>
            <doc-id>dd316835</doc-id>
            <unmanaged>GetTextAntialiasMode / SetTextAntialiasMode</unmanaged>
            <unmanaged-short>GetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.TextRenderingParams">
            <summary>
            <p>Retrieves or sets the render target's current text rendering options. </p>
            </summary>
            <remarks>
            <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>
            </remarks>
            <doc-id>dd316841</doc-id>
            <unmanaged>GetTextRenderingParams / SetTextRenderingParams</unmanaged>
            <unmanaged-short>GetTextRenderingParams</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.PixelFormat">
            <summary>
            <p>Retrieves the pixel format and alpha mode of the render target. </p>
            </summary>
            <doc-id>dd316814</doc-id>
            <unmanaged>GetPixelFormat</unmanaged>
            <unmanaged-short>GetPixelFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.Size">
            <summary>
            <p>Returns the size of the render target in device-independent pixels.</p>
            </summary>
            <doc-id>dd316823</doc-id>
            <unmanaged>GetSize</unmanaged>
            <unmanaged-short>GetSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.PixelSize">
            <summary>
            <p>Returns the size of the render target in device pixels.</p>
            </summary>
            <doc-id>dd316820</doc-id>
            <unmanaged>GetPixelSize</unmanaged>
            <unmanaged-short>GetPixelSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderTarget.MaximumBitmapSize">
            <summary>
            <p>Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.</p>
            </summary>
            <remarks>
            <p>This method returns the maximum texture size of the Direct3D device.</p><strong>Note</strong>??The software renderer and WARP devices return the value of 16 megapixels (16*1024*1024).  You can create a Direct2D texture that is this size, but not a Direct3D texture that is this size.?
            </remarks>
            <doc-id>dd742853</doc-id>
            <unmanaged>GetMaximumBitmapSize</unmanaged>
            <unmanaged-short>GetMaximumBitmapSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateBitmap(SharpDX.Size2,System.IntPtr,System.Int32,SharpDX.Direct2D1.BitmapProperties,SharpDX.Direct2D1.Bitmap)">
            <summary>
            <p>Creates a Direct2D bitmap from a reference to in-memory source data.</p>
            </summary>
            <param name = "size"><dd>  <p>The dimension of the bitmap to create in pixels.</p> </dd></param>
            <param name = "srcData"><dd>  <p>A reference to the memory location of the image data, or <strong><c>null</c></strong> to create an uninitialized bitmap.</p> </dd></param>
            <param name = "pitch"><dd>  <p>The byte count of each scanline, which is equal to (the image width in pixels ? the number of bytes per pixel) + memory padding. If <em>srcData</em> is <strong><c>null</c></strong>, this value is ignored. (Note that pitch is also sometimes called <em>stride</em>.)</p> </dd></param>
            <param name = "bitmapProperties"><dd>  <p>The pixel format and dots per inch (DPI) of the bitmap to create.</p> </dd></param>
            <param name = "bitmap"><dd>  <p>When this method returns, contains a reference to a reference to the new bitmap. This parameter is passed uninitialized.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371800</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateBitmapFromWicBitmap(SharpDX.WIC.BitmapSource,System.Nullable{SharpDX.Direct2D1.BitmapProperties},SharpDX.Direct2D1.Bitmap@)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.Bitmap"/></strong> by copying the specified Microsoft Windows Imaging Component (WIC)   bitmap.</p>
            </summary>
            <param name = "wicBitmapSource">No documentation.</param>
            <param name = "bitmapProperties">No documentation.</param>
            <param name = "bitmap">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Before Direct2D can load a WIC bitmap, that bitmap must be converted to a supported pixel format and alpha mode. For a list of supported pixel formats and alpha modes, see Supported Pixel Formats and Alpha Modes. </p>
            </remarks>
            <doc-id>dd371797</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateBitmapFromWicBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateSharedBitmap(System.Guid,System.IntPtr,System.Nullable{SharpDX.Direct2D1.BitmapProperties},SharpDX.Direct2D1.Bitmap)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.Bitmap"/></strong> whose data is shared with another resource.</p>
            </summary>
            <param name = "riid">No documentation.</param>
            <param name = "data">No documentation.</param>
            <param name = "bitmapProperties">No documentation.</param>
            <param name = "bitmap">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong>CreateSharedBitmap</strong> method is useful for efficiently reusing bitmap data and can also be used to provide interoperability with Direct3D. </p>
            </remarks>
            <doc-id>dd371865</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateBitmapBrush(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Direct2D1.BitmapBrushProperties},System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.BitmapBrush)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> from the specified bitmap.</p>
            </summary>
            <param name = "bitmap">No documentation.</param>
            <param name = "bitmapBrushProperties">No documentation.</param>
            <param name = "brushProperties">No documentation.</param>
            <param name = "bitmapBrush">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371788</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In, Optional] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateBitmapBrush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateSolidColorBrush(SharpDX.Mathematics.Interop.RawColor4,System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.SolidColorBrush)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.Direct2D1.SolidColorBrush"/></strong> that has the specified color and a base opacity of 1.0f.  </p>
            </summary>
            <param name = "color">No documentation.</param>
            <param name = "brushProperties">No documentation.</param>
            <param name = "solidColorBrush">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371871</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateSolidColorBrush([In] const D2D_COLOR_F* color,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1SolidColorBrush** solidColorBrush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateSolidColorBrush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateGradientStopCollection(SharpDX.Direct2D1.GradientStop[],System.Int32,SharpDX.Direct2D1.Gamma,SharpDX.Direct2D1.ExtendMode,SharpDX.Direct2D1.GradientStopCollection)">
            <summary>
            <p> Creates an <strong><see cref = "T:SharpDX.Direct2D1.GradientStopCollection"/></strong> from the specified gradient stops that uses the <strong>D2D1_GAMMA_2_2</strong> color interpolation gamma and the clamp extend mode.</p>
            </summary>
            <param name = "gradientStops">No documentation.</param>
            <param name = "gradientStopsCount">No documentation.</param>
            <param name = "colorInterpolationGamma">No documentation.</param>
            <param name = "extendMode">No documentation.</param>
            <param name = "gradientStopCollection">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371832</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount,[In] D2D1_GAMMA colorInterpolationGamma,[In] D2D1_EXTEND_MODE extendMode,[Out, Fast] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateGradientStopCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateLinearGradientBrush(SharpDX.Direct2D1.LinearGradientBrushProperties,System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.GradientStopCollection,SharpDX.Direct2D1.LinearGradientBrush)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrush"/></strong> that contains the specified gradient stops, has no transform, and has a base opacity of 1.0. </p>
            </summary>
            <param name = "linearGradientBrushProperties">No documentation.</param>
            <param name = "brushProperties">No documentation.</param>
            <param name = "gradientStopCollection">No documentation.</param>
            <param name = "linearGradientBrush">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371845</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateLinearGradientBrush([In] const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out, Fast] ID2D1LinearGradientBrush** linearGradientBrush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateLinearGradientBrush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateRadialGradientBrush(SharpDX.Direct2D1.RadialGradientBrushProperties@,System.Nullable{SharpDX.Direct2D1.BrushProperties},SharpDX.Direct2D1.GradientStopCollection,SharpDX.Direct2D1.RadialGradientBrush)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.RadialGradientBrush"/></strong> that contains the specified gradient stops, has no transform, and has a base opacity of 1.0. </p>
            </summary>
            <param name = "radialGradientBrushProperties">No documentation.</param>
            <param name = "brushProperties">No documentation.</param>
            <param name = "gradientStopCollection">No documentation.</param>
            <param name = "radialGradientBrush">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371859</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out, Fast] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateRadialGradientBrush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateCompatibleRenderTarget(System.Nullable{SharpDX.Size2F},System.Nullable{SharpDX.Size2},System.Nullable{SharpDX.Direct2D1.PixelFormat},SharpDX.Direct2D1.CompatibleRenderTargetOptions,SharpDX.Direct2D1.BitmapRenderTarget)">
            <summary>
            <p> Creates a new  bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target and has the same size, DPI, and pixel format (but not alpha mode) as the current render target.  </p>
            </summary>
            <param name = "desiredSize"><dd>  <p>When this method returns, contains a reference to a reference to a new bitmap render target. This parameter is passed uninitialized.</p> </dd></param>
            <param name = "desiredPixelSize">No documentation.</param>
            <param name = "desiredFormat">No documentation.</param>
            <param name = "options">No documentation.</param>
            <param name = "bitmapRenderTarget">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The bitmap render target created by this method is not compatible with GDI and has an alpha mode of  <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong>.</p>
            </remarks>
            <doc-id>dd371825</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateCompatibleRenderTarget([In, Optional] const D2D_SIZE_F* desiredSize,[In, Optional] const D2D_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[In] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out, Fast] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateCompatibleRenderTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateLayer(System.Nullable{SharpDX.Size2F},SharpDX.Direct2D1.Layer)">
            <summary>
            <p>Creates a layer resource that can be used with this render target and its compatible render targets. The new layer has the specified initial size.  </p>
            </summary>
            <param name = "size"><dd>  <p>If (0, 0) is specified, no backing store is created behind the layer resource. The layer resource is allocated to the minimum size when <strong>PushLayer</strong> is called.</p> </dd></param>
            <param name = "layer"><dd>  <p>When the method returns, contains a reference to a reference to the new layer. This parameter is passed uninitialized.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Regardless of whether a size is initially specified, the layer automatically resizes as needed.</p>
            </remarks>
            <doc-id>dd371835</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateLayer([In, Optional] const D2D_SIZE_F* size,[Out, Fast] ID2D1Layer** layer)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateLayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.CreateMesh(SharpDX.Direct2D1.Mesh)">
            <summary>
            <p>Create a mesh that uses triangles to describe a shape.</p>
            </summary>
            <param name = "mesh"><dd>  <p>When this method returns, contains a reference to a reference to the new mesh.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To populate a mesh, use its <strong>Open</strong> method to obtain an <strong><see cref = "T:SharpDX.Direct2D1.TessellationSink"/></strong>. To draw the mesh, use the render target's <strong>FillMesh</strong> method.</p>
            </remarks>
            <doc-id>dd371851</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::CreateMesh([Out, Fast] ID2D1Mesh** mesh)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::CreateMesh</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawLine(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Draws a line between the specified points using the specified stroke style. </p>
            </summary>
            <param name = "point0"><dd>  <p>The start point of the line, in device-independent pixels.</p> </dd></param>
            <param name = "point1"><dd>  <p>The end point of the line, in device-independent pixels.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the line's stroke.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of stroke to paint, or <strong><c>null</c></strong> to paint a solid line.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawLine</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371895</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawLine</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Draws the outline of a rectangle that has the specified dimensions and stroke style. </p>
            </summary>
            <param name = "rect"><dd>  <p>The dimensions of the rectangle to draw, in device-independent pixels.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the rectangle's stroke.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of stroke to paint, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>
            <remarks>
            <p>When this method fails, it does not return an error code. To determine whether a drawing method (such as <strong>DrawRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> method. </p>
            </remarks>
            <doc-id>dd371902</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillRectangle(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Paints the interior of the specified rectangle. </p>
            </summary>
            <param name = "rect"><dd>  <p>The dimension of the rectangle to paint, in device-independent pixels.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the rectangle's interior.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371954</doc-id>
            <unmanaged>void ID2D1RenderTarget::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::FillRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawRoundedRectangle(SharpDX.Direct2D1.RoundedRectangle@,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p> Draws the outline of the specified rounded rectangle using the specified stroke style.</p>
            </summary>
            <param name = "roundedRect"><dd>  <p>The dimensions of the rounded rectangle to draw, in device-independent pixels.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the rounded rectangle's outline. </p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of the rounded rectangle's stroke, or <strong><c>null</c></strong> to paint a solid stroke. The default value is <strong><c>null</c></strong>.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawRoundedRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371908</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawRoundedRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillRoundedRectangle(SharpDX.Direct2D1.RoundedRectangle@,SharpDX.Direct2D1.Brush)">
            <summary>
            <p> Paints the interior of the specified rounded rectangle.</p>
            </summary>
            <param name = "roundedRect"><dd>  <p>The dimensions of the rounded rectangle to paint, in device-independent pixels.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the interior of the rounded rectangle.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillRoundedRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371959</doc-id>
            <unmanaged>void ID2D1RenderTarget::FillRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::FillRoundedRectangle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawEllipse(SharpDX.Direct2D1.Ellipse,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Draws the outline of the specified ellipse using the specified stroke style. </p>
            </summary>
            <param name = "ellipse"><dd>  <p>The position and radius of the ellipse to draw, in device-independent pixels.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the ellipse's outline.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of stroke to apply to the ellipse's outline, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>
            <remarks>
            <p>The <strong>DrawEllipse</strong> method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawEllipse</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371886</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawEllipse</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillEllipse(SharpDX.Direct2D1.Ellipse,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Paints the interior of the specified ellipse. </p>
            </summary>
            <param name = "ellipse"><dd>  <p>The position and radius, in device-independent pixels, of the ellipse to paint.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the interior of the ellipse.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillEllipse</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371928</doc-id>
            <unmanaged>void ID2D1RenderTarget::FillEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::FillEllipse</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,System.Single,SharpDX.Direct2D1.StrokeStyle)">
            <summary>
            <p>Draws the outline of the specified geometry using the specified stroke style. </p>
            </summary>
            <param name = "geometry"><dd>  <p>The geometry to draw.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the geometry's stroke.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
            <param name = "strokeStyle"><dd>  <p>The style of stroke to apply to the geometry's outline, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawGeometry</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371890</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillGeometry(SharpDX.Direct2D1.Geometry,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Paints the interior of the specified geometry. </p>
            </summary>
            <param name = "geometry"><dd>  <p>The geometry to paint.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the geometry's interior.</p> </dd></param>
            <param name = "opacityBrush"><dd>  <p>The opacity mask to apply to the geometry, or <strong><c>null</c></strong> for no opacity mask. If an opacity mask (the <em>opacityBrush</em> parameter) is specified, <em>brush</em> must be an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> that has   its x- and y-extend modes set to <strong>D2D1_EXTEND_MODE_CLAMP</strong>. For more information, see the Remarks section. </p> </dd></param>
            <remarks>
            <p>If the <em>opacityBrush</em> parameter is not <strong><c>null</c></strong>, the alpha value of each pixel of the mapped <em>opacityBrush</em> is used to determine the resulting opacity of each corresponding pixel of the geometry. Only the alpha value of each color in the brush is used for this processing; all other color information is ignored.  The alpha value specified by the brush is multiplied by the alpha value of the geometry after the geometry has been painted by <em>brush</em>.  
            </p><p>When this method fails, it does not return an error code. To determine whether a drawing operation (such as <strong>FillGeometry</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> method. </p>
            </remarks>
            <doc-id>dd371933</doc-id>
            <unmanaged>void ID2D1RenderTarget::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::FillGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillMesh(SharpDX.Direct2D1.Mesh,SharpDX.Direct2D1.Brush)">
            <summary>
            <p> Paints the interior of the specified mesh.</p>
            </summary>
            <param name = "mesh"><dd>  <p>The mesh to paint.</p> </dd></param>
            <param name = "brush"><dd>  <p>The brush used to paint the mesh.</p> </dd></param>
            <remarks>
            <p>The current antialias mode of the render target must be <strong>D2D1_ANTIALIAS_MODE_ALIASED</strong> when <strong>FillMesh</strong> is called. To change the render target's antialias mode, use the <strong>SetAntialiasMode</strong> method.</p><p><strong>FillMesh</strong> does not expect a particular winding order for the triangles in the <strong><see cref = "T:SharpDX.Direct2D1.Mesh"/></strong>; both clockwise and counter-clockwise will work. </p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillMesh</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371939</doc-id>
            <unmanaged>void ID2D1RenderTarget::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::FillMesh</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.FillOpacityMask(SharpDX.Direct2D1.Bitmap,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.OpacityMaskContent,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>
            Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.
            </summary>
            <param name = "opacityMask">No documentation.</param>
            <param name = "brush">No documentation.</param>
            <param name = "content">No documentation.</param>
            <param name = "destinationRectangle">No documentation.</param>
            <param name = "sourceRectangle">No documentation.</param>
            <remarks>
            <p>For this method to work properly, the render target must be using the <strong>D2D1_ANTIALIAS_MODE_ALIASED</strong> antialiasing mode. You can set the antialiasing mode by calling the <strong>ID2D1RenderTarget::SetAntialiasMode</strong> method.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillOpacityMask</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd742850</doc-id>
            <unmanaged>void ID2D1RenderTarget::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In] D2D1_OPACITY_MASK_CONTENT content,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::FillOpacityMask</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawBitmap(SharpDX.Direct2D1.Bitmap,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF},System.Single,SharpDX.Direct2D1.BitmapInterpolationMode,System.Nullable{SharpDX.Mathematics.Interop.RawRectangleF})">
            <summary>
            <p>Draws the specified bitmap after scaling it to the size of the specified rectangle. </p>
            </summary>
            <param name = "bitmap"><dd>  <p>The bitmap to render.</p> </dd></param>
            <param name = "destinationRectangle"><dd>  <p>The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn. If the rectangle is not well-ordered, nothing is drawn, but the render target does not enter an error state.</p> </dd></param>
            <param name = "opacity"><dd>  <p>A value between 0.0f and 1.0f, inclusive, that specifies the opacity value to be applied to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  Default is 1.0f.</p> </dd></param>
            <param name = "interpolationMode"><dd>  <p>The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong>. </p> </dd></param>
            <param name = "sourceRectangle"><dd>  <p>The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to draw; <strong><c>null</c></strong> to draw the entire bitmap.</p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawBitmap</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371878</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawText(System.String,System.Int32,SharpDX.DirectWrite.TextFormat,SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.DrawTextOptions,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p>Draws the specified text using the format information provided by an <strong><see cref = "T:SharpDX.DirectWrite.TextFormat"/></strong> object.</p>
            </summary>
            <param name = "text">No documentation.</param>
            <param name = "stringLength">No documentation.</param>
            <param name = "textFormat">No documentation.</param>
            <param name = "layoutRect">No documentation.</param>
            <param name = "defaultFillBrush">No documentation.</param>
            <param name = "options">No documentation.</param>
            <param name = "measuringMode">No documentation.</param>
            <remarks>
            <p>To create an <strong><see cref = "T:SharpDX.DirectWrite.TextFormat"/></strong> object, create an <strong><see cref = "T:SharpDX.DirectWrite.Factory"/></strong> and call its <strong>CreateTextFormat</strong> method.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawText</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371919</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawTextW([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D_RECT_F* layoutRect,[In] ID2D1Brush* defaultFillBrush,[In] D2D1_DRAW_TEXT_OPTIONS options,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawTextW</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawTextLayout(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.TextLayout,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.DrawTextOptions)">
            <summary>
            <p>Draws the formatted text described by the specified <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> object.</p>
            </summary>
            <param name = "origin">No documentation.</param>
            <param name = "textLayout">No documentation.</param>
            <param name = "defaultFillBrush">No documentation.</param>
            <param name = "options">No documentation.</param>
            <remarks>
            <p>When drawing the same text repeatedly, using the <strong>DrawTextLayout</strong> method is more efficient than using the <strong>DrawText</strong> method because the text doesn't need to be formatted and the layout processed with each call.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawTextLayout</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371913</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawTextLayout([In] D2D_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In] ID2D1Brush* defaultFillBrush,[In] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawTextLayout</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.MeasuringMode)">
            <summary>
            <p>Draws the specified glyphs. </p>
            </summary>
            <param name = "baselineOrigin"><dd>  <p>The origin, in device-independent pixels, of the glyphs' baseline.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
            <param name = "foregroundBrush"><dd>  <p>The brush used to paint the specified glyphs.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>A value that indicates how glyph metrics are used to measure text when it is formatted.  The default value is <strong>DWRITE_MEASURING_MODE_NATURAL</strong>. </p> </dd></param>
            <remarks>
            <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawGlyphRun</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd371893</doc-id>
            <unmanaged>void ID2D1RenderTarget::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::DrawGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SetTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.
            </summary>
            <param name = "transform">No documentation.</param>
            <doc-id>dd742857</doc-id>
            <unmanaged>void ID2D1RenderTarget::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Gets the current transform of the render target. </p>
            </summary>
            <param name = "transform"><dd>  <p>When this returns, contains the current transform of the render target. This parameter is passed uninitialized.</p> </dd></param>
            <doc-id>dd316845</doc-id>
            <unmanaged>void ID2D1RenderTarget::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SetAntialiasMode(SharpDX.Direct2D1.AntialiasMode)">
            <summary>
            <p>Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations. </p>
            </summary>
            <param name = "antialiasMode"><dd>  <p>The antialiasing mode for future drawing operations. </p> </dd></param>
            <remarks>
            <p>To specify the antialiasing mode for text and glyph operations, use the <strong>SetTextAntialiasMode</strong> method. </p>
            </remarks>
            <doc-id>dd316881</doc-id>
            <unmanaged>void ID2D1RenderTarget::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SetAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetAntialiasMode">
            <summary>
            <p> Retrieves the current antialiasing mode for nontext drawing operations.</p>
            </summary>
            <returns><p>The current antialiasing mode for nontext drawing operations. </p></returns>
            <doc-id>dd316805</doc-id>
            <unmanaged>D2D1_ANTIALIAS_MODE ID2D1RenderTarget::GetAntialiasMode()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SetTextAntialiasMode(SharpDX.Direct2D1.TextAntialiasMode)">
            <summary>
            <p>Specifies the antialiasing mode to use for subsequent text and glyph drawing operations. </p>
            </summary>
            <param name = "textAntialiasMode"><dd>  <p>The antialiasing mode to use for subsequent text and glyph drawing operations.</p> </dd></param>
            <doc-id>dd316897</doc-id>
            <unmanaged>void ID2D1RenderTarget::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetTextAntialiasMode">
            <summary>
            <p>Gets the current antialiasing mode for text and glyph drawing operations. </p>
            </summary>
            <returns><p>The current antialiasing mode for text and glyph drawing operations. </p></returns>
            <doc-id>dd316835</doc-id>
            <unmanaged>D2D1_TEXT_ANTIALIAS_MODE ID2D1RenderTarget::GetTextAntialiasMode()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p>Specifies text rendering options to be applied to all subsequent text and glyph drawing operations. </p>
            </summary>
            <param name = "textRenderingParams"><dd>  <p>The text rendering options to be applied to all subsequent text and glyph drawing operations; <strong><c>null</c></strong> to clear current text rendering options. </p> </dd></param>
            <remarks>
            <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>
            </remarks>
            <doc-id>dd316898</doc-id>
            <unmanaged>void ID2D1RenderTarget::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SetTextRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetTextRenderingParams(SharpDX.DirectWrite.RenderingParams@)">
            <summary>
            <p>Retrieves the render target's current text rendering options. </p>
            </summary>
            <param name = "textRenderingParams"><dd>  <p> When this method returns, <em>textRenderingParams</em>contains the address  of a reference to the render target's current text rendering options. </p> </dd></param>
            <remarks>
            <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>
            </remarks>
            <doc-id>dd316841</doc-id>
            <unmanaged>void ID2D1RenderTarget::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetTextRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SetTags(System.Int64,System.Int64)">
            <summary>
            <p>Specifies a label for subsequent drawing operations.   </p>
            </summary>
            <param name = "tag1"><dd>  <p>A label to apply to subsequent drawing operations.</p> </dd></param>
            <param name = "tag2"><dd>  <p>A label to apply to subsequent drawing operations.</p> </dd></param>
            <remarks>
            <p>The labels specified by this method are printed by debug error messages. If no tag is set, the default value for each tag is 0.</p>
            </remarks>
            <doc-id>dd316892</doc-id>
            <unmanaged>void ID2D1RenderTarget::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SetTags</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetTags(System.Int64@,System.Int64@)">
            <summary>
            <p>Gets the label for subsequent drawing operations. </p>
            </summary>
            <param name = "tag1"><dd>  <p>When this method returns, contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If <strong><c>null</c></strong> is specified, no value is retrieved for this parameter. </p> </dd></param>
            <param name = "tag2"><dd>  <p>When this method returns, contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If <strong><c>null</c></strong> is specified, no value is retrieved for this parameter.</p> </dd></param>
            <remarks>
            <p>If the same address is passed for both parameters, both parameters receive the value of the second tag. </p>
            </remarks>
            <doc-id>dd316830</doc-id>
            <unmanaged>void ID2D1RenderTarget::GetTags([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetTags</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.PushLayer(SharpDX.Direct2D1.LayerParameters@,SharpDX.Direct2D1.Layer)">
            <summary>
            <p>Adds the specified layer to the render target so that it receives all subsequent drawing operations until <strong>PopLayer</strong> is called. </p>
            </summary>
            <param name = "layerParameters">No documentation.</param>
            <param name = "layer">No documentation.</param>
            <remarks>
            <p>The <strong>PushLayer</strong> method allows a caller to begin redirecting rendering to a layer. All rendering operations are valid in a layer. The location of the layer is affected by the world transform set on the render target. </p><p>Each <strong>PushLayer</strong> must have a matching <strong>PopLayer</strong> call. If there are more <strong>PopLayer</strong> calls than <strong>PushLayer</strong> calls, the render target is placed into an error state. If <strong>Flush</strong> is called before all outstanding layers are popped, the render target is placed into an error state, and an error is returned. The error state can be cleared by a call to <strong>EndDraw</strong>.</p><p>A particular <strong><see cref = "T:SharpDX.Direct2D1.Layer"/></strong> resource can be active only at one time. In other words, you cannot call a <strong>PushLayer</strong> method, and then immediately follow  with another <strong>PushLayer</strong> method with the same layer resource. Instead, you must call the second <strong>PushLayer</strong> method with different layer resources. 
            </p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PushLayer</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd316869</doc-id>
            <unmanaged>void ID2D1RenderTarget::PushLayer([In] const D2D1_LAYER_PARAMETERS* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::PushLayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.PopLayer">
            <summary>
            <p>Stops redirecting drawing operations to the layer that is specified by the last <strong>PushLayer</strong> call. </p>
            </summary>
            <remarks>
            <p>A <strong>PopLayer</strong> must match a previous <strong>PushLayer</strong> call.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PopLayer</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd316852</doc-id>
            <unmanaged>void ID2D1RenderTarget::PopLayer()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::PopLayer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.Flush(System.Int64@,System.Int64@)">
            <summary>
            <p>Executes all pending drawing commands. </p>
            </summary>
            <param name = "tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
            <param name = "tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. If no error occurred, this method sets the error tag state to be (0,0).</p></returns>
            <remarks>
            <p>This command does not flush the Direct3D device context that is associated with the render target.</p><p>Calling this method resets the error state of the render target.</p>
            </remarks>
            <doc-id>dd316801</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::Flush([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SaveDrawingState(SharpDX.Direct2D1.DrawingStateBlock)">
            <summary>
            <p>Saves the current drawing state to the specified <strong><see cref = "T:SharpDX.Direct2D1.DrawingStateBlock"/></strong>.</p>
            </summary>
            <param name = "drawingStateBlock">No documentation.</param>
            <doc-id>dd316876</doc-id>
            <unmanaged>void ID2D1RenderTarget::SaveDrawingState([InOut] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SaveDrawingState</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.RestoreDrawingState(SharpDX.Direct2D1.DrawingStateBlock)">
            <summary>
            <p>Sets the render target's drawing state to that of the specified <strong><see cref = "T:SharpDX.Direct2D1.DrawingStateBlock"/></strong>.</p>
            </summary>
            <param name = "drawingStateBlock">No documentation.</param>
            <doc-id>dd316872</doc-id>
            <unmanaged>void ID2D1RenderTarget::RestoreDrawingState([In] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::RestoreDrawingState</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.PushAxisAlignedClip(SharpDX.Mathematics.Interop.RawRectangleF,SharpDX.Direct2D1.AntialiasMode)">
            <summary>
            <p>Specifies a rectangle to which all subsequent drawing operations are clipped. </p>
            </summary>
            <param name = "clipRect"><dd>  <p>The size and position of the clipping area, in device-independent pixels.</p> </dd></param>
            <param name = "antialiasMode"><dd>  <p>The antialiasing mode that is used to draw the edges of clip rects that have subpixel boundaries, and to blend the clip with the scene contents. The blending is performed once when the <strong>PopAxisAlignedClip</strong> method is called, and does not apply to each primitive within the layer. </p> </dd></param>
            <remarks>
            <p>The <em>clipRect</em> is transformed by the current world transform set on the render target. After the transform is applied to the <em>clipRect</em> that is passed in, the axis-aligned bounding box for the <em>clipRect</em> is computed.  For efficiency, the contents are clipped to this axis-aligned bounding box and not to the original <em>clipRect</em> that is passed in. </p><p>The following diagrams show how a rotation transform is applied to the render target, the resulting <em>clipRect</em>, and  a calculated axis-aligned bounding box.</p><ol> <li> <p>Assume the rectangle in the following illustration is a render target that is aligned to the screen pixels.</p> <p></p> </li> <li> <p>Apply a rotation transform to the render target. In the following illustration, the black rectangle represents the original render target and the red dashed rectangle represents the transformed render target.</p> <p></p> </li> <li> <p>After calling <strong>PushAxisAlignedClip</strong>, the rotation transform is applied to the <em>clipRect</em>. In the following illustration, the blue rectangle represents the transformed <em>clipRect</em>.</p> <p></p> </li> <li> <p>The axis-aligned bounding box is calculated. The green dashed rectangle represents the bounding box in the following illustration. All contents are clipped to this axis-aligned bounding box.</p> <p></p> </li> </ol><strong>Note</strong>??If rendering operations fail or if <strong>PopAxisAlignedClip</strong> is not called, clip rects may cause some artifacts on the render target. <strong>PopAxisAlignedClip</strong> can be considered a drawing operation that is designed to fix the borders of a clipping region. Without this call, the borders of a clipped area may be not antialiased or otherwise corrected.?<p>The <strong>PushAxisAlignedClip</strong> and <strong>PopAxisAlignedClip</strong> must match. Otherwise, the error state is set. For the render target to continue receiving new commands, you can call <strong>Flush</strong> to clear the error. </p><p>A           <strong>PushAxisAlignedClip</strong> and <strong>PopAxisAlignedClip</strong> pair can occur around or within a PushLayer and PopLayer, but cannot overlap. For example, the sequence of <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopLayer</strong>, <strong>PopAxisAlignedClip</strong> is valid, but the sequence of <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopAxisAlignedClip</strong>, <strong>PopLayer</strong> is invalid.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PushAxisAlignedClip</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd316860</doc-id>
            <unmanaged>void ID2D1RenderTarget::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::PushAxisAlignedClip</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.PopAxisAlignedClip">
            <summary>
            <p>Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations. </p>
            </summary>
            <remarks>
            <p>A <strong>PushAxisAlignedClip</strong>/<strong>PopAxisAlignedClip</strong> pair can occur around or within a <strong>PushLayer</strong>/<strong>PopLayer</strong> pair, but may not overlap. For example, a <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopLayer</strong>, <strong>PopAxisAlignedClip</strong> sequence is valid, but a <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopAxisAlignedClip</strong>, <strong>PopLayer</strong> sequence is not. </p><p><strong>PopAxisAlignedClip</strong> must be called once for every call to <strong>PushAxisAlignedClip</strong>.</p><p>For an example, see How to Clip with an Axis-Aligned Clip Rectangle.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PopAxisAlignedClip</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
            </remarks>
            <doc-id>dd316850</doc-id>
            <unmanaged>void ID2D1RenderTarget::PopAxisAlignedClip()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::PopAxisAlignedClip</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.Clear(System.Nullable{SharpDX.Mathematics.Interop.RawColor4})">
            <summary>
            <p>Clears the drawing area to the specified color. </p>
            </summary>
            <param name = "clearColor"><dd>  <p>The color to which the drawing area is cleared, or <strong><c>null</c></strong> for transparent black.</p> </dd></param>
            <remarks>
            <p>Direct2D interprets the <em>clearColor</em> as straight alpha (not premultiplied).  If the render target's alpha mode is <strong>D2D1_ALPHA_MODE_IGNORE</strong>, the alpha channel of <em>clearColor</em> is ignored and replaced with 1.0f (fully opaque).</p><p>If the render target has an active clip (specified by <strong>PushAxisAlignedClip</strong>), the clear command is applied only to the area within the clip region.</p>
            </remarks>
            <doc-id>dd371769</doc-id>
            <unmanaged>void ID2D1RenderTarget::Clear([In, Optional] const D2D_COLOR_F* clearColor)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::Clear</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.BeginDraw">
            <summary>
            <p>Initiates drawing on this render target. </p>
            </summary>
            <remarks>
            <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p>BeginDraw and EndDraw are used to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The BeginDraw method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <see cref = "T:SharpDX.Result"/> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <see cref = "T:SharpDX.Result"/>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <see cref = "T:SharpDX.Result"/> and error information when <strong>EndDraw</strong> is called.
            </p>
            </remarks>
            <doc-id>dd371768</doc-id>
            <unmanaged>void ID2D1RenderTarget::BeginDraw()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::BeginDraw</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.TryEndDraw(System.Int64@,System.Int64@)">
            <summary>
            <p>Ends drawing operations  on the render target and indicates the current error state and associated tags. </p>
            </summary>
            <param name = "tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
            <param name = "tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. </p></returns>
            <remarks>
            <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p> <strong>BeginDraw</strong> and <strong>EndDraw</strong> are use to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref = "T:SharpDX.Direct2D1.BitmapRenderTarget"/></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The <strong>BeginDraw</strong> method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <strong><see cref = "T:SharpDX.Result"/></strong> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <strong><see cref = "T:SharpDX.Result"/></strong>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <strong><see cref = "T:SharpDX.Result"/></strong> and error information when <strong>EndDraw</strong> is called.
            </p>
            </remarks>
            <doc-id>dd371924</doc-id>
            <unmanaged>HRESULT ID2D1RenderTarget::EndDraw([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::EndDraw</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetPixelFormat">
            <summary>
            <p>Retrieves the pixel format and alpha mode of the render target. </p>
            </summary>
            <returns><p>The pixel format and alpha mode of the render target.</p></returns>
            <doc-id>dd316814</doc-id>
            <unmanaged>D2D1_PIXEL_FORMAT ID2D1RenderTarget::GetPixelFormat()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.SetDpi(System.Single,System.Single)">
            <summary>
            <p>Sets the dots per inch (DPI) of the render target. </p>
            </summary>
            <param name = "dpiX"><dd>  <p>A value greater than or equal to zero that specifies the horizontal DPI of the render target.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>A value greater than or equal to zero that specifies the vertical DPI of the render target.</p> </dd></param>
            <remarks>
            <p>This method specifies the mapping from pixel space to device-independent space  for the render target.  If both <em>dpiX</em> and <em>dpiY</em> are 0, the factory-read system DPI is chosen. If one parameter is zero and the other unspecified, the DPI is not changed.</p><p>For <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  </p>
            </remarks>
            <doc-id>dd316887</doc-id>
            <unmanaged>void ID2D1RenderTarget::SetDpi([In] float dpiX,[In] float dpiY)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::SetDpi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetDpi(System.Single@,System.Single@)">
            <summary>
            <p>Return the render target's dots per inch (DPI).</p>
            </summary>
            <param name = "dpiX"><dd>  <p>When this method returns, contains the horizontal DPI of the render target. This parameter is passed uninitialized.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>When this method returns, contains the vertical DPI of the render target. This parameter is passed uninitialized.</p> </dd></param>
            <remarks>
            <p>This method indicates the mapping from pixel space to device-independent space  for the render target.  </p><p>For <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  </p>
            </remarks>
            <doc-id>dd316809</doc-id>
            <unmanaged>void ID2D1RenderTarget::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetDpi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetSize">
            <summary>
            <p>Returns the size of the render target in device-independent pixels.</p>
            </summary>
            <returns><p>The current size of the render target in device-independent pixels.</p></returns>
            <doc-id>dd316823</doc-id>
            <unmanaged>D2D_SIZE_F ID2D1RenderTarget::GetSize()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetPixelSize">
            <summary>
            <p>Returns the size of the render target in device pixels.</p>
            </summary>
            <returns><p>The size of the render target in device pixels.</p></returns>
            <doc-id>dd316820</doc-id>
            <unmanaged>D2D_SIZE_U ID2D1RenderTarget::GetPixelSize()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetPixelSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.GetMaximumBitmapSize">
            <summary>
            <p>Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.</p>
            </summary>
            <returns><p> The maximum size, in pixels, of  any one bitmap dimension supported by the render target.</p></returns>
            <remarks>
            <p>This method returns the maximum texture size of the Direct3D device.</p><strong>Note</strong>??The software renderer and WARP devices return the value of 16 megapixels (16*1024*1024).  You can create a Direct2D texture that is this size, but not a Direct3D texture that is this size.?
            </remarks>
            <doc-id>dd742853</doc-id>
            <unmanaged>unsigned int ID2D1RenderTarget::GetMaximumBitmapSize()</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::GetMaximumBitmapSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTarget.IsSupported(SharpDX.Direct2D1.RenderTargetProperties@)">
            <summary>
            <p>Indicates whether the render target supports the specified properties.</p>
            </summary>
            <param name = "renderTargetProperties"><dd>  <p>The render target properties to test.</p> </dd></param>
            <returns><p><strong>TRUE</strong> if the specified render target properties are supported by this render target; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <remarks>
            <p>This method does not evaluate the DPI settings specified by the <em>renderTargetProperties</em> parameter.</p>
            </remarks>
            <doc-id>dd742854</doc-id>
            <unmanaged>BOOL ID2D1RenderTarget::IsSupported([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties)</unmanaged>
            <unmanaged-short>ID2D1RenderTarget::IsSupported</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RenderTargetProperties">
            <summary>
            <p> Contains rendering options (hardware or software), pixel format, DPI information, remoting options, and Direct3D support requirements for a render target. </p>
            </summary>
            <remarks>
            <p>Use this structure when creating a render target, or use it with the <strong>ID2D1RenderTarget::IsSupported</strong> method to check the properties supported by an existing render target.</p><p>As a convenience, Direct2D provides the <strong>D2D1::RenderTargetProperties</strong> helper function for creating <strong><see cref = "T:SharpDX.Direct2D1.RenderTargetProperties"/></strong> structures. An easy way to create a <strong><see cref = "T:SharpDX.Direct2D1.RenderTargetProperties"/></strong> structure that works for most render targets is to call the function without specifying any parameters. Doing so creates a <strong><see cref = "T:SharpDX.Direct2D1.RenderTargetProperties"/></strong> structure that has its fields set to default values. For more information, see   <strong>D2D1::RenderTargetProperties</strong>.</p><p>Not all render targets support hardware rendering. For a list, see the Render Targets Overview.</p>
            </remarks>
            <doc-id>dd368155</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_PROPERTIES</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTargetProperties.#ctor(SharpDX.Direct2D1.PixelFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.RenderTargetProperties"/> struct.
            </summary>
            <param name="pixelFormat">The pixel format and alpha mode of the render target. You can use the {{D2D1::PixelFormat}} function to create a pixel format that specifies that Direct2D should select the pixel format and alpha mode for you. For a list of pixel formats and alpha modes supported by each render target, see {{Supported Pixel Formats and Alpha Modes}}.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderTargetProperties.#ctor(SharpDX.Direct2D1.RenderTargetType,SharpDX.Direct2D1.PixelFormat,System.Single,System.Single,SharpDX.Direct2D1.RenderTargetUsage,SharpDX.Direct2D1.FeatureLevel)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.RenderTargetProperties"/> struct.
            </summary>
            <param name="type">A value that specifies whether the render target should force hardware or software rendering. A value of <see cref="F:SharpDX.Direct2D1.RenderTargetType.Default"/> specifies that the render target should use hardware rendering if it is available; otherwise, it uses software rendering. Note that WIC bitmap render targets do not support hardware rendering.</param>
            <param name="pixelFormat">The pixel format and alpha mode of the render target. You can use the {{D2D1::PixelFormat}} function to create a pixel format that specifies that Direct2D should select the pixel format and alpha mode for you. For a list of pixel formats and alpha modes supported by each render target, see {{Supported Pixel Formats and Alpha Modes}}.</param>
            <param name="dpiX">The horizontal DPI of the render target.  To use the default DPI, set dpiX and dpiY to 0. For more information, see the Remarks section. 	</param>
            <param name="dpiY">The vertical DPI of the render target. To use the default DPI, set dpiX and dpiY to 0.  For more information, see the Remarks section. 	</param>
            <param name="usage">A value that specifies how the render target is remoted and whether it should be GDI-compatible.  Set to <see cref="F:SharpDX.Direct2D1.RenderTargetUsage.None"/> to create a render target that is not compatible with GDI and uses Direct3D command-stream remoting if it  is available.</param>
            <param name="minLevel">A value that specifies the minimum Direct3D feature level required for hardware rendering. If the specified minimum level is not available, the render target uses software rendering if the type  member is set to <see cref="F:SharpDX.Direct2D1.RenderTargetType.Default"/>; if  type  is set to to D2D1_RENDER_TARGET_TYPE_HARDWARE, render target creation fails. A value of <see cref="F:SharpDX.Direct2D1.FeatureLevel.Level_DEFAULT"/> indicates that Direct2D should determine whether the Direct3D feature level of the device is adequate. This field is used only when creating <see cref="T:SharpDX.Direct2D1.WindowRenderTarget"/> and <see cref="T:SharpDX.Direct2D1.DeviceContextRenderTarget"/> objects.	</param>  
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetProperties.Type">
            <summary>
            <dd> <p>A value that specifies whether the render target should force hardware or software rendering. A value of <strong>D2D1_RENDER_TARGET_TYPE_DEFAULT</strong> specifies that the render target should use hardware rendering if it is available; otherwise, it uses software rendering. Note that WIC bitmap render targets do not support hardware rendering.</p> </dd>
            </summary>
            <doc-id>dd368155</doc-id>
            <unmanaged>type</unmanaged>
            <unmanaged-short>type</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetProperties.PixelFormat">
            <summary>
            <dd> <p>The pixel format and alpha mode of the render target. You can use the <strong>D2D1::PixelFormat</strong> function to create a pixel format that specifies that Direct2D should select the pixel format and alpha mode for you. For a list of pixel formats and alpha modes supported by each render target, see Supported Pixel Formats and Alpha Modes.</p> </dd>
            </summary>
            <doc-id>dd368155</doc-id>
            <unmanaged>pixelFormat</unmanaged>
            <unmanaged-short>pixelFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetProperties.DpiX">
            <summary>
            <dd> <p>The horizontal DPI of the render target.  To use the default DPI, set <em>dpiX</em> and <em>dpiY</em> to 0. For more information, see the Remarks section. </p> </dd>
            </summary>
            <doc-id>dd368155</doc-id>
            <unmanaged>dpiX</unmanaged>
            <unmanaged-short>dpiX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetProperties.DpiY">
            <summary>
            <dd> <p>The vertical DPI of the render target. To use the default DPI, set <em>dpiX</em> and <em>dpiY</em> to 0.  For more information, see the Remarks section. </p> </dd>
            </summary>
            <doc-id>dd368155</doc-id>
            <unmanaged>dpiY</unmanaged>
            <unmanaged-short>dpiY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetProperties.Usage">
            <summary>
            <dd> <p>A value that specifies how the render target is remoted and whether it should be GDI-compatible.  Set to <strong>D2D1_RENDER_TARGET_USAGE_NONE</strong> to create a render target that is not compatible with GDI and uses Direct3D command-stream remoting if it  is available. </p> </dd>
            </summary>
            <doc-id>dd368155</doc-id>
            <unmanaged>usage</unmanaged>
            <unmanaged-short>usage</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetProperties.MinLevel">
            <summary>
            <dd> <p>A value that specifies the minimum Direct3D feature level required for hardware rendering. If the specified minimum level is not available, the render target uses software rendering if the <strong>type </strong> member is set to <strong>D2D1_RENDER_TARGET_TYPE_DEFAULT</strong>; if  <strong>type </strong> is set to to <strong>D2D1_RENDER_TARGET_TYPE_HARDWARE</strong>, render target creation fails. A value of <strong>D2D1_FEATURE_LEVEL_DEFAULT</strong> indicates that Direct2D should determine whether the Direct3D feature level of the device is adequate. This field is used only when creating <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong> and <strong><see cref = "T:SharpDX.Direct2D1.DeviceContextRenderTarget"/></strong> objects.</p> </dd>
            </summary>
            <doc-id>dd368155</doc-id>
            <unmanaged>minLevel</unmanaged>
            <unmanaged-short>minLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ResourceTexture.#ctor(SharpDX.Direct2D1.EffectContext,System.Guid,SharpDX.Direct2D1.ResourceTextureProperties)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.BlendTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="resourceId">A unique identifier to the resource</param>
            <param name="resourceTextureProperties">The description of the resource</param>
            <unmanaged>HRESULT ID2D1EffectContext::CreateResourceTexture([In, Optional] const GUID* resourceId,[In] const D2D1_RESOURCE_TEXTURE_PROPERTIES* resourceTextureProperties,[In, Buffer, Optional] const unsigned char* data,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dataSize,[Out] ID2D1ResourceTexture** resourceTexture)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ResourceTexture.#ctor(SharpDX.Direct2D1.EffectContext,System.Guid,SharpDX.Direct2D1.ResourceTextureProperties,System.Byte[],System.Int32[])">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.BlendTransform"/> class
            </summary>
            <param name="context">The effect context</param>
            <param name="resourceId">A unique identifier to the resource</param>
            <param name="resourceTextureProperties">The description of the resource</param>
            <param name="data">The data to be loaded into the resource texture.</param>
            <param name="strides">Reference to the stride to advance through the resource texture, according to dimension.</param>
            <unmanaged>HRESULT ID2D1EffectContext::CreateResourceTexture([In, Optional] const GUID* resourceId,[In] const D2D1_RESOURCE_TEXTURE_PROPERTIES* resourceTextureProperties,[In, Buffer, Optional] const unsigned char* data,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dataSize,[Out] ID2D1ResourceTexture** resourceTexture)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.ResourceTexture.Update(System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <p>Updates the specific resource texture inside the specific range or box using the supplied data.</p>
            </summary>
            <param name = "minimumExtents"><dd>  <p>The "left" extent of the updates if specified; if <strong><c>null</c></strong>, the entire texture is updated.</p> </dd></param>
            <param name = "maximimumExtents"><dd>  <p>The "right" extent of the updates if specified; if <strong><c>null</c></strong>, the entire texture is updated.</p> </dd></param>
            <param name = "strides"><dd>  <p>The stride to advance through the input data, according to dimension.</p> </dd></param>
            <param name = "dimensions"><dd>  <p>The number of dimensions in the resource texture. This must match the number used to load the texture.</p> </dd></param>
            <param name = "data"><dd>  <p>The data to be placed into the resource texture.</p> </dd></param>
            <param name = "dataCount"><dd>  <p>The size of the data buffer to be used to update the resource texture.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td> E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The number of dimensions in the update must match those of the created texture.</p>
            </remarks>
            <doc-id>hh446906</doc-id>
            <unmanaged>HRESULT ID2D1ResourceTexture::Update([In, Buffer, Optional] const unsigned int* minimumExtents,[In, Buffer, Optional] const unsigned int* maximimumExtents,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dimensions,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount)</unmanaged>
            <unmanaged-short>ID2D1ResourceTexture::Update</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ResourceTextureProperties">
            <summary>
            <p>Defines a resource texture when the original resource texture is created.</p>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>D2D1_RESOURCE_TEXTURE_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_RESOURCE_TEXTURE_PROPERTIES</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ResourceTextureProperties.Extents">
            <summary>	
            <para>The extents of the resource table in each dimension.</para>	
            </summary>	
            <unmanaged>const unsigned int* extents</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.ResourceTextureProperties.ExtendModes">
            <summary>	
            <para>Specifies how pixel values beyond the extent of the texture will be sampled, in every dimension.</para>	
            </summary>	
            <unmanaged>const D2D1_EXTEND_MODE* extendModes</unmanaged>	
        </member>
        <member name="F:SharpDX.Direct2D1.ResourceTextureProperties.ExtentsPointer">
            <summary>
            <dd> <p>The extents of the resource table in each dimension.</p> </dd>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>extents</unmanaged>
            <unmanaged-short>extents</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ResourceTextureProperties.Dimensions">
            <summary>
            <dd> <p>The number of dimensions in the resource texture. This must be a number from 1 to 3.</p> </dd>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>dimensions</unmanaged>
            <unmanaged-short>dimensions</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ResourceTextureProperties.BufferPrecision">
            <summary>
            <dd> <p>The precision of the resource texture to create. </p> </dd>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>bufferPrecision</unmanaged>
            <unmanaged-short>bufferPrecision</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ResourceTextureProperties.ChannelDepth">
            <summary>
            <dd> <p>The number of channels in the resource texture.</p> </dd>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>channelDepth</unmanaged>
            <unmanaged-short>channelDepth</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ResourceTextureProperties.Filter">
            <summary>
            <dd> <p>The filtering mode to use on the texture.</p> </dd>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>filter</unmanaged>
            <unmanaged-short>filter</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ResourceTextureProperties.ExtendModesPointer">
            <summary>
            <dd> <p>Specifies how pixel values beyond the extent of the texture will be sampled, in every dimension.</p> </dd>
            </summary>
            <doc-id>hh404324</doc-id>
            <unmanaged>extendModes</unmanaged>
            <unmanaged-short>extendModes</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RoundedRectangleGeometry.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.RoundedRectangle)">
            <summary>	
             Creates an <see cref="T:SharpDX.Direct2D1.RoundedRectangleGeometry"/>. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="roundedRectangle">The coordinates and corner radii of the rounded rectangle geometry.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.RoundedRectangleGeometry.RoundedRect">
            <summary>
            <p>Retrieves a rounded rectangle that describes this rounded rectangle geometry. </p>
            </summary>
            <doc-id>dd316917</doc-id>
            <unmanaged>GetRoundedRect</unmanaged>
            <unmanaged-short>GetRoundedRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RoundedRectangleGeometry.GetRoundedRect(SharpDX.Direct2D1.RoundedRectangle@)">
            <summary>
            <p>Retrieves a rounded rectangle that describes this rounded rectangle geometry. </p>
            </summary>
            <param name = "roundedRect"><dd>  <p>A reference that receives a rounded rectangle that describes this rounded rectangle geometry. You must allocate storage for this parameter. </p> </dd></param>
            <doc-id>dd316917</doc-id>
            <unmanaged>void ID2D1RoundedRectangleGeometry::GetRoundedRect([Out] D2D1_ROUNDED_RECT* roundedRect)</unmanaged>
            <unmanaged-short>ID2D1RoundedRectangleGeometry::GetRoundedRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.SetFillMode(SharpDX.Direct2D1.FillMode)">
            <summary>	
            Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  	
            </summary>	
            <remarks>	
            The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call SetFillMode before the first call to {{BeginFigure}}. Not doing will put the geometry sink in an error state. 	
            </remarks>	
            <param name="fillMode">The method used to determine whether a given point is part of the geometry.</param>
            <unmanaged>void SetFillMode([None] D2D1_FILL_MODE fillMode)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.SetSegmentFlags(SharpDX.Direct2D1.PathSegment)">
            <summary>	
            Specifies stroke and join options to be applied to new segments added to the geometry sink. 	
            </summary>	
            <remarks>	
            After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     	
            </remarks>	
            <param name="vertexFlags">Stroke and join options to be applied to new segments added to the geometry sink.</param>
            <unmanaged>void SetSegmentFlags([None] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.BeginFigure(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.FigureBegin)">
            <summary>	
            Starts a new figure at the specified point. 	
            </summary>	
            <remarks>	
            If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.	
            </remarks>	
            <param name="startPoint">The point at which to begin the new figure.</param>
            <param name="figureBegin">Whether the new figure should be hollow or filled.</param>
            <unmanaged>void BeginFigure([None] D2D1_POINT_2F startPoint,[None] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.AddLines(SharpDX.Mathematics.Interop.RawVector2[])">
            <summary>	
             Creates a sequence of lines using the specified points and adds them to the geometry sink.	
            </summary>	
            <param name="ointsRef">A pointer to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by {{BeginFigure}}) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </param>
            <unmanaged>void AddLines([In, Buffer] const D2D1_POINT_2F* points,[None] UINT pointsCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.AddBeziers(SharpDX.Direct2D1.BezierSegment[])">
            <summary>	
            Creates a sequence of cubic Bezier curves and adds them to the geometry sink. 	
            </summary>	
            <param name="beziers">A pointer to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by {{BeginFigure}}) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</param>
            <unmanaged>void AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[None] UINT beziersCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.EndFigure(SharpDX.Direct2D1.FigureEnd)">
            <summary>	
             Ends the current figure; optionally, closes it.	
            </summary>	
            <remarks>	
            Calling this method without a matching call to {{BeginFigure}} places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the {{Close}} method is called.	
            </remarks>	
            <param name="figureEnd">A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by {{BeginFigure}}.</param>
            <unmanaged>void EndFigure([None] D2D1_FIGURE_END figureEnd)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySink.Close">
            <summary>	
            Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. 	
            </summary>	
            <remarks>	
            Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one {{EndFigure}} call for each call to {{BeginFigure}}.After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.	
            </remarks>	
            <unmanaged>HRESULT Close()</unmanaged>
        </member>
        <member name="T:SharpDX.Direct2D1.SimplifiedGeometrySinkNative">
            <summary>
            Describes a geometric path that does not contain quadratic Bezier curves or arcs.
            </summary>
            <remarks>
            A geometry sink consists of one or more figures. Each figure is made up of one or more line or Bezier curve segments. To create a figure, call the <strong>BeginFigure</strong> method and specify the figure's start point, then use <strong>AddLines</strong> and <strong>AddBeziers</strong> to add line and Bezier segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method. To create geometry paths that can contain arcs and quadratic Bezier curves, use an <strong><see cref="T:SharpDX.Direct2D1.GeometrySink"/></strong>.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.AddBeziers(SharpDX.Direct2D1.BezierSegment[])">
            <summary>
            Creates a sequence of cubic Bezier curves and adds them to the geometry sink.
            </summary>
            <param name="beziers">An array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the end point of the first Bezier segment in the array. If the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.AddLines(SharpDX.Mathematics.Interop.RawVector2[])">
            <summary>
            Creates a sequence of lines using the specified points and adds them to the geometry sink.
            </summary>
            <param name="points">An array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the first point in the array. If the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.BeginFigure(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.FigureBegin)">
            <summary>
            Starts a new figure at the specified point.
            </summary>
            <param name="startPoint">The point at which to begin the new figure.</param>
            <param name="figureBegin">Whether the new figure should be hollow or filled.</param>
            <remarks>
            If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.Close">
            <summary>
            Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state.
            </summary>
            <returns>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</returns>
            <remarks>
            Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one <strong>EndFigure</strong> call for each call to <strong>BeginFigure</strong>.After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.EndFigure(SharpDX.Direct2D1.FigureEnd)">
            <summary>
             Ends the current figure; optionally, closes it.
            </summary>
            <param name="figureEnd">A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by <strong>BeginFigure</strong>.</param>
            <remarks>
            Calling this method without a matching call to <strong>BeginFigure</strong> places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the <strong>Close</strong> method is called.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.SetFillMode(SharpDX.Direct2D1.FillMode)">
            <summary>
            Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.
            </summary>
            <param name="fillMode">The method used to determine whether a given point is part of the geometry.</param>
            <remarks>
            The fill mode defaults to <see cref="F:SharpDX.Direct2D1.FillMode.Alternate"/>. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state.
            </remarks>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.SetSegmentFlags(SharpDX.Direct2D1.PathSegment)">
            <summary>
            Specifies stroke and join options to be applied to new segments added to the geometry sink.
            </summary>
            <param name="vertexFlags">Stroke and join options to be applied to new segments added to the geometry sink.</param>
            <remarks>
            After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.FillMode_">
            <summary>
            <p>Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  </p>
            </summary>
            <remarks>
            <p>The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state. </p>
            </remarks>
            <doc-id>dd316937</doc-id>
            <unmanaged>SetFillMode</unmanaged>
            <unmanaged-short>SetFillMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.SegmentFlags_">
            <summary>
            <p>Specifies stroke and join options to be applied to new segments added to the geometry sink. </p>
            </summary>
            <remarks>
            <p>After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     </p>
            </remarks>
            <doc-id>dd316939</doc-id>
            <unmanaged>SetSegmentFlags</unmanaged>
            <unmanaged-short>SetSegmentFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.SetFillMode_(SharpDX.Direct2D1.FillMode)">
            <summary>
            <p>Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  </p>
            </summary>
            <param name = "fillMode"><dd>  <p>The method used to determine whether a given point is part of the geometry.</p> </dd></param>
            <remarks>
            <p>The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state. </p>
            </remarks>
            <doc-id>dd316937</doc-id>
            <unmanaged>void ID2D1SimplifiedGeometrySink::SetFillMode([In] D2D1_FILL_MODE fillMode)</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::SetFillMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.SetSegmentFlags_(SharpDX.Direct2D1.PathSegment)">
            <summary>
            <p>Specifies stroke and join options to be applied to new segments added to the geometry sink. </p>
            </summary>
            <param name = "vertexFlags"><dd>  <p>Stroke and join options to be applied to new segments added to the geometry sink.</p> </dd></param>
            <remarks>
            <p>After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     </p>
            </remarks>
            <doc-id>dd316939</doc-id>
            <unmanaged>void ID2D1SimplifiedGeometrySink::SetSegmentFlags([In] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::SetSegmentFlags</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.BeginFigure_(SharpDX.Mathematics.Interop.RawVector2,SharpDX.Direct2D1.FigureBegin)">
            <summary>
            <p>Starts a new figure at the specified point. </p>
            </summary>
            <param name = "startPoint"><dd>  <p>The point at which to begin the new figure.</p> </dd></param>
            <param name = "figureBegin"><dd>  <p>Whether the new figure should be hollow or filled.</p> </dd></param>
            <remarks>
            <p>If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.</p>
            </remarks>
            <doc-id>dd316929</doc-id>
            <unmanaged>void ID2D1SimplifiedGeometrySink::BeginFigure([In] D2D_POINT_2F startPoint,[In] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::BeginFigure</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.AddLines_(SharpDX.Mathematics.Interop.RawVector2[],System.Int32)">
            <summary>
            <p> Creates a sequence of lines using the specified points and adds them to the geometry sink.</p>
            </summary>
            <param name = "ointsRef"><dd>  <p>A reference to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </p> </dd></param>
            <param name = "pointsCount"><dd>  <p>The number of points in the <em>points</em> array.</p> </dd></param>
            <doc-id>dd316925</doc-id>
            <unmanaged>void ID2D1SimplifiedGeometrySink::AddLines([In, Buffer] const D2D_POINT_2F* points,[In] unsigned int pointsCount)</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::AddLines</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.AddBeziers_(SharpDX.Direct2D1.BezierSegment[],System.Int32)">
            <summary>
            <p>Creates a sequence of cubic Bezier curves and adds them to the geometry sink. </p>
            </summary>
            <param name = "beziers"><dd>  <p>A reference to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</p> </dd></param>
            <param name = "beziersCount"><dd>  <p>The number of Bezier segments in the <em>beziers</em> array.</p> </dd></param>
            <doc-id>dd316922</doc-id>
            <unmanaged>void ID2D1SimplifiedGeometrySink::AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::AddBeziers</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.EndFigure_(SharpDX.Direct2D1.FigureEnd)">
            <summary>
            <p> Ends the current figure; optionally, closes it.</p>
            </summary>
            <param name = "figureEnd"><dd>  <p>A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by <strong>BeginFigure</strong>.</p> </dd></param>
            <remarks>
            <p>Calling this method without a matching call to <strong>BeginFigure</strong> places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the <strong>Close</strong> method is called.</p>
            </remarks>
            <doc-id>dd316934</doc-id>
            <unmanaged>void ID2D1SimplifiedGeometrySink::EndFigure([In] D2D1_FIGURE_END figureEnd)</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::EndFigure</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkNative.Close_">
            <summary>
            <p>Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one <strong>EndFigure</strong> call for each call to <strong>BeginFigure</strong>.</p><p>After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.</p>
            </remarks>
            <doc-id>dd316932</doc-id>
            <unmanaged>HRESULT ID2D1SimplifiedGeometrySink::Close()</unmanaged>
            <unmanaged-short>ID2D1SimplifiedGeometrySink::Close</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SimplifiedGeometrySinkShadow">
            <summary>
            Internal SimplifiedGeometrySink Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.SimplifiedGeometrySinkShadow.ToIntPtr(SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="M:SharpDX.Direct2D1.SolidColorBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Mathematics.Interop.RawColor4)">
            <summary>	
            Creates a new <see cref="T:SharpDX.Direct2D1.SolidColorBrush"/> that has the specified color and opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="color">The red, green, blue, and alpha values of the brush's color.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SolidColorBrush.#ctor(SharpDX.Direct2D1.RenderTarget,SharpDX.Mathematics.Interop.RawColor4,System.Nullable{SharpDX.Direct2D1.BrushProperties})">
            <summary>	
            Creates a new <see cref="T:SharpDX.Direct2D1.SolidColorBrush"/> that has the specified color and opacity. 	
            </summary>	
            <param name="renderTarget">an instance of <see cref = "T:SharpDX.Direct2D1.RenderTarget" /></param>
            <param name="color">The red, green, blue, and alpha values of the brush's color.</param>
            <param name="brushProperties">The base opacity of the brush.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.SolidColorBrush.Color">
            <summary>
            <p>Retrieves or sets the color of the solid color brush.</p>
            </summary>
            <doc-id>dd372209</doc-id>
            <unmanaged>GetColor / SetColor</unmanaged>
            <unmanaged-short>GetColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SolidColorBrush.SetColor(SharpDX.Mathematics.Interop.RawColor4)">
            <summary>
            <p>Specifies the color of this solid color brush. </p>
            </summary>
            <param name = "color"><dd>  <p>The color of this solid color brush.</p> </dd></param>
            <remarks>
            <p>To help create colors, Direct2D provides the <strong>ColorF</strong> class. It offers several helper methods for creating colors and provides a set or predefined colors. </p>
            </remarks>
            <doc-id>dd372211</doc-id>
            <unmanaged>void ID2D1SolidColorBrush::SetColor([In] const D2D_COLOR_F* color)</unmanaged>
            <unmanaged-short>ID2D1SolidColorBrush::SetColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SolidColorBrush.GetColor">
            <summary>
            <p> Retrieves the color of the solid color brush.</p>
            </summary>
            <returns><p>The color of this solid color brush.</p></returns>
            <doc-id>dd372209</doc-id>
            <unmanaged>D2D_COLOR_F ID2D1SolidColorBrush::GetColor()</unmanaged>
            <unmanaged-short>ID2D1SolidColorBrush::GetColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransform.SetRenderInformation(SharpDX.Direct2D1.RenderInformation)">
            <summary>	
            [This documentation is preliminary and is subject to change.]	
            </summary>	
            <param name="renderInfo"><para>The interface supplied to the transform to allow specifying the precision-based transform pass.</para></param>	
            <returns>If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok" />. If it fails, it returns an <see cref="T:SharpDX.Result" /> error code.</returns>	
            <remarks>	
            Provides a render information interface to the source transform to allow it to specify state to the rendering system. This part of the render information interface is shared with the GPU transform.	
            </remarks>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1SourceTransform::SetRenderInfo']/*" />	
            <unmanaged>HRESULT ID2D1SourceTransform::SetRenderInfo([In] ID2D1RenderInfo* renderInfo)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransform.Draw(SharpDX.Direct2D1.Bitmap1,SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Mathematics.Interop.RawPoint)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="target">No documentation.</param>	
            <param name="drawRect">No documentation.</param>	
            <param name="targetOrigin">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- Failed to insert some or all of included XML --><include file=".\..\Documentation\CodeComments.xml" path="/comments/comment[@id='ID2D1SourceTransform::Draw']/*" />	
            <unmanaged>HRESULT ID2D1SourceTransform::Draw([In] ID2D1Bitmap1* target,[In] const RECT* drawRect,[In] D2D_POINT_2U targetOrigin)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransformNative.SetRenderInformation(SharpDX.Direct2D1.RenderInformation)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransformNative.Draw(SharpDX.Direct2D1.Bitmap1,SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Mathematics.Interop.RawPoint)">
            <inheritdoc/>
        </member>
        <member name="P:SharpDX.Direct2D1.SourceTransformNative.RenderInfo_">
            <summary>
            <p>Sets the render information for the transform.</p>
            </summary>
            <remarks>
            <p>Provides a render information interface to the source transform to allow it to specify state to the rendering system.</p>
            </remarks>
            <doc-id>hh446912</doc-id>
            <unmanaged>SetRenderInfo</unmanaged>
            <unmanaged-short>SetRenderInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransformNative.SetRenderInfo_(SharpDX.Direct2D1.RenderInformation)">
            <summary>
            <p>Sets the render information for the transform.</p>
            </summary>
            <param name = "renderInfo"><dd>  <p>The interface supplied to the transform to allow specifying the CPU based transform pass.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Provides a render information interface to the source transform to allow it to specify state to the rendering system.</p>
            </remarks>
            <doc-id>hh446912</doc-id>
            <unmanaged>HRESULT ID2D1SourceTransform::SetRenderInfo([In] ID2D1RenderInfo* renderInfo)</unmanaged>
            <unmanaged-short>ID2D1SourceTransform::SetRenderInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransformNative.Draw_(SharpDX.Direct2D1.Bitmap1,SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Mathematics.Interop.RawPoint)">
            <summary>
            <p>Draws the transform to the graphics processing unit (GPU)?based Direct2D pipeline.</p>
            </summary>
            <param name = "target"><dd>  <p>The target to which the transform should be written.</p> </dd></param>
            <param name = "drawRect"><dd>  <p>The area within the source from which the image should be drawn.</p> </dd></param>
            <param name = "targetOrigin"><dd>  <p>The origin within the target bitmap to which the source data should be drawn.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The implementation of the rasterizer guarantees that adding the <em>renderRect</em> to the <em>targetOrigin</em> does not exceed the bounds of the bitmap.</p><p>When implementing this method you must update the bitmap in this way: </p><ol> <li>Call the <strong>ID2D1Bitmap::Map</strong> method with the  D2D1_MAP_OPTIONS_DISCARD and D2D1_MAP_OPTIONS_WRITE
            flags.</li> <li>Update the buffer this method returns.</li> <li>Call the <strong>ID2D1Bitmap::Unmap</strong> method.</li> </ol><p>If you  set the buffer precision manually on the associated <strong><see cref = "T:SharpDX.Direct2D1.RenderInformation"/></strong> object, it must handle different pixel formats in this method by calling <strong>ID2D1Bitmap::GetPixelFormat</strong>.  If you set the buffer precision manually, then you can rely on that format always being the one you provided.</p>
            </remarks>
            <doc-id>hh446910</doc-id>
            <unmanaged>HRESULT ID2D1SourceTransform::Draw([In] ID2D1Bitmap1* target,[In] const RECT* drawRect,[In] D2D_POINT_2U targetOrigin)</unmanaged>
            <unmanaged-short>ID2D1SourceTransform::Draw</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SourceTransformShadow">
            <summary>
            Internal SourceTransform Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.SourceTransformShadow.ToIntPtr(SharpDX.Direct2D1.SourceTransform)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.SourceTransformShadow.SourceTransformVtbl.SetRenderInformationDelegate">
            <unmanaged>HRESULT ID2D1SourceTransform::SetRenderInfo([In] ID2D1RenderInfo* renderInfo)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.SourceTransformShadow.SourceTransformVtbl.DrawDelegate">
            <unmanaged>HRESULT ID2D1SourceTransform::Draw([In] ID2D1Bitmap1* target,[In] const RECT* drawRect,[In] D2D_POINT_2U targetOrigin)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.SpriteBatch.#ctor(SharpDX.Direct2D1.DeviceContext3)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.SpriteBatch"/>.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.SpriteBatch.SpriteCount">
            <summary>
            <p>Retrieves the number of sprites in this sprite batch.</p>
            </summary>
            <doc-id>mt619836</doc-id>
            <unmanaged>GetSpriteCount</unmanaged>
            <unmanaged-short>GetSpriteCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SpriteBatch.AddSprites(System.Int32,SharpDX.Mathematics.Interop.RawRectangleF[],SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawColor4[],SharpDX.Mathematics.Interop.RawMatrix3x2[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <p>Adds the given sprites to the end of this sprite batch.</p>
            </summary>
            <param name = "spriteCount"><dd>  <p>The number of sprites to be added. This determines how many strides into each given array Direct2D will read.</p> </dd></param>
            <param name = "destinationRectangles"><dd>  <p>A reference to an array containing the destination rectangles specifying where to draw the sprites on the destination device context.</p> </dd></param>
            <param name = "sourceRectangles"><dd>  <p>A reference to an array containing the source rectangles specifying the regions of the source bitmap to draw as sprites. Direct2D will use the entire source bitmap for sprites that are assigned a null value or the InfiniteRectU.  If this parameter is omitted entirely or set to a null value, then Direct2D will use the entire source bitmap for all the added sprites.</p> </dd></param>
            <param name = "colors"><dd>  <p>A reference to an array containing the colors to apply to each sprite.  The output color is the result of component-wise multiplication of the source bitmap color and the provided color.  The output color is not clamped. </p> <p>Direct2D will not change the color of sprites that are assigned a null value. If this parameter is omitted entirely or set to a null value,  then Direct2D will not change the color of any of the added sprites.</p> </dd></param>
            <param name = "transforms"><dd>  <p>A reference to an array containing the transforms to apply to each sprite?s destination rectangle. </p> <p>Direct2D will not transform the destination rectangle of any sprites that are assigned a null value.  If this parameter is omitted entirely or set to a null value,  then Direct2D will not transform the destination rectangle of any of the added sprites.</p> </dd></param>
            <param name = "destinationRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the destinationRectangles array.  If you provide a stride of 0, then the same destination rectangle will be used for each added sprite.</p> </dd></param>
            <param name = "sourceRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the sourceRectangles array (if that array is given).  If you provide a stride of 0, then the same source rectangle will be used for each added sprite.</p> </dd></param>
            <param name = "colorsStride"><dd>  <p>Specifies the distance, in bytes, between each color in the colors array (if that array is given).  If you provide a stride of 0, then the same color will be used for each added sprite.</p> </dd></param>
            <param name = "transformsStride"><dd>  <p>Specifies the distance, in bytes, between each transform in the transforms array (if that array is given).  If you provide a stride of 0, then the same transform will be used for each added sprite.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>In Direct2D, a sprite is defined by four properties: a destination rectangle, a source rectangle, a color, and a transform.  Destination rectangles are mandatory, but the remaining properties are optional.</p><strong>Note</strong>??Always omit or pass a null value for properties you do not wish to use. This allows Direct2D to avoid storing values for those properties and to skip their handling entirely,  which improves drawing speed. For example, suppose you have a batch of 500 sprites, and you do not wish to transform any of their destination rectangles.  Rather than passing an array of identity matrices, simply omit the transforms parameter. This allows Direct2D to avoid storing any transforms and will yield the fastest drawing performance.  On the other hand, if any sprite in the batch has any value set for a property, then internally  Direct2D must allocate space for that property array and assign every sprite a value for that property (even if it?s just the default value).?
            </remarks>
            <doc-id>mt619834</doc-id>
            <unmanaged>HRESULT ID2D1SpriteBatch::AddSprites([In] unsigned int spriteCount,[In, Buffer] const D2D_RECT_F* destinationRectangles,[In, Buffer, Optional] const D2D_RECT_U* sourceRectangles,[In, Buffer, Optional] const D2D_COLOR_F* colors,[In, Buffer, Optional] const D2D_MATRIX_3X2_F* transforms,[In] unsigned int destinationRectanglesStride,[In] unsigned int sourceRectanglesStride,[In] unsigned int colorsStride,[In] unsigned int transformsStride)</unmanaged>
            <unmanaged-short>ID2D1SpriteBatch::AddSprites</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SpriteBatch.SetSprites(System.Int32,System.Int32,SharpDX.Mathematics.Interop.RawRectangleF[],SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawColor4[],SharpDX.Mathematics.Interop.RawMatrix3x2[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <p>Updates the properties of the specified sprites in this sprite batch. Providing a null value for any property will leave that property unmodified for that sprite. </p>
            </summary>
            <param name = "startIndex"><dd>  <p>The index of the first sprite in this sprite batch to update.</p> </dd></param>
            <param name = "spriteCount"><dd>  <p>The number of sprites to update with new properties. This determines how many strides into each given array Direct2D will read.</p> </dd></param>
            <param name = "destinationRectangles"><dd>  <p>A reference to an array containing the destination rectangles specifying where to draw the sprites on the destination device context.</p> </dd></param>
            <param name = "sourceRectangles"><dd>  <p>A reference to an array containing the source rectangles specifying the regions of the source bitmap to draw as sprites. </p> <p>Direct2D will use the entire source bitmap for sprites that are assigned a null value or the InfiniteRectU.  If this parameter is omitted entirely or set to a null value, then Direct2D will use the entire source bitmap for all the updated sprites.</p> </dd></param>
            <param name = "colors"><dd>  <p>A reference to an array containing the colors to apply to each sprite. The output color is the result of component-wise multiplication of the source bitmap color and the provided color.  The output color is not clamped. </p> <p>Direct2D will not change the color of sprites that are assigned a null value. If this parameter is omitted entirely or set to a null value,  then Direct2D will not change the color of any of the updated sprites.</p> </dd></param>
            <param name = "transforms"><dd>  <p>A reference to an array containing the transforms to apply to each sprite?s destination rectangle. </p> <p>Direct2D will not transform the destination rectangle of any sprites that are assigned a null value.  If this parameter is omitted entirely or set to a null value, then Direct2D will not transform the destination rectangle of any of the updated sprites.</p> </dd></param>
            <param name = "destinationRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the destinationRectangles array.  If you provide a stride of 0, then the same destination rectangle will be used for each updated sprite.</p> </dd></param>
            <param name = "sourceRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the sourceRectangles array (if that array is given).  If you provide a stride of 0, then the same source rectangle will be used for each updated sprite.</p> </dd></param>
            <param name = "colorsStride"><dd>  <p>Specifies the distance, in bytes, between each color in the colors array (if that array is given).  If you provide a stride of 0, then the same color will be used for each updated sprite.</p> </dd></param>
            <param name = "transformsStride"><dd>  <p>Specifies the distance, in bytes, between each transform in the transforms array (if that array is given).  If you provide a stride of 0, then the same transform will be used for each updated sprite.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on success. Returns E_INVALIDARG if an invalid value was passed to the method. In this case, no sprites are modified by this call to SetSprites.</p></returns>
            <doc-id>mt604121</doc-id>
            <unmanaged>HRESULT ID2D1SpriteBatch::SetSprites([In] unsigned int startIndex,[In] unsigned int spriteCount,[In, Buffer, Optional] const D2D_RECT_F* destinationRectangles,[In, Buffer, Optional] const D2D_RECT_U* sourceRectangles,[In, Buffer, Optional] const D2D_COLOR_F* colors,[In, Buffer, Optional] const D2D_MATRIX_3X2_F* transforms,[In] unsigned int destinationRectanglesStride,[In] unsigned int sourceRectanglesStride,[In] unsigned int colorsStride,[In] unsigned int transformsStride)</unmanaged>
            <unmanaged-short>ID2D1SpriteBatch::SetSprites</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SpriteBatch.GetSprites(System.Int32,System.Int32,SharpDX.Mathematics.Interop.RawRectangleF[],SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawColor4[],SharpDX.Mathematics.Interop.RawMatrix3x2[])">
            <summary>
            <p>Retrieves the specified subset of sprites from this sprite batch. For the best performance, use nullptr for properties that you do not need to retrieve.</p>
            </summary>
            <param name = "startIndex"><dd>  <p>The index of the first sprite in this sprite batch to retrieve.</p> </dd></param>
            <param name = "spriteCount"><dd>  <p>The number of sprites to retrieve.</p> </dd></param>
            <param name = "destinationRectangles"><dd>  <p>When this method returns, contains a reference to an array containing the destination rectangles for the retrieved sprites.</p> </dd></param>
            <param name = "sourceRectangles"><dd>  <p>When this method returns, contains a reference to an array containing the source rectangles for the retrieved sprites. </p> <p>The InfiniteRectU is returned for any sprites that were not assigned a source rectangle.</p> </dd></param>
            <param name = "colors"><dd>  <p>When this method returns, contains a reference to an array containing the colors to be applied to the retrieved sprites. </p> <p>The color {1.0f, 1.0f, 1.0f, 1.0f} is returned for any sprites that were not assigned a color.</p> </dd></param>
            <param name = "transforms"><dd>  <p>When this method returns, contains a reference to an array containing the transforms to be applied to the retrieved sprites. </p> <p>The identity matrix is returned for any sprites that were not assigned a transform.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt619837</doc-id>
            <unmanaged>HRESULT ID2D1SpriteBatch::GetSprites([In] unsigned int startIndex,[In] unsigned int spriteCount,[Out, Buffer, Optional] D2D_RECT_F* destinationRectangles,[Out, Buffer, Optional] D2D_RECT_U* sourceRectangles,[Out, Buffer, Optional] D2D_COLOR_F* colors,[Out, Buffer, Optional] D2D_MATRIX_3X2_F* transforms)</unmanaged>
            <unmanaged-short>ID2D1SpriteBatch::GetSprites</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SpriteBatch.GetSpriteCount">
            <summary>
            <p>Retrieves the number of sprites in this sprite batch.</p>
            </summary>
            <returns><p>Returns the number of sprites in this sprite batch</p></returns>
            <doc-id>mt619836</doc-id>
            <unmanaged>unsigned int ID2D1SpriteBatch::GetSpriteCount()</unmanaged>
            <unmanaged-short>ID2D1SpriteBatch::GetSpriteCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SpriteBatch.Clear">
            <summary>
            <p>Removes all sprites from this sprite batch.</p>
            </summary>
            <doc-id>mt619835</doc-id>
            <unmanaged>void ID2D1SpriteBatch::Clear()</unmanaged>
            <unmanaged-short>ID2D1SpriteBatch::Clear</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.StrokeStyleProperties)">
            <summary>
            Creates an <see cref="T:SharpDX.Direct2D1.StrokeStyle"/> that describes start cap, dash pattern, and other features of a stroke.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="properties">a definition for this render target</param>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.StrokeStyleProperties,System.Single[])">
            <summary>
            Creates an <see cref="T:SharpDX.Direct2D1.StrokeStyle"/> that describes start cap, dash pattern, and other features of a stroke.	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="properties">A structure that describes the stroke's line cap, dash offset, and other details of a stroke.</param>
            <param name="dashes">An array whose elements are set to the length of each dash and space in the dash pattern. The first element sets the length of a dash, the second element sets the length of a space, the third element sets the length of a dash, and so on. The length of each dash and space in the dash pattern is the product of the element value in the array and the stroke width. </param>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.StartCap">
            <summary>
            <p> Retrieves the type of shape used at the beginning of a stroke.  </p>
            </summary>
            <doc-id>dd372244</doc-id>
            <unmanaged>GetStartCap</unmanaged>
            <unmanaged-short>GetStartCap</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.EndCap">
            <summary>
            <p>Retrieves the type of shape used at the end of a stroke. </p>
            </summary>
            <doc-id>dd372238</doc-id>
            <unmanaged>GetEndCap</unmanaged>
            <unmanaged-short>GetEndCap</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.DashCap">
            <summary>
            <p>Gets a value that specifies how the ends of each dash are drawn. </p>
            </summary>
            <doc-id>dd372218</doc-id>
            <unmanaged>GetDashCap</unmanaged>
            <unmanaged-short>GetDashCap</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.MiterLimit">
            <summary>
            <p>Retrieves the limit on the ratio of the miter length to half the stroke's thickness. </p>
            </summary>
            <doc-id>dd372242</doc-id>
            <unmanaged>GetMiterLimit</unmanaged>
            <unmanaged-short>GetMiterLimit</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.LineJoin">
            <summary>
            <p>Retrieves the type of joint used at the vertices of a shape's outline.  </p>
            </summary>
            <doc-id>dd372240</doc-id>
            <unmanaged>GetLineJoin</unmanaged>
            <unmanaged-short>GetLineJoin</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.DashOffset">
            <summary>
            <p>Retrieves a value that specifies how far in the dash sequence the stroke will start.  </p>
            </summary>
            <doc-id>dd372234</doc-id>
            <unmanaged>GetDashOffset</unmanaged>
            <unmanaged-short>GetDashOffset</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.DashStyle">
            <summary>
            <p>Gets a value that describes the stroke's dash pattern. </p>
            </summary>
            <remarks>
            <p>If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the <strong>GetDashes</strong> method.</p>
            </remarks>
            <doc-id>dd372236</doc-id>
            <unmanaged>GetDashStyle</unmanaged>
            <unmanaged-short>GetDashStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle.DashesCount">
            <summary>
            <p>Retrieves the number of entries in the dashes array. </p>
            </summary>
            <doc-id>dd372232</doc-id>
            <unmanaged>GetDashesCount</unmanaged>
            <unmanaged-short>GetDashesCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetStartCap">
            <summary>
            <p> Retrieves the type of shape used at the beginning of a stroke.  </p>
            </summary>
            <returns><p>The type of shape used at the beginning of a stroke.</p></returns>
            <doc-id>dd372244</doc-id>
            <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetStartCap()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetStartCap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetEndCap">
            <summary>
            <p>Retrieves the type of shape used at the end of a stroke. </p>
            </summary>
            <returns><p>The type of shape used at the end of a stroke.</p></returns>
            <doc-id>dd372238</doc-id>
            <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetEndCap()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetEndCap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetDashCap">
            <summary>
            <p>Gets a value that specifies how the ends of each dash are drawn. </p>
            </summary>
            <returns><p>A value that specifies how the ends of each dash are drawn.</p></returns>
            <doc-id>dd372218</doc-id>
            <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetDashCap()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetDashCap</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetMiterLimit">
            <summary>
            <p>Retrieves the limit on the ratio of the miter length to half the stroke's thickness. </p>
            </summary>
            <returns><p>A positive number greater than or equal to 1.0f that describes the limit on the ratio of the miter length to half the stroke's thickness.</p></returns>
            <doc-id>dd372242</doc-id>
            <unmanaged>float ID2D1StrokeStyle::GetMiterLimit()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetMiterLimit</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetLineJoin">
            <summary>
            <p>Retrieves the type of joint used at the vertices of a shape's outline.  </p>
            </summary>
            <returns><p>A value that specifies the type of joint used at the vertices of a shape's outline.</p></returns>
            <doc-id>dd372240</doc-id>
            <unmanaged>D2D1_LINE_JOIN ID2D1StrokeStyle::GetLineJoin()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetLineJoin</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetDashOffset">
            <summary>
            <p>Retrieves a value that specifies how far in the dash sequence the stroke will start.  </p>
            </summary>
            <returns><p>A value that specifies how far in the dash sequence the stroke will start. </p></returns>
            <doc-id>dd372234</doc-id>
            <unmanaged>float ID2D1StrokeStyle::GetDashOffset()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetDashOffset</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetDashStyle">
            <summary>
            <p>Gets a value that describes the stroke's dash pattern. </p>
            </summary>
            <returns><p>A value that describes the predefined dash pattern used, or <strong>D2D1_DASH_STYLE_CUSTOM</strong> if a custom dash style is used.</p></returns>
            <remarks>
            <p>If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the <strong>GetDashes</strong> method.</p>
            </remarks>
            <doc-id>dd372236</doc-id>
            <unmanaged>D2D1_DASH_STYLE ID2D1StrokeStyle::GetDashStyle()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetDashStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetDashesCount">
            <summary>
            <p>Retrieves the number of entries in the dashes array. </p>
            </summary>
            <returns><p>The number of entries in the dashes array if the stroke is dashed; otherwise, 0.</p></returns>
            <doc-id>dd372232</doc-id>
            <unmanaged>unsigned int ID2D1StrokeStyle::GetDashesCount()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetDashesCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle.GetDashes(System.Single[],System.Int32)">
            <summary>
            <p>Copies the dash pattern to the specified array. </p>
            </summary>
            <param name = "dashes"><dd>  <p>A reference to an array that will receive the dash pattern. The array must be able to contain at least as many elements as specified by <em>dashesCount</em>. You must allocate storage for this array.</p> </dd></param>
            <param name = "dashesCount"><dd>  <p>The number of dashes to copy. If this value is less than the number of dashes in the stroke style's dashes array, the returned dashes are truncated to <em>dashesCount</em>. If this value is greater than the number of dashes in the stroke style's dashes array, the extra dashes are set to 0.0f. To obtain the actual number of dashes in the stroke style's dashes array, use the <strong>GetDashesCount</strong> method. </p> </dd></param>
            <remarks>
            <p>The dashes are specified in units that are a multiple of the stroke width, with subsequent members of the array indicating the dashes and gaps between dashes: the first entry indicates a filled dash, the second a gap, and so on. </p>
            </remarks>
            <doc-id>dd372230</doc-id>
            <unmanaged>void ID2D1StrokeStyle::GetDashes([Out, Buffer] float* dashes,[In] unsigned int dashesCount)</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle::GetDashes</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle1.#ctor(SharpDX.Direct2D1.Factory1,SharpDX.Direct2D1.StrokeStyleProperties1)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.StrokeStyle1"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="strokeStyleProperties">No documentation.</param>
            <unmanaged>HRESULT ID2D1Factory1::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle1** strokeStyle)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle1.#ctor(SharpDX.Direct2D1.Factory1,SharpDX.Direct2D1.StrokeStyleProperties1,System.Single[])">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.StrokeStyle1"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="strokeStyleProperties">No documentation.</param>
            <param name="dashes">No documentation.</param>
            <unmanaged>HRESULT ID2D1Factory1::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle1** strokeStyle)</unmanaged>
              
            <unmanaged>HRESULT ID2D1Factory1::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle1** strokeStyle)</unmanaged>
            <remarks>
            It is valid to specify a dash array only if <see cref="F:SharpDX.Direct2D1.DashStyle.Custom"/> is also specified.
            </remarks>
        </member>
        <member name="P:SharpDX.Direct2D1.StrokeStyle1.StrokeTransformType">
            <summary>
            <p>Gets the stroke transform type.</p>
            </summary>
            <doc-id>hh446916</doc-id>
            <unmanaged>GetStrokeTransformType</unmanaged>
            <unmanaged-short>GetStrokeTransformType</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.StrokeStyle1.GetStrokeTransformType">
            <summary>
            <p>Gets the stroke transform type.</p>
            </summary>
            <returns><p>This method returns the stroke transform type.</p></returns>
            <doc-id>hh446916</doc-id>
            <unmanaged>D2D1_STROKE_TRANSFORM_TYPE ID2D1StrokeStyle1::GetStrokeTransformType()</unmanaged>
            <unmanaged-short>ID2D1StrokeStyle1::GetStrokeTransformType</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgAttribute.Clone">
            <summary>
            Clones an svg attribute
            </summary>
            <returns></returns>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgAttribute.Element">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetElement</unmanaged>
            <unmanaged-short>GetElement</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgAttribute.GetElement(SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "element">No documentation.</param>
            <unmanaged>void ID2D1SvgAttribute::GetElement([Out, Optional] ID2D1SvgElement** element)</unmanaged>
            <unmanaged-short>ID2D1SvgAttribute::GetElement</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgAttribute.Clone(SharpDX.Direct2D1.SvgAttribute@)">
            <summary>
            No documentation.
            </summary>
            <param name = "attribute">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgAttribute::Clone([Out] ID2D1SvgAttribute** attribute)</unmanaged>
            <unmanaged-short>ID2D1SvgAttribute::Clone</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.FindElementById(System.String)">
            <summary>
            Finds an svg element by id
            </summary>
            <param name="id">Id to lookup for</param>
            <returns>SvgElement if found, null otherwise</returns>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgDocument.ViewportSize">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetViewportSize / SetViewportSize</unmanaged>
            <unmanaged-short>GetViewportSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgDocument.Root">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetRoot / SetRoot</unmanaged>
            <unmanaged-short>GetRoot</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.SetViewportSize(SharpDX.Size2F)">
            <summary>
            No documentation.
            </summary>
            <param name = "viewportSize">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::SetViewportSize([In] D2D_SIZE_F viewportSize)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::SetViewportSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.GetViewportSize">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>D2D_SIZE_F ID2D1SvgDocument::GetViewportSize()</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::GetViewportSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.SetRoot(SharpDX.Direct2D1.SvgElement)">
            <summary>
            No documentation.
            </summary>
            <param name = "root">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::SetRoot([In, Optional] ID2D1SvgElement* root)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::SetRoot</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.GetRoot(SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "root">No documentation.</param>
            <unmanaged>void ID2D1SvgDocument::GetRoot([Out, Optional] ID2D1SvgElement** root)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::GetRoot</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.TryFindElementById_(System.String,SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "id">No documentation.</param>
            <param name = "svgElement">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::FindElementById([In] const wchar_t* id,[Out, Optional] ID2D1SvgElement** svgElement)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::FindElementById</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.Serialize(SharpDX.Win32.IStream,SharpDX.Direct2D1.SvgElement)">
            <summary>
            No documentation.
            </summary>
            <param name = "outputXmlStream">No documentation.</param>
            <param name = "subtree">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::Serialize([In] IStream* outputXmlStream,[In, Optional] ID2D1SvgElement* subtree)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::Serialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.Deserialize(SharpDX.Win32.IStream,SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "inputXmlStream">No documentation.</param>
            <param name = "subtree">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::Deserialize([In] IStream* inputXmlStream,[Out] ID2D1SvgElement** subtree)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::Deserialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.CreatePaint(SharpDX.Direct2D1.SvgPaintType,System.Nullable{SharpDX.Mathematics.Interop.RawColor4},System.String,SharpDX.Direct2D1.SvgPaint@)">
            <summary>
            No documentation.
            </summary>
            <param name = "paintType">No documentation.</param>
            <param name = "color">No documentation.</param>
            <param name = "id">No documentation.</param>
            <param name = "aintRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::CreatePaint([In] D2D1_SVG_PAINT_TYPE paintType,[In, Optional] const D2D_COLOR_F* color,[In, Optional] const wchar_t* id,[Out] ID2D1SvgPaint** paint)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::CreatePaint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.CreateStrokeDashArray(SharpDX.Direct2D1.SvgLength[],System.Int32,SharpDX.Direct2D1.SvgStrokeDashArray@)">
            <summary>
            No documentation.
            </summary>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "strokeDashArray">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::CreateStrokeDashArray([In, Buffer, Optional] const D2D1_SVG_LENGTH* dashes,[In] unsigned int dashesCount,[Out] ID2D1SvgStrokeDashArray** strokeDashArray)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::CreateStrokeDashArray</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.CreatePointCollection(SharpDX.Mathematics.Interop.RawVector2[],System.Int32,SharpDX.Direct2D1.SvgPointCollection@)">
            <summary>
            No documentation.
            </summary>
            <param name = "ointsRef">No documentation.</param>
            <param name = "pointsCount">No documentation.</param>
            <param name = "ointCollectionRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::CreatePointCollection([In, Buffer, Optional] const D2D_POINT_2F* points,[In] unsigned int pointsCount,[Out] ID2D1SvgPointCollection** pointCollection)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::CreatePointCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgDocument.CreatePathData(System.Single[],System.Int32,SharpDX.Direct2D1.SvgPathCommand[],System.Int32,SharpDX.Direct2D1.SvgPathData@)">
            <summary>
            No documentation.
            </summary>
            <param name = "segmentData">No documentation.</param>
            <param name = "segmentDataCount">No documentation.</param>
            <param name = "commands">No documentation.</param>
            <param name = "commandsCount">No documentation.</param>
            <param name = "athDataRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgDocument::CreatePathData([In, Buffer, Optional] const float* segmentData,[In] unsigned int segmentDataCount,[In, Buffer, Optional] const D2D1_SVG_PATH_COMMAND* commands,[In] unsigned int commandsCount,[Out] ID2D1SvgPathData** pathData)</unmanaged>
            <unmanaged-short>ID2D1SvgDocument::CreatePathData</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.Children">
            <summary>
            Gets all children of this element.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.TagName">
            <summary>
            Gets tag name for this element
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,System.Single)">
            <summary>
            Sets float attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">New valuee</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,System.Single@)">
            <summary>
            Gets a float attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="value">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Mathematics.Interop.RawColor4)">
            <summary>
            Sets color attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="color">New color</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Mathematics.Interop.RawColor4@)">
            <summary>
            Gets a color attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="color">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.FillMode)">
            <summary>
            Sets fill mode attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="fillMode">New fill mode</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.FillMode@)">
            <summary>
            Gets a fill mode  attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="fillMode">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgDisplay)">
            <summary>
            Sets display mode attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="display">New svg display</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgDisplay@)">
            <summary>
            Gets a display attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="display">When this returns , contains the attribute value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgOverflow)" -->
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgOverflow@)">
            <summary>
            Gets an overflow attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="overflow">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgLineJoin)">
            <summary>
            Sets line join attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="lineJoin">New svg line join</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgLineJoin@)">
            <summary>
            Gets a line join attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="lineJoin">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgLineCap)">
            <summary>
            Sets line cap attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="lineCap">New svg line cap</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgLineCap@)">
            <summary>
            Gets a line cap attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="lineCap">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgVisibility)">
            <summary>
            Sets visibility attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="visibility">New svg visibility</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgVisibility@)">
            <summary>
            Gets a visibility attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="visibility">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>
            Sets transform attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="matrix">New transform</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            Gets a transform attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="matrix">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgUnitType)">
            <summary>
            Sets unit type attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="unitType">New unit type</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgUnitType@)">
            <summary>
            Gets a unit type attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="unitType">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.ExtendMode)">
            <summary>
            Sets extend mode attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="extendMode">New extend mode</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.ExtendMode@)">
            <summary>
            Gets an extend mode attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="extendMode">When this returns , contains the attribute value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgPreserveAspectRatio)" -->
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgPreserveAspectRatio@)">
            <summary>
            Gets a preserve aspect ratio attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="preserveAspectRatio">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgLength)">
            <summary>
            Sets length attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="length">New length</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgLength@)">
            <summary>
            Gets an svg length attribute
            </summary>
            <param name="name">Attribute name</param>
            <param name="length">When this returns , contains the attribute value</param>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue``1(System.String)">
            <summary>
            Gets an attribute from a type id
            </summary>
            <typeparam name="T">Attribute type, must inherit from <see cref="T:SharpDX.Direct2D1.SvgAttribute"/></typeparam>
            <param name="name">Attribute name</param>
            <returns>Attribute instance</returns>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.Document">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDocument</unmanaged>
            <unmanaged-short>GetDocument</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.TagNameLength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetTagNameLength</unmanaged>
            <unmanaged-short>GetTagNameLength</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.IsTextContent">
            <summary>
            No documentation.
            </summary>
            <unmanaged>IsTextContent</unmanaged>
            <unmanaged-short>IsTextContent</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.Parent">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetParent</unmanaged>
            <unmanaged-short>GetParent</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.FirstChild">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetFirstChild</unmanaged>
            <unmanaged-short>GetFirstChild</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.LastChild">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetLastChild</unmanaged>
            <unmanaged-short>GetLastChild</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.SpecifiedAttributeCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetSpecifiedAttributeCount</unmanaged>
            <unmanaged-short>GetSpecifiedAttributeCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgElement.TextValueLength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetTextValueLength</unmanaged>
            <unmanaged-short>GetTextValueLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetDocument(SharpDX.Direct2D1.SvgDocument@)">
            <summary>
            No documentation.
            </summary>
            <param name = "document">No documentation.</param>
            <unmanaged>void ID2D1SvgElement::GetDocument([Out, Optional] ID2D1SvgDocument** document)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetDocument</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetTagName(System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "nameCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetTagName([Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetTagName</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetTagNameLength">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgElement::GetTagNameLength()</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetTagNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.IsTextContent_">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>BOOL ID2D1SvgElement::IsTextContent()</unmanaged>
            <unmanaged-short>ID2D1SvgElement::IsTextContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetParent(SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "arentRef">No documentation.</param>
            <unmanaged>void ID2D1SvgElement::GetParent([Out, Optional] ID2D1SvgElement** parent)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetParent</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.HasChildren">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>BOOL ID2D1SvgElement::HasChildren()</unmanaged>
            <unmanaged-short>ID2D1SvgElement::HasChildren</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetFirstChild(SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "child">No documentation.</param>
            <unmanaged>void ID2D1SvgElement::GetFirstChild([Out, Optional] ID2D1SvgElement** child)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetFirstChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetLastChild(SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "child">No documentation.</param>
            <unmanaged>void ID2D1SvgElement::GetLastChild([Out, Optional] ID2D1SvgElement** child)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetLastChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetPreviousChild(SharpDX.Direct2D1.SvgElement,SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "referenceChild">No documentation.</param>
            <param name = "reviousChildRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetPreviousChild([In] ID2D1SvgElement* referenceChild,[Out, Optional] ID2D1SvgElement** previousChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetPreviousChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetNextChild(SharpDX.Direct2D1.SvgElement,SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "referenceChild">No documentation.</param>
            <param name = "nextChild">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetNextChild([In] ID2D1SvgElement* referenceChild,[Out, Optional] ID2D1SvgElement** nextChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetNextChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.InsertChildBefore(SharpDX.Direct2D1.SvgElement,SharpDX.Direct2D1.SvgElement)">
            <summary>
            No documentation.
            </summary>
            <param name = "newChild">No documentation.</param>
            <param name = "referenceChild">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::InsertChildBefore([In] ID2D1SvgElement* newChild,[In, Optional] ID2D1SvgElement* referenceChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::InsertChildBefore</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.AppendChild(SharpDX.Direct2D1.SvgElement)">
            <summary>
            No documentation.
            </summary>
            <param name = "newChild">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::AppendChild([In] ID2D1SvgElement* newChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::AppendChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.ReplaceChild(SharpDX.Direct2D1.SvgElement,SharpDX.Direct2D1.SvgElement)">
            <summary>
            No documentation.
            </summary>
            <param name = "newChild">No documentation.</param>
            <param name = "oldChild">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::ReplaceChild([In] ID2D1SvgElement* newChild,[In] ID2D1SvgElement* oldChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::ReplaceChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.RemoveChild(SharpDX.Direct2D1.SvgElement)">
            <summary>
            No documentation.
            </summary>
            <param name = "oldChild">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::RemoveChild([In] ID2D1SvgElement* oldChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::RemoveChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.CreateChild(System.String,SharpDX.Direct2D1.SvgElement@)">
            <summary>
            No documentation.
            </summary>
            <param name = "tagName">No documentation.</param>
            <param name = "newChild">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::CreateChild([In] const wchar_t* tagName,[Out] ID2D1SvgElement** newChild)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::CreateChild</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.IsAttributeSpecified(System.String,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "inherited">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>BOOL ID2D1SvgElement::IsAttributeSpecified([In] const wchar_t* name,[Out, Optional] BOOL* inherited)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::IsAttributeSpecified</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetSpecifiedAttributeCount">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgElement::GetSpecifiedAttributeCount()</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetSpecifiedAttributeCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetSpecifiedAttributeName(System.Int32,System.IntPtr,System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "name">No documentation.</param>
            <param name = "nameCount">No documentation.</param>
            <param name = "inherited">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetSpecifiedAttributeName([In] unsigned int index,[Out, Buffer] wchar_t* name,[In] unsigned int nameCount,[Out, Optional] BOOL* inherited)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetSpecifiedAttributeName</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetSpecifiedAttributeNameLength(System.Int32,System.Int32@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            No documentation.
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "nameLength">No documentation.</param>
            <param name = "inherited">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetSpecifiedAttributeNameLength([In] unsigned int index,[Out] unsigned int* nameLength,[Out, Optional] BOOL* inherited)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetSpecifiedAttributeNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.RemoveAttribute(System.String)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::RemoveAttribute([In] const wchar_t* name)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::RemoveAttribute</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetTextValue(System.String,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "nameCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::SetTextValue([In, Buffer] const wchar_t* name,[In] unsigned int nameCount)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::SetTextValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetTextValue(System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "nameCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetTextValue([Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetTextValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetTextValueLength">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgElement::GetTextValueLength()</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetTextValueLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgAttribute)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::SetAttributeValue([In] const wchar_t* name,[In] ID2D1SvgAttribute* value)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::SetAttributeValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgAttributePodType,System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "type">No documentation.</param>
            <param name = "value">No documentation.</param>
            <param name = "valueSizeInBytes">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::SetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_POD_TYPE type,[In, Buffer] const void* value,[In] unsigned int valueSizeInBytes)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::SetAttributeValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.SetAttributeValue(System.String,SharpDX.Direct2D1.SvgAttributeStringType,System.String)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "type">No documentation.</param>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::SetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_STRING_TYPE type,[In] const wchar_t* value)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::SetAttributeValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,System.Guid,System.IntPtr@)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "value">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValue([In] const wchar_t* name,[In] const GUID&amp; riid,[Out, Optional] void** value)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetAttributeValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgAttributePodType,System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "type">No documentation.</param>
            <param name = "value">No documentation.</param>
            <param name = "valueSizeInBytes">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_POD_TYPE type,[Out, Buffer] void* value,[In] unsigned int valueSizeInBytes)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetAttributeValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValue(System.String,SharpDX.Direct2D1.SvgAttributeStringType,System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "type">No documentation.</param>
            <param name = "value">No documentation.</param>
            <param name = "valueCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_STRING_TYPE type,[Out, Buffer] wchar_t* value,[In] unsigned int valueCount)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetAttributeValue</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgElement.GetAttributeValueLength(System.String,SharpDX.Direct2D1.SvgAttributeStringType,System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "name">No documentation.</param>
            <param name = "type">No documentation.</param>
            <param name = "valueLength">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValueLength([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_STRING_TYPE type,[Out] unsigned int* valueLength)</unmanaged>
            <unmanaged-short>ID2D1SvgElement::GetAttributeValueLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TessellationSink.AddTriangles(SharpDX.Direct2D1.Triangle[])">
            <summary>	
            Copies the specified triangles to the sink.  	
            </summary>	
            <param name="triangles">An array of <see cref="T:SharpDX.Direct2D1.Triangle"/> structures that describe the triangles to add to the sink.</param>
            <unmanaged>void AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[None] UINT trianglesCount)</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.TessellationSink.Close">
            <summary>	
             Closes the sink.	
            </summary>	
            <unmanaged>HRESULT Close()</unmanaged>
        </member>
        <member name="M:SharpDX.Direct2D1.TessellationSinkNative.AddTriangles_(SharpDX.Direct2D1.Triangle[],System.Int32)">
            <summary>
            <p>Copies the specified triangles to the sink.  </p>
            </summary>
            <param name = "triangles"><dd>  <p>An array of <strong><see cref = "T:SharpDX.Direct2D1.Triangle"/></strong> structures that describe the triangles to add to the sink.</p> </dd></param>
            <param name = "trianglesCount"><dd>  <p>The number of triangles to copy from the <em>triangles</em> array.</p> </dd></param>
            <doc-id>dd372248</doc-id>
            <unmanaged>void ID2D1TessellationSink::AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[In] unsigned int trianglesCount)</unmanaged>
            <unmanaged-short>ID2D1TessellationSink::AddTriangles</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TessellationSinkNative.Close_">
            <summary>
            <p> Closes the sink and returns its error status.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd372250</doc-id>
            <unmanaged>HRESULT ID2D1TessellationSink::Close()</unmanaged>
            <unmanaged-short>ID2D1TessellationSink::Close</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TessellationSinkShadow">
            <summary>
            Internal TessellationSink Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.TessellationSinkShadow.ToIntPtr(SharpDX.Direct2D1.TessellationSink)">
            <summary>
            Get a native callback pointer from a managed callback.
            </summary>
            <param name="tessellationSink">The geometry sink.</param>
            <returns>A pointer to the unmanaged geometry sink counterpart</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.Transform">
            <summary>
            Represents the base interface for all of the transforms implemented by the transform author.
            </summary>
            <unmanaged>ID2D1Transform</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.Transform.MapOutputRectangleToInputRectangles(SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Mathematics.Interop.RawRectangle[])">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Allows a transform to state how it would map a rectangle requested on its output to a set of sample rectangles on its input.</p>	
            </summary>	
            <param name="outputRect"><dd> <p>The output rectangle to which the inputs must be mapped.</p> </dd></param>	
            <param name="inputRects"><dd> <p>The corresponding set of inputs. The inputs will directly correspond to the transform inputs.</p> </dd></param>	
            <remarks>	
            <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>The transform implementation must regard this method as purely functional. It can base the mapped input and output rectangles on its current state as specified by the encapsulating effect properties.    However, it must not change its own state in response to this method being invoked. The DirectImage renderer implementation reserves the right to call this method at any time and in any sequence.</p>	
            </remarks>	
            <msdn-id>hh446945</msdn-id>	
            <unmanaged>HRESULT ID2D1Transform::MapOutputRectToInputRects([In] const RECT* outputRect,[Out, Buffer] RECT* inputRects,[In] unsigned int inputRectsCount)</unmanaged>	
            <unmanaged-short>ID2D1Transform::MapOutputRectToInputRects</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Transform.MapInputRectanglesToOutputRectangle(SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p><strong>Applies to: </strong>desktop apps | Metro style apps</p><p>Performs the inverse mapping to <strong>MapOutputRectToInputRects</strong>.</p>	
            </summary>	
            <param name="inputRects">No documentation.</param>	
            <param name="inputOpaqueSubRects">No documentation.</param>
            <param name="outputOpaqueSubRect">No documentation.</param>
            <returns>No outputOpaqueSubRect.</returns>	
            <remarks>	
            <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>The transform implementation must regard this method as purely functional. It can base the mapped input and output rectangles on its current state as specified by the encapsulating effect properties. However, it must not change its own state in response to this method being invoked. The Direct2D renderer implementation reserves the right to call this method at any time and in any sequence.</p>	
            </remarks>	
            <msdn-id>hh446943</msdn-id>	
            <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In, Buffer] const RECT* inputOpaqueSubRects,[In] unsigned int inputRectCount,[Out] RECT* outputRect,[Out] RECT* outputOpaqueSubRect)</unmanaged>	
            <unmanaged-short>ID2D1Transform::MapInputRectsToOutputRect</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.Transform.MapInvalidRect(System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>	
            No documentation.	
            </summary>	
            <param name="inputIndex">No documentation.</param>	
            <param name="invalidInputRect">No documentation.</param>	
            <returns>The rectangle invalidated.</returns>	
            <unmanaged>HRESULT ID2D1Transform::MapInvalidRect([In] unsigned int inputIndex,[In] RECT invalidInputRect,[Out] RECT* invalidOutputRect)</unmanaged>	
            <unmanaged-short>ID2D1Transform::MapInvalidRect</unmanaged-short>	
        </member>
        <member name="M:SharpDX.Direct2D1.TransformedGeometry.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.Geometry,SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.TransformedGeometry" />.
            </summary>
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="geometrySource"></param>
            <param name="matrix3X2"></param>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformedGeometry.SourceGeometry">
            <summary>
            <p>Retrieves the source geometry of this transformed geometry object. </p>
            </summary>
            <doc-id>dd372255</doc-id>
            <unmanaged>GetSourceGeometry</unmanaged>
            <unmanaged-short>GetSourceGeometry</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformedGeometry.Transform">
            <summary>
            <p>Retrieves the matrix used to transform the <strong><see cref = "T:SharpDX.Direct2D1.TransformedGeometry"/></strong> object's source geometry. </p>
            </summary>
            <doc-id>dd372256</doc-id>
            <unmanaged>GetTransform</unmanaged>
            <unmanaged-short>GetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformedGeometry.GetSourceGeometry(SharpDX.Direct2D1.Geometry@)">
            <summary>
            <p>Retrieves the source geometry of this transformed geometry object. </p>
            </summary>
            <param name = "sourceGeometry"><dd>  <p>When this method returns, contains a reference to a reference to the source geometry for this transformed geometry object. This parameter is passed uninitialized.</p> </dd></param>
            <doc-id>dd372255</doc-id>
            <unmanaged>void ID2D1TransformedGeometry::GetSourceGeometry([Out] ID2D1Geometry** sourceGeometry)</unmanaged>
            <unmanaged-short>ID2D1TransformedGeometry::GetSourceGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformedGeometry.GetTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Retrieves the matrix used to transform the <strong><see cref = "T:SharpDX.Direct2D1.TransformedGeometry"/></strong> object's source geometry. </p>
            </summary>
            <param name = "transform">No documentation.</param>
            <doc-id>dd372256</doc-id>
            <unmanaged>void ID2D1TransformedGeometry::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1TransformedGeometry::GetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformedImageSource.#ctor(SharpDX.Direct2D1.DeviceContext2,SharpDX.Direct2D1.ImageSource,SharpDX.Direct2D1.TransformedImageSourceProperties@)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.TransformedImageSource"/>.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformedImageSource.Source">
            <summary>
            <p> Retrieves the source image used to create the transformed image source. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
            </summary>
            <doc-id>dn952307</doc-id>
            <unmanaged>GetSource</unmanaged>
            <unmanaged-short>GetSource</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformedImageSource.Properties">
            <summary>
            <p> Retrieves the properties specified when the transformed image source was created. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
            </summary>
            <doc-id>dn952306</doc-id>
            <unmanaged>GetProperties</unmanaged>
            <unmanaged-short>GetProperties</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformedImageSource.GetSource(SharpDX.Direct2D1.ImageSource@)">
            <summary>
            <p> Retrieves the source image used to create the transformed image source. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
            </summary>
            <param name = "imageSource">No documentation.</param>
            <doc-id>dn952307</doc-id>
            <unmanaged>void ID2D1TransformedImageSource::GetSource([Out, Optional] ID2D1ImageSource** imageSource)</unmanaged>
            <unmanaged-short>ID2D1TransformedImageSource::GetSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformedImageSource.GetProperties(SharpDX.Direct2D1.TransformedImageSourceProperties@)">
            <summary>
            <p> Retrieves the properties specified when the transformed image source was created. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
            </summary>
            <param name = "ropertiesRef">No documentation.</param>
            <doc-id>dn952306</doc-id>
            <unmanaged>void ID2D1TransformedImageSource::GetProperties([Out] D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties)</unmanaged>
            <unmanaged-short>ID2D1TransformedImageSource::GetProperties</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNative.MapOutputRectangleToInputRectangles(SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Mathematics.Interop.RawRectangle[])">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNative.MapInputRectanglesToOutputRectangle(SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawRectangle@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNative.MapInvalidRect(System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <inheritdoc/>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNative.MapOutputRectToInputRects_(SharpDX.Mathematics.Interop.RawRectangle,SharpDX.Mathematics.Interop.RawRectangle[],System.Int32)">
            <summary>
            <p>Allows a transform to state how it would map a rectangle requested on its output to a set of sample rectangles on its input.</p>
            </summary>
            <param name = "outputRect"><dd>  <p>The output rectangle from which the inputs must be mapped.</p> </dd></param>
            <param name = "inputRects"><dd>  <p>The corresponding set of inputs. The inputs will directly correspond to the transform inputs.</p> </dd></param>
            <param name = "inputRectsCount"><dd>  <p>The number of inputs specified. Direct2D guarantees that this is equal to the number of inputs specified on the transform.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>The transform implementation must regard this method as purely functional. It can base the mapped input and output rectangles on its current state as specified by the encapsulating effect properties.    However, it must not change its own state in response to this method being invoked. The Direct2D renderer implementation reserves the right to call this method at any time and in any sequence.</p>
            </remarks>
            <doc-id>hh446945</doc-id>
            <unmanaged>HRESULT ID2D1Transform::MapOutputRectToInputRects([In] const RECT* outputRect,[Out, Buffer] RECT* inputRects,[In] unsigned int inputRectsCount)</unmanaged>
            <unmanaged-short>ID2D1Transform::MapOutputRectToInputRects</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNative.MapInputRectsToOutputRect_(SharpDX.Mathematics.Interop.RawRectangle[],SharpDX.Mathematics.Interop.RawRectangle[],System.Int32,SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>
            <p>Performs the inverse mapping to <strong>MapOutputRectToInputRects</strong>.</p>
            </summary>
            <param name = "inputRects">No documentation.</param>
            <param name = "inputOpaqueSubRects">No documentation.</param>
            <param name = "inputRectCount">No documentation.</param>
            <param name = "outputOpaqueSubRect">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>Unlike the <strong>MapOutputRectToInputRects</strong> and <strong>MapInvalidRect</strong> functions, this method is explicitly called by the renderer at a determined place in its rendering algorithm. The transform implementation may change its state based on the input rectangles and use this information to control its rendering information. This method is always called before the <strong>MapInvalidRect</strong> and <strong>MapOutputRectToInputRects</strong> methods of the transform.</p>
            </remarks>
            <doc-id>hh446943</doc-id>
            <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In, Buffer] const RECT* inputOpaqueSubRects,[In] unsigned int inputRectCount,[Out] RECT* outputRect,[Out] RECT* outputOpaqueSubRect)</unmanaged>
            <unmanaged-short>ID2D1Transform::MapInputRectsToOutputRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNative.MapInvalidRect_(System.Int32,SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>
            <p>Sets the input rectangles for this rendering pass into the transform.</p>
            </summary>
            <param name = "inputIndex"><dd>  <p>The index of the input rectangle.</p> </dd></param>
            <param name = "invalidInputRect"><dd>  <p>The invalid input rectangle.</p> </dd></param>
            <returns><dd>  <p>The output rectangle to which the input rectangle must be mapped.</p> </dd></returns>
            <remarks>
            <p>The transform implementation must regard <strong>MapInvalidRect</strong> as purely functional. The transform implementation can base the mapped input rectangle on the transform implementation's current state as specified by the encapsulating effect properties. But the transform implementation can't change its own state in response to a call to <strong>MapInvalidRect</strong>. Direct2D can call this method at any time and in any sequence following a call to the <strong>MapInputRectsToOutputRect</strong> method.
            </p>
            </remarks>
            <doc-id>hh446946</doc-id>
            <unmanaged>HRESULT ID2D1Transform::MapInvalidRect([In] unsigned int inputIndex,[In] RECT invalidInputRect,[Out] RECT* invalidOutputRect)</unmanaged>
            <unmanaged-short>ID2D1Transform::MapInvalidRect</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TransformNode">
            <summary>
            Describes a node in a transform topology.
            </summary>
            <unmanaged>ID2D1TransformNode</unmanaged>	
        </member>
        <member name="P:SharpDX.Direct2D1.TransformNode.InputCount">
            <summary>
            Gets the number of inputs to the transform node.
            </summary>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformNodeNative.InputCount">
            <inheritdoc/>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformNodeNative.InputCount_">
            <summary>
            <p>Gets the number of inputs to the transform node.</p>
            </summary>
            <doc-id>hh446940</doc-id>
            <unmanaged>GetInputCount</unmanaged>
            <unmanaged-short>GetInputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNodeNative.GetInputCount_">
            <summary>
            <p>Gets the number of inputs to the transform node.</p>
            </summary>
            <returns><p>This method returns the number of inputs to this transform node.</p></returns>
            <doc-id>hh446940</doc-id>
            <unmanaged>unsigned int ID2D1TransformNode::GetInputCount()</unmanaged>
            <unmanaged-short>ID2D1TransformNode::GetInputCount</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TransformNodeShadow">
            <summary>
            Internal TransformNode Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformNodeShadow.ToIntPtr(SharpDX.Direct2D1.TransformNode)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.TransformNodeShadow.TransformNodeVtbl.GetInputCountDelegate">
            <unmanaged>unsigned int ID2D1TransformNode::GetInputCount()</unmanaged>	
            <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.TransformShadow">
            <summary>
            Internal Transform Callback
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformShadow.ToIntPtr(SharpDX.Direct2D1.Transform)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.Direct2D1.TransformShadow.TransformVtbl.MapOutputRectToInputRectsDelegate">
            <unmanaged>HRESULT ID2D1Transform::MapOutputRectToInputRects([In] const RECT* outputRect,[Out, Buffer] RECT* inputRects,[In] unsigned int inputRectsCount)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.TransformShadow.TransformVtbl.MapInputRectsToOutputRectDelegate">
            <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In] unsigned int inputRectsCount,[Out] RECT* outputRect)</unmanaged>	
            <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In, Buffer] const RECT* inputOpaqueSubRects,[In] unsigned int inputRectCount,[Out] RECT* outputRect,[Out] RECT* outputOpaqueSubRect)</unmanaged>	
        </member>
        <member name="T:SharpDX.Direct2D1.TransformShadow.TransformVtbl.MapInvalidRectDelegate">
            <unmanaged>HRESULT ID2D1Transform::MapInvalidRect([In] unsigned int inputIndex,[In] RECT invalidInputRect,[Out] RECT* invalidOutputRect)</unmanaged>	
        </member>
        <member name="M:SharpDX.Direct2D1.VertexBuffer.#ctor(SharpDX.Direct2D1.EffectContext,System.Guid,SharpDX.Direct2D1.VertexBufferProperties,SharpDX.Direct2D1.CustomVertexBufferProperties)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.VertexBuffer"/> class.
            </summary>
            <param name="context">Instance of an effect context</param>
            <param name="resourceId"></param>
            <param name="vertexBufferProperties"></param>
            <param name="customVertexBufferProperties"></param>
        </member>
        <member name="M:SharpDX.Direct2D1.VertexBuffer.Map(System.Byte[],System.Int32)">
            <summary>
            <p>Maps the provided data into user memory.</p>
            </summary>
            <param name = "data"><dd>  <p>When this method returns, contains the address of a reference to the available buffer.</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The desired size of the buffer.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_DEVICELOST</td><td>The device has been lost but cannot be reset at this time.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If <em>data</em> is larger than <em>bufferSize</em>, this method fails. </p>
            </remarks>
            <doc-id>hh446951</doc-id>
            <unmanaged>HRESULT ID2D1VertexBuffer::Map([Out, Buffer] unsigned char** data,[In] unsigned int bufferSize)</unmanaged>
            <unmanaged-short>ID2D1VertexBuffer::Map</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.VertexBuffer.Unmap">
            <summary>
            <p>Unmaps the vertex buffer.</p>
            </summary>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "!:WrongState"/></td><td>The object was not in the correct state to process the method.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>After this method returns, the mapped memory from the vertex buffer is no longer accessible by the effect.</p>
            </remarks>
            <doc-id>hh446967</doc-id>
            <unmanaged>HRESULT ID2D1VertexBuffer::Unmap()</unmanaged>
            <unmanaged-short>ID2D1VertexBuffer::Unmap</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.VertexBufferProperties">
            <summary>
            <p>Defines the properties of a vertex buffer that are standard for all vertex shader definitions.</p>
            </summary>
            <remarks>
            <p>If <strong>usage</strong> is dynamic, the system might return a system memory buffer and copy these vertices into the rendering vertex buffer for each element.</p><p>If the initialization data is not specified, the buffer will be uninitialized.</p>
            </remarks>
            <doc-id>hh404330</doc-id>
            <unmanaged>D2D1_VERTEX_BUFFER_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_VERTEX_BUFFER_PROPERTIES</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.VertexBufferProperties.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.VertexBufferProperties"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.VertexBufferProperties.#ctor(System.Int32,SharpDX.Direct2D1.VertexUsage,SharpDX.DataStream)">
            <summary>
            Initializes a new instance of <see cref="T:SharpDX.Direct2D1.VertexBufferProperties"/> class.
            </summary>
            <param name="inputCount">The number of inputs to the vertex shader.</param>
            <param name="usage">Indicates how frequently the vertex buffer is likely to be updated.</param>
            <param name="data">The initial contents of the vertex buffer</param>
        </member>
        <member name="P:SharpDX.Direct2D1.VertexBufferProperties.Data">
            <summary>	
            The initial contents of the vertex buffer.
            </summary>	
        </member>
        <member name="F:SharpDX.Direct2D1.VertexBufferProperties.InputCount">
            <summary>
            <dd> <p>The number of inputs to the vertex shader.</p> </dd>
            </summary>
            <doc-id>hh404330</doc-id>
            <unmanaged>inputCount</unmanaged>
            <unmanaged-short>inputCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexBufferProperties.Usage">
            <summary>
            <dd> <p>Indicates how frequently the vertex buffer is likely to be updated.</p> </dd>
            </summary>
            <doc-id>hh404330</doc-id>
            <unmanaged>usage</unmanaged>
            <unmanaged-short>usage</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexBufferProperties.DataPointer">
            <summary>
            <dd> <p>The initial contents of the vertex buffer.</p> </dd>
            </summary>
            <doc-id>hh404330</doc-id>
            <unmanaged>data</unmanaged>
            <unmanaged-short>data</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexBufferProperties.SizeInBytes">
            <summary>
            <dd> <p>The size of the vertex buffer, in bytes.</p> </dd>
            </summary>
            <doc-id>hh404330</doc-id>
            <unmanaged>byteWidth</unmanaged>
            <unmanaged-short>byteWidth</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.VertexRange">
            <summary>
            <p>Defines a range of vertices that are used when rendering less than the full contents of a vertex buffer.</p>
            </summary>
            <doc-id>hh404335</doc-id>
            <unmanaged>D2D1_VERTEX_RANGE</unmanaged>
            <unmanaged-short>D2D1_VERTEX_RANGE</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.VertexRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes an instance of <see cref="T:SharpDX.Direct2D1.VertexRange"/> struct.
            </summary>
            <param name="startVertex">The first vertex in the range to process.</param>
            <param name="vertexCount">The number of vertices in the count to use.</param>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexRange.StartVertex">
            <summary>
            <dd> <p>The first vertex in the range to process.</p> </dd>
            </summary>
            <doc-id>hh404335</doc-id>
            <unmanaged>startVertex</unmanaged>
            <unmanaged-short>startVertex</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexRange.VertexCount">
            <summary>
            <dd> <p>The number of vertices to use.</p> </dd>
            </summary>
            <doc-id>hh404335</doc-id>
            <unmanaged>vertexCount</unmanaged>
            <unmanaged-short>vertexCount</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.WicRenderTarget">
            <summary>
            A WIC RenderTarget.
            </summary>
        </member>
        <member name="M:SharpDX.Direct2D1.WicRenderTarget.#ctor(SharpDX.Direct2D1.Factory,SharpDX.WIC.Bitmap,SharpDX.Direct2D1.RenderTargetProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Direct2D1.WicRenderTarget"/> class from a <see cref="T:SharpDX.WIC.Bitmap"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="wicBitmap">The WIC bitmap.</param>
            <param name="renderTargetProperties">The render target properties.</param>
        </member>
        <member name="M:SharpDX.Direct2D1.WindowRenderTarget.#ctor(SharpDX.Direct2D1.Factory,SharpDX.Direct2D1.RenderTargetProperties,SharpDX.Direct2D1.HwndRenderTargetProperties)">
            <summary>	
            Creates an <see cref="T:SharpDX.Direct2D1.WindowRenderTarget"/>, a render target that renders to a window.	
            </summary>	
            <remarks>	
            When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the {{D2DERR_RECREATE_TARGET}} error is received. When you receive this error, you need to recreate the render target (and any resources it created).	
            </remarks>
            <param name="factory">an instance of <see cref = "T:SharpDX.Direct2D1.Factory" /></param>
            <param name="renderTargetProperties">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  {{Supported Pixel  Formats and Alpha Modes}}.</param>
            <param name="hwndProperties">The window handle, initial size (in pixels), and present options.</param>
        </member>
        <member name="P:SharpDX.Direct2D1.WindowRenderTarget.Hwnd">
            <summary>
            <p> Returns the <see cref = "T:System.IntPtr"/> associated with this render target.</p>
            </summary>
            <doc-id>dd371470</doc-id>
            <unmanaged>GetHwnd</unmanaged>
            <unmanaged-short>GetHwnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.WindowRenderTarget.CheckWindowState">
            <summary>
            <p>Indicates whether the <see cref = "T:System.IntPtr"/> associated with this render target is occluded. </p>
            </summary>
            <returns><p>A value that indicates whether the <see cref = "T:System.IntPtr"/> associated with this render target is occluded.</p></returns>
            <remarks>
            <strong>Note</strong>??If the window was occluded the last time  that <strong>EndDraw</strong> was called, the next time that the render target calls <strong>CheckWindowState</strong>, it will return <strong>D2D1_WINDOW_STATE_OCCLUDED</strong> regardless of the current window state. If you want to use <strong>CheckWindowState</strong> to determine the current window state, you should call <strong>CheckWindowState</strong> after every <strong>EndDraw</strong> call and ignore its return value. This call will ensure that your next call to <strong>CheckWindowState</strong> state will return the actual window state.?
            </remarks>
            <doc-id>dd371466</doc-id>
            <unmanaged>D2D1_WINDOW_STATE ID2D1HwndRenderTarget::CheckWindowState()</unmanaged>
            <unmanaged-short>ID2D1HwndRenderTarget::CheckWindowState</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.WindowRenderTarget.Resize(SharpDX.Size2)">
            <summary>
            Changes the size of the render target to the specified pixel size.
            </summary>
            <param name = "ixelSizeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>After this method is called, the contents of the render target's back-buffer are not defined, even if the <strong>D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS</strong> option was specified when the render target was created.</p>
            </remarks>
            <doc-id>dd742774</doc-id>
            <unmanaged>HRESULT ID2D1HwndRenderTarget::Resize([In] const D2D_SIZE_U* pixelSize)</unmanaged>
            <unmanaged-short>ID2D1HwndRenderTarget::Resize</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.WindowRenderTarget.GetHwnd">
            <summary>
            <p> Returns the <see cref = "T:System.IntPtr"/> associated with this render target.</p>
            </summary>
            <returns><p>The <see cref = "T:System.IntPtr"/> associated with this render target.</p></returns>
            <doc-id>dd371470</doc-id>
            <unmanaged>HWND ID2D1HwndRenderTarget::GetHwnd()</unmanaged>
            <unmanaged-short>ID2D1HwndRenderTarget::GetHwnd</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.AffineTransform2DInterpolationMode">
            <summary>
            <p>The interpolation mode to be used with the 2D affine transform effect to scale the image. There are 6 scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DInterpolationMode.NearestNeighbor">
            <summary>
            <dd> <p>Samples the nearest single point and uses that. This mode uses less processing time, but outputs the lowest quality image.</p> </dd>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DInterpolationMode.Linear">
            <summary>
            <dd> <p>Uses a four point sample and linear interpolation. This mode uses more processing time than the nearest neighbor mode, but outputs a higher quality image.</p> </dd>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DInterpolationMode.Cubic">
            <summary>
            <dd> <p>Uses a 16 sample cubic kernel for interpolation. This mode uses the most processing time, but outputs a higher quality image. </p> </dd>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DInterpolationMode.MultiSampleLinear">
            <summary>
            <dd> <p>Uses 4 linear samples within a single pixel for good edge anti-aliasing. This mode is good for scaling down by small amounts on images with few pixels.</p> </dd>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DInterpolationMode.Anisotropic">
            <summary>
            <dd> <p>Uses anisotropic filtering to sample a pattern according to the transformed shape of the bitmap.</p> </dd>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DInterpolationMode.HighQualityCubic">
            <summary>
            <dd> <p>Uses a variable size high quality cubic kernel to perform a pre-downscale the image if downscaling is involved in the transform matrix. Then uses the cubic interpolation mode for the final output.</p> </dd>
            </summary>
            <doc-id>dn934205</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.AffineTransform2DProperties">
            <summary>
            <p>Identifiers for properties of the 2D affine transform effect.</p>
            </summary>
            <doc-id>dn934206</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_PROP</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934206</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934206</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DProperties.TransformMatrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934206</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_PROP_TRANSFORM_MATRIX</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_PROP_TRANSFORM_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AffineTransform2DProperties.Sharpness">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934206</doc-id>
            <unmanaged>D2D1_2DAFFINETRANSFORM_PROP_SHARPNESS</unmanaged>
            <unmanaged-short>D2D1_2DAFFINETRANSFORM_PROP_SHARPNESS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.AlphaMode">
            <summary>
            <p>Specifies how the alpha value of a bitmap or render target should be treated.</p>
            </summary>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.Direct2D1.AlphaMode"/></strong> enumeration is used with the <strong><see cref = "T:SharpDX.Direct2D1.PixelFormat"/></strong> enumeration to specify the alpha mode of a render target or bitmap. Different render targets and bitmaps support different alpha modes. For a list, see Supported Pixel Formats and Alpha Modes.</p>
            </remarks>
            <doc-id>dd368058</doc-id>
            <unmanaged>D2D1_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AlphaMode.Unknown">
            <summary>
            <dd> <p>The alpha value might not be meaningful.</p> </dd>
            </summary>
            <doc-id>dd368058</doc-id>
            <unmanaged>D2D1_ALPHA_MODE_UNKNOWN</unmanaged>
            <unmanaged-short>D2D1_ALPHA_MODE_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AlphaMode.Premultiplied">
            <summary>
            <dd> <p>The alpha value has been premultiplied. Each color is first scaled by the alpha value. The alpha value itself is the same in both straight and premultiplied alpha. Typically, no color channel value is greater than the alpha channel value.  If a color channel value in a premultiplied format is greater than the alpha channel, the standard source-over blending math results in an additive blend.</p> </dd>
            </summary>
            <doc-id>dd368058</doc-id>
            <unmanaged>D2D1_ALPHA_MODE_PREMULTIPLIED</unmanaged>
            <unmanaged-short>D2D1_ALPHA_MODE_PREMULTIPLIED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AlphaMode.Straight">
            <summary>
            <dd> <p>The alpha value has not been premultiplied. The alpha channel indicates the transparency of the color. </p> </dd>
            </summary>
            <doc-id>dd368058</doc-id>
            <unmanaged>D2D1_ALPHA_MODE_STRAIGHT</unmanaged>
            <unmanaged-short>D2D1_ALPHA_MODE_STRAIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AlphaMode.Ignore">
            <summary>
            <dd> <p>The alpha value is ignored.</p> </dd>
            </summary>
            <doc-id>dd368058</doc-id>
            <unmanaged>D2D1_ALPHA_MODE_IGNORE</unmanaged>
            <unmanaged-short>D2D1_ALPHA_MODE_IGNORE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.AntialiasMode">
            <summary>
            <p>Specifies how the edges of nontext primitives are rendered.</p>
            </summary>
            <doc-id>dd368061</doc-id>
            <unmanaged>D2D1_ANTIALIAS_MODE</unmanaged>
            <unmanaged-short>D2D1_ANTIALIAS_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AntialiasMode.PerPrimitive">
            <summary>
            <dd> <p>Edges are antialiased using the Direct2D per-primitive method of high-quality antialiasing.</p> </dd>
            </summary>
            <doc-id>dd368061</doc-id>
            <unmanaged>D2D1_ANTIALIAS_MODE_PER_PRIMITIVE</unmanaged>
            <unmanaged-short>D2D1_ANTIALIAS_MODE_PER_PRIMITIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AntialiasMode.Aliased">
            <summary>
            <dd> <p>Objects are aliased in most cases. Objects are antialiased only when they are drawn to a render target created by the <strong>CreateDxgiSurfaceRenderTarget</strong> method and  Direct3D multisampling has been enabled on the backing DirectX Graphics Infrastructure (DXGI) surface. </p> </dd>
            </summary>
            <doc-id>dd368061</doc-id>
            <unmanaged>D2D1_ANTIALIAS_MODE_ALIASED</unmanaged>
            <unmanaged-short>D2D1_ANTIALIAS_MODE_ALIASED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ArcSize">
            <summary>
            <p>Specifies whether an arc should be greater than 180 degrees.</p>
            </summary>
            <doc-id>dd368068</doc-id>
            <unmanaged>D2D1_ARC_SIZE</unmanaged>
            <unmanaged-short>D2D1_ARC_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSize.Small">
            <summary>
            <dd> <p> An arc's sweep should be 180 degrees or less.</p> </dd>
            </summary>
            <doc-id>dd368068</doc-id>
            <unmanaged>D2D1_ARC_SIZE_SMALL</unmanaged>
            <unmanaged-short>D2D1_ARC_SIZE_SMALL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSize.Large">
            <summary>
            <dd> <p> An arc's sweep should be 180 degrees or greater.</p> </dd>
            </summary>
            <doc-id>dd368068</doc-id>
            <unmanaged>D2D1_ARC_SIZE_LARGE</unmanaged>
            <unmanaged-short>D2D1_ARC_SIZE_LARGE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ArithmeticCompositeProperties">
            <summary>
            <p> Identifiers for the properties of the Arithmetic composite effect. </p>
            </summary>
            <doc-id>dn934211</doc-id>
            <unmanaged>D2D1_ARITHMETICCOMPOSITE_PROP</unmanaged>
            <unmanaged-short>D2D1_ARITHMETICCOMPOSITE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArithmeticCompositeProperties.Coefficients">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934211</doc-id>
            <unmanaged>D2D1_ARITHMETICCOMPOSITE_PROP_COEFFICIENTS</unmanaged>
            <unmanaged-short>D2D1_ARITHMETICCOMPOSITE_PROP_COEFFICIENTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArithmeticCompositeProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934211</doc-id>
            <unmanaged>D2D1_ARITHMETICCOMPOSITE_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_ARITHMETICCOMPOSITE_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.AtlasProperties">
            <summary>
            <p> Identifiers for properties of the Atlas effect. </p>
            </summary>
            <doc-id>dn934212</doc-id>
            <unmanaged>D2D1_ATLAS_PROP</unmanaged>
            <unmanaged-short>D2D1_ATLAS_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AtlasProperties.InputRectangle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934212</doc-id>
            <unmanaged>D2D1_ATLAS_PROP_INPUT_RECT</unmanaged>
            <unmanaged-short>D2D1_ATLAS_PROP_INPUT_RECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.AtlasProperties.InputPaddingRectangle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934212</doc-id>
            <unmanaged>D2D1_ATLAS_PROP_INPUT_PADDING_RECT</unmanaged>
            <unmanaged-short>D2D1_ATLAS_PROP_INPUT_PADDING_RECT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapInterpolationMode">
            <summary>
            <p>Specifies the algorithm that is used when images are scaled or rotated.</p><strong>Note</strong>??Starting in Windows?8, more interpolations modes are available.  See <strong><see cref = "T:SharpDX.Direct2D1.InterpolationMode"/></strong> for more info.?
            </summary>
            <remarks>
            <p> To stretch an image, each pixel in the original image must be mapped to a group of pixels in the larger image. To shrink an image, groups of pixels in the original image must be mapped to single pixels in the smaller image. The effectiveness of the algorithms that perform these mappings determines the quality of a scaled image. Algorithms that produce higher-quality scaled images tend to require more processing time. <strong>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR </strong>provides faster but lower-quality interpolation, while <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong> provides higher-quality interpolation. </p>
            </remarks>
            <doc-id>dd368073</doc-id>
            <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_BITMAP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapInterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368073</doc-id>
            <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapInterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368073</doc-id>
            <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapOptions.None">
            <summary>
            <dd> <p>The bitmap is created with default properties.</p> </dd>
            </summary>
            <doc-id>hh446984</doc-id>
            <unmanaged>D2D1_BITMAP_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_BITMAP_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapOptions.Target">
            <summary>
            <dd> <p>The bitmap can be used as a device context target.</p> </dd>
            </summary>
            <doc-id>hh446984</doc-id>
            <unmanaged>D2D1_BITMAP_OPTIONS_TARGET</unmanaged>
            <unmanaged-short>D2D1_BITMAP_OPTIONS_TARGET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapOptions.CannotDraw">
            <summary>
            <dd> <p>The bitmap cannot be used as an input. </p> </dd>
            </summary>
            <doc-id>hh446984</doc-id>
            <unmanaged>D2D1_BITMAP_OPTIONS_CANNOT_DRAW</unmanaged>
            <unmanaged-short>D2D1_BITMAP_OPTIONS_CANNOT_DRAW</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapOptions.CpuRead">
            <summary>
            <dd> <p>The bitmap can be read from the CPU.</p> </dd>
            </summary>
            <doc-id>hh446984</doc-id>
            <unmanaged>D2D1_BITMAP_OPTIONS_CPU_READ</unmanaged>
            <unmanaged-short>D2D1_BITMAP_OPTIONS_CPU_READ</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapOptions.GdiCompatible">
            <summary>
            <dd> <p>The bitmap works with <strong>ID2D1GdiInteropRenderTarget::GetDC</strong>.</p> <strong>Note</strong>??This flag is not available in Windows Store apps. ? </dd>
            </summary>
            <doc-id>hh446984</doc-id>
            <unmanaged>D2D1_BITMAP_OPTIONS_GDI_COMPATIBLE</unmanaged>
            <unmanaged-short>D2D1_BITMAP_OPTIONS_GDI_COMPATIBLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapSourceAlphaMode">
            <summary>
            <p>Specifies the alpha mode of the output of the Bitmap source effect.</p>
            </summary>
            <doc-id>dn934213</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceAlphaMode.Premultiplied">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934213</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ALPHA_MODE_PREMULTIPLIED</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ALPHA_MODE_PREMULTIPLIED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceAlphaMode.Straight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934213</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ALPHA_MODE_STRAIGHT</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ALPHA_MODE_STRAIGHT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapSourceInterpolationMode">
            <summary>
            <p>The interpolation mode used to scale the image in the Bitmap source effect. If the mode disables the mipmap, then BitmapSouce will cache the image at the resolution determined by the Scale and EnableDPICorrection properties. </p>
            </summary>
            <doc-id>dn934214</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceInterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934214</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceInterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934214</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceInterpolationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934214</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceInterpolationMode.Fant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934214</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_FANT</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_FANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceInterpolationMode.MipmapLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934214</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_MIPMAP_LINEAR</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_INTERPOLATION_MODE_MIPMAP_LINEAR</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapSourceOrientation">
            <summary>
            <p> Speficies whether a flip and/or rotation operation should be performed by the Bitmap source effect </p>
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.FlipHorizontal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.RotateClockwise180">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.RotateClockwise180FlipHorizontal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.RotateClockwise270FlipHorizontal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.RotateClockwise90">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.RotateClockwise90FlipHorizontal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceOrientation.RotateClockwise270">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934215</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapSourceProperties">
            <summary>
            <p> Identifiers for properties of the Bitmap source effect. </p>
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceProperties.WicBitmapSource">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP_WIC_BITMAP_SOURCE</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP_WIC_BITMAP_SOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceProperties.Scale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP_SCALE</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceProperties.EnableDpiCorrection">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP_ENABLE_DPI_CORRECTION</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP_ENABLE_DPI_CORRECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceProperties.AlphaMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapSourceProperties.Orientation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934216</doc-id>
            <unmanaged>D2D1_BITMAPSOURCE_PROP_ORIENTATION</unmanaged>
            <unmanaged-short>D2D1_BITMAPSOURCE_PROP_ORIENTATION</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Blend">
            <summary>
            <p>Specifies how one of the color sources is to be derived and optionally specifies a preblend operation on the color source.</p>
            </summary>
            <remarks>
            <p>This enumeration has the same numeric values as <strong>D3D10_BLEND</strong>.</p>
            </remarks>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND</unmanaged>
            <unmanaged-short>D2D1_BLEND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.Zero">
            <summary>
            <dd> <p>The data source is black (0, 0, 0, 0). There is no preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_ZERO</unmanaged>
            <unmanaged-short>D2D1_BLEND_ZERO</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.One">
            <summary>
            <dd> <p>The data source is white (1, 1, 1, 1). There is no preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_ONE</unmanaged>
            <unmanaged-short>D2D1_BLEND_ONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.SourceColor">
            <summary>
            <dd> <p>The data source is color data (RGB) from the second input of the blend transform. There is not a preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_SRC_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_SRC_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.InverseSourceColor">
            <summary>
            <dd> <p>The data source is color data (RGB) from second input of the blend transform. The preblend operation inverts the data, generating 1 - RGB.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_INV_SRC_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_INV_SRC_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.SourceAlpha">
            <summary>
            <dd> <p>The data source is alpha data (A) from second input of the blend transform. There is no preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_SRC_ALPHA</unmanaged>
            <unmanaged-short>D2D1_BLEND_SRC_ALPHA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.InverseSourceAlpha">
            <summary>
            <dd> <p>The data source is alpha data (A) from the second input of the blend transform. The preblend operation inverts the data, generating 1 - A.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_INV_SRC_ALPHA</unmanaged>
            <unmanaged-short>D2D1_BLEND_INV_SRC_ALPHA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.DestinationAlpha">
            <summary>
            <dd> <p>The data source is alpha data (A) from the first input of the blend transform. There is no preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_DEST_ALPHA</unmanaged>
            <unmanaged-short>D2D1_BLEND_DEST_ALPHA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.InverseDestinationAlpha">
            <summary>
            <dd> <p>The data source is alpha data (A) from the first input of the blend transform. The preblend operation inverts the data, generating 1 - A.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_INV_DEST_ALPHA</unmanaged>
            <unmanaged-short>D2D1_BLEND_INV_DEST_ALPHA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.DestinationColor">
            <summary>
            <dd> <p>The data source is color data from the first input of the blend transform. There is no preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_DEST_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_DEST_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.InverseDestinationColor">
            <summary>
            <dd> <p>The data source is color data from the first input of the blend transform. The preblend operation inverts the data, generating 1 - RGB.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_INV_DEST_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_INV_DEST_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.SourceAlphaSaturate">
            <summary>
            <dd> <p>The data source is alpha data from the second input of the blend transform. The preblend operation clamps the data to 1 or less.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_SRC_ALPHA_SAT</unmanaged>
            <unmanaged-short>D2D1_BLEND_SRC_ALPHA_SAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.BlendFactor">
            <summary>
            <dd> <p>The data source is the blend factor. There is no preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_BLEND_FACTOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_BLEND_FACTOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Blend.InverseBlendFactor">
            <summary>
            <dd> <p>The data source is the blend factor. The preblend operation inverts the blend factor, generating 1 - blend_factor.</p> </dd>
            </summary>
            <doc-id>hh404276</doc-id>
            <unmanaged>D2D1_BLEND_INV_BLEND_FACTOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_INV_BLEND_FACTOR</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BlendMode">
            <summary>
            <p>The blend mode used for the Blend effect.</p>
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Multiply">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_MULTIPLY</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_MULTIPLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Screen">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_SCREEN</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_SCREEN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Darken">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_DARKEN</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_DARKEN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Lighten">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_LIGHTEN</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_LIGHTEN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Dissolve">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_DISSOLVE</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_DISSOLVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.ColorBurn">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_COLOR_BURN</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_COLOR_BURN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.LinearBurn">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_LINEAR_BURN</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_LINEAR_BURN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.DarkerColor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_DARKER_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_DARKER_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.LighterColor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_LIGHTER_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_LIGHTER_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.ColorDodge">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_COLOR_DODGE</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_COLOR_DODGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.LinearDodge">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_LINEAR_DODGE</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_LINEAR_DODGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Overlay">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_OVERLAY</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_OVERLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.SoftLight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_SOFT_LIGHT</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_SOFT_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.HardLight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_HARD_LIGHT</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_HARD_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.VividLight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_VIVID_LIGHT</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_VIVID_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.LinearLight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_LINEAR_LIGHT</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_LINEAR_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.PinLight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_PIN_LIGHT</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_PIN_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.HardMix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_HARD_MIX</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_HARD_MIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Difference">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_DIFFERENCE</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_DIFFERENCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Exclusion">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_EXCLUSION</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_EXCLUSION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Hue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_HUE</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_HUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Saturation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_SATURATION</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_SATURATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_COLOR</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Luminosity">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_LUMINOSITY</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_LUMINOSITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Subtract">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_SUBTRACT</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_SUBTRACT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendMode.Division">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934217</doc-id>
            <unmanaged>D2D1_BLEND_MODE_DIVISION</unmanaged>
            <unmanaged-short>D2D1_BLEND_MODE_DIVISION</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BlendOperation">
            <summary>
            <p>Specifies the blend operation on two color sources.</p>
            </summary>
            <remarks>
            <p>This enumeration has the same numeric values as <strong>D3D10_BLEND_OP</strong>.</p>
            </remarks>
            <doc-id>hh404278</doc-id>
            <unmanaged>D2D1_BLEND_OPERATION</unmanaged>
            <unmanaged-short>D2D1_BLEND_OPERATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendOperation.Add">
            <summary>
            <dd> <p>Add source 1 and source 2.</p> </dd>
            </summary>
            <doc-id>hh404278</doc-id>
            <unmanaged>D2D1_BLEND_OPERATION_ADD</unmanaged>
            <unmanaged-short>D2D1_BLEND_OPERATION_ADD</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendOperation.Subtract">
            <summary>
            <dd> <p>Subtract source 1 from source 2.</p> </dd>
            </summary>
            <doc-id>hh404278</doc-id>
            <unmanaged>D2D1_BLEND_OPERATION_SUBTRACT</unmanaged>
            <unmanaged-short>D2D1_BLEND_OPERATION_SUBTRACT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendOperation.ReverseSubtract">
            <summary>
            <dd> <p>Subtract source 2 from source 1.</p> </dd>
            </summary>
            <doc-id>hh404278</doc-id>
            <unmanaged>D2D1_BLEND_OPERATION_REV_SUBTRACT</unmanaged>
            <unmanaged-short>D2D1_BLEND_OPERATION_REV_SUBTRACT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendOperation.Minimum">
            <summary>
            <dd> <p>Find the minimum of source 1 and source 2.</p> </dd>
            </summary>
            <doc-id>hh404278</doc-id>
            <unmanaged>D2D1_BLEND_OPERATION_MIN</unmanaged>
            <unmanaged-short>D2D1_BLEND_OPERATION_MIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendOperation.Maximum">
            <summary>
            <dd> <p>Find the maximum of source 1 and source 2.</p> </dd>
            </summary>
            <doc-id>hh404278</doc-id>
            <unmanaged>D2D1_BLEND_OPERATION_MAX</unmanaged>
            <unmanaged-short>D2D1_BLEND_OPERATION_MAX</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BlendProperties">
            <summary>
            <p> Identifiers for properties of the Blend effect. </p>
            </summary>
            <doc-id>dn934218</doc-id>
            <unmanaged>D2D1_BLEND_PROP</unmanaged>
            <unmanaged-short>D2D1_BLEND_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendProperties.Mode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934218</doc-id>
            <unmanaged>D2D1_BLEND_PROP_MODE</unmanaged>
            <unmanaged-short>D2D1_BLEND_PROP_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BorderEdgeMode">
            <summary>
            <p>The edge mode for the Border effect. </p>
            </summary>
            <doc-id>dn934219</doc-id>
            <unmanaged>D2D1_BORDER_EDGE_MODE</unmanaged>
            <unmanaged-short>D2D1_BORDER_EDGE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderEdgeMode.Clamp">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934219</doc-id>
            <unmanaged>D2D1_BORDER_EDGE_MODE_CLAMP</unmanaged>
            <unmanaged-short>D2D1_BORDER_EDGE_MODE_CLAMP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderEdgeMode.Wrap">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934219</doc-id>
            <unmanaged>D2D1_BORDER_EDGE_MODE_WRAP</unmanaged>
            <unmanaged-short>D2D1_BORDER_EDGE_MODE_WRAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderEdgeMode.Mirror">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934219</doc-id>
            <unmanaged>D2D1_BORDER_EDGE_MODE_MIRROR</unmanaged>
            <unmanaged-short>D2D1_BORDER_EDGE_MODE_MIRROR</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BorderMode">
            <summary>
            <p> Specifies how the Crop effect handles the crop rectangle falling on fractional pixel coordinates. </p>
            </summary>
            <doc-id>dn934220</doc-id>
            <unmanaged>D2D1_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderMode.Soft">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934220</doc-id>
            <unmanaged>D2D1_BORDER_MODE_SOFT</unmanaged>
            <unmanaged-short>D2D1_BORDER_MODE_SOFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderMode.Hard">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934220</doc-id>
            <unmanaged>D2D1_BORDER_MODE_HARD</unmanaged>
            <unmanaged-short>D2D1_BORDER_MODE_HARD</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BorderProperties">
            <summary>
            <p>Identifiers for properties of the Border effect.</p>
            </summary>
            <doc-id>dn934221</doc-id>
            <unmanaged>D2D1_BORDER_PROP</unmanaged>
            <unmanaged-short>D2D1_BORDER_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderProperties.EdgeModeX">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934221</doc-id>
            <unmanaged>D2D1_BORDER_PROP_EDGE_MODE_X</unmanaged>
            <unmanaged-short>D2D1_BORDER_PROP_EDGE_MODE_X</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BorderProperties.EdgeModeY">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934221</doc-id>
            <unmanaged>D2D1_BORDER_PROP_EDGE_MODE_Y</unmanaged>
            <unmanaged-short>D2D1_BORDER_PROP_EDGE_MODE_Y</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BrightnessProperties">
            <summary>
            <p>Identifiers for the properties of the Brightness effect.</p>
            </summary>
            <doc-id>dn934223</doc-id>
            <unmanaged>D2D1_BRIGHTNESS_PROP</unmanaged>
            <unmanaged-short>D2D1_BRIGHTNESS_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BrightnessProperties.WhitePoint">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934223</doc-id>
            <unmanaged>D2D1_BRIGHTNESS_PROP_WHITE_POINT</unmanaged>
            <unmanaged-short>D2D1_BRIGHTNESS_PROP_WHITE_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BrightnessProperties.BlackPoint">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934223</doc-id>
            <unmanaged>D2D1_BRIGHTNESS_PROP_BLACK_POINT</unmanaged>
            <unmanaged-short>D2D1_BRIGHTNESS_PROP_BLACK_POINT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BufferPrecision">
            <summary>
            <p>Represents the bit depth of the imaging pipeline in Direct2D.</p>
            </summary>
            <remarks>
            <strong>Note</strong>?? Feature level 9 may or may not support precision types other than 8BPC.?
            </remarks>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BufferPrecision.Unknown">
            <summary>
            <dd> <p>The buffer precision is not specified.</p> </dd>
            </summary>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION_UNKNOWN</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BufferPrecision.PerChannel8UNorm">
            <summary>
            <dd> <p>Use 8-bit normalized integer per channel.</p> </dd>
            </summary>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION_8BPC_UNORM</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION_8BPC_UNORM</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BufferPrecision.PerChannel8UNormSRgb">
            <summary>
            <dd> <p>Use 8-bit normalized integer standard RGB data per channel.</p> </dd>
            </summary>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION_8BPC_UNORM_SRGB</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION_8BPC_UNORM_SRGB</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BufferPrecision.PerChannel16UNorm">
            <summary>
            <dd> <p>Use 16-bit normalized integer per channel.</p> </dd>
            </summary>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION_16BPC_UNORM</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION_16BPC_UNORM</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BufferPrecision.PerChannel16Float">
            <summary>
            <dd> <p>Use 16-bit floats per channel.</p> </dd>
            </summary>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION_16BPC_FLOAT</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION_16BPC_FLOAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BufferPrecision.PerChannel32Float">
            <summary>
            <dd> <p>Use 32-bit floats per channel.</p> </dd>
            </summary>
            <doc-id>hh446986</doc-id>
            <unmanaged>D2D1_BUFFER_PRECISION_32BPC_FLOAT</unmanaged>
            <unmanaged-short>D2D1_BUFFER_PRECISION_32BPC_FLOAT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CapStyle">
            <summary>
            <p>Describes the shape at the end of a line or segment.</p>
            </summary>
            <remarks>
            <p> The following illustration shows the available cap styles for lines or segments. The red portion of the line shows the extra area added by the line cap setting. </p>
            </remarks>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_CAP_STYLE</unmanaged>
            <unmanaged-short>D2D1_CAP_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CapStyle.Flat">
            <summary>
            <dd> <p>A cap that does not extend past the last point of the line. Comparable to cap used for objects other than lines. </p> </dd>
            </summary>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_CAP_STYLE_FLAT</unmanaged>
            <unmanaged-short>D2D1_CAP_STYLE_FLAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CapStyle.Square">
            <summary>
            <dd> <p>Half of a square that has a length equal to the line thickness.</p> </dd>
            </summary>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_CAP_STYLE_SQUARE</unmanaged>
            <unmanaged-short>D2D1_CAP_STYLE_SQUARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CapStyle.Round">
            <summary>
            <dd> <p>A semicircle that has a diameter equal to the line thickness.</p> </dd>
            </summary>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_CAP_STYLE_ROUND</unmanaged>
            <unmanaged-short>D2D1_CAP_STYLE_ROUND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CapStyle.Triangle">
            <summary>
            <dd> <p>An isosceles right triangle whose hypotenuse is equal in length to the thickness of the line.</p> </dd>
            </summary>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_CAP_STYLE_TRIANGLE</unmanaged>
            <unmanaged-short>D2D1_CAP_STYLE_TRIANGLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ChangeType">
            <summary>
            <p>Describes flags that influence how the renderer interacts with a custom vertex shader.</p>
            </summary>
            <doc-id>hh404280</doc-id>
            <unmanaged>D2D1_CHANGE_TYPE</unmanaged>
            <unmanaged-short>D2D1_CHANGE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChangeType.None">
            <summary>
            <dd> <p>There were no changes.</p> </dd>
            </summary>
            <doc-id>hh404280</doc-id>
            <unmanaged>D2D1_CHANGE_TYPE_NONE</unmanaged>
            <unmanaged-short>D2D1_CHANGE_TYPE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChangeType.Properties">
            <summary>
            <dd> <p>The properties of the effect changed.</p> </dd>
            </summary>
            <doc-id>hh404280</doc-id>
            <unmanaged>D2D1_CHANGE_TYPE_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_CHANGE_TYPE_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChangeType.Context">
            <summary>
            <dd> <p>The context state changed.</p> </dd>
            </summary>
            <doc-id>hh404280</doc-id>
            <unmanaged>D2D1_CHANGE_TYPE_CONTEXT</unmanaged>
            <unmanaged-short>D2D1_CHANGE_TYPE_CONTEXT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChangeType.Graph">
            <summary>
            <dd> <p>The effect?s transform graph has changed.  This happens only when an effect supports a variable input count.</p> </dd>
            </summary>
            <doc-id>hh404280</doc-id>
            <unmanaged>D2D1_CHANGE_TYPE_GRAPH</unmanaged>
            <unmanaged-short>D2D1_CHANGE_TYPE_GRAPH</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ChannelDepth">
            <summary>
            <p>Allows a caller to control the channel depth of a stage in the rendering pipeline.</p>
            </summary>
            <doc-id>hh404281</doc-id>
            <unmanaged>D2D1_CHANNEL_DEPTH</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_DEPTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelDepth.Default">
            <summary>
            <dd> <p>The channel depth is the default. It is inherited from the inputs.</p> </dd>
            </summary>
            <doc-id>hh404281</doc-id>
            <unmanaged>D2D1_CHANNEL_DEPTH_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_DEPTH_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelDepth.One">
            <summary>
            <dd> <p>The channel depth is 1.</p> </dd>
            </summary>
            <doc-id>hh404281</doc-id>
            <unmanaged>D2D1_CHANNEL_DEPTH_1</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_DEPTH_1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelDepth.Four">
            <summary>
            <dd> <p>The channel depth is 4.</p> </dd>
            </summary>
            <doc-id>hh404281</doc-id>
            <unmanaged>D2D1_CHANNEL_DEPTH_4</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_DEPTH_4</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ChannelSelector">
            <summary>
            <p>Specifies the color channel the Displacement map effect extracts the intensity from and uses it to spatially displace the image in the X or Y direction.</p>
            </summary>
            <doc-id>dn934224</doc-id>
            <unmanaged>D2D1_CHANNEL_SELECTOR</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_SELECTOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelSelector.R">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934224</doc-id>
            <unmanaged>D2D1_CHANNEL_SELECTOR_R</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_SELECTOR_R</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelSelector.G">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934224</doc-id>
            <unmanaged>D2D1_CHANNEL_SELECTOR_G</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_SELECTOR_G</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelSelector.B">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934224</doc-id>
            <unmanaged>D2D1_CHANNEL_SELECTOR_B</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_SELECTOR_B</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChannelSelector.A">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934224</doc-id>
            <unmanaged>D2D1_CHANNEL_SELECTOR_A</unmanaged>
            <unmanaged-short>D2D1_CHANNEL_SELECTOR_A</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ChromakeyProperty">
            <summary>
            <p>Identifiers for properties of the Chroma-key effect.</p>
            </summary>
            <doc-id>dn890719</doc-id>
            <unmanaged>D2D1_CHROMAKEY_PROP</unmanaged>
            <unmanaged-short>D2D1_CHROMAKEY_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChromakeyProperty.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890719</doc-id>
            <unmanaged>D2D1_CHROMAKEY_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_CHROMAKEY_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChromakeyProperty.Tolerance">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890719</doc-id>
            <unmanaged>D2D1_CHROMAKEY_PROP_TOLERANCE</unmanaged>
            <unmanaged-short>D2D1_CHROMAKEY_PROP_TOLERANCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChromakeyProperty.InvertAlpha">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890719</doc-id>
            <unmanaged>D2D1_CHROMAKEY_PROP_INVERT_ALPHA</unmanaged>
            <unmanaged-short>D2D1_CHROMAKEY_PROP_INVERT_ALPHA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ChromakeyProperty.Feather">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890719</doc-id>
            <unmanaged>D2D1_CHROMAKEY_PROP_FEATHER</unmanaged>
            <unmanaged-short>D2D1_CHROMAKEY_PROP_FEATHER</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorBitmapGlyphSnapOption">
            <summary>
            <p>Specifies the pixel snapping policy when rendering color bitmap glyphs.</p>
            </summary>
            <doc-id>mt736463</doc-id>
            <unmanaged>D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION</unmanaged>
            <unmanaged-short>D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorBitmapGlyphSnapOption.Default">
            <summary>
            <dd> <p>Color bitmap glyph positions are snapped to the nearest pixel if the bitmap resolution matches that of the device context.</p> </dd>
            </summary>
            <doc-id>mt736463</doc-id>
            <unmanaged>D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorBitmapGlyphSnapOption.Disable">
            <summary>
            <dd> <p>Color bitmap glyph positions are not snapped.</p> </dd>
            </summary>
            <doc-id>mt736463</doc-id>
            <unmanaged>D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DISABLE</unmanaged>
            <unmanaged-short>D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DISABLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorContextType">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_COLOR_CONTEXT_TYPE</unmanaged>
            <unmanaged-short>D2D1_COLOR_CONTEXT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorContextType.Icc">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_COLOR_CONTEXT_TYPE_ICC</unmanaged>
            <unmanaged-short>D2D1_COLOR_CONTEXT_TYPE_ICC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorContextType.Simple">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_COLOR_CONTEXT_TYPE_SIMPLE</unmanaged>
            <unmanaged-short>D2D1_COLOR_CONTEXT_TYPE_SIMPLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorContextType.Dxgi">
            <summary>
            <dd> <p>The render target uses hardware rendering only. </p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_COLOR_CONTEXT_TYPE_DXGI</unmanaged>
            <unmanaged-short>D2D1_COLOR_CONTEXT_TYPE_DXGI</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorInterpolationMode">
            <summary>
            <p>Defines how to interpolate between colors.</p>
            </summary>
            <doc-id>hh871441</doc-id>
            <unmanaged>D2D1_COLOR_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_COLOR_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorInterpolationMode.Straight">
            <summary>
            <dd> <p>Colors are interpolated with straight alpha.</p> </dd>
            </summary>
            <doc-id>hh871441</doc-id>
            <unmanaged>D2D1_COLOR_INTERPOLATION_MODE_STRAIGHT</unmanaged>
            <unmanaged-short>D2D1_COLOR_INTERPOLATION_MODE_STRAIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorInterpolationMode.Premultiplied">
            <summary>
            <dd> <p>Colors are interpolated with premultiplied alpha.</p> </dd>
            </summary>
            <doc-id>hh871441</doc-id>
            <unmanaged>D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED</unmanaged>
            <unmanaged-short>D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorManagementAlphaMode">
            <summary>
            <p> Indicates how the Color management effect should interpret alpha data that is contained in the input image. </p>
            </summary>
            <doc-id>dn934225</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementAlphaMode.Premultiplied">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934225</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_ALPHA_MODE_PREMULTIPLIED</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_ALPHA_MODE_PREMULTIPLIED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementAlphaMode.Straight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934225</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_ALPHA_MODE_STRAIGHT</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_ALPHA_MODE_STRAIGHT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorManagementProperties">
            <summary>
            <p> Identifiers for the properties of the Color management effect. </p>
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementProperties.SourceColorContext">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP_SOURCE_COLOR_CONTEXT</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP_SOURCE_COLOR_CONTEXT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementProperties.SourceRenderingIntent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP_SOURCE_RENDERING_INTENT</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP_SOURCE_RENDERING_INTENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementProperties.DestinationColorContext">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP_DESTINATION_COLOR_CONTEXT</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP_DESTINATION_COLOR_CONTEXT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementProperties.DestinationRenderingIntent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP_DESTINATION_RENDERING_INTENT</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP_DESTINATION_RENDERING_INTENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementProperties.AlphaMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementProperties.Quality">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934226</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_PROP_QUALITY</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_PROP_QUALITY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorManagementQuality">
            <summary>
            <p>The quality level of the transform for the Color management effect. </p>
            </summary>
            <doc-id>dn934227</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_QUALITY</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_QUALITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementQuality.Proof">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934227</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_QUALITY_PROOF</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_QUALITY_PROOF</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementQuality.Normal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934227</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_QUALITY_NORMAL</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_QUALITY_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementQuality.Best">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934227</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_QUALITY_BEST</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_QUALITY_BEST</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorManagementRenderingIntent">
            <summary>
            <p>Specifies which ICC rendering intent the Color management effect should use.</p>
            </summary>
            <doc-id>dn934228</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_RENDERING_INTENT</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_RENDERING_INTENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementRenderingIntent.Perceptual">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934228</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_RENDERING_INTENT_PERCEPTUAL</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_RENDERING_INTENT_PERCEPTUAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementRenderingIntent.RelativeColorimetric">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934228</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_RENDERING_INTENT_RELATIVE_COLORIMETRIC</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_RENDERING_INTENT_RELATIVE_COLORIMETRIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementRenderingIntent.Saturation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934228</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_RENDERING_INTENT_SATURATION</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_RENDERING_INTENT_SATURATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorManagementRenderingIntent.AbsoluteColorimetric">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934228</doc-id>
            <unmanaged>D2D1_COLORMANAGEMENT_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC</unmanaged>
            <unmanaged-short>D2D1_COLORMANAGEMENT_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorMatrixAlphaMode">
            <summary>
            <p>The alpha mode of the output of the Color matrix effect.</p>
            </summary>
            <doc-id>dn934229</doc-id>
            <unmanaged>D2D1_COLORMATRIX_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorMatrixAlphaMode.Premultiplied">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934229</doc-id>
            <unmanaged>D2D1_COLORMATRIX_ALPHA_MODE_PREMULTIPLIED</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_ALPHA_MODE_PREMULTIPLIED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorMatrixAlphaMode.Straight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934229</doc-id>
            <unmanaged>D2D1_COLORMATRIX_ALPHA_MODE_STRAIGHT</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_ALPHA_MODE_STRAIGHT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorMatrixProperties">
            <summary>
            <p>Identifiers for the properties of the Color matrix effect.</p>
            </summary>
            <doc-id>dn934230</doc-id>
            <unmanaged>D2D1_COLORMATRIX_PROP</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorMatrixProperties.ColorMatrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934230</doc-id>
            <unmanaged>D2D1_COLORMATRIX_PROP_COLOR_MATRIX</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_PROP_COLOR_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorMatrixProperties.AlphaMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934230</doc-id>
            <unmanaged>D2D1_COLORMATRIX_PROP_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_PROP_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorMatrixProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934230</doc-id>
            <unmanaged>D2D1_COLORMATRIX_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_COLORMATRIX_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ColorSpace">
            <summary>
            <p>Defines options that should be applied to the color space.</p>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_COLOR_SPACE</unmanaged>
            <unmanaged-short>D2D1_COLOR_SPACE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorSpace.Custom">
            <summary>
            <dd> <p>The color space is otherwise described, such as with a color profile.</p> </dd>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_COLOR_SPACE_CUSTOM</unmanaged>
            <unmanaged-short>D2D1_COLOR_SPACE_CUSTOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorSpace.SRgb">
            <summary>
            <dd> <p>The color space is sRGB.</p> </dd>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_COLOR_SPACE_SRGB</unmanaged>
            <unmanaged-short>D2D1_COLOR_SPACE_SRGB</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ColorSpace.ScRgb">
            <summary>
            <dd> <p>The color space is scRGB.</p> </dd>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_COLOR_SPACE_SCRGB</unmanaged>
            <unmanaged-short>D2D1_COLOR_SPACE_SCRGB</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CombineMode">
            <summary>
            <p>Specifies the different methods by which two geometries can be combined.</p>
            </summary>
            <remarks>
            <p>The following illustration shows the different geometry combine modes.
            </p>
            </remarks>
            <doc-id>dd368083</doc-id>
            <unmanaged>D2D1_COMBINE_MODE</unmanaged>
            <unmanaged-short>D2D1_COMBINE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CombineMode.Union">
            <summary>
            <dd> <p>The two regions are combined by taking the union of both. Given two geometries, <em>A</em> and <em>B</em>, the resulting geometry is geometry <em>A</em> + geometry <em>B</em>.</p> </dd>
            </summary>
            <doc-id>dd368083</doc-id>
            <unmanaged>D2D1_COMBINE_MODE_UNION</unmanaged>
            <unmanaged-short>D2D1_COMBINE_MODE_UNION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CombineMode.Intersect">
            <summary>
            <dd> <p>The two regions are combined by taking their intersection. The new area consists of the overlapping region between the two geometries. </p> </dd>
            </summary>
            <doc-id>dd368083</doc-id>
            <unmanaged>D2D1_COMBINE_MODE_INTERSECT</unmanaged>
            <unmanaged-short>D2D1_COMBINE_MODE_INTERSECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CombineMode.Xor">
            <summary>
            <dd> <p>The two regions are combined by taking the area that exists in the first region but not the second and the area that exists in the second region but not the first. Given two geometries, <em>A</em> and <em>B</em>, the new region consists of (<em>A</em>-<em>B</em>) + (<em>B</em>-<em>A</em>). </p> </dd>
            </summary>
            <doc-id>dd368083</doc-id>
            <unmanaged>D2D1_COMBINE_MODE_XOR</unmanaged>
            <unmanaged-short>D2D1_COMBINE_MODE_XOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CombineMode.Exclude">
            <summary>
            <dd> <p>The second region is excluded from the first. Given two geometries, <em>A</em> and <em>B</em>, the area of geometry <em>B</em> is removed from the area of geometry <em>A</em>, producing a region that is <em>A</em>-<em>B</em>.</p> </dd>
            </summary>
            <doc-id>dd368083</doc-id>
            <unmanaged>D2D1_COMBINE_MODE_EXCLUDE</unmanaged>
            <unmanaged-short>D2D1_COMBINE_MODE_EXCLUDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompatibleRenderTargetOptions.None">
            <summary>
            <dd> <p>The render target supports no additional features.</p> </dd>
            </summary>
            <doc-id>dd368085</doc-id>
            <unmanaged>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompatibleRenderTargetOptions.GdiCompatible">
            <summary>
            <dd> <p>The render target supports interoperability with the Windows Graphics Device Interface  (GDI). </p> </dd>
            </summary>
            <doc-id>dd368085</doc-id>
            <unmanaged>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE</unmanaged>
            <unmanaged-short>D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CompositeMode">
            <summary>
            <p>Used to specify the blend mode for all of the Direct2D blending operations.</p>
            </summary>
            <remarks>
            <p>The figure here shows an example of each of the modes with images that have an opacity of 1.0 or 0.5. </p><p></p><p>There can be slightly different interpretations of these enumeration values depending on where the value is used.</p><ul> <li> <p>With a composite effect:
            </p><strong>D2D1_COMPOSITE_MODE_DESTINATION_COPY</strong> is equivalent to <strong>D2D1_COMPOSITE_MODE_SOURCE_COPY</strong> with the inputs inverted.</li> <li> <p> As a parameter to <strong>ID2D1DeviceContext::DrawImage</strong>: </p><strong>D2D1_COMPOSITE_MODE_DESTINATION_COPY</strong> is a no-op since the destination is already in the selected target.</li> </ul>
            </remarks>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.SourceOver">
            <summary>
            <dd> <p>The standard source-over-destination blend mode.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_SOURCE_OVER</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_SOURCE_OVER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.DestinationOver">
            <summary>
            <dd> <p>The destination is rendered over the source.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_DESTINATION_OVER</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_DESTINATION_OVER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.SourceIn">
            <summary>
            <dd> <p>Performs a logical clip of the source pixels against the destination pixels.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_SOURCE_IN</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_SOURCE_IN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.DestinationIn">
            <summary>
            <dd> <p>The inverse of the <strong>D2D1_COMPOSITE_MODE_SOURCE_IN</strong> operation.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_DESTINATION_IN</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_DESTINATION_IN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.SourceOut">
            <summary>
            <dd> <p>This is the logical inverse to <strong>D2D1_COMPOSITE_MODE_SOURCE_IN</strong>.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_SOURCE_OUT</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_SOURCE_OUT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.DestinationOut">
            <summary>
            <dd> <p>The is the logical inverse to <strong>D2D1_COMPOSITE_MODE_DESTINATION_IN</strong>.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_DESTINATION_OUT</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_DESTINATION_OUT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.SourceAtop">
            <summary>
            <dd> <p>Writes the source pixels over the destination where there are destination pixels.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_SOURCE_ATOP</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_SOURCE_ATOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.DestinationAtop">
            <summary>
            <dd> <p>The logical inverse of <strong>D2D1_COMPOSITE_MODE_SOURCE_ATOP</strong>.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_DESTINATION_ATOP</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_DESTINATION_ATOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.Xor">
            <summary>
            <dd> <p>The source is inverted with the destination.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_XOR</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_XOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.Plus">
            <summary>
            <dd> <p>The channel components are summed.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_PLUS</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_PLUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.SourceCopy">
            <summary>
            <dd> <p>The source is copied to the destination; the destination pixels are ignored.</p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_SOURCE_COPY</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_SOURCE_COPY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.BoundedSourceCopy">
            <summary>
            <dd> <p>Equivalent to <strong>D2D1_COMPOSITE_MODE_SOURCE_COPY</strong>, but pixels outside of the source bounds are unchanged.
            </p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_BOUNDED_SOURCE_COPY</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_BOUNDED_SOURCE_COPY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeMode.MaskInvert">
            <summary>
            <dd> <p>Destination colors are inverted according to a source mask.
            </p> </dd>
            </summary>
            <doc-id>hh446995</doc-id>
            <unmanaged>D2D1_COMPOSITE_MODE_MASK_INVERT</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_MODE_MASK_INVERT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CompositeProperties">
            <summary>
            <p> Identifiers for properties of the Composite effect. </p>
            </summary>
            <doc-id>dn934231</doc-id>
            <unmanaged>D2D1_COMPOSITE_PROP</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CompositeProperties.Mode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934231</doc-id>
            <unmanaged>D2D1_COMPOSITE_PROP_MODE</unmanaged>
            <unmanaged-short>D2D1_COMPOSITE_PROP_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ContrastProperty">
            <summary>
            <p>Identifiers for properties of the Contrast effect.</p>
            </summary>
            <doc-id>dn890720</doc-id>
            <unmanaged>D2D1_CONTRAST_PROP</unmanaged>
            <unmanaged-short>D2D1_CONTRAST_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ContrastProperty.Contrast">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890720</doc-id>
            <unmanaged>D2D1_CONTRAST_PROP_CONTRAST</unmanaged>
            <unmanaged-short>D2D1_CONTRAST_PROP_CONTRAST</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ContrastProperty.ClampInput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890720</doc-id>
            <unmanaged>D2D1_CONTRAST_PROP_CLAMP_INPUT</unmanaged>
            <unmanaged-short>D2D1_CONTRAST_PROP_CLAMP_INPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ConvoleMatrixProperties">
            <summary>
            <p>Identifiers for properties of the Convolve matrix effect.</p>
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.KernelSizeX">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_X</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_X</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.KernelSizeY">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_Y</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_Y</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.KernelMatrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_KERNEL_MATRIX</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_KERNEL_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.Divisor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_DIVISOR</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_DIVISOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.Bias">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_BIAS</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_BIAS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.KernelOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_KERNEL_OFFSET</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_KERNEL_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.PreserveAlpha">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_PRESERVE_ALPHA</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_PRESERVE_ALPHA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934232</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ConvoleMatrixScaleMode">
            <summary>
            <p>The interpolation mode the Convolve matrix effect uses to scale the image to the corresponding kernel unit length.  There are six scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ConvoleMatrixScaleMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934233</doc-id>
            <unmanaged>D2D1_CONVOLVEMATRIX_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_CONVOLVEMATRIX_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CropProperties">
            <summary>
            <p>Identifiers for properties of the Crop effect.</p>
            </summary>
            <doc-id>dn934234</doc-id>
            <unmanaged>D2D1_CROP_PROP</unmanaged>
            <unmanaged-short>D2D1_CROP_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CropProperties.Rectangle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934234</doc-id>
            <unmanaged>D2D1_CROP_PROP_RECT</unmanaged>
            <unmanaged-short>D2D1_CROP_PROP_RECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CropProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934234</doc-id>
            <unmanaged>D2D1_CROP_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_CROP_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CrossfadeProp">
            <summary>
            <p>This effect combines two images by adding weighted pixels from input images. It has two inputs, named Destination and Source.</p><p>The cross fade formula is <strong>output = weight * Destination + (1 - weight) * Source</strong>.</p><p>The CLSID for this effect is <see cref = "!:CrossFade"/>.</p>
            </summary>
            <doc-id>mt745030</doc-id>
            <unmanaged>D2D1_CROSSFADE_PROP</unmanaged>
            <unmanaged-short>D2D1_CROSSFADE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CrossfadeProp.Weight">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt745030</doc-id>
            <unmanaged>D2D1_CROSSFADE_PROP_WEIGHT</unmanaged>
            <unmanaged-short>D2D1_CROSSFADE_PROP_WEIGHT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DashStyle">
            <summary>
            <p>Describes the sequence of dashes and gaps in a stroke. </p>
            </summary>
            <remarks>
            <p>The following illustration shows several available dash styles.  </p>
            </remarks>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DashStyle.Solid">
            <summary>
            <dd> <p>A solid line with no breaks.</p> </dd>
            </summary>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE_SOLID</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE_SOLID</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DashStyle.Dash">
            <summary>
            <dd> <p>A dash followed by a gap of equal length. The dash and the gap are each twice as long as the stroke thickness.</p> <p>The equivalent dash  array for  <strong>D2D1_DASH_STYLE_DASH</strong> is {2, 2}.</p> </dd>
            </summary>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE_DASH</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE_DASH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DashStyle.Dot">
            <summary>
            <dd> <p>A dot followed by a longer gap.</p> <p>The equivalent dash  array for  <strong>D2D1_DASH_STYLE_DOT</strong> is {0, 2}.</p> </dd>
            </summary>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE_DOT</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE_DOT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DashStyle.DashDot">
            <summary>
            <dd> <p>A dash, followed by a gap, followed by a dot, followed by another gap.</p> <p>The equivalent dash array for  <strong>D2D1_DASH_STYLE_DASH_DOT</strong> is {2, 2, 0, 2}.</p> </dd>
            </summary>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE_DASH_DOT</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE_DASH_DOT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DashStyle.DashDotDot">
            <summary>
            <dd> <p>A dash, followed by a gap, followed by a dot, followed by another gap, followed by another dot, followed by another gap.</p> <p>The equivalent dash array for  <strong>D2D1_DASH_STYLE_DASH_DOT_DOT</strong> is {2, 2, 0, 2, 0, 2}.</p> </dd>
            </summary>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE_DASH_DOT_DOT</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE_DASH_DOT_DOT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DashStyle.Custom">
            <summary>
            <dd> <p>The dash pattern is specified by an array of floating-point values.</p> </dd>
            </summary>
            <doc-id>dd368087</doc-id>
            <unmanaged>D2D1_DASH_STYLE_CUSTOM</unmanaged>
            <unmanaged-short>D2D1_DASH_STYLE_CUSTOM</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DebugLevel">
            <summary>
            <p>Indicates the type of information provided by the Direct2D Debug Layer.  </p>
            </summary>
            <remarks>
            <p>To receive debugging messages, you must install the Direct2D Debug Layer.</p>
            </remarks>
            <doc-id>dd368090</doc-id>
            <unmanaged>D2D1_DEBUG_LEVEL</unmanaged>
            <unmanaged-short>D2D1_DEBUG_LEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DebugLevel.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368090</doc-id>
            <unmanaged>D2D1_DEBUG_LEVEL_NONE</unmanaged>
            <unmanaged-short>D2D1_DEBUG_LEVEL_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DebugLevel.Error">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368090</doc-id>
            <unmanaged>D2D1_DEBUG_LEVEL_ERROR</unmanaged>
            <unmanaged-short>D2D1_DEBUG_LEVEL_ERROR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DebugLevel.Warning">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368090</doc-id>
            <unmanaged>D2D1_DEBUG_LEVEL_WARNING</unmanaged>
            <unmanaged-short>D2D1_DEBUG_LEVEL_WARNING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DebugLevel.Information">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368090</doc-id>
            <unmanaged>D2D1_DEBUG_LEVEL_INFORMATION</unmanaged>
            <unmanaged-short>D2D1_DEBUG_LEVEL_INFORMATION</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DeviceContextInitializeMode">
            <summary>
            <p> Specifies how a device context is initialized for GDI rendering when it is retrieved from the render target.</p>
            </summary>
            <remarks>
            <p>Use this enumeration with the <strong>ID2D1GdiInteropRenderTarget::GetDC</strong> method to specify how the device context is  initialized for GDI rendering.</p>
            </remarks>
            <doc-id>dd368088</doc-id>
            <unmanaged>D2D1_DC_INITIALIZE_MODE</unmanaged>
            <unmanaged-short>D2D1_DC_INITIALIZE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DeviceContextInitializeMode.Copy">
            <summary>
            <dd> <p>The current contents of the render target are copied to the device context when it is initialized. </p> </dd>
            </summary>
            <doc-id>dd368088</doc-id>
            <unmanaged>D2D1_DC_INITIALIZE_MODE_COPY</unmanaged>
            <unmanaged-short>D2D1_DC_INITIALIZE_MODE_COPY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DeviceContextInitializeMode.Clear">
            <summary>
            <dd> <p>The device context is cleared to transparent black when it is initialized.</p> </dd>
            </summary>
            <doc-id>dd368088</doc-id>
            <unmanaged>D2D1_DC_INITIALIZE_MODE_CLEAR</unmanaged>
            <unmanaged-short>D2D1_DC_INITIALIZE_MODE_CLEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DeviceContextOptions.None">
            <summary>
            <dd> <p>The device context is created with default options.</p> </dd>
            </summary>
            <doc-id>hh446998</doc-id>
            <unmanaged>D2D1_DEVICE_CONTEXT_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_DEVICE_CONTEXT_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DeviceContextOptions.EnableMultithreadedOptimizations">
            <summary>
            <dd> <p>Distribute rendering work across multiple threads. Refer to Improving the performance of Direct2D apps for additional notes on the use of this flag.</p> </dd>
            </summary>
            <doc-id>hh446998</doc-id>
            <unmanaged>D2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS</unmanaged>
            <unmanaged-short>D2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DirectionalBlurOptimization">
            <summary>
            <p>Specifies the optimization mode for the Directional blur effect.</p>
            </summary>
            <doc-id>dn934235</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_OPTIMIZATION</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurOptimization.Speed">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934235</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_OPTIMIZATION_SPEED</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_OPTIMIZATION_SPEED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurOptimization.Balanced">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934235</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_OPTIMIZATION_BALANCED</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_OPTIMIZATION_BALANCED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurOptimization.Quality">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934235</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_OPTIMIZATION_QUALITY</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_OPTIMIZATION_QUALITY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DirectionalBlurProperties">
            <summary>
            <p> Identifiers for properties of the Directional blur effect. </p>
            </summary>
            <doc-id>dn934236</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_PROP</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurProperties.StandardDeviation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934236</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_PROP_STANDARD_DEVIATION</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_PROP_STANDARD_DEVIATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurProperties.Angle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934236</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_PROP_ANGLE</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_PROP_ANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurProperties.Optimization">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934236</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_PROP_OPTIMIZATION</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_PROP_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DirectionalBlurProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934236</doc-id>
            <unmanaged>D2D1_DIRECTIONALBLUR_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_DIRECTIONALBLUR_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DiscreteTransferProperties">
            <summary>
            <p>Identifiers for properties of the Discrete transfer effect.</p>
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.RedTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_RED_TABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_RED_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.RedDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_RED_DISABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_RED_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.GreenTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_GREEN_TABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_GREEN_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.GreenDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_GREEN_DISABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_GREEN_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.BlueTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_BLUE_TABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_BLUE_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.BlueDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_BLUE_DISABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_BLUE_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.AlphaTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_ALPHA_TABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_ALPHA_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.AlphaDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_ALPHA_DISABLE</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_ALPHA_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DiscreteTransferProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934237</doc-id>
            <unmanaged>D2D1_DISCRETETRANSFER_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_DISCRETETRANSFER_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DisplacementMapProperties">
            <summary>
            <p> Identifiers for properties of the Displacement map effect. </p>
            </summary>
            <doc-id>dn934238</doc-id>
            <unmanaged>D2D1_DISPLACEMENTMAP_PROP</unmanaged>
            <unmanaged-short>D2D1_DISPLACEMENTMAP_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DisplacementMapProperties.Scale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934238</doc-id>
            <unmanaged>D2D1_DISPLACEMENTMAP_PROP_SCALE</unmanaged>
            <unmanaged-short>D2D1_DISPLACEMENTMAP_PROP_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DisplacementMapProperties.XChannelSelect">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934238</doc-id>
            <unmanaged>D2D1_DISPLACEMENTMAP_PROP_X_CHANNEL_SELECT</unmanaged>
            <unmanaged-short>D2D1_DISPLACEMENTMAP_PROP_X_CHANNEL_SELECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DisplacementMapProperties.YChannelSelect">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934238</doc-id>
            <unmanaged>D2D1_DISPLACEMENTMAP_PROP_Y_CHANNEL_SELECT</unmanaged>
            <unmanaged-short>D2D1_DISPLACEMENTMAP_PROP_Y_CHANNEL_SELECT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DistantDiffuseProperties">
            <summary>
            <p>Identifiers for properties of the Distant-diffuse lighting effect.</p>
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.Azimuth">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_AZIMUTH</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_AZIMUTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.Elevation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_ELEVATION</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_ELEVATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.DiffuseConstant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_DIFFUSE_CONSTANT</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_DIFFUSE_CONSTANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.SurfaceScale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_SURFACE_SCALE</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_SURFACE_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934239</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DistantDiffuseScaleMode">
            <summary>
            <p>The interpolation mode the effect uses to scale the image to the corresponding kernel unit length. There are six scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseScaleMode.NearestNeighbor">
            <summary>
            <dd> <p>Samples the nearest single point and uses that. This mode uses less processing time, but outputs the lowest quality image.</p> </dd>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseScaleMode.Linear">
            <summary>
            <dd> <p>Uses a four point sample and linear interpolation. This mode outputs a higher quality image than nearest neighbor.</p> </dd>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseScaleMode.Cubic">
            <summary>
            <dd> <p>Uses a 16 sample cubic kernel for interpolation. This mode uses the most processing time, but outputs a higher quality image. </p> </dd>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseScaleMode.MultiSampleLinear">
            <summary>
            <dd> <p>Uses 4 linear samples within a single pixel for good edge anti-aliasing. This mode is good for scaling down by small amounts on images with few pixels.</p> </dd>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseScaleMode.Anisotropic">
            <summary>
            <dd> <p>Uses anisotropic filtering to sample a pattern according to the transformed shape of the bitmap.</p> </dd>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantDiffuseScaleMode.HighQualityCubic">
            <summary>
            <dd> <p>Uses a variable size high quality cubic kernel to perform a pre-downscale the image if downscaling is involved in the transform matrix.  Then uses the cubic interpolation mode for the final output.</p> </dd>
            </summary>
            <doc-id>dn934240</doc-id>
            <unmanaged>D2D1_DISTANTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_DISTANTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DistantSpecularProperties">
            <summary>
            <p> Identifiers for properties of the Distant-specular lighting effect. </p>
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.Azimuth">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_AZIMUTH</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_AZIMUTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.Elevation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_ELEVATION</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_ELEVATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.SpecularExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_SPECULAR_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_SPECULAR_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.SpecularConstant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_SPECULAR_CONSTANT</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_SPECULAR_CONSTANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.SurfaceScale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_SURFACE_SCALE</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_SURFACE_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934241</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DistantSpecularScaleMode">
            <summary>
            <p>The interpolation mode the Distant-specular lighting effect uses to scale the image to the corresponding kernel unit length.  There are six scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DistantSpecularScaleMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934242</doc-id>
            <unmanaged>D2D1_DISTANTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_DISTANTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DpiCompensationInterpolationMode">
            <summary>
            <p> The interpolation mode the DPI compensation effect uses to scale the image. </p>
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationInterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationInterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationInterpolationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationInterpolationMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationInterpolationMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationInterpolationMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934243</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DpiCompensationProperties">
            <summary>
            <p> Identifiers for properties of the DPI compensation effect. </p>
            </summary>
            <doc-id>dn934244</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_PROP</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934244</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934244</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DpiCompensationProperties.InputDpi">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934244</doc-id>
            <unmanaged>D2D1_DPICOMPENSATION_PROP_INPUT_DPI</unmanaged>
            <unmanaged-short>D2D1_DPICOMPENSATION_PROP_INPUT_DPI</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawTextOptions.NoSnap">
            <summary>
            <dd> <p>Text is not vertically snapped to pixel boundaries. This setting is recommended for text that is being animated. </p> </dd>
            </summary>
            <doc-id>dd368095</doc-id>
            <unmanaged>D2D1_DRAW_TEXT_OPTIONS_NO_SNAP</unmanaged>
            <unmanaged-short>D2D1_DRAW_TEXT_OPTIONS_NO_SNAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawTextOptions.Clip">
            <summary>
            <dd> <p>Text is clipped to the layout rectangle.</p> </dd>
            </summary>
            <doc-id>dd368095</doc-id>
            <unmanaged>D2D1_DRAW_TEXT_OPTIONS_CLIP</unmanaged>
            <unmanaged-short>D2D1_DRAW_TEXT_OPTIONS_CLIP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawTextOptions.EnableColorFont">
            <summary>
            <dd> <p>In Windows?8.1 and later, text is rendered using color versions of glyphs, if defined by the font.</p> </dd>
            </summary>
            <doc-id>dd368095</doc-id>
            <unmanaged>D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT</unmanaged>
            <unmanaged-short>D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawTextOptions.DisableColorBitmapSnapping">
            <summary>
            <dd> <p>Bitmap origins of color glyph bitmaps are not snapped.</p> </dd>
            </summary>
            <doc-id>dd368095</doc-id>
            <unmanaged>D2D1_DRAW_TEXT_OPTIONS_DISABLE_COLOR_BITMAP_SNAPPING</unmanaged>
            <unmanaged-short>D2D1_DRAW_TEXT_OPTIONS_DISABLE_COLOR_BITMAP_SNAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawTextOptions.None">
            <summary>
            <dd> <p>Text is vertically snapped to pixel boundaries and is not clipped to the layout rectangle. </p> </dd>
            </summary>
            <doc-id>dd368095</doc-id>
            <unmanaged>D2D1_DRAW_TEXT_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_DRAW_TEXT_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.EdgeDetectionMode">
            <summary>
            <p>Values for the <strong>D2D1_EDGEDETECTION_PROP_MODE</strong> property of the Edge Detection effect.</p>
            </summary>
            <doc-id>dn890722</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_MODE</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionMode.StreamOutputBel">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890722</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_MODE_SOBEL</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_MODE_SOBEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionMode.Prewitt">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890722</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_MODE_PREWITT</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_MODE_PREWITT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.EdgeDetectionProperty">
            <summary>
            <p>Identifiers for properties of the Edge Detection effect.</p>
            </summary>
            <doc-id>dn890723</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_PROP</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionProperty.Strength">
            <summary>
            <dd> <p>The D2D1_EDGEDETECTION_PROP_STRENGTH property is a float value modulating the response of the edge detection filter. A low strength value means that weaker edges will get filtered out,  while a high value means stronger edges will get filtered out.  The allowed range is 0.0 to 1.0.  The default value is 0.5.</p> </dd>
            </summary>
            <doc-id>dn890723</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_PROP_STRENGTH</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_PROP_STRENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionProperty.BlurRadius">
            <summary>
            <dd> <p>The D2D1_EDGEDETECTION_PROP_BLUR_RADIUS property is a float value specifying the amount of blur to apply.  Applying blur is used to remove high frequencies and reduce phantom edges.   The allowed range is 0.0 to 10.0. The default value is 0.0 (no blur applied).</p> </dd>
            </summary>
            <doc-id>dn890723</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_PROP_BLUR_RADIUS</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_PROP_BLUR_RADIUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionProperty.Mode">
            <summary>
            <dd> <p>The D2D1_EDGEDETECTION_PROP_MODE property is a <strong><see cref = "T:SharpDX.Direct2D1.EdgeDetectionMode"/></strong> enumeration value which mode to use for edge detection.   The default value is D2D1_EDGEDETECTION_MODE_SOBEL.</p> </dd>
            </summary>
            <doc-id>dn890723</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_PROP_MODE</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_PROP_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionProperty.OverlayEdges">
            <summary>
            <dd> <p>The D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES property is a boolean value. Edge detection only applies to the RGB channels, the alpha channel is ignored for purposes of detecting edges. If D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES is false, the output edges is fully opaque. If D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES is true, the input opacity is preserved. The default value is false.</p> </dd>
            </summary>
            <doc-id>dn890723</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EdgeDetectionProperty.AlphaMode">
            <summary>
            <dd> <p>The D2D1_EDGEDETECTION_PROP_ALPHA_MODE property is a <strong><see cref = "T:SharpDX.Direct2D1.AlphaMode"/></strong> enumeration value indicating the alpha mode of the input file. If the input is not opaque, this value is used to determine whether to unpremultiply the inputs. See the About Alpha Modes section of the Supported Pixel Formats and Alpha Modes topic for additional information.    The default value is D2D1_ALPHA_MODE_PREMULTIPLIED.</p> </dd>
            </summary>
            <doc-id>dn890723</doc-id>
            <unmanaged>D2D1_EDGEDETECTION_PROP_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_EDGEDETECTION_PROP_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.EmbossProperty">
            <summary>
            <p>Identifiers for properties of the Emboss effect.</p>
            </summary>
            <doc-id>dn890724</doc-id>
            <unmanaged>D2D1_EMBOSS_PROP</unmanaged>
            <unmanaged-short>D2D1_EMBOSS_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EmbossProperty.Height">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890724</doc-id>
            <unmanaged>D2D1_EMBOSS_PROP_HEIGHT</unmanaged>
            <unmanaged-short>D2D1_EMBOSS_PROP_HEIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EmbossProperty.Direction">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890724</doc-id>
            <unmanaged>D2D1_EMBOSS_PROP_DIRECTION</unmanaged>
            <unmanaged-short>D2D1_EMBOSS_PROP_DIRECTION</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ExposureProperty">
            <summary>
            <p>Identifiers for properties of the Exposure effect.</p>
            </summary>
            <doc-id>dn890725</doc-id>
            <unmanaged>D2D1_EXPOSURE_PROP</unmanaged>
            <unmanaged-short>D2D1_EXPOSURE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ExposureProperty.ExposureValue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890725</doc-id>
            <unmanaged>D2D1_EXPOSURE_PROP_EXPOSURE_VALUE</unmanaged>
            <unmanaged-short>D2D1_EXPOSURE_PROP_EXPOSURE_VALUE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ExtendMode">
            <summary>
            <p>Specifies how a brush paints areas outside of its normal content area.</p>
            </summary>
            <remarks>
            <p>For an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong>, the brush's content is the brush's bitmap. For an <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrush"/></strong>, the brush's content area is the gradient axis. For an <strong><see cref = "T:SharpDX.Direct2D1.RadialGradientBrush"/></strong>, the brush's content is the area within the gradient ellipse.  </p>
            </remarks>
            <doc-id>dd368100</doc-id>
            <unmanaged>D2D1_EXTEND_MODE</unmanaged>
            <unmanaged-short>D2D1_EXTEND_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ExtendMode.Clamp">
            <summary>
            <dd> <p>Repeat the edge pixels of the brush's content for all regions outside the normal content area.</p> </dd>
            </summary>
            <doc-id>dd368100</doc-id>
            <unmanaged>D2D1_EXTEND_MODE_CLAMP</unmanaged>
            <unmanaged-short>D2D1_EXTEND_MODE_CLAMP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ExtendMode.Wrap">
            <summary>
            <dd> <p>Repeat the brush's content.</p> </dd>
            </summary>
            <doc-id>dd368100</doc-id>
            <unmanaged>D2D1_EXTEND_MODE_WRAP</unmanaged>
            <unmanaged-short>D2D1_EXTEND_MODE_WRAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ExtendMode.Mirror">
            <summary>
            <dd> <p> The same as D2D1_EXTEND_MODE_WRAP, except that alternate tiles of the brush's content are flipped. (The brush's normal content is drawn untransformed.)</p> </dd>
            </summary>
            <doc-id>dd368100</doc-id>
            <unmanaged>D2D1_EXTEND_MODE_MIRROR</unmanaged>
            <unmanaged-short>D2D1_EXTEND_MODE_MIRROR</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FactoryType">
            <summary>
            <p>Specifies whether Direct2D provides synchronization for an <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> and the resources it creates, so that they may be safely accessed from multiple threads. </p>
            </summary>
            <remarks>
            <p>When you create a factory, you can specify whether it is multithreaded or singlethreaded. A singlethreaded factory provides no serialization against any other single threaded instance within Direct2D, so this mechanism provides a very large degree of scaling on the CPU.</p><p>You can also create a multithreaded factory instance. In this case, the factory and all derived objects can be used from any thread, and each render target can be rendered to independently. Direct2D serializes calls to these objects, so a single multithreaded Direct2D instance won't scale as well on the CPU as many single threaded instances. However, the resources can be shared within the multithreaded instance.</p><p>Note the qualifier "On the CPU": GPUs generally take advantage of fine-grained parallelism more so than CPUs. For example, multithreaded calls from the CPU might still end up being serialized when being sent to the GPU; however, a whole bank of pixel and vertex shaders will run in parallel to perform the rendering.</p>
            </remarks>
            <doc-id>dd368104</doc-id>
            <unmanaged>D2D1_FACTORY_TYPE</unmanaged>
            <unmanaged-short>D2D1_FACTORY_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FactoryType.SingleThreaded">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368104</doc-id>
            <unmanaged>D2D1_FACTORY_TYPE_SINGLE_THREADED</unmanaged>
            <unmanaged-short>D2D1_FACTORY_TYPE_SINGLE_THREADED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FactoryType.MultiThreaded">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368104</doc-id>
            <unmanaged>D2D1_FACTORY_TYPE_MULTI_THREADED</unmanaged>
            <unmanaged-short>D2D1_FACTORY_TYPE_MULTI_THREADED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Feature">
            <summary>
            <p>Defines capabilities of the underlying Direct3D device which may be queried using <strong>ID2D1EffectContext::CheckFeatureSupport</strong>.</p>
            </summary>
            <doc-id>hh871443</doc-id>
            <unmanaged>D2D1_FEATURE</unmanaged>
            <unmanaged-short>D2D1_FEATURE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Feature.Doubles">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh871443</doc-id>
            <unmanaged>D2D1_FEATURE_DOUBLES</unmanaged>
            <unmanaged-short>D2D1_FEATURE_DOUBLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Feature.D3D10XHardwareOptions">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh871443</doc-id>
            <unmanaged>D2D1_FEATURE_D3D10_X_HARDWARE_OPTIONS</unmanaged>
            <unmanaged-short>D2D1_FEATURE_D3D10_X_HARDWARE_OPTIONS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FeatureLevel">
            <summary>
            <p>Describes the minimum DirectX support required for hardware rendering by a render target.</p>
            </summary>
            <doc-id>dd756628</doc-id>
            <unmanaged>D2D1_FEATURE_LEVEL</unmanaged>
            <unmanaged-short>D2D1_FEATURE_LEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FeatureLevel.Level_DEFAULT">
            <summary>
            <dd> <p>Direct2D determines whether the video card provides adequate hardware rendering support.</p> </dd>
            </summary>
            <doc-id>dd756628</doc-id>
            <unmanaged>D2D1_FEATURE_LEVEL_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_FEATURE_LEVEL_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FeatureLevel.Level_9">
            <summary>
            <dd> <p>The video card must support DirectX 9.</p> </dd>
            </summary>
            <doc-id>dd756628</doc-id>
            <unmanaged>D2D1_FEATURE_LEVEL_9</unmanaged>
            <unmanaged-short>D2D1_FEATURE_LEVEL_9</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FeatureLevel.Level_10">
            <summary>
            <dd> <p>The video card must support DirectX 10. </p> </dd>
            </summary>
            <doc-id>dd756628</doc-id>
            <unmanaged>D2D1_FEATURE_LEVEL_10</unmanaged>
            <unmanaged-short>D2D1_FEATURE_LEVEL_10</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FigureBegin">
            <summary>
            <p>Indicates whether a specific <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> figure is filled or hollow. </p>
            </summary>
            <doc-id>dd368106</doc-id>
            <unmanaged>D2D1_FIGURE_BEGIN</unmanaged>
            <unmanaged-short>D2D1_FIGURE_BEGIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FigureBegin.Filled">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368106</doc-id>
            <unmanaged>D2D1_FIGURE_BEGIN_FILLED</unmanaged>
            <unmanaged-short>D2D1_FIGURE_BEGIN_FILLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FigureBegin.Hollow">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368106</doc-id>
            <unmanaged>D2D1_FIGURE_BEGIN_HOLLOW</unmanaged>
            <unmanaged-short>D2D1_FIGURE_BEGIN_HOLLOW</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FigureEnd">
            <summary>
            <p>Indicates whether a specific  <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> figure is open or closed. </p>
            </summary>
            <doc-id>dd368108</doc-id>
            <unmanaged>D2D1_FIGURE_END</unmanaged>
            <unmanaged-short>D2D1_FIGURE_END</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FigureEnd.Open">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368108</doc-id>
            <unmanaged>D2D1_FIGURE_END_OPEN</unmanaged>
            <unmanaged-short>D2D1_FIGURE_END_OPEN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FigureEnd.Closed">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368108</doc-id>
            <unmanaged>D2D1_FIGURE_END_CLOSED</unmanaged>
            <unmanaged-short>D2D1_FIGURE_END_CLOSED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FillMode">
            <summary>
            <p>Specifies how the intersecting areas of geometries or figures are combined to form the area of the composite geometry. </p>
            </summary>
            <remarks>
            <p>Use the <strong><see cref = "T:SharpDX.Direct2D1.FillMode"/></strong> enumeration when creating an <strong><see cref = "T:SharpDX.Direct2D1.GeometryGroup"/></strong> with the <strong>CreateGeometryGroup</strong> method, or when modifying the fill mode of an <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> with the <strong>ID2D1SimplifiedGeometrySink::SetFillMode</strong> method.</p><p>Direct2D fills the interior of a path by using one of the two fill modes specified by this enumeration: <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) or <strong>D2D1_FILL_MODE_WINDING</strong> (winding). Because the modes determine how to fill the interior of a closed shape, all shapes are treated as closed when they are filled.  If there is a gap in a segment in a shape, draw an imaginary line to close it. </p><p> To see the difference between the winding and alternate fill modes, assume that you have four circles with the same center and a different radius, as shown in the following illustration. The first one has the radius of 25, the second 50, the third 75, and the fourth 100.</p><p>The following  illustration shows the shape filled by using the alternate fill mode. Notice that the center and third ring are not filled. This is because a ray drawn from any point in either of those two rings passes through an even number of segments. </p><p>The following illustration explains this process. </p><p>The following illustration shows how the same shape is filled when the winding fill mode is specified. </p><p>Notice that all the rings are filled. This is because all the segments run in the same direction, so a ray drawn from any point will cross one or more segments, and the sum of the crossings will not equal zero. </p><p>The following illustration explains this process. The red arrows represent the direction in which the segments are drawn and the black arrow represents an arbitrary ray that runs from a point in the innermost ring. Starting with a value of zero, for each segment that the ray crosses, a value of one is added for every clockwise intersection. All points lie in the fill region in this illustration, because the count does not equal zero. </p>
            </remarks>
            <doc-id>dd368110</doc-id>
            <unmanaged>D2D1_FILL_MODE</unmanaged>
            <unmanaged-short>D2D1_FILL_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FillMode.Alternate">
            <summary>
            <dd> <p>Determines whether a point is in the fill region by drawing a ray from that point to infinity in any direction, and then counting the number of path segments within the given shape that the ray crosses. If this number is odd, the point is in the fill region; if even, the point is outside the fill region.  </p> </dd>
            </summary>
            <doc-id>dd368110</doc-id>
            <unmanaged>D2D1_FILL_MODE_ALTERNATE</unmanaged>
            <unmanaged-short>D2D1_FILL_MODE_ALTERNATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FillMode.Winding">
            <summary>
            <dd> <p>Determines whether a point is in the fill region of the path by drawing a ray from that point to infinity in any direction, and then examining the places where a segment of the shape crosses the ray. Starting with a count of zero, add one each time a segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left,  as long as left and right are seen from the perspective of the ray. After counting the crossings, if the result is zero, then the point is outside the path. Otherwise, it is inside the path.  </p> </dd>
            </summary>
            <doc-id>dd368110</doc-id>
            <unmanaged>D2D1_FILL_MODE_WINDING</unmanaged>
            <unmanaged-short>D2D1_FILL_MODE_WINDING</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Filter">
            <summary>
            <p>Represents filtering modes that a transform may select to use on input textures.</p>
            </summary>
            <remarks>
            <p>This enumeration has the same numeric values as <strong><see cref = "!:SharpDX.Direct3D11.Filter"/></strong>.</p>
            </remarks>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER</unmanaged>
            <unmanaged-short>D2D1_FILTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumMagMipPoint">
            <summary>
            <dd> <p>Use point sampling for minification, magnification, and mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_MAG_MIP_POINT</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_MAG_MIP_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumMagPointMipLinear">
            <summary>
            <dd> <p>Use point sampling for minification and magnification; use linear interpolation for mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_MAG_POINT_MIP_LINEAR</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_MAG_POINT_MIP_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumPointMagLinearMipPoint">
            <summary>
            <dd> <p>Use point sampling for minification; use linear interpolation for magnification; use point sampling for mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumPointMagMipLinear">
            <summary>
            <dd> <p>Use point sampling for minification; use linear interpolation for magnification and mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_POINT_MAG_MIP_LINEAR</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_POINT_MAG_MIP_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumLinearMagMipPoint">
            <summary>
            <dd> <p>Use linear interpolation for minification; use point sampling for magnification and mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_LINEAR_MAG_MIP_POINT</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_LINEAR_MAG_MIP_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumLinearMagPointMipLinear">
            <summary>
            <dd> <p>Use linear interpolation for minification; use point sampling for magnification; use linear interpolation for mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumMagLinearMipPoint">
            <summary>
            <dd> <p>Use linear interpolation for minification and magnification; use point sampling for mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_MAG_LINEAR_MIP_POINT</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_MAG_LINEAR_MIP_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.MinimumMagMipLinear">
            <summary>
            <dd> <p>Use linear interpolation for minification, magnification, and mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_MIN_MAG_MIP_LINEAR</unmanaged>
            <unmanaged-short>D2D1_FILTER_MIN_MAG_MIP_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Filter.Anisotropic">
            <summary>
            <dd> <p>Use anisotropic interpolation for minification, magnification, and mip-level sampling.</p> </dd>
            </summary>
            <doc-id>hh404306</doc-id>
            <unmanaged>D2D1_FILTER_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_FILTER_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FloodProperties">
            <summary>
            <p> Identifiers for properties of the Flood effect. </p>
            </summary>
            <doc-id>dn934245</doc-id>
            <unmanaged>D2D1_FLOOD_PROP</unmanaged>
            <unmanaged-short>D2D1_FLOOD_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FloodProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934245</doc-id>
            <unmanaged>D2D1_FLOOD_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_FLOOD_PROP_COLOR</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Gamma">
            <summary>
            <p>Specifies which gamma is used for interpolation.</p>
            </summary>
            <remarks>
            <p>Interpolating in a linear gamma space (<strong>D2D1_GAMMA_1_0</strong>) can avoid changes in perceived brightness caused by the effect of gamma correction in spaces where the gamma is not 1.0, such as the default sRGB color space, where the gamma is 2.2. For an example of the differences between these two blending modes, consider the following illustration, which shows two gradients, each of which blends from red to blue to green:</p><p></p><p>The first gradient is interpolated linearly in the space of the render target (sRGB in this case), and one can see the dark bands between each color. The second gradient uses a gamma-correct linear interpolation, and thus does not exhibit the same variations in brightness.</p>
            </remarks>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA</unmanaged>
            <unmanaged-short>D2D1_GAMMA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Gamma.StandardRgb">
            <summary>
            <dd> <p>Interpolation is performed in the standard RGB (sRGB) gamma.</p> </dd>
            </summary>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA_2_2</unmanaged>
            <unmanaged-short>D2D1_GAMMA_2_2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Gamma.Linear">
            <summary>
            <dd> <p>Interpolation is performed in the linear-gamma color space.</p> </dd>
            </summary>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA_1_0</unmanaged>
            <unmanaged-short>D2D1_GAMMA_1_0</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Gamma1">
            <summary>
            <p>Specifies which gamma is used for interpolation.</p>
            </summary>
            <remarks>
            <p>Interpolating in a linear gamma space (<strong>D2D1_GAMMA_1_0</strong>) can avoid changes in perceived brightness caused by the effect of gamma correction in spaces where the gamma is not 1.0, such as the default sRGB color space, where the gamma is 2.2. For an example of the differences between these two blending modes, consider the following illustration, which shows two gradients, each of which blends from red to blue to green:</p><p></p><p>The first gradient is interpolated linearly in the space of the render target (sRGB in this case), and one can see the dark bands between each color. The second gradient uses a gamma-correct linear interpolation, and thus does not exhibit the same variations in brightness.</p>
            </remarks>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA1</unmanaged>
            <unmanaged-short>D2D1_GAMMA1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Gamma1.G22">
            <summary>
            <dd> <p>Interpolation is performed in the standard RGB (sRGB) gamma.</p> </dd>
            </summary>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA1_G22</unmanaged>
            <unmanaged-short>D2D1_GAMMA1_G22</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Gamma1.G10">
            <summary>
            <dd> <p>Interpolation is performed in the linear-gamma color space.</p> </dd>
            </summary>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA1_G10</unmanaged>
            <unmanaged-short>D2D1_GAMMA1_G10</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Gamma1.G2084">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368113</doc-id>
            <unmanaged>D2D1_GAMMA1_G2084</unmanaged>
            <unmanaged-short>D2D1_GAMMA1_G2084</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GammaTransferProperties">
            <summary>
            <p> Identifiers for properties of the Gamma transfer effect. </p>
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.RedAmplitude">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_RED_AMPLITUDE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_RED_AMPLITUDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.RedExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_RED_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_RED_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.RedOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_RED_OFFSET</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_RED_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.RedDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_RED_DISABLE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_RED_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.GreenAmplitude">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_GREEN_AMPLITUDE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_GREEN_AMPLITUDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.GreenExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_GREEN_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_GREEN_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.GreenOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_GREEN_OFFSET</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_GREEN_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.GreenDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_GREEN_DISABLE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_GREEN_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.BlueAmplitude">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_BLUE_AMPLITUDE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_BLUE_AMPLITUDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.BlueExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_BLUE_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_BLUE_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.BlueOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_BLUE_OFFSET</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_BLUE_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.BlueDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_BLUE_DISABLE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_BLUE_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.AlphaAmplitude">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_ALPHA_AMPLITUDE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_ALPHA_AMPLITUDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.AlphaExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_ALPHA_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_ALPHA_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.AlphaOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_ALPHA_OFFSET</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_ALPHA_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.AlphaDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_ALPHA_DISABLE</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_ALPHA_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GammaTransferProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934246</doc-id>
            <unmanaged>D2D1_GAMMATRANSFER_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_GAMMATRANSFER_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GaussianBlurOptimization">
            <summary>
            <p> The optimization mode for the Gaussian blur effect. </p>
            </summary>
            <doc-id>dn934247</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_OPTIMIZATION</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GaussianBlurOptimization.Speed">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934247</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_OPTIMIZATION_SPEED</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_OPTIMIZATION_SPEED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GaussianBlurOptimization.Balanced">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934247</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_OPTIMIZATION_BALANCED</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_OPTIMIZATION_BALANCED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GaussianBlurOptimization.Quality">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934247</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_OPTIMIZATION_QUALITY</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_OPTIMIZATION_QUALITY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GaussianBlurProperties">
            <summary>
            <p> Identifiers for properties of the Gaussian blur effect. </p>
            </summary>
            <doc-id>dn934248</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_PROP</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GaussianBlurProperties.StandardDeviation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934248</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_PROP_STANDARD_DEVIATION</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_PROP_STANDARD_DEVIATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GaussianBlurProperties.Optimization">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934248</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_PROP_OPTIMIZATION</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_PROP_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GaussianBlurProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934248</doc-id>
            <unmanaged>D2D1_GAUSSIANBLUR_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_GAUSSIANBLUR_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GeometryRelation">
            <summary>
            <p>Describes how one geometry object is spatially related to another geometry object. </p>
            </summary>
            <doc-id>dd368115</doc-id>
            <unmanaged>D2D1_GEOMETRY_RELATION</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_RELATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometryRelation.Unknown">
            <summary>
            <dd> <p>The relationship between the two geometries cannot be determined. This value is never returned by any D2D method.  </p> </dd>
            </summary>
            <doc-id>dd368115</doc-id>
            <unmanaged>D2D1_GEOMETRY_RELATION_UNKNOWN</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_RELATION_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometryRelation.Disjoint">
            <summary>
            <dd> <p>The two geometries  do not intersect at all.</p> </dd>
            </summary>
            <doc-id>dd368115</doc-id>
            <unmanaged>D2D1_GEOMETRY_RELATION_DISJOINT</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_RELATION_DISJOINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometryRelation.IsContained">
            <summary>
            <dd> <p>The instance geometry is entirely contained by  the passed-in geometry.</p> </dd>
            </summary>
            <doc-id>dd368115</doc-id>
            <unmanaged>D2D1_GEOMETRY_RELATION_IS_CONTAINED</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_RELATION_IS_CONTAINED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometryRelation.Contains">
            <summary>
            <dd> <p>The instance geometry entirely contains the passed-in geometry.</p> </dd>
            </summary>
            <doc-id>dd368115</doc-id>
            <unmanaged>D2D1_GEOMETRY_RELATION_CONTAINS</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_RELATION_CONTAINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometryRelation.Overlap">
            <summary>
            <dd> <p>The two geometries overlap but neither completely contains the other. </p> </dd>
            </summary>
            <doc-id>dd368115</doc-id>
            <unmanaged>D2D1_GEOMETRY_RELATION_OVERLAP</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_RELATION_OVERLAP</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GeometrySimplificationOption">
            <summary>
            <p>Specifies how a geometry is simplified to an <strong><see cref = "T:SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>
            </summary>
            <doc-id>dd368117</doc-id>
            <unmanaged>D2D1_GEOMETRY_SIMPLIFICATION_OPTION</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_SIMPLIFICATION_OPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometrySimplificationOption.CubicsAndLines">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368117</doc-id>
            <unmanaged>D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GeometrySimplificationOption.Lines">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368117</doc-id>
            <unmanaged>D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES</unmanaged>
            <unmanaged-short>D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GlyphImageFormatS">
            <summary>
            <p>Specifies which formats are supported in the font, either at a font-wide level or per glyph.</p>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.None">
            <summary>
            <dd> <p>Indicates no data is available for this glyph.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_NONE</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Truetype">
            <summary>
            <dd> <p>The glyph has TrueType outlines.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Cff">
            <summary>
            <dd> <p>The glyph has CFF outlines.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_CFF</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_CFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Colr">
            <summary>
            <dd> <p>The glyph has multilayered COLR data.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_COLR</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_COLR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Svg">
            <summary>
            <dd> <p>The glyph has SVG outlines as standard XML.  Fonts may store the content gzip'd rather than plain text, indicated by the first two bytes as gzip header {0x1F 0x8B}.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_SVG</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_SVG</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Png">
            <summary>
            <dd> <p>The glyph has PNG image data, with standard PNG IHDR.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_PNG</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_PNG</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Jpeg">
            <summary>
            <dd> <p>The glyph has JPEG image data, with standard JIFF SOI header.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_JPEG</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_JPEG</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.Tiff">
            <summary>
            <dd> <p>The glyph has TIFF image data.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_TIFF</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_TIFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GlyphImageFormatS.PremultipliedB8G8R8A8">
            <summary>
            <dd> <p>The glyph has raw 32-bit premultiplied BGRA data.</p> </dd>
            </summary>
            <doc-id>mt725308</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS_PREMULTIPLIED_B8G8R8A8</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_FORMATS_PREMULTIPLIED_B8G8R8A8</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HighlightSandShadowsInputGamma">
            <summary>
            <p>Values for the <strong>D2D1_HIGHLIGHTSANDSHADOWS_PROP_INPUT_GAMMA</strong> property  of the Highlights and Shadows effect.</p>
            </summary>
            <doc-id>dn890727</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsInputGamma.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890727</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_LINEAR</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsInputGamma.SRgb">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890727</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_SRGB</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_SRGB</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HighlightSandShadowsProperty">
            <summary>
            <p>Identifiers for properties of the Highlights and Shadows effect.</p>
            </summary>
            <doc-id>dn890728</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_PROP</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsProperty.Highlights">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890728</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_PROP_HIGHLIGHTS</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_PROP_HIGHLIGHTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsProperty.Shadows">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890728</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_PROP_SHADOWS</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_PROP_SHADOWS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsProperty.Clarity">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890728</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_PROP_CLARITY</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_PROP_CLARITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsProperty.InputGamma">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890728</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_PROP_INPUT_GAMMA</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_PROP_INPUT_GAMMA</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HighlightSandShadowsProperty.MaskBlurRadius">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890728</doc-id>
            <unmanaged>D2D1_HIGHLIGHTSANDSHADOWS_PROP_MASK_BLUR_RADIUS</unmanaged>
            <unmanaged-short>D2D1_HIGHLIGHTSANDSHADOWS_PROP_MASK_BLUR_RADIUS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HistogramProperties">
            <summary>
            <p> Identifiers for properties of the Histogram effect. </p>
            </summary>
            <doc-id>dn934249</doc-id>
            <unmanaged>D2D1_HISTOGRAM_PROP</unmanaged>
            <unmanaged-short>D2D1_HISTOGRAM_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HistogramProperties.NumBins">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934249</doc-id>
            <unmanaged>D2D1_HISTOGRAM_PROP_NUM_BINS</unmanaged>
            <unmanaged-short>D2D1_HISTOGRAM_PROP_NUM_BINS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HistogramProperties.ChannelSelect">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934249</doc-id>
            <unmanaged>D2D1_HISTOGRAM_PROP_CHANNEL_SELECT</unmanaged>
            <unmanaged-short>D2D1_HISTOGRAM_PROP_CHANNEL_SELECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HistogramProperties.HistogramOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934249</doc-id>
            <unmanaged>D2D1_HISTOGRAM_PROP_HISTOGRAM_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_HISTOGRAM_PROP_HISTOGRAM_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HueRotationProperties">
            <summary>
            <p>Identifiers for properties of the Hue rotate effect.</p>
            </summary>
            <doc-id>dn934250</doc-id>
            <unmanaged>D2D1_HUEROTATION_PROP</unmanaged>
            <unmanaged-short>D2D1_HUEROTATION_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HueRotationProperties.Angle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934250</doc-id>
            <unmanaged>D2D1_HUEROTATION_PROP_ANGLE</unmanaged>
            <unmanaged-short>D2D1_HUEROTATION_PROP_ANGLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HueToRgbInputColorSpace">
            <summary>
            <p>Values for the <strong>D2D1_HUETORGB_PROP_INPUT_COLOR_SPACE</strong> property of the Hue to RGB effect.</p>
            </summary>
            <doc-id>dn890729</doc-id>
            <unmanaged>D2D1_HUETORGB_INPUT_COLOR_SPACE</unmanaged>
            <unmanaged-short>D2D1_HUETORGB_INPUT_COLOR_SPACE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HueToRgbInputColorSpace.HueSaturationValue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890729</doc-id>
            <unmanaged>D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_VALUE</unmanaged>
            <unmanaged-short>D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_VALUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HueToRgbInputColorSpace.HueSaturationLightness">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890729</doc-id>
            <unmanaged>D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS</unmanaged>
            <unmanaged-short>D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HueToRgbProperty">
            <summary>
            <p>Identifiers for properties of the Hue to RGB effect.</p>
            </summary>
            <doc-id>dn890730</doc-id>
            <unmanaged>D2D1_HUETORGB_PROP</unmanaged>
            <unmanaged-short>D2D1_HUETORGB_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HueToRgbProperty.InputColorSpace">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890730</doc-id>
            <unmanaged>D2D1_HUETORGB_PROP_INPUT_COLOR_SPACE</unmanaged>
            <unmanaged-short>D2D1_HUETORGB_PROP_INPUT_COLOR_SPACE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageSourceFromDxgiOptions.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890733</doc-id>
            <unmanaged>D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageSourceFromDxgiOptions.LowQualityPrimaryConversion">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890733</doc-id>
            <unmanaged>D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_LOW_QUALITY_PRIMARY_CONVERSION</unmanaged>
            <unmanaged-short>D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_LOW_QUALITY_PRIMARY_CONVERSION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageSourceLoadingOptions.None">
            <summary>
            <dd> <p>No options are used.</p> </dd>
            </summary>
            <doc-id>dn890734</doc-id>
            <unmanaged>D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageSourceLoadingOptions.ReleaseSource">
            <summary>
            <dd> <p>Indicates the image source should release its reference to the WIC bitmap source after it has initialized.  By default, the image source retains a reference to the WIC bitmap source for the lifetime of the object to enable quality and speed optimizations for printing.  This option disables that optimization.
            </p> </dd>
            </summary>
            <doc-id>dn890734</doc-id>
            <unmanaged>D2D1_IMAGE_SOURCE_LOADING_OPTIONS_RELEASE_SOURCE</unmanaged>
            <unmanaged-short>D2D1_IMAGE_SOURCE_LOADING_OPTIONS_RELEASE_SOURCE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageSourceLoadingOptions.CacheOnDemand">
            <summary>
            <dd> <p>Indicates the image source should only populate subregions of the image cache on-demand. You can control this behavior using  the <strong>EnsureCached</strong> and <strong>TrimCache</strong> methods.  This options provides the ability to improve memory usage by only keeping needed portions of the image in memory.  This option requires that the image source has a reference to the WIC bitmap source, and is incompatible with D2D1_IMAGE_SOURCE_LOADING_OPTIONS_RELEASE_SOURCE.</p> </dd>
            </summary>
            <doc-id>dn890734</doc-id>
            <unmanaged>D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND</unmanaged>
            <unmanaged-short>D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InkNibShape">
            <summary>
            <p> Specifies the appearance of the ink nib (pen tip) as part of an <strong><see cref = "T:SharpDX.Direct2D1.InkStyleProperties"/></strong> structure. </p>
            </summary>
            <doc-id>dn890735</doc-id>
            <unmanaged>D2D1_INK_NIB_SHAPE</unmanaged>
            <unmanaged-short>D2D1_INK_NIB_SHAPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkNibShape.Round">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890735</doc-id>
            <unmanaged>D2D1_INK_NIB_SHAPE_ROUND</unmanaged>
            <unmanaged-short>D2D1_INK_NIB_SHAPE_ROUND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkNibShape.Square">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890735</doc-id>
            <unmanaged>D2D1_INK_NIB_SHAPE_SQUARE</unmanaged>
            <unmanaged-short>D2D1_INK_NIB_SHAPE_SQUARE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InterpolationMode">
            <summary>
            <p>This is used to specify the quality of image scaling with  <strong>ID2D1DeviceContext::DrawImage</strong> and with the 2D affine transform effect. </p>
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447004</doc-id>
            <unmanaged>D2D1_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InterpolationModeDefinition">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_ENUM_0</unmanaged>
            <unmanaged-short>D2D1_ENUM_0</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.Linear">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.Cubic">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.Fant">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_FANT</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_FANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InterpolationModeDefinition.MipmapLinear">
            <summary>
            No documentation.
            </summary>
            <unmanaged>D2D1_INTERPOLATION_MODE_DEFINITION_MIPMAP_LINEAR</unmanaged>
            <unmanaged-short>D2D1_INTERPOLATION_MODE_DEFINITION_MIPMAP_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerOptions.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368124</doc-id>
            <unmanaged>D2D1_LAYER_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_LAYER_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerOptions.InitializeForCleartype">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368124</doc-id>
            <unmanaged>D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE</unmanaged>
            <unmanaged-short>D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerOptions1.None">
            <summary>
            <dd> <p>Default layer behavior. A premultiplied layer target is pushed and its contents are cleared to transparent black. 
            </p> </dd>
            </summary>
            <doc-id>hh997712</doc-id>
            <unmanaged>D2D1_LAYER_OPTIONS1_NONE</unmanaged>
            <unmanaged-short>D2D1_LAYER_OPTIONS1_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerOptions1.InitializeFromBackground">
            <summary>
            <dd> <p> The layer is not cleared to transparent black.</p> </dd>
            </summary>
            <doc-id>hh997712</doc-id>
            <unmanaged>D2D1_LAYER_OPTIONS1_INITIALIZE_FROM_BACKGROUND</unmanaged>
            <unmanaged-short>D2D1_LAYER_OPTIONS1_INITIALIZE_FROM_BACKGROUND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LayerOptions1.IgnoreAlpha">
            <summary>
            <dd> <p> The layer is always created as ignore alpha. All content rendered into the layer will be treated as opaque.</p> </dd>
            </summary>
            <doc-id>hh997712</doc-id>
            <unmanaged>D2D1_LAYER_OPTIONS1_IGNORE_ALPHA</unmanaged>
            <unmanaged-short>D2D1_LAYER_OPTIONS1_IGNORE_ALPHA</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.LinearTransferProperties">
            <summary>
            <p>Identifiers for properties of the Linear transfer effect.</p>
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.RedYIntercept">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_RED_Y_INTERCEPT</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_RED_Y_INTERCEPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.RedSlope">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_RED_SLOPE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_RED_SLOPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.RedDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_RED_DISABLE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_RED_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.GreenYIntercept">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_GREEN_Y_INTERCEPT</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_GREEN_Y_INTERCEPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.GreenSlope">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_GREEN_SLOPE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_GREEN_SLOPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.GreenDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_GREEN_DISABLE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_GREEN_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.BlueYIntercept">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_BLUE_Y_INTERCEPT</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_BLUE_Y_INTERCEPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.BlueSlope">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_BLUE_SLOPE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_BLUE_SLOPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.BlueDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_BLUE_DISABLE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_BLUE_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.AlphaYIntercept">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_ALPHA_Y_INTERCEPT</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_ALPHA_Y_INTERCEPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.AlphaSlope">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_ALPHA_SLOPE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_ALPHA_SLOPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.AlphaDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_ALPHA_DISABLE</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_ALPHA_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearTransferProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934251</doc-id>
            <unmanaged>D2D1_LINEARTRANSFER_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_LINEARTRANSFER_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.LineJoin">
            <summary>
            <p>Describes the shape that joins two lines or segments.  </p>
            </summary>
            <remarks>
            <p> A miter limit affects how sharp miter joins are allowed to be. If the line join style is <strong>D2D1_LINE_JOIN_MITER_OR_BEVEL</strong>, then the join will be mitered with regular angular vertices if it doesn't extend beyond the miter limit; otherwise, the line join will be beveled.</p><p>The following illustration shows  different line join settings for the same stroked path geometry.   </p><p></p>
            </remarks>
            <doc-id>dd368130</doc-id>
            <unmanaged>D2D1_LINE_JOIN</unmanaged>
            <unmanaged-short>D2D1_LINE_JOIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LineJoin.Miter">
            <summary>
            <dd> <p>Regular angular vertices. </p> </dd>
            </summary>
            <doc-id>dd368130</doc-id>
            <unmanaged>D2D1_LINE_JOIN_MITER</unmanaged>
            <unmanaged-short>D2D1_LINE_JOIN_MITER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LineJoin.Bevel">
            <summary>
            <dd> <p>Beveled vertices.   </p> </dd>
            </summary>
            <doc-id>dd368130</doc-id>
            <unmanaged>D2D1_LINE_JOIN_BEVEL</unmanaged>
            <unmanaged-short>D2D1_LINE_JOIN_BEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LineJoin.Round">
            <summary>
            <dd> <p>Rounded vertices. </p> </dd>
            </summary>
            <doc-id>dd368130</doc-id>
            <unmanaged>D2D1_LINE_JOIN_ROUND</unmanaged>
            <unmanaged-short>D2D1_LINE_JOIN_ROUND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LineJoin.MiterOrBevel">
            <summary>
            <dd> <p>Regular angular vertices unless the join would extend beyond the miter limit; otherwise, beveled vertices.  </p> </dd>
            </summary>
            <doc-id>dd368130</doc-id>
            <unmanaged>D2D1_LINE_JOIN_MITER_OR_BEVEL</unmanaged>
            <unmanaged-short>D2D1_LINE_JOIN_MITER_OR_BEVEL</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.LookupTable3DProperty">
            <summary>
            <p>Identifiers for the properties of the 3D Lookup Table effect.</p>
            </summary>
            <doc-id>dn890738</doc-id>
            <unmanaged>D2D1_LOOKUPTABLE3D_PROP</unmanaged>
            <unmanaged-short>D2D1_LOOKUPTABLE3D_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LookupTable3DProperty.Lut">
            <summary>
            <dd> <p>The D2D1_LOOKUPTABLE3D_PROP_LUT property is a reference to an <strong><see cref = "T:SharpDX.Direct2D1.LookupTable3D"/></strong> object.  The default value is null.</p> </dd>
            </summary>
            <doc-id>dn890738</doc-id>
            <unmanaged>D2D1_LOOKUPTABLE3D_PROP_LUT</unmanaged>
            <unmanaged-short>D2D1_LOOKUPTABLE3D_PROP_LUT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LookupTable3DProperty.AlphaMode">
            <summary>
            <dd> <p>The D2D1_LOOKUPTABLE3D_PROP_ALPHA_MODE property is a <strong><see cref = "T:SharpDX.Direct2D1.AlphaMode"/></strong> value indicating the alpha mode of the input file. See the About Alpha Modes section of the Supported Pixel Formats and Alpha Modes topic for additional information.</p> </dd>
            </summary>
            <doc-id>dn890738</doc-id>
            <unmanaged>D2D1_LOOKUPTABLE3D_PROP_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_LOOKUPTABLE3D_PROP_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MapOptions.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447006</doc-id>
            <unmanaged>D2D1_MAP_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_MAP_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MapOptions.Read">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447006</doc-id>
            <unmanaged>D2D1_MAP_OPTIONS_READ</unmanaged>
            <unmanaged-short>D2D1_MAP_OPTIONS_READ</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MapOptions.Write">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447006</doc-id>
            <unmanaged>D2D1_MAP_OPTIONS_WRITE</unmanaged>
            <unmanaged-short>D2D1_MAP_OPTIONS_WRITE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MapOptions.Discard">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447006</doc-id>
            <unmanaged>D2D1_MAP_OPTIONS_DISCARD</unmanaged>
            <unmanaged-short>D2D1_MAP_OPTIONS_DISCARD</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.MeasuringMode">
            <summary>
            <p> Indicates the measuring method used for text layout.</p>
            </summary>
            <doc-id>dd368133</doc-id>
            <unmanaged>DWRITE_MEASURING_MODE</unmanaged>
            <unmanaged-short>DWRITE_MEASURING_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MeasuringMode.Natural">
            <summary>
            <dd> <p> Specifies that text is measured using glyph ideal metrics whose values are independent to the current display resolution.</p> </dd>
            </summary>
            <doc-id>dd368133</doc-id>
            <unmanaged>DWRITE_MEASURING_MODE_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_MEASURING_MODE_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MeasuringMode.GdiClassic">
            <summary>
            <dd> <p> Specifies that text is measured using glyph display-compatible metrics whose values tuned for the current display resolution.</p> </dd>
            </summary>
            <doc-id>dd368133</doc-id>
            <unmanaged>DWRITE_MEASURING_MODE_GDI_CLASSIC</unmanaged>
            <unmanaged-short>DWRITE_MEASURING_MODE_GDI_CLASSIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MeasuringMode.GdiNatural">
            <summary>
            <dd> <p> Specifies that text is measured using the same glyph display metrics as text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY.</p> </dd>
            </summary>
            <doc-id>dd368133</doc-id>
            <unmanaged>DWRITE_MEASURING_MODE_GDI_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_MEASURING_MODE_GDI_NATURAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.MorphologyMode">
            <summary>
            <p> The mode for the Morphology effect. </p>
            </summary>
            <doc-id>dn934252</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_MODE</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MorphologyMode.Erode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934252</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_MODE_ERODE</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_MODE_ERODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MorphologyMode.Dilate">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934252</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_MODE_DILATE</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_MODE_DILATE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.MorphologyProperties">
            <summary>
            <p> Identifiers for properties of the Morphology effect. </p>
            </summary>
            <doc-id>dn934253</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_PROP</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MorphologyProperties.Mode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934253</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_PROP_MODE</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_PROP_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MorphologyProperties.Width">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934253</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_PROP_WIDTH</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_PROP_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MorphologyProperties.Height">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934253</doc-id>
            <unmanaged>D2D1_MORPHOLOGY_PROP_HEIGHT</unmanaged>
            <unmanaged-short>D2D1_MORPHOLOGY_PROP_HEIGHT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.OpacityMaskContent">
            <summary>
            <p>Describes whether an opacity mask contains graphics or text. Direct2D uses this information to determine which gamma space to use when blending the opacity mask.</p>
            </summary>
            <doc-id>dd756629</doc-id>
            <unmanaged>D2D1_OPACITY_MASK_CONTENT</unmanaged>
            <unmanaged-short>D2D1_OPACITY_MASK_CONTENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.OpacityMaskContent.Graphics">
            <summary>
            <dd> <p>The opacity mask contains graphics. The opacity mask is blended in the gamma 2.2 color space.</p> </dd>
            </summary>
            <doc-id>dd756629</doc-id>
            <unmanaged>D2D1_OPACITY_MASK_CONTENT_GRAPHICS</unmanaged>
            <unmanaged-short>D2D1_OPACITY_MASK_CONTENT_GRAPHICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.OpacityMaskContent.TextNatural">
            <summary>
            <dd> <p>The opacity mask contains non-GDI text. The gamma space used for blending is obtained from the render target's text rendering parameters. (<strong>ID2D1RenderTarget::SetTextRenderingParams</strong>).</p> </dd>
            </summary>
            <doc-id>dd756629</doc-id>
            <unmanaged>D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL</unmanaged>
            <unmanaged-short>D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.OpacityMaskContent.TextGdiCompatible">
            <summary>
            <dd> <p>The opacity mask contains text rendered using the GDI-compatible rendering mode. The opacity mask is blended using the gamma for GDI rendering.</p> </dd>
            </summary>
            <doc-id>dd756629</doc-id>
            <unmanaged>D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE</unmanaged>
            <unmanaged-short>D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.OpacityMetadataProperties">
            <summary>
            <p> Identifiers for properties of the Opacity metadata effect. </p>
            </summary>
            <doc-id>dn934254</doc-id>
            <unmanaged>D2D1_OPACITYMETADATA_PROP</unmanaged>
            <unmanaged-short>D2D1_OPACITYMETADATA_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.OpacityMetadataProperties.InputOpaqueRectangle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934254</doc-id>
            <unmanaged>D2D1_OPACITYMETADATA_PROP_INPUT_OPAQUE_RECT</unmanaged>
            <unmanaged-short>D2D1_OPACITYMETADATA_PROP_INPUT_OPAQUE_RECT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.OpacityProp">
            <summary>
            <p>This effect adjusts the opacity of an image by multiplying the alpha channel of the input by the specified opacity value. It has a single input.</p><p>The CLSID for this effect is <see cref = "F:SharpDX.Direct2D1.OpacityProp.Opacity"/>.</p>
            </summary>
            <doc-id>mt745076</doc-id>
            <unmanaged>D2D1_OPACITY_PROP</unmanaged>
            <unmanaged-short>D2D1_OPACITY_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.OpacityProp.Opacity">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt745076</doc-id>
            <unmanaged>D2D1_OPACITY_PROP_OPACITY</unmanaged>
            <unmanaged-short>D2D1_OPACITY_PROP_OPACITY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Orientation">
            <summary>
            <p>Specifies the flip and rotation at which an image appears.</p>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.Default">
            <summary>
            <dd> <p>The orientation is unchanged.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.FlipHorizontal">
            <summary>
            <dd> <p>The image is flipped horizontally.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.RotateClockwise180">
            <summary>
            <dd> <p>The image is rotated clockwise 180 degrees.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_ROTATE_CLOCKWISE180</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_ROTATE_CLOCKWISE180</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.RotateClockwise180FlipHorizontal">
            <summary>
            <dd> <p>The image is rotated clockwise 180 degrees, then flipped horizontally.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.RotateClockwise90FlipHorizontal">
            <summary>
            <dd> <p>The image is rotated clockwise 90 degrees, then flipped horizontally.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.RotateClockwise270">
            <summary>
            <dd> <p>The image is rotated clockwise 270 degrees.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_ROTATE_CLOCKWISE270</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_ROTATE_CLOCKWISE270</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.RotateClockwise270FlipHorizontal">
            <summary>
            <dd> <p>The image is rotated clockwise 270 degrees, then flipped horizontally.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Orientation.RotateClockwise90">
            <summary>
            <dd> <p>The image is rotated clockwise 90 degrees.</p> </dd>
            </summary>
            <doc-id>dn890739</doc-id>
            <unmanaged>D2D1_ORIENTATION_ROTATE_CLOCKWISE90</unmanaged>
            <unmanaged-short>D2D1_ORIENTATION_ROTATE_CLOCKWISE90</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PatchEdgeMode">
            <summary>
            <p>Specifies how to render gradient mesh edges.</p>
            </summary>
            <doc-id>dn986881</doc-id>
            <unmanaged>D2D1_PATCH_EDGE_MODE</unmanaged>
            <unmanaged-short>D2D1_PATCH_EDGE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PatchEdgeMode.Aliased">
            <summary>
            <dd> <p>Render this patch edge aliased. Use this value for the internal edges of your gradient mesh.</p> </dd>
            </summary>
            <doc-id>dn986881</doc-id>
            <unmanaged>D2D1_PATCH_EDGE_MODE_ALIASED</unmanaged>
            <unmanaged-short>D2D1_PATCH_EDGE_MODE_ALIASED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PatchEdgeMode.Antialiased">
            <summary>
            <dd> <p>Render this patch edge antialiased. Use this value for the external (boundary) edges of your mesh.</p> </dd>
            </summary>
            <doc-id>dn986881</doc-id>
            <unmanaged>D2D1_PATCH_EDGE_MODE_ANTIALIASED</unmanaged>
            <unmanaged-short>D2D1_PATCH_EDGE_MODE_ANTIALIASED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PatchEdgeMode.AliasedInflated">
            <summary>
            <dd> <p>Render this patch edge aliased and also slightly inflated. Use this for the internal edges of your gradient mesh when there could be t-junctions among patches.  Inflating the internal edges mitigates seams that can appear along those junctions.</p> </dd>
            </summary>
            <doc-id>dn986881</doc-id>
            <unmanaged>D2D1_PATCH_EDGE_MODE_ALIASED_INFLATED</unmanaged>
            <unmanaged-short>D2D1_PATCH_EDGE_MODE_ALIASED_INFLATED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PathSegment">
            <summary>
            <p>Indicates whether a segment should be stroked and whether the join between this segment and the previous one should be smooth. This enumeration allows a bitwise combination of its member values. </p>
            </summary>
            <doc-id>dd368136</doc-id>
            <unmanaged>D2D1_PATH_SEGMENT</unmanaged>
            <unmanaged-short>D2D1_PATH_SEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PathSegment.None">
            <summary>
            <dd> <p>The segment is joined  as specified by the <strong><see cref = "T:SharpDX.Direct2D1.StrokeStyle"/></strong> interface, and it is stroked. </p> </dd>
            </summary>
            <doc-id>dd368136</doc-id>
            <unmanaged>D2D1_PATH_SEGMENT_NONE</unmanaged>
            <unmanaged-short>D2D1_PATH_SEGMENT_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PathSegment.ForceUnstroked">
            <summary>
            <dd> <p>The segment is not stroked.</p> </dd>
            </summary>
            <doc-id>dd368136</doc-id>
            <unmanaged>D2D1_PATH_SEGMENT_FORCE_UNSTROKED</unmanaged>
            <unmanaged-short>D2D1_PATH_SEGMENT_FORCE_UNSTROKED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PathSegment.ForceRoundLineJoin">
            <summary>
            <dd> <p>The segment is always joined with the one preceding it using a round line join, regardless of which <strong><see cref = "T:SharpDX.Direct2D1.LineJoin"/></strong>enumeration is specified by the <strong><see cref = "T:SharpDX.Direct2D1.StrokeStyle"/></strong> interface. If this segment is the first segment and the figure is closed, a round line join is used to connect the closing segment with the first segment. If the figure is not closed, this setting has no effect on the first segment of the figure. If <strong>ID2D1SimplifiedGeometrySink::SetSegmentFlags</strong> is called just before <strong>ID2D1SimplifiedGeometrySink::EndFigure</strong>, the join between the closing segment and the last explicitly specified segment is affected.</p> </dd>
            </summary>
            <doc-id>dd368136</doc-id>
            <unmanaged>D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN</unmanaged>
            <unmanaged-short>D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PerspectiveTransform3DInteroplationMode">
            <summary>
            <p> The interpolation mode the 3D perspective transform effect uses on the image. There are 5 scale modes that range in quality and speed. </p>
            </summary>
            <doc-id>dn934207</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DInteroplationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934207</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DInteroplationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934207</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DInteroplationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934207</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DInteroplationMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934207</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DInteroplationMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934207</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PerspectiveTransform3DProperties">
            <summary>
            <p> Identifiers for the properties of the 3D perspective transform effect. </p>
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.Depth">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_DEPTH</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_DEPTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.PerspectiveOrigin">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_PERSPECTIVE_ORIGIN</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_PERSPECTIVE_ORIGIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.LocalOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_LOCAL_OFFSET</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_LOCAL_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.GlobalOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_GLOBAL_OFFSET</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_GLOBAL_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.RotationOrigin">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION_ORIGIN</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION_ORIGIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PerspectiveTransform3DProperties.Rotation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934208</doc-id>
            <unmanaged>D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION</unmanaged>
            <unmanaged-short>D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PixelOptions.None">
            <summary>
            <dd> <p>The pixel shader is not restricted in its sampling.</p> </dd>
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_PIXEL_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_PIXEL_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PixelOptions.TrivialSampling">
            <summary>
            <dd> <p> The pixel shader samples inputs only at the same scene coordinate as the output pixel and returns transparent black whenever the input pixels are also transparent black.</p> </dd>
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_PIXEL_OPTIONS_TRIVIAL_SAMPLING</unmanaged>
            <unmanaged-short>D2D1_PIXEL_OPTIONS_TRIVIAL_SAMPLING</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PointDiffuseProperties">
            <summary>
            <p> Identifiers for properties of the Point-diffuse lighting effect. </p>
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseProperties.LightPosition">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP_LIGHT_POSITION</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP_LIGHT_POSITION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseProperties.DiffuseConstant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP_DIFFUSE_CONSTANT</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP_DIFFUSE_CONSTANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseProperties.SurfaceScale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP_SURFACE_SCALE</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP_SURFACE_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934255</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PointDiffuseScaleMode">
            <summary>
            <p>The interpolation mode the Point-diffuse lighting effect uses to scale the image to the corresponding kernel unit length. There are six scale modes that range in quality and speed</p>
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDiffuseScaleMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934256</doc-id>
            <unmanaged>D2D1_POINTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_POINTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PointSpecularProperties">
            <summary>
            <p> Identifiers for properties of the Point-specular lighting effect. </p>
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.LightPosition">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_LIGHT_POSITION</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_LIGHT_POSITION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.SpecularExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_SPECULAR_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_SPECULAR_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.SpecularConstant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_SPECULAR_CONSTANT</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_SPECULAR_CONSTANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.SurfaceScale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_SURFACE_SCALE</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_SURFACE_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934257</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PointSpecularScaleMode">
            <summary>
            <p>The interpolation mode the Point-specular lighting effect uses to scale the image to the corresponding kernel unit length.  There are six scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointSpecularScaleMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934258</doc-id>
            <unmanaged>D2D1_POINTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_POINTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PosterizeProperty">
            <summary>
            <p>Identifiers for properties of the Posterize effect.</p>
            </summary>
            <doc-id>dn890742</doc-id>
            <unmanaged>D2D1_POSTERIZE_PROP</unmanaged>
            <unmanaged-short>D2D1_POSTERIZE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PosterizeProperty.RedValueCount">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890742</doc-id>
            <unmanaged>D2D1_POSTERIZE_PROP_RED_VALUE_COUNT</unmanaged>
            <unmanaged-short>D2D1_POSTERIZE_PROP_RED_VALUE_COUNT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PosterizeProperty.GreenValueCount">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890742</doc-id>
            <unmanaged>D2D1_POSTERIZE_PROP_GREEN_VALUE_COUNT</unmanaged>
            <unmanaged-short>D2D1_POSTERIZE_PROP_GREEN_VALUE_COUNT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PosterizeProperty.BlueValueCount">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890742</doc-id>
            <unmanaged>D2D1_POSTERIZE_PROP_BLUE_VALUE_COUNT</unmanaged>
            <unmanaged-short>D2D1_POSTERIZE_PROP_BLUE_VALUE_COUNT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PresentOptions.None">
            <summary>
            <dd> <p>The render target waits until the display refreshes to present and discards the frame upon presenting.</p> </dd>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_PRESENT_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_PRESENT_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PresentOptions.RetainContents">
            <summary>
            <dd> <p>The render target does not discard the frame upon presenting.</p> </dd>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS</unmanaged>
            <unmanaged-short>D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PresentOptions.Immediately">
            <summary>
            <dd> <p>The render target does not wait until the display refreshes to present.</p> </dd>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_PRESENT_OPTIONS_IMMEDIATELY</unmanaged>
            <unmanaged-short>D2D1_PRESENT_OPTIONS_IMMEDIATELY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PrimitiveBlend">
            <summary>
            <p>Used to specify the geometric blend mode for all Direct2D primitives.  </p>
            </summary>
            <doc-id>hh447008</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND</unmanaged>
            <unmanaged-short>D2D1_PRIMITIVE_BLEND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrimitiveBlend.SourceOver">
            <summary>
            <dd> <p>The standard source-over-destination blend mode.</p> </dd>
            </summary>
            <doc-id>hh447008</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND_SOURCE_OVER</unmanaged>
            <unmanaged-short>D2D1_PRIMITIVE_BLEND_SOURCE_OVER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrimitiveBlend.Copy">
            <summary>
            <dd> <p>The source is copied to the destination; the destination pixels are ignored.</p> </dd>
            </summary>
            <doc-id>hh447008</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND_COPY</unmanaged>
            <unmanaged-short>D2D1_PRIMITIVE_BLEND_COPY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrimitiveBlend.Minimum">
            <summary>
            <dd> <p>The resulting pixel values use the minimum of the source and destination pixel values. Available in Windows?8 and later.</p> </dd>
            </summary>
            <doc-id>hh447008</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND_MIN</unmanaged>
            <unmanaged-short>D2D1_PRIMITIVE_BLEND_MIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrimitiveBlend.Add">
            <summary>
            <dd> <p>The resulting pixel values are the sum of the source and destination pixel values. Available in Windows?8 and later.</p> </dd>
            </summary>
            <doc-id>hh447008</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND_ADD</unmanaged>
            <unmanaged-short>D2D1_PRIMITIVE_BLEND_ADD</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrimitiveBlend.Maximum">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447008</doc-id>
            <unmanaged>D2D1_PRIMITIVE_BLEND_MAX</unmanaged>
            <unmanaged-short>D2D1_PRIMITIVE_BLEND_MAX</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PrintFontSubsetMode">
            <summary>
            <p>Defines when font resources should be subset during printing.</p>
            </summary>
            <doc-id>hh871442</doc-id>
            <unmanaged>D2D1_PRINT_FONT_SUBSET_MODE</unmanaged>
            <unmanaged-short>D2D1_PRINT_FONT_SUBSET_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrintFontSubsetMode.Default">
            <summary>
            <dd> <p>Uses a heuristic strategy to decide when to subset fonts. </p> <strong>Note</strong>??If the print driver has requested archive-optimized content, then Direct2D will subset fonts once, for the entire document. ? </dd>
            </summary>
            <doc-id>hh871442</doc-id>
            <unmanaged>D2D1_PRINT_FONT_SUBSET_MODE_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_PRINT_FONT_SUBSET_MODE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrintFontSubsetMode.Eachpage">
            <summary>
            <dd> <p>Subsets and embeds font resources in each page, then discards that font subset after the page is printed out. </p> </dd>
            </summary>
            <doc-id>hh871442</doc-id>
            <unmanaged>D2D1_PRINT_FONT_SUBSET_MODE_EACHPAGE</unmanaged>
            <unmanaged-short>D2D1_PRINT_FONT_SUBSET_MODE_EACHPAGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrintFontSubsetMode.None">
            <summary>
            <dd> <p>Sends out the original font resources without subsetting along with the page that first uses the font, and re-uses the font resources for later pages without resending them.  </p> </dd>
            </summary>
            <doc-id>hh871442</doc-id>
            <unmanaged>D2D1_PRINT_FONT_SUBSET_MODE_NONE</unmanaged>
            <unmanaged-short>D2D1_PRINT_FONT_SUBSET_MODE_NONE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Property">
            <summary>
            <p>Specifies the indices of the system properties present on the <strong><see cref = "T:SharpDX.Direct2D1.Properties"/></strong> interface for an <strong><see cref = "T:SharpDX.Direct2D1.Effect"/></strong>.</p>
            </summary>
            <remarks>
            <p>Under normal circumstances the minimum and maximum number of inputs to the effect are the same. If the effect supports a variable number of inputs, the <strong>ID2D1Effect::SetNumberOfInputs</strong> method can be used to choose the number that the application will enable.</p>
            </remarks>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY</unmanaged>
            <unmanaged-short>D2D1_PROPERTY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Clsid">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_CLSID</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_CLSID</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.DisplayName">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_DISPLAYNAME</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_DISPLAYNAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Author">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_AUTHOR</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_AUTHOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Category">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_CATEGORY</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_CATEGORY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Description">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_DESCRIPTION</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Inputs">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_INPUTS</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_INPUTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Cached">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_CACHED</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_CACHED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.Precision">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_PRECISION</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_PRECISION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.MinimumInputs">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_MIN_INPUTS</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_MIN_INPUTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Property.MaximumInputs">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh447010</doc-id>
            <unmanaged>D2D1_PROPERTY_MAX_INPUTS</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_MAX_INPUTS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PropertyType">
            <summary>
            <p>Specifies the types of properties supported by the Direct2D property interface. </p>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Unknown">
            <summary>
            <dd> <p>An unknown property.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_UNKNOWN</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.String">
            <summary>
            <dd> <p>An arbitrary-length string.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_STRING</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_STRING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Bool">
            <summary>
            <dd> <p>A 32-bit integer value constrained to be either 0 or 1.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_BOOL</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_BOOL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.UInt32">
            <summary>
            <dd> <p>An unsigned 32-bit integer.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_UINT32</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_UINT32</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Int32">
            <summary>
            <dd> <p>A signed 32-bit integer.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_INT32</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_INT32</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Float">
            <summary>
            <dd> <p>A 32-bit float.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_FLOAT</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_FLOAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Vector2">
            <summary>
            <dd> <p>Two 32-bit float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_VECTOR2</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_VECTOR2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Vector3">
            <summary>
            <dd> <p> Three 32-bit float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_VECTOR3</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_VECTOR3</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Vector4">
            <summary>
            <dd> <p>Four 32-bit float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_VECTOR4</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_VECTOR4</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Blob">
            <summary>
            <dd> <p>An arbitrary number of bytes.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_BLOB</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_BLOB</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.IUnknown">
            <summary>
            <dd> <p>A returned COM or nano-COM interface. </p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_IUNKNOWN</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_IUNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Enum">
            <summary>
            <dd> <p>An enumeration. The value should be treated as a <strong>UINT32</strong> with a defined array of fields to specify the bindings to human-readable strings.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_ENUM</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_ENUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Array">
            <summary>
            <dd> <p>An enumeration. The value is the count of sub-properties in the array. The set of array elements will be contained in the sub-property.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_ARRAY</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_ARRAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Clsid">
            <summary>
            <dd> <p>A CLSID.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_CLSID</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_CLSID</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Matrix3x2">
            <summary>
            <dd> <p>A 3x2 matrix of  float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_MATRIX_3X2</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_MATRIX_3X2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Matrix4x3">
            <summary>
            <dd> <p>A 4x2 matrix of  float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_MATRIX_4X3</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_MATRIX_4X3</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Matrix4x4">
            <summary>
            <dd> <p>A 4x4 matrix of  float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_MATRIX_4X4</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_MATRIX_4X4</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.Matrix5x4">
            <summary>
            <dd> <p>A 5x4 matrix of  float values.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_MATRIX_5X4</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_MATRIX_5X4</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PropertyType.ColorContext">
            <summary>
            <dd> <p>A nano-COM color context interface reference.</p> </dd>
            </summary>
            <doc-id>hh447012</doc-id>
            <unmanaged>D2D1_PROPERTY_TYPE_COLOR_CONTEXT</unmanaged>
            <unmanaged-short>D2D1_PROPERTY_TYPE_COLOR_CONTEXT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RenderingPriority">
            <summary>
            <p>The rendering priority affects the extent to which Direct2D will throttle its rendering workload.</p>
            </summary>
            <doc-id>dn280382</doc-id>
            <unmanaged>D2D1_RENDERING_PRIORITY</unmanaged>
            <unmanaged-short>D2D1_RENDERING_PRIORITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderingPriority.Normal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280382</doc-id>
            <unmanaged>D2D1_RENDERING_PRIORITY_NORMAL</unmanaged>
            <unmanaged-short>D2D1_RENDERING_PRIORITY_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderingPriority.Low">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280382</doc-id>
            <unmanaged>D2D1_RENDERING_PRIORITY_LOW</unmanaged>
            <unmanaged-short>D2D1_RENDERING_PRIORITY_LOW</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RenderTargetType">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_TYPE</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetType.Default">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_TYPE_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_TYPE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetType.Software">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_TYPE_SOFTWARE</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_TYPE_SOFTWARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetType.Hardware">
            <summary>
            <dd> <p>The render target uses hardware rendering only. </p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_TYPE_HARDWARE</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_TYPE_HARDWARE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RenderTargetUsage">
            <summary>
            <p> Describes how a render target is remoted and whether it should be GDI-compatible. This enumeration allows a bitwise combination of its member values.</p>
            </summary>
            <doc-id>dd368157</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_USAGE</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_USAGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetUsage.None">
            <summary>
            <dd> <p>The render target attempts to use Direct3D command-stream remoting and uses bitmap remoting if stream remoting fails. The render target is not GDI-compatible.</p> </dd>
            </summary>
            <doc-id>dd368157</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_USAGE_NONE</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_USAGE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetUsage.ForceBitmapRemoting">
            <summary>
            <dd> <p>The render target renders content locally and sends it to the terminal services client as a bitmap. </p> </dd>
            </summary>
            <doc-id>dd368157</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderTargetUsage.GdiCompatible">
            <summary>
            <dd> <p>The render target can be used efficiently with GDI.</p> </dd>
            </summary>
            <doc-id>dd368157</doc-id>
            <unmanaged>D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE</unmanaged>
            <unmanaged-short>D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RgbToHueOutputColorSpace">
            <summary>
            <p>Values for the <strong>D2D1_RGBTOHUE_PROP_OUTPUT_COLOR_SPACE</strong> property of the RGB to Hue effect.</p>
            </summary>
            <doc-id>dn890743</doc-id>
            <unmanaged>D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE</unmanaged>
            <unmanaged-short>D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RgbToHueOutputColorSpace.HueSaturationValue">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890743</doc-id>
            <unmanaged>D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_VALUE</unmanaged>
            <unmanaged-short>D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_VALUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RgbToHueOutputColorSpace.HueSaturationLightness">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890743</doc-id>
            <unmanaged>D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS</unmanaged>
            <unmanaged-short>D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RgbToHueProperty">
            <summary>
            <p>Indentifiers for properties of the RGB to Hue effect.</p>
            </summary>
            <doc-id>dn890744</doc-id>
            <unmanaged>D2D1_RGBTOHUE_PROP</unmanaged>
            <unmanaged-short>D2D1_RGBTOHUE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RgbToHueProperty.OutputColorSpace">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890744</doc-id>
            <unmanaged>D2D1_RGBTOHUE_PROP_OUTPUT_COLOR_SPACE</unmanaged>
            <unmanaged-short>D2D1_RGBTOHUE_PROP_OUTPUT_COLOR_SPACE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SaturationProperties">
            <summary>
            <p>Identifiers for properties of the Saturation effect.</p>
            </summary>
            <doc-id>dn934259</doc-id>
            <unmanaged>D2D1_SATURATION_PROP</unmanaged>
            <unmanaged-short>D2D1_SATURATION_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SaturationProperties.Saturation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934259</doc-id>
            <unmanaged>D2D1_SATURATION_PROP_SATURATION</unmanaged>
            <unmanaged-short>D2D1_SATURATION_PROP_SATURATION</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ScaleInterpolationMode">
            <summary>
            <p>The interpolation mode the Scale effect uses to scale the image. There are 6 scale modes that range in quality and speed. </p>
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleInterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleInterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleInterpolationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleInterpolationMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleInterpolationMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleInterpolationMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934260</doc-id>
            <unmanaged>D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ScaleProperties">
            <summary>
            <p> Identifiers for properties of the Scale effect. </p>
            </summary>
            <doc-id>dn934261</doc-id>
            <unmanaged>D2D1_SCALE_PROP</unmanaged>
            <unmanaged-short>D2D1_SCALE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleProperties.Scale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934261</doc-id>
            <unmanaged>D2D1_SCALE_PROP_SCALE</unmanaged>
            <unmanaged-short>D2D1_SCALE_PROP_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleProperties.CenterPoint">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934261</doc-id>
            <unmanaged>D2D1_SCALE_PROP_CENTER_POINT</unmanaged>
            <unmanaged-short>D2D1_SCALE_PROP_CENTER_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934261</doc-id>
            <unmanaged>D2D1_SCALE_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_SCALE_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934261</doc-id>
            <unmanaged>D2D1_SCALE_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_SCALE_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ScaleProperties.Sharpness">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934261</doc-id>
            <unmanaged>D2D1_SCALE_PROP_SHARPNESS</unmanaged>
            <unmanaged-short>D2D1_SCALE_PROP_SHARPNESS</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SepiaProperty">
            <summary>
            <p>Identifiers for properties of the Sepia effect.</p>
            </summary>
            <doc-id>dn890745</doc-id>
            <unmanaged>D2D1_SEPIA_PROP</unmanaged>
            <unmanaged-short>D2D1_SEPIA_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SepiaProperty.Intensity">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890745</doc-id>
            <unmanaged>D2D1_SEPIA_PROP_INTENSITY</unmanaged>
            <unmanaged-short>D2D1_SEPIA_PROP_INTENSITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SepiaProperty.AlphaMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890745</doc-id>
            <unmanaged>D2D1_SEPIA_PROP_ALPHA_MODE</unmanaged>
            <unmanaged-short>D2D1_SEPIA_PROP_ALPHA_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ShadowOptimization">
            <summary>
            <p>The level of performance optimization for the Shadow effect.</p>
            </summary>
            <doc-id>dn934262</doc-id>
            <unmanaged>D2D1_SHADOW_OPTIMIZATION</unmanaged>
            <unmanaged-short>D2D1_SHADOW_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ShadowOptimization.Speed">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934262</doc-id>
            <unmanaged>D2D1_SHADOW_OPTIMIZATION_SPEED</unmanaged>
            <unmanaged-short>D2D1_SHADOW_OPTIMIZATION_SPEED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ShadowOptimization.Balanced">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934262</doc-id>
            <unmanaged>D2D1_SHADOW_OPTIMIZATION_BALANCED</unmanaged>
            <unmanaged-short>D2D1_SHADOW_OPTIMIZATION_BALANCED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ShadowOptimization.Quality">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934262</doc-id>
            <unmanaged>D2D1_SHADOW_OPTIMIZATION_QUALITY</unmanaged>
            <unmanaged-short>D2D1_SHADOW_OPTIMIZATION_QUALITY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ShadowProperties">
            <summary>
            <p> Identifiers for properties of the Shadow effect. </p>
            </summary>
            <doc-id>dn934263</doc-id>
            <unmanaged>D2D1_SHADOW_PROP</unmanaged>
            <unmanaged-short>D2D1_SHADOW_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ShadowProperties.BlurStandardDeviation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934263</doc-id>
            <unmanaged>D2D1_SHADOW_PROP_BLUR_STANDARD_DEVIATION</unmanaged>
            <unmanaged-short>D2D1_SHADOW_PROP_BLUR_STANDARD_DEVIATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ShadowProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934263</doc-id>
            <unmanaged>D2D1_SHADOW_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_SHADOW_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ShadowProperties.Optimization">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934263</doc-id>
            <unmanaged>D2D1_SHADOW_PROP_OPTIMIZATION</unmanaged>
            <unmanaged-short>D2D1_SHADOW_PROP_OPTIMIZATION</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SharpenProperty">
            <summary>
            <p>Identifiers for properties of the Sharpen effect.</p>
            </summary>
            <doc-id>dn890746</doc-id>
            <unmanaged>D2D1_SHARPEN_PROP</unmanaged>
            <unmanaged-short>D2D1_SHARPEN_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SharpenProperty.Sharpness">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890746</doc-id>
            <unmanaged>D2D1_SHARPEN_PROP_SHARPNESS</unmanaged>
            <unmanaged-short>D2D1_SHARPEN_PROP_SHARPNESS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SharpenProperty.Threshold">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890746</doc-id>
            <unmanaged>D2D1_SHARPEN_PROP_THRESHOLD</unmanaged>
            <unmanaged-short>D2D1_SHARPEN_PROP_THRESHOLD</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SpotDiffuseProperties">
            <summary>
            <p> Identifiers for properties of the Spot-diffuse lighting effect. </p>
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.LightPosition">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_LIGHT_POSITION</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_LIGHT_POSITION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.PointsAt">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_POINTS_AT</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_POINTS_AT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.Focus">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_FOCUS</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_FOCUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.LimitingConeAngle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_LIMITING_CONE_ANGLE</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_LIMITING_CONE_ANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.DiffuseConstant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_DIFFUSE_CONSTANT</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_DIFFUSE_CONSTANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.SurfaceScale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_SURFACE_SCALE</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_SURFACE_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934264</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SpotDiffuseScaleMode">
            <summary>
            <p>The interpolation mode the Spot-diffuse lighting effect uses to scale the image to the corresponding kernel unit length.  There are six scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotDiffuseScaleMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934265</doc-id>
            <unmanaged>D2D1_SPOTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_SPOTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SpotSpecularProperties">
            <summary>
            <p> Identifiers for properties of the Spot-specular lighting effect. </p>
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.LightPosition">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_LIGHT_POSITION</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_LIGHT_POSITION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.PointsAt">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_POINTS_AT</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_POINTS_AT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.Focus">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_FOCUS</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_FOCUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.LimitingConeAngle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_LIMITING_CONE_ANGLE</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_LIMITING_CONE_ANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.SpecularExponent">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_SPECULAR_EXPONENT</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_SPECULAR_EXPONENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.SpecularConstant">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_SPECULAR_CONSTANT</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_SPECULAR_CONSTANT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.SurfaceScale">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_SURFACE_SCALE</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_SURFACE_SCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.KernelUnitLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_KERNEL_UNIT_LENGTH</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_KERNEL_UNIT_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularProperties.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934266</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SpotSpecularScaleMode">
            <summary>
            <p>The interpolation mode the Spot-specular lighting effect uses to scale the image  to the corresponding kernel unit length. There are six scale modes that range in quality and speed.</p>
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpotSpecularScaleMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934267</doc-id>
            <unmanaged>D2D1_SPOTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_SPOTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpriteOptions.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt619821</doc-id>
            <unmanaged>D2D1_SPRITE_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_SPRITE_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SpriteOptions.ClampToSourceRectangle">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt619821</doc-id>
            <unmanaged>D2D1_SPRITE_OPTIONS_CLAMP_TO_SOURCE_RECTANGLE</unmanaged>
            <unmanaged-short>D2D1_SPRITE_OPTIONS_CLAMP_TO_SOURCE_RECTANGLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.StraightenProperty">
            <summary>
            <p>Identifiers for properties of the Straighten effect.</p>
            </summary>
            <doc-id>dn890747</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_PROP</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenProperty.Angle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890747</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_PROP_ANGLE</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_PROP_ANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenProperty.MaintainSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890747</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_PROP_MAINTAIN_SIZE</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_PROP_MAINTAIN_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenProperty.ScaleMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890747</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_PROP_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_PROP_SCALE_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.StraightenScaleMode">
            <summary>
            <p>Values for the <strong>D2D1_STRAIGHTEN_PROP_SCALE_MODE</strong> property of the Straighten effect.</p>
            </summary>
            <doc-id>dn890748</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_SCALE_MODE</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_SCALE_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenScaleMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890748</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_SCALE_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenScaleMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890748</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_SCALE_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_SCALE_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenScaleMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890748</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_SCALE_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_SCALE_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenScaleMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890748</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_SCALE_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StraightenScaleMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890748</doc-id>
            <unmanaged>D2D1_STRAIGHTEN_SCALE_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_STRAIGHTEN_SCALE_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.StrokeTransformType">
            <summary>
            <p>Defines how the world transform, dots per inch (dpi), and stroke width affect the shape of the pen used to stroke a primitive.</p>
            </summary>
            <remarks>
            <p>If you specify <strong>D2D1_STROKE_TRANSFORM_TYPE_FIXED</strong> the stroke isn't affected by the world transform.</p><p>If you specify <strong>D2D1_STROKE_TRANSFORM_TYPE_FIXED</strong> the application has the same behavior in Windows 7 and later.</p><p>If you specify <strong>D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE</strong> the stroke is always 1 pixel wide.</p><p>Apart from the stroke, any value derived from the stroke width is not affected when the transformType is either fixed or hairline. This includes miters, line caps and so on.</p><p> It is important to distinguish between the geometry being stroked and the shape of the stroke pen. When D2D1_STROKE_TRANSFORM_TYPE_FIXED or D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE is specified, the geometry still respects the transform and dpi, but the pen that traces the geometry will not.</p><p>Here is an illustration of a stroke with dashing and a skew and stretch transform.</p><p>And here is an illustration of a fixed width stroke which does not get transformed.</p>
            </remarks>
            <doc-id>hh447016</doc-id>
            <unmanaged>D2D1_STROKE_TRANSFORM_TYPE</unmanaged>
            <unmanaged-short>D2D1_STROKE_TRANSFORM_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeTransformType.Normal">
            <summary>
            <dd> <p>The stroke respects the currently set world transform, the dpi, and the stroke width.</p> </dd>
            </summary>
            <doc-id>hh447016</doc-id>
            <unmanaged>D2D1_STROKE_TRANSFORM_TYPE_NORMAL</unmanaged>
            <unmanaged-short>D2D1_STROKE_TRANSFORM_TYPE_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeTransformType.Fixed">
            <summary>
            <dd> <p>The stroke does not respect the world transform but it does respect the dpi and stroke width.</p> </dd>
            </summary>
            <doc-id>hh447016</doc-id>
            <unmanaged>D2D1_STROKE_TRANSFORM_TYPE_FIXED</unmanaged>
            <unmanaged-short>D2D1_STROKE_TRANSFORM_TYPE_FIXED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeTransformType.Hairline">
            <summary>
            <dd> <p>The stroke is forced to 1 pixel wide (in device space) and does not respect the world transform, the dpi, or the stroke width.</p> </dd>
            </summary>
            <doc-id>hh447016</doc-id>
            <unmanaged>D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE</unmanaged>
            <unmanaged-short>D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SubProperty">
            <summary>
            <p>Specifies the indices of the system sub-properties that may be present in any property.</p>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.DisplayName">
            <summary>
            <dd> <p>The name for the parent property.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_DISPLAYNAME</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_DISPLAYNAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.Isreadonly">
            <summary>
            <dd> <p>A Boolean indicating whether the parent property is writeable.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_ISREADONLY</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_ISREADONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.Minimum">
            <summary>
            <dd> <p>The minimum value that can be set to the parent property.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_MIN</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_MIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.Maximum">
            <summary>
            <dd> <p>The maximum value that can be set to the parent property.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_MAX</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_MAX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.Default">
            <summary>
            <dd> <p>The default value of the parent property.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.Fields">
            <summary>
            <dd> <p>An array of name/index pairs that indicate the possible values that can be set to the parent property.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_FIELDS</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_FIELDS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SubProperty.Index">
            <summary>
            <dd> <p>An index sub-property used by the elements of the <strong>D2D1_SUBPROPERTY_FIELDS</strong> array.</p> </dd>
            </summary>
            <doc-id>hh447018</doc-id>
            <unmanaged>D2D1_SUBPROPERTY_INDEX</unmanaged>
            <unmanaged-short>D2D1_SUBPROPERTY_INDEX</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgAspectAlign">
            <summary>
            <p>Describes how a render target behaves when it presents its content. This enumeration allows a bitwise combination of its member values.</p>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.None">
            <summary>
            <dd> <p>The render target waits until the display refreshes to present and discards the frame upon presenting.</p> </dd>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_NONE</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMinimumYMinimum">
            <summary>
            <dd> <p>The render target does not discard the frame upon presenting.</p> </dd>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MIN</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMidYMinimum">
            <summary>
            <dd> <p>The render target does not wait until the display refreshes to present.</p> </dd>
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MIN</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMaximumYMinimum">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MIN</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMinimumYMid">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MID</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MID</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMidYMid">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MID</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MID</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMaximumYMid">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MID</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MID</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMinimumYMaximum">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MAX</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MAX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMidYMaximum">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MAX</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MAX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectAlign.XMaximumYMaximum">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368144</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MAX</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MAX</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgAspectScaling">
            <summary>
            <p>Indicates how pixel shader sampling will be restricted. This indicates whether the vertex buffer is large and tends to change infrequently or smaller and changes frequently (typically frame over frame). </p>
            </summary>
            <remarks>
            <p> If the shader specifies <strong>D2D1_PIXEL_OPTIONS_NONE</strong>, it must still correctly implement the region of interest calculations in <strong>ID2D1Transform::MapOutputRectToInputRects</strong> and <strong>ID2D1Transform::MapInputRectsToOutputRect</strong>.</p>
            </remarks>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_SCALING</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_SCALING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectScaling.Meet">
            <summary>
            <dd> <p>The pixel shader is not restricted in its sampling.</p> </dd>
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_SCALING_MEET</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_SCALING_MEET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAspectScaling.Slice">
            <summary>
            <dd> <p> The pixel shader samples inputs only at the same scene coordinate as the output pixel and returns transparent black whenever the input pixels are also transparent black.</p> </dd>
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_ASPECT_SCALING_SLICE</unmanaged>
            <unmanaged-short>D2D1_SVG_ASPECT_SCALING_SLICE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgAttributePodType">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Float">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_FLOAT</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_FLOAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Color">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_COLOR</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.FillMode">
            <summary>
            <dd> <p>The render target uses hardware rendering only. </p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_FILL_MODE</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_FILL_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Display">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_DISPLAY</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_DISPLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Overflow">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_OVERFLOW</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_OVERFLOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.LineCap">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_LINE_CAP</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_LINE_CAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.LineJoin">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_LINE_JOIN</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_LINE_JOIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Visibility">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_VISIBILITY</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_VISIBILITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Matrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_MATRIX</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.UnitType">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_UNIT_TYPE</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_UNIT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.ExtendMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_EXTEND_MODE</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_EXTEND_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.PreserveAspectRatio">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_PRESERVE_ASPECT_RATIO</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_PRESERVE_ASPECT_RATIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.ViewBox">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_VIEWBOX</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_VIEWBOX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributePodType.Length">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_POD_TYPE_LENGTH</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_POD_TYPE_LENGTH</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgAttributeStringType">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_STRING_TYPE</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_STRING_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributeStringType.Svg">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_STRING_TYPE_SVG</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_STRING_TYPE_SVG</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgAttributeStringType.Id">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_ATTRIBUTE_STRING_TYPE_ID</unmanaged>
            <unmanaged-short>D2D1_SVG_ATTRIBUTE_STRING_TYPE_ID</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgDisplay">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_DISPLAY</unmanaged>
            <unmanaged-short>D2D1_SVG_DISPLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgDisplay.Inline">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_DISPLAY_INLINE</unmanaged>
            <unmanaged-short>D2D1_SVG_DISPLAY_INLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgDisplay.None">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_DISPLAY_NONE</unmanaged>
            <unmanaged-short>D2D1_SVG_DISPLAY_NONE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgLengthUnits">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LENGTH_UNITS</unmanaged>
            <unmanaged-short>D2D1_SVG_LENGTH_UNITS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLengthUnits.Number">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LENGTH_UNITS_NUMBER</unmanaged>
            <unmanaged-short>D2D1_SVG_LENGTH_UNITS_NUMBER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLengthUnits.Percentage">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LENGTH_UNITS_PERCENTAGE</unmanaged>
            <unmanaged-short>D2D1_SVG_LENGTH_UNITS_PERCENTAGE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgLineCap">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LINE_CAP</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_CAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLineCap.Butt">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LINE_CAP_BUTT</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_CAP_BUTT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLineCap.Square">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LINE_CAP_SQUARE</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_CAP_SQUARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLineCap.Round">
            <summary>
            <dd> <p>The render target uses hardware rendering only. </p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_LINE_CAP_ROUND</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_CAP_ROUND</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgLineJoin">
            <summary>
            <p>Indicates how pixel shader sampling will be restricted. This indicates whether the vertex buffer is large and tends to change infrequently or smaller and changes frequently (typically frame over frame). </p>
            </summary>
            <remarks>
            <p> If the shader specifies <strong>D2D1_PIXEL_OPTIONS_NONE</strong>, it must still correctly implement the region of interest calculations in <strong>ID2D1Transform::MapOutputRectToInputRects</strong> and <strong>ID2D1Transform::MapInputRectsToOutputRect</strong>.</p>
            </remarks>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_LINE_JOIN</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_JOIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLineJoin.Bevel">
            <summary>
            <dd> <p>The pixel shader is not restricted in its sampling.</p> </dd>
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_LINE_JOIN_BEVEL</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_JOIN_BEVEL</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLineJoin.Miter">
            <summary>
            <dd> <p> The pixel shader samples inputs only at the same scene coordinate as the output pixel and returns transparent black whenever the input pixels are also transparent black.</p> </dd>
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_LINE_JOIN_MITER</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_JOIN_MITER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLineJoin.Round">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404316</doc-id>
            <unmanaged>D2D1_SVG_LINE_JOIN_ROUND</unmanaged>
            <unmanaged-short>D2D1_SVG_LINE_JOIN_ROUND</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgOverflow">
            <summary>
            <p>Describes the shape at the end of a line or segment.</p>
            </summary>
            <remarks>
            <p> The following illustration shows the available cap styles for lines or segments. The red portion of the line shows the extra area added by the line cap setting. </p>
            </remarks>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_SVG_OVERFLOW</unmanaged>
            <unmanaged-short>D2D1_SVG_OVERFLOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgOverflow.Visible">
            <summary>
            <dd> <p>A cap that does not extend past the last point of the line. Comparable to cap used for objects other than lines. </p> </dd>
            </summary>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_SVG_OVERFLOW_VISIBLE</unmanaged>
            <unmanaged-short>D2D1_SVG_OVERFLOW_VISIBLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgOverflow.Hidden">
            <summary>
            <dd> <p>Half of a square that has a length equal to the line thickness.</p> </dd>
            </summary>
            <doc-id>dd368079</doc-id>
            <unmanaged>D2D1_SVG_OVERFLOW_HIDDEN</unmanaged>
            <unmanaged-short>D2D1_SVG_OVERFLOW_HIDDEN</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgPaintType">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.None">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_NONE</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.Color">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_COLOR</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.CurrentColor">
            <summary>
            <dd> <p>The render target uses hardware rendering only. </p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_CURRENT_COLOR</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_CURRENT_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.Uri">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_URI</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_URI</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.UriNone">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_URI_NONE</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_URI_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.UriColor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_URI_COLOR</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_URI_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPaintType.UriCurrentColor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PAINT_TYPE_URI_CURRENT_COLOR</unmanaged>
            <unmanaged-short>D2D1_SVG_PAINT_TYPE_URI_CURRENT_COLOR</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgPathCommand">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.ClosePath">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_CLOSE_PATH</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_CLOSE_PATH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.MoveAbsolute">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_MOVE_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_MOVE_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.MoveRelative">
            <summary>
            <dd> <p>The render target uses hardware rendering only. </p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_MOVE_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_MOVE_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.LineAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_LINE_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_LINE_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.LineRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_LINE_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_LINE_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.CubicAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_CUBIC_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_CUBIC_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.CubicRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_CUBIC_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_CUBIC_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.QuadradicAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_QUADRADIC_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_QUADRADIC_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.QuadradicRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_QUADRADIC_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_QUADRADIC_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.ArcAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_ARC_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_ARC_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.ArcRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_ARC_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_ARC_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.HorizontalAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_HORIZONTAL_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_HORIZONTAL_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.HorizontalRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_HORIZONTAL_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_HORIZONTAL_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.VerticalAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_VERTICAL_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_VERTICAL_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.VerticalRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_VERTICAL_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_VERTICAL_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.CubicSmoothAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_CUBIC_SMOOTH_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_CUBIC_SMOOTH_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.CubicSmoothRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_CUBIC_SMOOTH_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_CUBIC_SMOOTH_RELATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.QuadradicSmoothAbsolute">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_QUADRADIC_SMOOTH_ABSOLUTE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_QUADRADIC_SMOOTH_ABSOLUTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPathCommand.QuadradicSmoothRelative">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_PATH_COMMAND_QUADRADIC_SMOOTH_RELATIVE</unmanaged>
            <unmanaged-short>D2D1_SVG_PATH_COMMAND_QUADRADIC_SMOOTH_RELATIVE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgUnitType">
            <summary>
            <p>Describes whether a render target uses hardware or software rendering, or if Direct2D should select the rendering mode.</p>
            </summary>
            <remarks>
            <p>Not every render target supports hardware rendering. For more information, see the Render Targets Overview. </p>
            </remarks>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_UNIT_TYPE</unmanaged>
            <unmanaged-short>D2D1_SVG_UNIT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgUnitType.UserSpaceOnUse">
            <summary>
            <dd> <p>The render target uses hardware rendering, if available; otherwise, it uses software rendering.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_UNIT_TYPE_USER_SPACE_ON_USE</unmanaged>
            <unmanaged-short>D2D1_SVG_UNIT_TYPE_USER_SPACE_ON_USE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgUnitType.ObjectBoundingBox">
            <summary>
            <dd> <p>The render target uses software rendering only.</p> </dd>
            </summary>
            <doc-id>dd756630</doc-id>
            <unmanaged>D2D1_SVG_UNIT_TYPE_OBJECT_BOUNDING_BOX</unmanaged>
            <unmanaged-short>D2D1_SVG_UNIT_TYPE_OBJECT_BOUNDING_BOX</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgVisibility">
            <summary>
            <p>Defines options that should be applied to the color space.</p>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_SVG_VISIBILITY</unmanaged>
            <unmanaged-short>D2D1_SVG_VISIBILITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgVisibility.Visible">
            <summary>
            <dd> <p>The color space is otherwise described, such as with a color profile.</p> </dd>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_SVG_VISIBILITY_VISIBLE</unmanaged>
            <unmanaged-short>D2D1_SVG_VISIBILITY_VISIBLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgVisibility.Hidden">
            <summary>
            <dd> <p>The color space is sRGB.</p> </dd>
            </summary>
            <doc-id>hh446992</doc-id>
            <unmanaged>D2D1_SVG_VISIBILITY_HIDDEN</unmanaged>
            <unmanaged-short>D2D1_SVG_VISIBILITY_HIDDEN</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SweepDirection">
            <summary>
            <p>Defines the direction that an elliptical arc is drawn.  </p>
            </summary>
            <doc-id>dd368166</doc-id>
            <unmanaged>D2D1_SWEEP_DIRECTION</unmanaged>
            <unmanaged-short>D2D1_SWEEP_DIRECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SweepDirection.CounterClockwise">
            <summary>
            <dd> <p> Arcs are drawn in a counterclockwise (negative-angle) direction. </p> </dd>
            </summary>
            <doc-id>dd368166</doc-id>
            <unmanaged>D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE</unmanaged>
            <unmanaged-short>D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SweepDirection.Clockwise">
            <summary>
            <dd> <p> Arcs are drawn in a clockwise (positive-angle) direction. </p> </dd>
            </summary>
            <doc-id>dd368166</doc-id>
            <unmanaged>D2D1_SWEEP_DIRECTION_CLOCKWISE</unmanaged>
            <unmanaged-short>D2D1_SWEEP_DIRECTION_CLOCKWISE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TableTransferProperties">
            <summary>
            <p> Identifiers for properties of the Table transfer effect. </p>
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.RedTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_RED_TABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_RED_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.RedDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_RED_DISABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_RED_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.GreenTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_GREEN_TABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_GREEN_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.GreenDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_GREEN_DISABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_GREEN_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.BlueTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_BLUE_TABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_BLUE_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.BlueDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_BLUE_DISABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_BLUE_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.AlphaTable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_ALPHA_TABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_ALPHA_TABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.AlphaDisable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_ALPHA_DISABLE</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_ALPHA_DISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TableTransferProperties.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934268</doc-id>
            <unmanaged>D2D1_TABLETRANSFER_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_TABLETRANSFER_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TemperatureAndTintProperty">
            <summary>
            <p>Identifiers for properties of the Temperature and Tint effect.</p>
            </summary>
            <doc-id>dn890749</doc-id>
            <unmanaged>D2D1_TEMPERATUREANDTINT_PROP</unmanaged>
            <unmanaged-short>D2D1_TEMPERATUREANDTINT_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TemperatureAndTintProperty.Temperature">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890749</doc-id>
            <unmanaged>D2D1_TEMPERATUREANDTINT_PROP_TEMPERATURE</unmanaged>
            <unmanaged-short>D2D1_TEMPERATUREANDTINT_PROP_TEMPERATURE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TemperatureAndTintProperty.Tint">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890749</doc-id>
            <unmanaged>D2D1_TEMPERATUREANDTINT_PROP_TINT</unmanaged>
            <unmanaged-short>D2D1_TEMPERATUREANDTINT_PROP_TINT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TextAntialiasMode">
            <summary>
            <p>Describes the antialiasing mode used for drawing text. </p>
            </summary>
            <remarks>
            <p>This enumeration is used with the <strong>SetTextAntialiasMode</strong> of an <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong> to specify how text and glyphs are antialiased.</p><p> By default, Direct2D renders text in ClearType mode. Factors that  can downgrade the default quality to grayscale or aliased:</p><ul> <li>If the <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode"/></strong> value  is <strong>DWRITE_RENDERING_MODE_ALIASED </strong>, then the  default text antialiasing mode is aliased.  To change the DirectWrite rendering mode of an <strong><see cref = "T:SharpDX.Direct2D1.RenderTarget"/></strong>, use the  <strong>ID2D1RenderTarget::SetTextRenderingParams</strong> method. </li> <li>If the <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode"/></strong> value is <strong>DWRITE_RENDERING_MODE_OUTLINE</strong>, then the default text  antialiasing mode is grayscale.</li> <li>If the render target has an alpha channel and is not set to <strong>D2D1_ALPHA_MODE_IGNORE</strong>, then  the default text antialiasing mode is grayscale.</li> <li>If <strong>ID2D1RenderTarget::PushLayer</strong> is called without <strong>D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE</strong> (and the corresponding <strong>PopLayer</strong> has not  been called yet), then the default text  antialiasing mode is grayscale.</li> </ul>
            </remarks>
            <doc-id>dd368170</doc-id>
            <unmanaged>D2D1_TEXT_ANTIALIAS_MODE</unmanaged>
            <unmanaged-short>D2D1_TEXT_ANTIALIAS_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TextAntialiasMode.Default">
            <summary>
            <dd> <p>Use the system default. See Remarks.</p> </dd>
            </summary>
            <doc-id>dd368170</doc-id>
            <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_DEFAULT</unmanaged>
            <unmanaged-short>D2D1_TEXT_ANTIALIAS_MODE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TextAntialiasMode.Cleartype">
            <summary>
            <dd> <p>Use ClearType antialiasing.</p> </dd>
            </summary>
            <doc-id>dd368170</doc-id>
            <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE</unmanaged>
            <unmanaged-short>D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TextAntialiasMode.Grayscale">
            <summary>
            <dd> <p>Use grayscale antialiasing.</p> </dd>
            </summary>
            <doc-id>dd368170</doc-id>
            <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE</unmanaged>
            <unmanaged-short>D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TextAntialiasMode.Aliased">
            <summary>
            <dd> <p>Do not use antialiasing.</p> </dd>
            </summary>
            <doc-id>dd368170</doc-id>
            <unmanaged>D2D1_TEXT_ANTIALIAS_MODE_ALIASED</unmanaged>
            <unmanaged-short>D2D1_TEXT_ANTIALIAS_MODE_ALIASED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ThreadingMode">
            <summary>
            <p>Specifies the threading mode used while simultaneously creating the device, factory, and device context.
            </p>
            </summary>
            <doc-id>hh447020</doc-id>
            <unmanaged>D2D1_THREADING_MODE</unmanaged>
            <unmanaged-short>D2D1_THREADING_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ThreadingMode.SingleThreaded">
            <summary>
            <dd> <p>Resources may only be invoked serially.  Device context state is not protected from multi-threaded access. </p> </dd>
            </summary>
            <doc-id>hh447020</doc-id>
            <unmanaged>D2D1_THREADING_MODE_SINGLE_THREADED</unmanaged>
            <unmanaged-short>D2D1_THREADING_MODE_SINGLE_THREADED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ThreadingMode.MultiThreaded">
            <summary>
            <dd> <p>Resources may be invoked from multiple threads. Resources use interlocked reference counting and their state is protected.
            </p> </dd>
            </summary>
            <doc-id>hh447020</doc-id>
            <unmanaged>D2D1_THREADING_MODE_MULTI_THREADED</unmanaged>
            <unmanaged-short>D2D1_THREADING_MODE_MULTI_THREADED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TileProperties">
            <summary>
            <p> Identifiers for properties of the Tile effect. </p>
            </summary>
            <doc-id>dn934269</doc-id>
            <unmanaged>D2D1_TILE_PROP</unmanaged>
            <unmanaged-short>D2D1_TILE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TileProperties.Rectangle">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934269</doc-id>
            <unmanaged>D2D1_TILE_PROP_RECT</unmanaged>
            <unmanaged-short>D2D1_TILE_PROP_RECT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TintProp">
            <summary>
            <p>This effect tints the source image by multiplying the source image by the specified color. It has a single input.</p><p>The CLSID for this effect is <see cref = "!:Tint"/>.</p>
            </summary>
            <doc-id>mt745077</doc-id>
            <unmanaged>D2D1_TINT_PROP</unmanaged>
            <unmanaged-short>D2D1_TINT_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TintProp.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt745077</doc-id>
            <unmanaged>D2D1_TINT_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_TINT_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TintProp.ClampOutput">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt745077</doc-id>
            <unmanaged>D2D1_TINT_PROP_CLAMP_OUTPUT</unmanaged>
            <unmanaged-short>D2D1_TINT_PROP_CLAMP_OUTPUT</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Transform3DInterpolationMode">
            <summary>
            <p> The interpolation mode the 3D transform effect uses on the image. There are 5 scale modes that range in quality and speed. </p>
            </summary>
            <doc-id>dn934209</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DInterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934209</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DInterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934209</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DInterpolationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934209</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DInterpolationMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934209</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DInterpolationMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934209</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Transform3DProperties">
            <summary>
            <p> Identifiers for properties of the 3D transform effect. </p>
            </summary>
            <doc-id>dn934210</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_PROP</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934210</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DProperties.BorderMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934210</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_PROP_BORDER_MODE</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_PROP_BORDER_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Transform3DProperties.TransformMatrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934210</doc-id>
            <unmanaged>D2D1_3DTRANSFORM_PROP_TRANSFORM_MATRIX</unmanaged>
            <unmanaged-short>D2D1_3DTRANSFORM_PROP_TRANSFORM_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceOptions.None">
            <summary>
            <dd> <p>No option flags.</p> </dd>
            </summary>
            <doc-id>dn934270</doc-id>
            <unmanaged>D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceOptions.DisableDpiScale">
            <summary>
            <dd> <p>Prevents the image source from being automatically scaled (by a ratio of the context DPI divided by 96) while drawn.</p> </dd>
            </summary>
            <doc-id>dn934270</doc-id>
            <unmanaged>D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_DISABLE_DPI_SCALE</unmanaged>
            <unmanaged-short>D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_DISABLE_DPI_SCALE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TurbulenceNoise">
            <summary>
            <p>The turbulence noise mode for the Turbulence effect.  Indicates whether to generate a bitmap based on Fractal Noise or the Turbulence function. </p>
            </summary>
            <doc-id>dn934353</doc-id>
            <unmanaged>D2D1_TURBULENCE_NOISE</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_NOISE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceNoise.FractalSum">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934353</doc-id>
            <unmanaged>D2D1_TURBULENCE_NOISE_FRACTAL_SUM</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_NOISE_FRACTAL_SUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceNoise.Turbulence">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934353</doc-id>
            <unmanaged>D2D1_TURBULENCE_NOISE_TURBULENCE</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_NOISE_TURBULENCE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TurbulenceProperties">
            <summary>
            <p> Identifiers for properties of the Turbulence effect. </p>
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.Offset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_OFFSET</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.Size">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_SIZE</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.BaseFrequency">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_BASE_FREQUENCY</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_BASE_FREQUENCY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.NumOctaves">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_NUM_OCTAVES</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_NUM_OCTAVES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.Seed">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_SEED</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_SEED</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.Noise">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_NOISE</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_NOISE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TurbulenceProperties.Stitchable">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934355</doc-id>
            <unmanaged>D2D1_TURBULENCE_PROP_STITCHABLE</unmanaged>
            <unmanaged-short>D2D1_TURBULENCE_PROP_STITCHABLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.UnitMode">
            <summary>
            <p>Specifies how units in Direct2D will be interpreted.</p>
            </summary>
            <remarks>
            <p>Setting the unit mode to <strong>D2D1_UNIT_MODE_PIXELS</strong> is similar to setting the <strong><see cref = "T:SharpDX.Direct2D1.DeviceContext"/></strong> dots per inch (dpi) to 96. However, Direct2D still checks the dpi to determine the threshold for enabling vertical antialiasing for text, and when the unit mode is restored, the dpi will be remembered.</p>
            </remarks>
            <doc-id>hh447022</doc-id>
            <unmanaged>D2D1_UNIT_MODE</unmanaged>
            <unmanaged-short>D2D1_UNIT_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.UnitMode.Dips">
            <summary>
            <dd> <p>Units will be interpreted as device-independent pixels (1/96").</p> </dd>
            </summary>
            <doc-id>hh447022</doc-id>
            <unmanaged>D2D1_UNIT_MODE_DIPS</unmanaged>
            <unmanaged-short>D2D1_UNIT_MODE_DIPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.UnitMode.Pixels">
            <summary>
            <dd> <p>Units will be interpreted as pixels.</p> </dd>
            </summary>
            <doc-id>hh447022</doc-id>
            <unmanaged>D2D1_UNIT_MODE_PIXELS</unmanaged>
            <unmanaged-short>D2D1_UNIT_MODE_PIXELS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexOptions.None">
            <summary>
            <dd> <p>The logical equivalent of having no flags set.</p> </dd>
            </summary>
            <doc-id>hh404332</doc-id>
            <unmanaged>D2D1_VERTEX_OPTIONS_NONE</unmanaged>
            <unmanaged-short>D2D1_VERTEX_OPTIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexOptions.DoNotClear">
            <summary>
            <dd> <p>If this flag is set, the renderer  assumes that the vertex shader will cover the entire region of interest with vertices and need not clear the destination render target. If this flag is not set, the renderer assumes that the vertices do not cover the entire region interest and must clear the render target to transparent black first.</p> </dd>
            </summary>
            <doc-id>hh404332</doc-id>
            <unmanaged>D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR</unmanaged>
            <unmanaged-short>D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexOptions.UseDepthBuffer">
            <summary>
            <dd> <p>The renderer will use a depth buffer when rendering custom vertices. The depth buffer will be used for calculating occlusion information. This can result in the renderer output being draw-order dependent if it contains transparency.</p> </dd>
            </summary>
            <doc-id>hh404332</doc-id>
            <unmanaged>D2D1_VERTEX_OPTIONS_USE_DEPTH_BUFFER</unmanaged>
            <unmanaged-short>D2D1_VERTEX_OPTIONS_USE_DEPTH_BUFFER</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexOptions.AssumeNoOverlap">
            <summary>
            <dd> <p>Indicates that custom vertices do not overlap each other.</p> </dd>
            </summary>
            <doc-id>hh404332</doc-id>
            <unmanaged>D2D1_VERTEX_OPTIONS_ASSUME_NO_OVERLAP</unmanaged>
            <unmanaged-short>D2D1_VERTEX_OPTIONS_ASSUME_NO_OVERLAP</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.VertexUsage">
            <summary>
            <p>Indicates whether the vertex buffer changes infrequently or frequently.</p>
            </summary>
            <remarks>
            <p>If a dynamic vertex buffer is created, Direct2D will not necessarily map the buffer directly to a Direct3D vertex buffer. Instead, a system memory copy can be copied to the rendering engine vertex buffer as the effects are rendered.</p>
            </remarks>
            <doc-id>hh404337</doc-id>
            <unmanaged>D2D1_VERTEX_USAGE</unmanaged>
            <unmanaged-short>D2D1_VERTEX_USAGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexUsage.Static">
            <summary>
            <dd> <p>The created vertex buffer is updated infrequently.</p> </dd>
            </summary>
            <doc-id>hh404337</doc-id>
            <unmanaged>D2D1_VERTEX_USAGE_STATIC</unmanaged>
            <unmanaged-short>D2D1_VERTEX_USAGE_STATIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VertexUsage.Dynamic">
            <summary>
            <dd> <p>The created vertex buffer is changed frequently.</p> </dd>
            </summary>
            <doc-id>hh404337</doc-id>
            <unmanaged>D2D1_VERTEX_USAGE_DYNAMIC</unmanaged>
            <unmanaged-short>D2D1_VERTEX_USAGE_DYNAMIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.VignetteProperty">
            <summary>
            <p>Identifiers for properties of the Vignette effect.</p>
            </summary>
            <doc-id>dn890750</doc-id>
            <unmanaged>D2D1_VIGNETTE_PROP</unmanaged>
            <unmanaged-short>D2D1_VIGNETTE_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VignetteProperty.Color">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890750</doc-id>
            <unmanaged>D2D1_VIGNETTE_PROP_COLOR</unmanaged>
            <unmanaged-short>D2D1_VIGNETTE_PROP_COLOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VignetteProperty.TransitionSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890750</doc-id>
            <unmanaged>D2D1_VIGNETTE_PROP_TRANSITION_SIZE</unmanaged>
            <unmanaged-short>D2D1_VIGNETTE_PROP_TRANSITION_SIZE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.VignetteProperty.Strength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890750</doc-id>
            <unmanaged>D2D1_VIGNETTE_PROP_STRENGTH</unmanaged>
            <unmanaged-short>D2D1_VIGNETTE_PROP_STRENGTH</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.WindowState">
            <summary>
            <p>Describes whether a window is occluded. </p>
            </summary>
            <remarks>
            <p>If the window was occluded the last time  <strong>EndDraw</strong> was called, the next time the render target calls <strong>CheckWindowState</strong>, it  returns <strong>D2D1_WINDOW_STATE_OCCLUDED</strong> regardless of the current window state. If you want to use <strong>CheckWindowState</strong> to check the current window state, call <strong>CheckWindowState</strong> after every <strong>EndDraw</strong> call and ignore its return value. This will ensure that your next call to <strong>CheckWindowState</strong> state  returns the actual window state.</p>
            </remarks>
            <doc-id>dd368174</doc-id>
            <unmanaged>D2D1_WINDOW_STATE</unmanaged>
            <unmanaged-short>D2D1_WINDOW_STATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.WindowState.None">
            <summary>
            <dd> <p>The window is not occluded.</p> </dd>
            </summary>
            <doc-id>dd368174</doc-id>
            <unmanaged>D2D1_WINDOW_STATE_NONE</unmanaged>
            <unmanaged-short>D2D1_WINDOW_STATE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.WindowState.Occluded">
            <summary>
            <dd> <p>The window is occluded.</p> </dd>
            </summary>
            <doc-id>dd368174</doc-id>
            <unmanaged>D2D1_WINDOW_STATE_OCCLUDED</unmanaged>
            <unmanaged-short>D2D1_WINDOW_STATE_OCCLUDED</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.YcbcrChromaSubSampling">
            <summary>
            <p> Specifies the chroma subsampling of the input chroma image used by the YCbCr effect. </p>
            </summary>
            <doc-id>dn934357</doc-id>
            <unmanaged>D2D1_YCBCR_CHROMA_SUBSAMPLING</unmanaged>
            <unmanaged-short>D2D1_YCBCR_CHROMA_SUBSAMPLING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrChromaSubSampling.Auto">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934357</doc-id>
            <unmanaged>D2D1_YCBCR_CHROMA_SUBSAMPLING_AUTO</unmanaged>
            <unmanaged-short>D2D1_YCBCR_CHROMA_SUBSAMPLING_AUTO</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrChromaSubSampling.Both">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934357</doc-id>
            <unmanaged>D2D1_YCBCR_CHROMA_SUBSAMPLING_420</unmanaged>
            <unmanaged-short>D2D1_YCBCR_CHROMA_SUBSAMPLING_420</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrChromaSubSampling.Horizontal">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934357</doc-id>
            <unmanaged>D2D1_YCBCR_CHROMA_SUBSAMPLING_422</unmanaged>
            <unmanaged-short>D2D1_YCBCR_CHROMA_SUBSAMPLING_422</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrChromaSubSampling.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934357</doc-id>
            <unmanaged>D2D1_YCBCR_CHROMA_SUBSAMPLING_444</unmanaged>
            <unmanaged-short>D2D1_YCBCR_CHROMA_SUBSAMPLING_444</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrChromaSubSampling.Vertical">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934357</doc-id>
            <unmanaged>D2D1_YCBCR_CHROMA_SUBSAMPLING_440</unmanaged>
            <unmanaged-short>D2D1_YCBCR_CHROMA_SUBSAMPLING_440</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.YcbcrInterpolationMode">
            <summary>
            <p>Specifies the interpolation mode for the YCbCr effect.</p>
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrInterpolationMode.NearestNeighbor">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE_NEAREST_NEIGHBOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrInterpolationMode.Linear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrInterpolationMode.Cubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE_CUBIC</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE_CUBIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrInterpolationMode.MultiSampleLinear">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrInterpolationMode.Anisotropic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE_ANISOTROPIC</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE_ANISOTROPIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YcbcrInterpolationMode.HighQualityCubic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934359</doc-id>
            <unmanaged>D2D1_YCBCR_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged>
            <unmanaged-short>D2D1_YCBCR_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.YCbCrProperties">
            <summary>
            <p> Identifiers for properties of the YCbCr effect. </p>
            </summary>
            <doc-id>dn934361</doc-id>
            <unmanaged>D2D1_YCBCR_PROP</unmanaged>
            <unmanaged-short>D2D1_YCBCR_PROP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YCbCrProperties.ChromaSubSampling">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934361</doc-id>
            <unmanaged>D2D1_YCBCR_PROP_CHROMA_SUBSAMPLING</unmanaged>
            <unmanaged-short>D2D1_YCBCR_PROP_CHROMA_SUBSAMPLING</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YCbCrProperties.TransformMatrix">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934361</doc-id>
            <unmanaged>D2D1_YCBCR_PROP_TRANSFORM_MATRIX</unmanaged>
            <unmanaged-short>D2D1_YCBCR_PROP_TRANSFORM_MATRIX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.YCbCrProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn934361</doc-id>
            <unmanaged>D2D1_YCBCR_PROP_INTERPOLATION_MODE</unmanaged>
            <unmanaged-short>D2D1_YCBCR_PROP_INTERPOLATION_MODE</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ResultCode">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.WrongState">
            <summary>Constant WrongState</summary>
            <unmanaged>D2DERR_WRONG_STATE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.NotInitializeD">
            <summary>Constant NotInitializeD</summary>
            <unmanaged>D2DERR_NOT_INITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.UnsupportedOperation">
            <summary>Constant UnsupportedOperation</summary>
            <unmanaged>D2DERR_UNSUPPORTED_OPERATION</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.ScannerFailed">
            <summary>Constant ScannerFailed</summary>
            <unmanaged>D2DERR_SCANNER_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.ScreenAccessDenied">
            <summary>Constant ScreenAccessDenied</summary>
            <unmanaged>D2DERR_SCREEN_ACCESS_DENIED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.DisplayStateInvalid">
            <summary>Constant DisplayStateInvalid</summary>
            <unmanaged>D2DERR_DISPLAY_STATE_INVALID</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.ZeroVector">
            <summary>Constant ZeroVector</summary>
            <unmanaged>D2DERR_ZERO_VECTOR</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InternalError">
            <summary>Constant InternalError</summary>
            <unmanaged>D2DERR_INTERNAL_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.DisplayFormatNotSupported">
            <summary>Constant DisplayFormatNotSupported</summary>
            <unmanaged>D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InvalidCall">
            <summary>Constant InvalidCall</summary>
            <unmanaged>D2DERR_INVALID_CALL</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.NoHardwareDevice">
            <summary>Constant NoHardwareDevice</summary>
            <unmanaged>D2DERR_NO_HARDWARE_DEVICE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.RecreateTarget">
            <summary>Constant RecreateTarget</summary>
            <unmanaged>D2DERR_RECREATE_TARGET</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.TooManyShaderElements">
            <summary>Constant TooManyShaderElements</summary>
            <unmanaged>D2DERR_TOO_MANY_SHADER_ELEMENTS</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.ShaderCompileFailed">
            <summary>Constant ShaderCompileFailed</summary>
            <unmanaged>D2DERR_SHADER_COMPILE_FAILED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.MaximumTextureSizeExceeded">
            <summary>Constant MaximumTextureSizeExceeded</summary>
            <unmanaged>D2DERR_MAX_TEXTURE_SIZE_EXCEEDED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.UnsupportedVersion">
            <summary>Constant UnsupportedVersion</summary>
            <unmanaged>D2DERR_UNSUPPORTED_VERSION</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.BadNumber">
            <summary>Constant BadNumber</summary>
            <unmanaged>D2DERR_BAD_NUMBER</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.WrongFactory">
            <summary>Constant WrongFactory</summary>
            <unmanaged>D2DERR_WRONG_FACTORY</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.LayerAlreadyInUse">
            <summary>Constant LayerAlreadyInUse</summary>
            <unmanaged>D2DERR_LAYER_ALREADY_IN_USE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.PopCallDidNotMatchPush">
            <summary>Constant PopCallDidNotMatchPush</summary>
            <unmanaged>D2DERR_POP_CALL_DID_NOT_MATCH_PUSH</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.WrongResourceDomain">
            <summary>Constant WrongResourceDomain</summary>
            <unmanaged>D2DERR_WRONG_RESOURCE_DOMAIN</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.PushPopUnbalanced">
            <summary>Constant PushPopUnbalanced</summary>
            <unmanaged>D2DERR_PUSH_POP_UNBALANCED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.RenderTargetHasLayerOrCliprect">
            <summary>Constant RenderTargetHasLayerOrCliprect</summary>
            <unmanaged>D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.IncompatibleBrushTypes">
            <summary>Constant IncompatibleBrushTypes</summary>
            <unmanaged>D2DERR_INCOMPATIBLE_BRUSH_TYPES</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.Win32Error">
            <summary>Constant Win32Error</summary>
            <unmanaged>D2DERR_WIN32_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.TargetNotGdiCompatible">
            <summary>Constant TargetNotGdiCompatible</summary>
            <unmanaged>D2DERR_TARGET_NOT_GDI_COMPATIBLE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.TextEffectIsWrongType">
            <summary>Constant TextEffectIsWrongType</summary>
            <unmanaged>D2DERR_TEXT_EFFECT_IS_WRONG_TYPE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.TextRendererNotReleased">
            <summary>Constant TextRendererNotReleased</summary>
            <unmanaged>D2DERR_TEXT_RENDERER_NOT_RELEASED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.ExceedsMaximumBitmapSize">
            <summary>Constant ExceedsMaximumBitmapSize</summary>
            <unmanaged>D2DERR_EXCEEDS_MAX_BITMAP_SIZE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InvalidGraphConfiguration">
            <summary>Constant InvalidGraphConfiguration</summary>
            <unmanaged>D2DERR_INVALID_GRAPH_CONFIGURATION</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InvalidInternalGraphConfiguration">
            <summary>Constant InvalidInternalGraphConfiguration</summary>
            <unmanaged>D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.CyclicGraph">
            <summary>Constant CyclicGraph</summary>
            <unmanaged>D2DERR_CYCLIC_GRAPH</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.BitmapCannotDraw">
            <summary>Constant BitmapCannotDraw</summary>
            <unmanaged>D2DERR_BITMAP_CANNOT_DRAW</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.OutstandingBitmapReferences">
            <summary>Constant OutstandingBitmapReferences</summary>
            <unmanaged>D2DERR_OUTSTANDING_BITMAP_REFERENCES</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.OriginalTargetNotBound">
            <summary>Constant OriginalTargetNotBound</summary>
            <unmanaged>D2DERR_ORIGINAL_TARGET_NOT_BOUND</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InvalidTarget">
            <summary>Constant InvalidTarget</summary>
            <unmanaged>D2DERR_INVALID_TARGET</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.BitmapBoundAsTarget">
            <summary>Constant BitmapBoundAsTarget</summary>
            <unmanaged>D2DERR_BITMAP_BOUND_AS_TARGET</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InsufficientDeviceCapabilities">
            <summary>Constant InsufficientDeviceCapabilities</summary>
            <unmanaged>D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.IntermediateTooLarge">
            <summary>Constant IntermediateTooLarge</summary>
            <unmanaged>D2DERR_INTERMEDIATE_TOO_LARGE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.EffectIsNotRegistered">
            <summary>Constant EffectIsNotRegistered</summary>
            <unmanaged>D2DERR_EFFECT_IS_NOT_REGISTERED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InvalidProperty">
            <summary>Constant InvalidProperty</summary>
            <unmanaged>D2DERR_INVALID_PROPERTY</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.NoSubProperties">
            <summary>Constant NoSubProperties</summary>
            <unmanaged>D2DERR_NO_SUBPROPERTIES</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.PrintJobClosed">
            <summary>Constant PrintJobClosed</summary>
            <unmanaged>D2DERR_PRINT_JOB_CLOSED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.PrintFormatNotSupported">
            <summary>Constant PrintFormatNotSupported</summary>
            <unmanaged>D2DERR_PRINT_FORMAT_NOT_SUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.TooManyTransformInputs">
            <summary>Constant TooManyTransformInputs</summary>
            <unmanaged>D2DERR_TOO_MANY_TRANSFORM_INPUTS</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InvalidGlyphImage">
            <summary>Constant InvalidGlyphImage</summary>
            <unmanaged>D2DERR_INVALID_GLYPH_IMAGE</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.UnsupportedPixelFormat">
            <summary>Constant UnsupportedPixelFormat</summary>
            <unmanaged>D2DERR_UNSUPPORTED_PIXEL_FORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.InsufficientBuffer">
            <summary>Constant InsufficientBuffer</summary>
            <unmanaged>D2DERR_INSUFFICIENT_BUFFER</unmanaged>
        </member>
        <member name="F:SharpDX.Direct2D1.ResultCode.FileNotFound">
            <summary>Constant FileNotFound</summary>
            <unmanaged>D2DERR_FILE_NOT_FOUND</unmanaged>
        </member>
        <member name="P:SharpDX.Direct2D1.Brush.Opacity">
            <summary>
            <p>Gets or sets the degree of opacity of this brush.   </p>
            </summary>
            <doc-id>dd371176</doc-id>
            <unmanaged>GetOpacity / SetOpacity</unmanaged>
            <unmanaged-short>GetOpacity</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Brush.Transform">
            <summary>
            <p>Gets or sets the transform applied to this brush. </p>
            </summary>
            <remarks>
            <p>When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.</p>
            </remarks>
            <doc-id>dd371179</doc-id>
            <unmanaged>GetTransform / SetTransform</unmanaged>
            <unmanaged-short>GetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Brush.SetOpacity(System.Single)">
            <summary>
            <p>Sets the degree of opacity of this brush.</p>
            </summary>
            <param name = "opacity"><dd>  <p>A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </p> </dd></param>
            <doc-id>dd371181</doc-id>
            <unmanaged>void ID2D1Brush::SetOpacity([In] float opacity)</unmanaged>
            <unmanaged-short>ID2D1Brush::SetOpacity</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Brush.SetTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p> Sets the transformation applied to the brush.</p>
            </summary>
            <param name = "transform"><dd>  <p>The transformation to apply to this brush.</p> </dd></param>
            <remarks>
            <p>When you paint with a brush, it paints in the coordinate space of the render target. Brushes do not automatically position themselves to align with the object being painted; by default, they begin painting at the origin (0, 0) of the render target. </p><p>You can "move" the gradient defined by an <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrush"/></strong> to a target area by setting its start point and end point. Likewise, you can move the gradient defined by an <strong><see cref = "T:SharpDX.Direct2D1.RadialGradientBrush"/></strong> by changing its center and radii. </p><p>To align the content of an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> to the area being painted, you can use the <strong>SetTransform</strong> method to translate the bitmap to the desired location. This transform only affects the brush; it does not affect any other content drawn by the render target. </p><p>The following illustrations show the effect of using an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> to fill a rectangle located at (100, 100). The illustration on the left illustration shows the result of filling the rectangle without transforming the brush: the bitmap is drawn at the render target's origin. As a result, only a portion of the bitmap appears in the rectangle.</p><p>The illustration on the right shows the result of transforming the <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong> so that its content is shifted 50 pixels to the right and 50 pixels down. The bitmap now fills the rectangle.</p><p></p>
            </remarks>
            <doc-id>dd371186</doc-id>
            <unmanaged>void ID2D1Brush::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1Brush::SetTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Brush.GetOpacity">
            <summary>
            <p>Gets the degree of opacity of this brush.   </p>
            </summary>
            <returns><p>A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </p></returns>
            <doc-id>dd371176</doc-id>
            <unmanaged>float ID2D1Brush::GetOpacity()</unmanaged>
            <unmanaged-short>ID2D1Brush::GetOpacity</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Brush.GetTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Gets the transform applied to this brush. </p>
            </summary>
            <param name = "transform"><dd>  <p>The transform applied to this brush.</p> </dd></param>
            <remarks>
            <p>When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.</p>
            </remarks>
            <doc-id>dd371179</doc-id>
            <unmanaged>void ID2D1Brush::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
            <unmanaged-short>ID2D1Brush::GetTransform</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.ConcreteTransform.Cached">
            <summary>
            <p>Sets whether the output of the specified transform is cached.</p>
            </summary>
            <doc-id>hh404454</doc-id>
            <unmanaged>SetCached</unmanaged>
            <unmanaged-short>SetCached</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ConcreteTransform.SetOutputBuffer(SharpDX.Direct2D1.BufferPrecision,SharpDX.Direct2D1.ChannelDepth)">
            <summary>
            <p>Sets the properties of the output buffer of the specified transform node.</p>
            </summary>
            <param name = "bufferPrecision"><dd>  <p>The number of bits and the type of the output buffer.</p> </dd></param>
            <param name = "channelDepth"><dd>  <p>The number of channels in the output buffer (1 or 4).</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>You can use the <strong>ID2D1EffectContext::IsBufferPrecisionSupported</strong> method to see if buffer precision is supported.</p><p>The available channel depth and precision depend on the capabilities of the underlying Microsoft Direct3D device.</p>
            </remarks>
            <doc-id>hh404456</doc-id>
            <unmanaged>HRESULT ID2D1ConcreteTransform::SetOutputBuffer([In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_CHANNEL_DEPTH channelDepth)</unmanaged>
            <unmanaged-short>ID2D1ConcreteTransform::SetOutputBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.ConcreteTransform.SetCached(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Sets whether the output of the specified transform is cached.</p>
            </summary>
            <param name = "isCached"><dd>  <p><strong>TRUE</strong> if the output should be cached; otherwise,  <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <doc-id>hh404454</doc-id>
            <unmanaged>void ID2D1ConcreteTransform::SetCached([In] BOOL isCached)</unmanaged>
            <unmanaged-short>ID2D1ConcreteTransform::SetCached</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext1.CreateLookupTable3D(SharpDX.Direct2D1.BufferPrecision,System.Int32[],System.Byte[],System.Int32,System.Int32[],SharpDX.Direct2D1.LookupTable3D@)">
            <summary>
            <p>Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output. The table data must be provided in 4-channel format.</p>
            </summary>
            <param name = "precision"><dd>  <p>Precision of the input lookup table data.</p> </dd></param>
            <param name = "extents"><dd>  <p>Number of lookup table elements per dimension (X, Y, Z).</p> </dd></param>
            <param name = "data"><dd>  <p>Buffer holding the lookup table data.</p> </dd></param>
            <param name = "dataCount"><dd>  <p>Size of the lookup table data buffer.</p> </dd></param>
            <param name = "strides"><dd>  <p>An array containing two values. The first value is the size in bytes from one row (X dimension) of LUT data to the next.  The second value is the size in bytes from one LUT data plane (X and Y dimensions) to the next.</p> </dd></param>
            <param name = "lookupTable"><dd>  <p>Receives the new lookup table instance.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn949339</doc-id>
            <unmanaged>HRESULT ID2D1EffectContext1::CreateLookupTable3D([In] D2D1_BUFFER_PRECISION precision,[In, Buffer] const unsigned int* extents,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount,[In, Buffer] const unsigned int* strides,[Out] ID2D1LookupTable3D** lookupTable)</unmanaged>
            <unmanaged-short>ID2D1EffectContext1::CreateLookupTable3D</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext2.CreateColorContextFromDxgiColorSpace(SharpDX.DXGI.ColorSpaceType,SharpDX.Direct2D1.ColorContext1)">
            <summary>
            No documentation.
            </summary>
            <param name = "colorSpace">No documentation.</param>
            <param name = "colorContext">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1EffectContext2::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
            <unmanaged-short>ID2D1EffectContext2::CreateColorContextFromDxgiColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.EffectContext2.CreateColorContextFromSimpleColorProfile(SharpDX.Direct2D1.SimpleColorProfile@,SharpDX.Direct2D1.ColorContext1)">
            <summary>
            No documentation.
            </summary>
            <param name = "simpleProfile">No documentation.</param>
            <param name = "colorContext">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1EffectContext2::CreateColorContextFromSimpleColorProfile([In] const D2D1_SIMPLE_COLOR_PROFILE* simpleProfile,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
            <unmanaged-short>ID2D1EffectContext2::CreateColorContextFromSimpleColorProfile</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory3.CreateDevice(SharpDX.DXGI.Device,SharpDX.Direct2D1.Device2)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.Device2"/></strong> object. </p>
            </summary>
            <param name = "dxgiDevice">No documentation.</param>
            <param name = "d2dDevice2">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900395</doc-id>
            <unmanaged>HRESULT ID2D1Factory3::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device2** d2dDevice2)</unmanaged>
            <unmanaged-short>ID2D1Factory3::CreateDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory4.CreateDevice(SharpDX.DXGI.Device,SharpDX.Direct2D1.Device3)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.Direct2D1.Device3"/></strong> object.</p>
            </summary>
            <param name = "dxgiDevice">No documentation.</param>
            <param name = "d2dDevice3">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt619832</doc-id>
            <unmanaged>HRESULT ID2D1Factory4::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device3** d2dDevice3)</unmanaged>
            <unmanaged-short>ID2D1Factory4::CreateDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory5.CreateDevice(SharpDX.DXGI.Device,SharpDX.Direct2D1.Device4)">
            <summary>
            <p> Creates an <strong><see cref = "T:SharpDX.Direct2D1.Device4"/></strong> object. </p>
            </summary>
            <param name = "dxgiDevice">No documentation.</param>
            <param name = "d2dDevice4">No documentation.</param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt750192</doc-id>
            <unmanaged>HRESULT ID2D1Factory5::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device4** d2dDevice4)</unmanaged>
            <unmanaged-short>ID2D1Factory5::CreateDevice</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Factory6.CreateDevice(SharpDX.DXGI.Device,SharpDX.Direct2D1.Device5)">
            <summary>
            <p>Creates Direct2D resources.</p>
            </summary>
            <param name = "dxgiDevice">No documentation.</param>
            <param name = "d2dDevice5">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> interface is the starting point for using Direct2D; it's what you use to create other Direct2D resources that you can use to draw or describe shapes.   </p><p>A factory defines a set of Create<em>Resource</em> methods that can produce the following drawing resources:</p><p> </p><ul> <li>Render targets: objects that render drawing commands.</li> <li>Drawing state blocks: objects that store drawing state information, such as the current transformation and antialiasing mode.</li> <li>Geometries: objects that represent simple and potentially complex shapes.</li> </ul><p>To create an <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong>, you use one of the <strong>CreateFactory</strong> methods. You should retain the <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> instance for as long as you use Direct2D resources; in general, you shouldn't need to recreate it when the application is running. For more information about Direct2D resources, see the Resources Overview.</p>
            </remarks>
            <doc-id>dd371246</doc-id>
            <unmanaged>HRESULT ID2D1Factory6::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device5** d2dDevice5)</unmanaged>
            <unmanaged-short>ID2D1Factory6::CreateDevice</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GdiMetafile.Bounds">
            <summary>
            <p> Gets the bounds of the metafile, in device-independent pixels (DIPs), as reported in the metafile?s header.</p>
            </summary>
            <doc-id>hh871463</doc-id>
            <unmanaged>GetBounds</unmanaged>
            <unmanaged-short>GetBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiMetafile.Stream(SharpDX.Direct2D1.GdiMetafileSink)">
            <summary>
            <p>This method streams the contents of the command  to the given metafile  sink. </p>
            </summary>
            <param name = "sink"><dd>  <p>The sink into which Direct2D  will call back.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <doc-id>hh871464</doc-id>
            <unmanaged>HRESULT ID2D1GdiMetafile::Stream([In] ID2D1GdiMetafileSink* sink)</unmanaged>
            <unmanaged-short>ID2D1GdiMetafile::Stream</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiMetafile.GetBounds(SharpDX.Mathematics.Interop.RawRectangleF@)">
            <summary>
            <p> Gets the bounds of the metafile, in device-independent pixels (DIPs), as reported in the metafile?s header.</p>
            </summary>
            <param name = "bounds"><dd>  <p>The bounds, in DIPs, of the metafile.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
            <doc-id>hh871463</doc-id>
            <unmanaged>HRESULT ID2D1GdiMetafile::GetBounds([Out] D2D_RECT_F* bounds)</unmanaged>
            <unmanaged-short>ID2D1GdiMetafile::GetBounds</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.GdiMetafile1.SourceBounds">
            <summary>
            <p>Gets the bounds of the metafile in source space in DIPs. This corresponds       to the frame rect in an EMF/EMF+.</p>
            </summary>
            <doc-id>dn900402</doc-id>
            <unmanaged>GetSourceBounds</unmanaged>
            <unmanaged-short>GetSourceBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiMetafile1.GetDpi(System.Single@,System.Single@)">
            <summary>
            <p>Gets the DPI reported by the metafile.</p>
            </summary>
            <param name = "dpiX"><dd>  <p>Receives the horizontal DPI reported by the metafile.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>Receives the vertical DPI reported by the metafile.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900401</doc-id>
            <unmanaged>HRESULT ID2D1GdiMetafile1::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
            <unmanaged-short>ID2D1GdiMetafile1::GetDpi</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiMetafile1.GetSourceBounds(SharpDX.Mathematics.Interop.RawRectangleF@)">
            <summary>
            <p>Gets the bounds of the metafile in source space in DIPs. This corresponds       to the frame rect in an EMF/EMF+.</p>
            </summary>
            <param name = "bounds"><dd>  <p>The bounds, in DIPs, of the metafile.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <doc-id>dn900402</doc-id>
            <unmanaged>HRESULT ID2D1GdiMetafile1::GetSourceBounds([Out] D2D_RECT_F* bounds)</unmanaged>
            <unmanaged-short>ID2D1GdiMetafile1::GetSourceBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiMetafileSink1Native.ProcessRecord_(System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            <p>Provides access to metafile records, including their type, data, and flags.</p>
            </summary>
            <param name = "recordType"><dd>  <p>The type of metafile record being processed. Please see MS-EMF and MS-EMFPLUS for a list of record types.</p> </dd></param>
            <param name = "recordData"><dd>  <p>The data contained in this record. Please see MS-EMF and MS-EMFPLUS for information on record data layouts.</p> </dd></param>
            <param name = "recordDataSize"><dd>  <p>TThe size of the data pointed to by recordData. </p> </dd></param>
            <param name = "flags"><dd>  <p>The set of flags set for this record. Please see MS-EMF and MS-EMFPLUS for information on record flags.</p> </dd></param>
            <returns><p><see cref = "F:SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "T:SharpDX.Result"/>.</p></returns>
            <remarks>
            <p>For details on the EMF and EMF+ formats, please see Microsoft technical documents  MS-EMF and MS-EMFPLUS.</p>
            </remarks>
            <doc-id>dn900404</doc-id>
            <unmanaged>HRESULT ID2D1GdiMetafileSink1::ProcessRecord([In] DWORD recordType,[In, Optional] const void* recordData,[In] DWORD recordDataSize,[In] unsigned int flags)</unmanaged>
            <unmanaged-short>ID2D1GdiMetafileSink1::ProcessRecord</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.GdiMetafileSinkNative.ProcessRecord_(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <p> This method is called once for each record stored in a metafile.</p>
            </summary>
            <param name = "recordType"><dd>  <p>The type of the record.</p> </dd></param>
            <param name = "recordData"><dd>  <p>The data for the record.</p> </dd></param>
            <param name = "recordDataSize"><dd>  <p>The byte size of the record data.</p> </dd></param>
            <returns><p>Return true if the record is successfully.</p></returns>
            <doc-id>hh871462</doc-id>
            <unmanaged>HRESULT ID2D1GdiMetafileSink::ProcessRecord([In] DWORD recordType,[In, Optional] const void* recordData,[In] DWORD recordDataSize)</unmanaged>
            <unmanaged-short>ID2D1GdiMetafileSink::ProcessRecord</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Multithread.MultithreadProtected">
            <summary>
            <p> Returns whether the Direct2D factory was created with the <strong>D2D1_FACTORY_TYPE_MULTI_THREADED</strong> flag. </p>
            </summary>
            <doc-id>hh997715</doc-id>
            <unmanaged>GetMultithreadProtected</unmanaged>
            <unmanaged-short>GetMultithreadProtected</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Multithread.GetMultithreadProtected">
            <summary>
            <p> Returns whether the Direct2D factory was created with the <strong>D2D1_FACTORY_TYPE_MULTI_THREADED</strong> flag. </p>
            </summary>
            <returns><p>Returns true if the Direct2D factory was created as multi-threaded, or false if it was created as single-threaded.</p></returns>
            <doc-id>hh997715</doc-id>
            <unmanaged>BOOL ID2D1Multithread::GetMultithreadProtected()</unmanaged>
            <unmanaged-short>ID2D1Multithread::GetMultithreadProtected</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Multithread.Enter">
            <summary>
            <p>Enters the Direct2D API critical section, if it exists. </p>
            </summary>
            <doc-id>hh997714</doc-id>
            <unmanaged>void ID2D1Multithread::Enter()</unmanaged>
            <unmanaged-short>ID2D1Multithread::Enter</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Multithread.Leave">
            <summary>
            <p>Leaves the Direct2D API critical section, if it exists.</p>
            </summary>
            <doc-id>hh997716</doc-id>
            <unmanaged>void ID2D1Multithread::Leave()</unmanaged>
            <unmanaged-short>ID2D1Multithread::Leave</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderInformation.Cached">
            <summary>
            <p>Specifies that the output of the transform in which the render information is encapsulated is or is not cached.</p>
            </summary>
            <doc-id>hh446891</doc-id>
            <unmanaged>SetCached</unmanaged>
            <unmanaged-short>SetCached</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.RenderInformation.InstructionCountHint">
            <summary>
            <p>Provides an estimated hint of shader execution cost to D2D.</p>
            </summary>
            <remarks>
            <p>The instruction count may be set according to the number of instructions in the shader.  This information is used as a hint when rendering extremely large images.  Calling this API is optional, but it may  improve performance if you provide an accurate number. </p><strong>Note</strong>??Instructions that occur in a loop should be counted according to the number of loop iterations.?
            </remarks>
            <doc-id>hh871466</doc-id>
            <unmanaged>SetInstructionCountHint</unmanaged>
            <unmanaged-short>SetInstructionCountHint</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderInformation.SetInputDescription(System.Int32,SharpDX.Direct2D1.InputDescription)">
            <summary>
            <p>Sets how a specific input to the transform should be handled by the renderer in terms of sampling.</p>
            </summary>
            <param name = "inputIndex"><dd>  <p>The index of the input that will have the input description applied.</p> </dd></param>
            <param name = "inputDescription"><dd>  <p>The description of the input to be applied to the transform.</p> </dd></param>
            <returns><p>The method returns an <see cref = "T:SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The input description must be matched correctly by the effect shader code.</p>
            </remarks>
            <doc-id>hh446892</doc-id>
            <unmanaged>HRESULT ID2D1RenderInfo::SetInputDescription([In] unsigned int inputIndex,[In] D2D1_INPUT_DESCRIPTION inputDescription)</unmanaged>
            <unmanaged-short>ID2D1RenderInfo::SetInputDescription</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderInformation.SetOutputBuffer(SharpDX.Direct2D1.BufferPrecision,SharpDX.Direct2D1.ChannelDepth)">
            <summary>
            <p>Allows a caller to control the output precision and channel-depth of the transform in which the render information is encapsulated.</p>
            </summary>
            <param name = "bufferPrecision"><dd>  <p>The type of buffer that should be used as an output from this transform.</p> </dd></param>
            <param name = "channelDepth"><dd>  <p>The number of channels that will be used on the output buffer. </p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If the output precision of the transform is not specified, then it will default to the precision specified on the Direct2D device context. The maximum of 16bpc <strong>UNORM</strong> and 16bpc <strong>FLOAT</strong> is 32bpc <strong>FLOAT</strong>.</p><p>The output channel depth will match the maximum of the input channel depths if the channel depth is <strong>D2D1_CHANNEL_DEPTH_DEFAULT</strong>.</p><p>There is no global output channel depth, this is always left to the control of the transforms. </p>
            </remarks>
            <doc-id>hh446893</doc-id>
            <unmanaged>HRESULT ID2D1RenderInfo::SetOutputBuffer([In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_CHANNEL_DEPTH channelDepth)</unmanaged>
            <unmanaged-short>ID2D1RenderInfo::SetOutputBuffer</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderInformation.SetCached(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Specifies that the output of the transform in which the render information is encapsulated is or is not cached.</p>
            </summary>
            <param name = "isCached"><dd>  <p><strong>TRUE</strong> if the output of the transform is cached; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <doc-id>hh446891</doc-id>
            <unmanaged>void ID2D1RenderInfo::SetCached([In] BOOL isCached)</unmanaged>
            <unmanaged-short>ID2D1RenderInfo::SetCached</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.RenderInformation.SetInstructionCountHint(System.Int32)">
            <summary>
            <p>Provides an estimated hint of shader execution cost to D2D.</p>
            </summary>
            <param name = "instructionCount"><dd>  <p>An approximate instruction count of the associated shader.</p> </dd></param>
            <remarks>
            <p>The instruction count may be set according to the number of instructions in the shader.  This information is used as a hint when rendering extremely large images.  Calling this API is optional, but it may  improve performance if you provide an accurate number. </p><strong>Note</strong>??Instructions that occur in a loop should be counted according to the number of loop iterations.?
            </remarks>
            <doc-id>hh871466</doc-id>
            <unmanaged>void ID2D1RenderInfo::SetInstructionCountHint([In] unsigned int instructionCount)</unmanaged>
            <unmanaged-short>ID2D1RenderInfo::SetInstructionCountHint</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.Resource.Factory">
            <summary>
            <p>Retrieves the factory associated with this resource.</p>
            </summary>
            <doc-id>dd316911</doc-id>
            <unmanaged>GetFactory</unmanaged>
            <unmanaged-short>GetFactory</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.Resource.GetFactory(SharpDX.Direct2D1.Factory@)">
            <summary>
            <p>Retrieves the factory associated with this resource.</p>
            </summary>
            <param name = "factory"><dd>  <p>When this method returns, contains a reference to a reference to the factory that created this resource. This parameter is passed uninitialized.</p> </dd></param>
            <doc-id>dd316911</doc-id>
            <unmanaged>void ID2D1Resource::GetFactory([Out] ID2D1Factory** factory)</unmanaged>
            <unmanaged-short>ID2D1Resource::GetFactory</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgGlyphStyle.Fill">
            <summary>
            <p>Returns or sets the requested fill parameters.</p>
            </summary>
            <doc-id>mt750194</doc-id>
            <unmanaged>GetFill / SetFill</unmanaged>
            <unmanaged-short>GetFill</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgGlyphStyle.StrokeDashesCount">
            <summary>
            <p>Returns the number of dashes in the dash array.</p>
            </summary>
            <doc-id>mt750196</doc-id>
            <unmanaged>GetStrokeDashesCount</unmanaged>
            <unmanaged-short>GetStrokeDashesCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgGlyphStyle.SetFill(SharpDX.Direct2D1.Brush)">
            <summary>
            <p>Provides values to an SVG glyph for fill.</p>
            </summary>
            <param name = "brush"><dd>  <p>Describes how the area is painted.  A null brush will cause the context-fill value to come from the <strong>defaultFillBrush</strong>. If the defaultFillBrush is also null, the context-fill value will be 'none'. To set the ?context-fill? value, this method uses the provided brush with its opacity set to 1. To set the ?context-fill-opacity? value, this method uses the opacity of the provided brush. </p> </dd></param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt750197</doc-id>
            <unmanaged>HRESULT ID2D1SvgGlyphStyle::SetFill([In, Optional] ID2D1Brush* brush)</unmanaged>
            <unmanaged-short>ID2D1SvgGlyphStyle::SetFill</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgGlyphStyle.GetFill(SharpDX.Direct2D1.Brush@)">
            <summary>
            <p>Returns the requested fill parameters.</p>
            </summary>
            <param name = "brush"><dd>  <p>Describes how the area is painted.</p> </dd></param>
            <doc-id>mt750194</doc-id>
            <unmanaged>void ID2D1SvgGlyphStyle::GetFill([Out, Optional] ID2D1Brush** brush)</unmanaged>
            <unmanaged-short>ID2D1SvgGlyphStyle::GetFill</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgGlyphStyle.SetStroke(SharpDX.Direct2D1.Brush,System.Single,System.Single[],System.Int32,System.Single)">
            <summary>
            <p>Provides values to an SVG glyph for stroke properties. The brush with opacity set to 1 is used as the 'context-stroke'. The opacity of the brush is used as the 'context-stroke-opacity' value.</p>
            </summary>
            <param name = "brush"><dd>  <p>Describes how the stroke is painted. A null brush will cause the context-stroke value to be none.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>Specifies the 'context-value' for the 'stroke-width' property.</p> </dd></param>
            <param name = "dashes"><dd>  <p>Specifies the 'context-value' for the 'stroke-dasharray' property. A null value will cause the stroke-dasharray to be set to 'none'.</p> </dd></param>
            <param name = "dashesCount"><dd>  <p>The the number of dashes in the dash array.</p> </dd></param>
            <param name = "dashOffset"><dd>  <p>Specifies the 'context-value' for the 'stroke-dashoffset' property.</p> </dd></param>
            <returns><p>This method returns an <see cref = "T:SharpDX.Result"/> success or error code.</p></returns>
            <doc-id>mt750198</doc-id>
            <unmanaged>HRESULT ID2D1SvgGlyphStyle::SetStroke([In, Optional] ID2D1Brush* brush,[In] float strokeWidth,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[In] float dashOffset)</unmanaged>
            <unmanaged-short>ID2D1SvgGlyphStyle::SetStroke</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgGlyphStyle.GetStrokeDashesCount">
            <summary>
            <p>Returns the number of dashes in the dash array.</p>
            </summary>
            <returns><p>Returns the number of dashes in the dash array.</p></returns>
            <doc-id>mt750196</doc-id>
            <unmanaged>unsigned int ID2D1SvgGlyphStyle::GetStrokeDashesCount()</unmanaged>
            <unmanaged-short>ID2D1SvgGlyphStyle::GetStrokeDashesCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgGlyphStyle.GetStroke(SharpDX.Direct2D1.Brush@,System.Single@,System.Single[],System.Int32,System.Single@)">
            <summary>
            <p>Returns the requested stroke parameters. Any parameters that are non-null will receive the value of the requested parameter. </p>
            </summary>
            <param name = "brush"><dd>  <p>Describes how the stroke is painted.</p> </dd></param>
            <param name = "strokeWidth"><dd>  <p>The 'context-value' for the 'stroke-width' property.</p> </dd></param>
            <param name = "dashes"><dd>  <p>The 'context-value' for the 'stroke-dasharray' property.</p> </dd></param>
            <param name = "dashesCount"><dd>  <p>The the number of dashes in the dash array.</p> </dd></param>
            <param name = "dashOffset"><dd>  <p>The 'context-value' for the 'stroke-dashoffset' property.</p> </dd></param>
            <doc-id>mt750195</doc-id>
            <unmanaged>void ID2D1SvgGlyphStyle::GetStroke([Out, Optional] ID2D1Brush** brush,[Out, Optional] float* strokeWidth,[Out, Buffer, Optional] float* dashes,[In] unsigned int dashesCount,[Out, Optional] float* dashOffset)</unmanaged>
            <unmanaged-short>ID2D1SvgGlyphStyle::GetStroke</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgPaint.PaintType">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetPaintType / SetPaintType</unmanaged>
            <unmanaged-short>GetPaintType</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgPaint.Color">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetColor / SetColor</unmanaged>
            <unmanaged-short>GetColor</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgPaint.IdLength">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetIdLength</unmanaged>
            <unmanaged-short>GetIdLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.SetPaintType(SharpDX.Direct2D1.SvgPaintType)">
            <summary>
            No documentation.
            </summary>
            <param name = "paintType">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPaint::SetPaintType([In] D2D1_SVG_PAINT_TYPE paintType)</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::SetPaintType</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.GetPaintType">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>D2D1_SVG_PAINT_TYPE ID2D1SvgPaint::GetPaintType()</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::GetPaintType</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.SetColor(SharpDX.Mathematics.Interop.RawColor4)">
            <summary>
            No documentation.
            </summary>
            <param name = "color">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPaint::SetColor([In] const D2D_COLOR_F* color)</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::SetColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.GetColor(SharpDX.Mathematics.Interop.RawColor4@)">
            <summary>
            No documentation.
            </summary>
            <param name = "color">No documentation.</param>
            <unmanaged>void ID2D1SvgPaint::GetColor([Out] D2D_COLOR_F* color)</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::GetColor</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.SetId(System.String)">
            <summary>
            No documentation.
            </summary>
            <param name = "id">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPaint::SetId([In] const wchar_t* id)</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::SetId</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.GetId(System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "id">No documentation.</param>
            <param name = "idCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPaint::GetId([Out, Buffer] wchar_t* id,[In] unsigned int idCount)</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::GetId</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPaint.GetIdLength">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgPaint::GetIdLength()</unmanaged>
            <unmanaged-short>ID2D1SvgPaint::GetIdLength</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgPathData.SegmentDataCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetSegmentDataCount</unmanaged>
            <unmanaged-short>GetSegmentDataCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgPathData.CommandsCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetCommandsCount</unmanaged>
            <unmanaged-short>GetCommandsCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.RemoveSegmentDataAtEnd(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dataCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::RemoveSegmentDataAtEnd([In] unsigned int dataCount)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::RemoveSegmentDataAtEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.UpdateSegmentData(System.Single[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "data">No documentation.</param>
            <param name = "dataCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::UpdateSegmentData([In, Buffer] const float* data,[In] unsigned int dataCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::UpdateSegmentData</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.GetSegmentData(System.Single[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "data">No documentation.</param>
            <param name = "dataCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::GetSegmentData([Out, Buffer] float* data,[In] unsigned int dataCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::GetSegmentData</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.GetSegmentDataCount">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgPathData::GetSegmentDataCount()</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::GetSegmentDataCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.RemoveCommandsAtEnd(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "commandsCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::RemoveCommandsAtEnd([In] unsigned int commandsCount)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::RemoveCommandsAtEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.UpdateCommands(SharpDX.Direct2D1.SvgPathCommand[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "commands">No documentation.</param>
            <param name = "commandsCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::UpdateCommands([In, Buffer] const D2D1_SVG_PATH_COMMAND* commands,[In] unsigned int commandsCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::UpdateCommands</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.GetCommands(SharpDX.Direct2D1.SvgPathCommand[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "commands">No documentation.</param>
            <param name = "commandsCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::GetCommands([Out, Buffer] D2D1_SVG_PATH_COMMAND* commands,[In] unsigned int commandsCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::GetCommands</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.GetCommandsCount">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgPathData::GetCommandsCount()</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::GetCommandsCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPathData.CreatePathGeometry(SharpDX.Direct2D1.FillMode,SharpDX.Direct2D1.PathGeometry1@)">
            <summary>
            No documentation.
            </summary>
            <param name = "fillMode">No documentation.</param>
            <param name = "athGeometryRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPathData::CreatePathGeometry([In] D2D1_FILL_MODE fillMode,[Out] ID2D1PathGeometry1** pathGeometry)</unmanaged>
            <unmanaged-short>ID2D1SvgPathData::CreatePathGeometry</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgPointCollection.PointsCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetPointsCount</unmanaged>
            <unmanaged-short>GetPointsCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPointCollection.RemovePointsAtEnd(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "pointsCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPointCollection::RemovePointsAtEnd([In] unsigned int pointsCount)</unmanaged>
            <unmanaged-short>ID2D1SvgPointCollection::RemovePointsAtEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPointCollection.UpdatePoints(SharpDX.Mathematics.Interop.RawVector2[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "ointsRef">No documentation.</param>
            <param name = "pointsCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPointCollection::UpdatePoints([In, Buffer] const D2D_POINT_2F* points,[In] unsigned int pointsCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgPointCollection::UpdatePoints</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPointCollection.GetPoints(SharpDX.Mathematics.Interop.RawVector2[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "ointsRef">No documentation.</param>
            <param name = "pointsCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgPointCollection::GetPoints([Out, Buffer] D2D_POINT_2F* points,[In] unsigned int pointsCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgPointCollection::GetPoints</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgPointCollection.GetPointsCount">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgPointCollection::GetPointsCount()</unmanaged>
            <unmanaged-short>ID2D1SvgPointCollection::GetPointsCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.SvgStrokeDashArray.DashesCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetDashesCount</unmanaged>
            <unmanaged-short>GetDashesCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgStrokeDashArray.RemoveDashesAtEnd(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dashesCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgStrokeDashArray::RemoveDashesAtEnd([In] unsigned int dashesCount)</unmanaged>
            <unmanaged-short>ID2D1SvgStrokeDashArray::RemoveDashesAtEnd</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgStrokeDashArray.UpdateDashes(SharpDX.Direct2D1.SvgLength[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgStrokeDashArray::UpdateDashes([In, Buffer] const D2D1_SVG_LENGTH* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgStrokeDashArray::UpdateDashes</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgStrokeDashArray.UpdateDashes(System.Single[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgStrokeDashArray::UpdateDashes([In, Buffer] const float* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgStrokeDashArray::UpdateDashes</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgStrokeDashArray.GetDashes(SharpDX.Direct2D1.SvgLength[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgStrokeDashArray::GetDashes([Out, Buffer] D2D1_SVG_LENGTH* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgStrokeDashArray::GetDashes</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgStrokeDashArray.GetDashes(System.Single[],System.Int32,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "dashes">No documentation.</param>
            <param name = "dashesCount">No documentation.</param>
            <param name = "startIndex">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT ID2D1SvgStrokeDashArray::GetDashes([Out, Buffer] float* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
            <unmanaged-short>ID2D1SvgStrokeDashArray::GetDashes</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.SvgStrokeDashArray.GetDashesCount">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int ID2D1SvgStrokeDashArray::GetDashesCount()</unmanaged>
            <unmanaged-short>ID2D1SvgStrokeDashArray::GetDashesCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.Direct2D1.TransformGraph.InputCount">
            <summary>
            <p>Returns the number of inputs to the transform graph.</p>
            </summary>
            <doc-id>hh871467</doc-id>
            <unmanaged>GetInputCount</unmanaged>
            <unmanaged-short>GetInputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.GetInputCount">
            <summary>
            <p>Returns the number of inputs to the transform graph.</p>
            </summary>
            <returns><p>The number of inputs to this transform graph.</p></returns>
            <doc-id>hh871467</doc-id>
            <unmanaged>unsigned int ID2D1TransformGraph::GetInputCount()</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::GetInputCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.SetSingleTransformNode(SharpDX.Direct2D1.TransformNode)">
            <summary>
            <p>Sets a single transform node as being equivalent to the whole graph.</p>
            </summary>
            <param name = "node"><dd>  <p>The node to be set.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This equivalent to calling <strong>ID2D1TransformGraph::Clear</strong>, adding a single node, connecting all of the node inputs to the effect inputs in order, and setting the transform not as the graph output.</p>
            </remarks>
            <doc-id>hh446935</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::SetSingleTransformNode([In] ID2D1TransformNode* node)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::SetSingleTransformNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.AddNode(SharpDX.Direct2D1.TransformNode)">
            <summary>
            <p>Adds the provided node to the transform graph.</p>
            </summary>
            <param name = "node"><dd>  <p>The node that will be added to the transform graph.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>This adds a transform node to the transform graph. A node must be added to the transform graph before it can be interconnected in any way.
            </p><p>A transform graph cannot be directly added to another transform graph. 
            Only interfaces derived from <strong><see cref = "T:SharpDX.Direct2D1.TransformNode"/></strong> can be added to the transform graph.
            </p>
            </remarks>
            <doc-id>hh446922</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::AddNode([In] ID2D1TransformNode* node)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::AddNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.RemoveNode(SharpDX.Direct2D1.TransformNode)">
            <summary>
            <p>Removes the provided node from the transform graph.</p>
            </summary>
            <param name = "node"><dd>  <p>The node that will be removed from the transform graph.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The node must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p><p>Any connections to this node will be removed when the node is removed.</p><p>After the node is removed, it cannot be used by the interface until it has been added to the graph by <strong>AddNode</strong>.</p>
            </remarks>
            <doc-id>hh446931</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::RemoveNode([In] ID2D1TransformNode* node)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::RemoveNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.SetOutputNode(SharpDX.Direct2D1.TransformNode)">
            <summary>
            <p>Sets the output node for the transform graph.</p>
            </summary>
            <param name = "node"><dd>  <p>The node that will be considered the output of the transform node.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The node must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p>
            </remarks>
            <doc-id>hh446932</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::SetOutputNode([In] ID2D1TransformNode* node)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::SetOutputNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.ConnectNode(SharpDX.Direct2D1.TransformNode,SharpDX.Direct2D1.TransformNode,System.Int32)">
            <summary>
            <p>Connects two nodes inside the transform graph.</p>
            </summary>
            <param name = "fromNode"><dd>  <p>The node from which the connection will be made.</p> </dd></param>
            <param name = "toNode"><dd>  <p>The node to which the connection will be made.</p> </dd></param>
            <param name = "toNodeInputIndex"><dd>  <p>The node input that will be connected.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Both nodes must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p>
            </remarks>
            <doc-id>hh446926</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::ConnectNode([In] ID2D1TransformNode* fromNode,[In] ID2D1TransformNode* toNode,[In] unsigned int toNodeInputIndex)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::ConnectNode</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.ConnectToEffectInput(System.Int32,SharpDX.Direct2D1.TransformNode,System.Int32)">
            <summary>
            <p>Connects a transform node inside the graph to the corresponding effect input of the encapsulating effect.</p>
            </summary>
            <param name = "toEffectInputIndex"><dd>  <p>The effect input to which the transform node will be bound.</p> </dd></param>
            <param name = "node"><dd>  <p>The node to which the connection will be made.</p> </dd></param>
            <param name = "toNodeInputIndex"><dd>  <p>The node input that will be connected.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
            <doc-id>hh446928</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::ConnectToEffectInput([In] unsigned int toEffectInputIndex,[In] ID2D1TransformNode* node,[In] unsigned int toNodeInputIndex)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::ConnectToEffectInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.Clear">
            <summary>
            <p>Clears the transform nodes and all connections from the transform graph.</p>
            </summary>
            <remarks>
            <p>Used when enough changes to transfoms would make  editing of the transform graph inefficient.</p>
            </remarks>
            <doc-id>hh446924</doc-id>
            <unmanaged>void ID2D1TransformGraph::Clear()</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::Clear</unmanaged-short>
        </member>
        <member name="M:SharpDX.Direct2D1.TransformGraph.SetPassthroughGraph(System.Int32)">
            <summary>
            <p>Uses the specified input as the effect output.</p>
            </summary>
            <param name = "effectInputIndex"><dd> <p>The index of the input to the effect.</p> </dd></param>
            <returns><p>The method returns an <strong><see cref = "T:SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "T:SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "F:SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
            <doc-id>hh997720</doc-id>
            <unmanaged>HRESULT ID2D1TransformGraph::SetPassthroughGraph([In] unsigned int effectInputIndex)</unmanaged>
            <unmanaged-short>ID2D1TransformGraph::SetPassthroughGraph</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ArcSegment">
            <summary>
            <p>Describes an elliptical arc between two points.</p>
            </summary>
            <doc-id>dd368065</doc-id>
            <unmanaged>D2D1_ARC_SEGMENT</unmanaged>
            <unmanaged-short>D2D1_ARC_SEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSegment.Point">
            <summary>
            <dd> <p>The end point of the arc.</p> </dd>
            </summary>
            <doc-id>dd368065</doc-id>
            <unmanaged>point</unmanaged>
            <unmanaged-short>point</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSegment.Size">
            <summary>
            <dd> <p>The x-radius and y-radius of the arc.</p> </dd>
            </summary>
            <doc-id>dd368065</doc-id>
            <unmanaged>size</unmanaged>
            <unmanaged-short>size</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSegment.RotationAngle">
            <summary>
            <dd> <p>A value that specifies how many degrees in the clockwise direction the ellipse is rotated relative to the current coordinate system.</p> </dd>
            </summary>
            <doc-id>dd368065</doc-id>
            <unmanaged>rotationAngle</unmanaged>
            <unmanaged-short>rotationAngle</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSegment.SweepDirection">
            <summary>
            <dd> <p>A value that specifies whether the arc sweep is clockwise or counterclockwise.</p> </dd>
            </summary>
            <doc-id>dd368065</doc-id>
            <unmanaged>sweepDirection</unmanaged>
            <unmanaged-short>sweepDirection</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ArcSegment.ArcSize">
            <summary>
            <dd> <p>A value that specifies whether the given arc is larger than 180 degrees.</p> </dd>
            </summary>
            <doc-id>dd368065</doc-id>
            <unmanaged>arcSize</unmanaged>
            <unmanaged-short>arcSize</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BezierSegment">
            <summary>
            <p>Represents a cubic bezier segment drawn  between two points.</p>
            </summary>
            <remarks>
            <p> A cubic Bezier curve is defined by four points: a start point, an end point (<em>point3</em>), and two control points (<em>point1</em> and <em>point2</em>). A Bezier segment does not contain a property for the starting point of the curve; it defines only the end point. The beginning point of the curve is the current point of the path to which the Bezier curve is added.</p><p> The two control points of a cubic Bezier curve behave like magnets, attracting portions of what would otherwise be a straight line toward themselves and producing a curve. The first control point, <em>point1</em>, affects the beginning portion of the curve; the second control point, <em>point2</em>, affects the ending portion of the curve. </p><strong>Note</strong>??The curve doesn't necessarily pass through either of the control points; each control point moves its portion of the line toward itself, but not through itself.?
            </remarks>
            <doc-id>dd368070</doc-id>
            <unmanaged>D2D1_BEZIER_SEGMENT</unmanaged>
            <unmanaged-short>D2D1_BEZIER_SEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BezierSegment.Point1">
            <summary>
            <dd> <p>The first control point for the Bezier segment.</p> </dd>
            </summary>
            <doc-id>dd368070</doc-id>
            <unmanaged>point1</unmanaged>
            <unmanaged-short>point1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BezierSegment.Point2">
            <summary>
            <dd> <p>The second control point for the Bezier segment.</p> </dd>
            </summary>
            <doc-id>dd368070</doc-id>
            <unmanaged>point2</unmanaged>
            <unmanaged-short>point2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BezierSegment.Point3">
            <summary>
            <dd> <p>The end point for the Bezier segment.</p> </dd>
            </summary>
            <doc-id>dd368070</doc-id>
            <unmanaged>point3</unmanaged>
            <unmanaged-short>point3</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapBrushProperties">
            <summary>
            <p> Describes the extend modes and the interpolation mode of an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong>.</p>
            </summary>
            <doc-id>dd368071</doc-id>
            <unmanaged>D2D1_BITMAP_BRUSH_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_BITMAP_BRUSH_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapBrushProperties.ExtendModeX">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368071</doc-id>
            <unmanaged>extendModeX</unmanaged>
            <unmanaged-short>extendModeX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapBrushProperties.ExtendModeY">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368071</doc-id>
            <unmanaged>extendModeY</unmanaged>
            <unmanaged-short>extendModeY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapBrushProperties.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368071</doc-id>
            <unmanaged>interpolationMode</unmanaged>
            <unmanaged-short>interpolationMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BitmapBrushProperties1">
            <summary>
            <p> Describes the extend modes and the interpolation mode of an <strong><see cref = "T:SharpDX.Direct2D1.BitmapBrush"/></strong>.</p>
            </summary>
            <doc-id>hh847943</doc-id>
            <unmanaged>D2D1_BITMAP_BRUSH_PROPERTIES1</unmanaged>
            <unmanaged-short>D2D1_BITMAP_BRUSH_PROPERTIES1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapBrushProperties1.ExtendModeX">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh847943</doc-id>
            <unmanaged>extendModeX</unmanaged>
            <unmanaged-short>extendModeX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapBrushProperties1.ExtendModeY">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh847943</doc-id>
            <unmanaged>extendModeY</unmanaged>
            <unmanaged-short>extendModeY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BitmapBrushProperties1.InterpolationMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh847943</doc-id>
            <unmanaged>interpolationMode</unmanaged>
            <unmanaged-short>interpolationMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BlendDescription">
            <summary>
            <p>Defines a blend description to be used in a particular blend transform.</p>
            </summary>
            <remarks>
            <p>This description closely matches the <strong><see cref = "!:SharpDX.Direct3D11.BlendStateDescription"/></strong> struct with some omissions and the addition of the blend factor in the description.</p>
            </remarks>
            <doc-id>hh404277</doc-id>
            <unmanaged>D2D1_BLEND_DESCRIPTION</unmanaged>
            <unmanaged-short>D2D1_BLEND_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.SourceBlend">
            <summary>
            <dd> <p>Specifies the first RGB data source and includes an optional preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>sourceBlend</unmanaged>
            <unmanaged-short>sourceBlend</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.DestinationBlend">
            <summary>
            <dd> <p>Specifies the second RGB data source and includes an optional preblend operation.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>destinationBlend</unmanaged>
            <unmanaged-short>destinationBlend</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.BlendOperation">
            <summary>
            <dd> <p>Specifies how to combine the RGB data sources.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>blendOperation</unmanaged>
            <unmanaged-short>blendOperation</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.SourceBlendAlpha">
            <summary>
            <dd> <p>Specifies the first alpha data source and includes an optional preblend operation. Blend options that end in _COLOR are not allowed.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>sourceBlendAlpha</unmanaged>
            <unmanaged-short>sourceBlendAlpha</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.DestinationBlendAlpha">
            <summary>
            <dd> <p>Specifies the second alpha data source and includes an optional preblend operation. Blend options that end in _COLOR are not allowed.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>destinationBlendAlpha</unmanaged>
            <unmanaged-short>destinationBlendAlpha</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.BlendOperationAlpha">
            <summary>
            <dd> <p>Specifies how to combine the alpha data sources.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>blendOperationAlpha</unmanaged>
            <unmanaged-short>blendOperationAlpha</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BlendDescription.BlendFactor">
            <summary>
            <dd> <p>Parameters to the blend operations. The blend must use <strong>D2D1_BLEND_BLEND_FACTOR</strong> for this to be used.</p> </dd>
            </summary>
            <doc-id>hh404277</doc-id>
            <unmanaged>blendFactor</unmanaged>
            <unmanaged-short>blendFactor</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.BrushProperties">
            <summary>
            <p> Describes the opacity and transformation of a brush.</p>
            </summary>
            <remarks>
            <p>This structure is used when creating a brush. For convenience, Direct2D provides the <strong>D2D1::BrushProperties</strong> function for creating <strong><see cref = "T:SharpDX.Direct2D1.BrushProperties"/></strong> structures.</p><p>After creating a brush, you can change its opacity or transform by calling the <strong>SetOpacity</strong> or <strong>SetTransform</strong> methods.</p>
            </remarks>
            <doc-id>dd368077</doc-id>
            <unmanaged>D2D1_BRUSH_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_BRUSH_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BrushProperties.Opacity">
            <summary>
            <dd> <p>A value between 0.0f and 1.0f, inclusive, that specifies the degree of opacity of the brush.</p> </dd>
            </summary>
            <doc-id>dd368077</doc-id>
            <unmanaged>opacity</unmanaged>
            <unmanaged-short>opacity</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.BrushProperties.Transform">
            <summary>
            <dd> <p>The transformation that is applied to the brush.</p> </dd>
            </summary>
            <doc-id>dd368077</doc-id>
            <unmanaged>transform</unmanaged>
            <unmanaged-short>transform</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.CreationProperties">
            <summary>
            <p>Specifies the options with which the Direct2D device, factory, and device context are created.
            </p>
            </summary>
            <remarks>
            <p>The root objects referred to here are the Direct2D device, Direct2D factory and the Direct2D device context.
            </p>
            </remarks>
            <doc-id>hh404298</doc-id>
            <unmanaged>D2D1_CREATION_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_CREATION_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CreationProperties.ThreadingMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404298</doc-id>
            <unmanaged>threadingMode</unmanaged>
            <unmanaged-short>threadingMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CreationProperties.DebugLevel">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404298</doc-id>
            <unmanaged>debugLevel</unmanaged>
            <unmanaged-short>debugLevel</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.CreationProperties.Options">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404298</doc-id>
            <unmanaged>options</unmanaged>
            <unmanaged-short>options</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DrawingStateDescription">
            <summary>
            <p>Describes the drawing state of a render target.  </p>
            </summary>
            <doc-id>dd368093</doc-id>
            <unmanaged>D2D1_DRAWING_STATE_DESCRIPTION</unmanaged>
            <unmanaged-short>D2D1_DRAWING_STATE_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription.AntialiasMode">
            <summary>
            <dd> <p>The antialiasing mode for subsequent nontext drawing operations. </p> </dd>
            </summary>
            <doc-id>dd368093</doc-id>
            <unmanaged>antialiasMode</unmanaged>
            <unmanaged-short>antialiasMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription.TextAntialiasMode">
            <summary>
            <dd> <p>The antialiasing mode for subsequent text and glyph drawing operations.</p> </dd>
            </summary>
            <doc-id>dd368093</doc-id>
            <unmanaged>textAntialiasMode</unmanaged>
            <unmanaged-short>textAntialiasMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription.Tag1">
            <summary>
            <dd> <p>A label for subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>dd368093</doc-id>
            <unmanaged>tag1</unmanaged>
            <unmanaged-short>tag1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription.Tag2">
            <summary>
            <dd> <p>A label for subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>dd368093</doc-id>
            <unmanaged>tag2</unmanaged>
            <unmanaged-short>tag2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription.Transform">
            <summary>
            <dd> <p>The transformation to apply to subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>dd368093</doc-id>
            <unmanaged>transform</unmanaged>
            <unmanaged-short>transform</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.DrawingStateDescription1">
            <summary>
            <p>Describes the drawing state of a device context.</p>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>D2D1_DRAWING_STATE_DESCRIPTION1</unmanaged>
            <unmanaged-short>D2D1_DRAWING_STATE_DESCRIPTION1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.AntialiasMode">
            <summary>
            <dd> <p>The antialiasing mode for subsequent nontext drawing operations. </p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>antialiasMode</unmanaged>
            <unmanaged-short>antialiasMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.TextAntialiasMode">
            <summary>
            <dd> <p>The antialiasing mode for subsequent text and glyph drawing operations.</p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>textAntialiasMode</unmanaged>
            <unmanaged-short>textAntialiasMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.Tag1">
            <summary>
            <dd> <p>A label for subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>tag1</unmanaged>
            <unmanaged-short>tag1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.Tag2">
            <summary>
            <dd> <p>A label for subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>tag2</unmanaged>
            <unmanaged-short>tag2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.Transform">
            <summary>
            <dd> <p>The transformation to apply to subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>transform</unmanaged>
            <unmanaged-short>transform</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.PrimitiveBlend">
            <summary>
            <dd> <p>The blend mode for the device context to apply to subsequent drawing operations.</p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>primitiveBlend</unmanaged>
            <unmanaged-short>primitiveBlend</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.DrawingStateDescription1.UnitMode">
            <summary>
            <dd> <p><see cref = "T:SharpDX.Direct2D1.UnitMode"/></p> </dd>
            </summary>
            <doc-id>hh847946</doc-id>
            <unmanaged>unitMode</unmanaged>
            <unmanaged-short>unitMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.EffectInputDescription">
            <summary>
            <p>Describes features of an effect.</p>
            </summary>
            <remarks>
            <strong>Note</strong>??The caller should not rely heavily on the input rectangles returned by this structure. They can change due to subtle changes in effect implementations and due to optimization changes in the effect rendering system.?
            </remarks>
            <doc-id>hh404305</doc-id>
            <unmanaged>D2D1_EFFECT_INPUT_DESCRIPTION</unmanaged>
            <unmanaged-short>D2D1_EFFECT_INPUT_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EffectInputDescription.Effect">
            <summary>
            <dd> <p>The effect whose input connection is being specified.</p> </dd>
            </summary>
            <doc-id>hh404305</doc-id>
            <unmanaged>effect</unmanaged>
            <unmanaged-short>effect</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EffectInputDescription.InputIndex">
            <summary>
            <dd> <p>The input index of the effect that is being considered.</p> </dd>
            </summary>
            <doc-id>hh404305</doc-id>
            <unmanaged>inputIndex</unmanaged>
            <unmanaged-short>inputIndex</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.EffectInputDescription.InputRectangle">
            <summary>
            <dd> <p>The amount of data that would be available on the input. This can be used to query this information when the data is not yet available. </p> </dd>
            </summary>
            <doc-id>hh404305</doc-id>
            <unmanaged>inputRectangle</unmanaged>
            <unmanaged-short>inputRectangle</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FactoryOptions">
            <summary>
            <p>Contains the debugging level of an <strong><see cref = "T:SharpDX.Direct2D1.Factory"/></strong> object. </p>
            </summary>
            <remarks>
            <p>To enable debugging, you must install the Direct2D Debug Layer.</p>
            </remarks>
            <doc-id>dd368102</doc-id>
            <unmanaged>D2D1_FACTORY_OPTIONS</unmanaged>
            <unmanaged-short>D2D1_FACTORY_OPTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FactoryOptions.DebugLevel">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368102</doc-id>
            <unmanaged>debugLevel</unmanaged>
            <unmanaged-short>debugLevel</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FeatureDataD3D10XHardwareOptions">
            <summary>
            <p>Describes compute shader support, which is an option on D3D10 feature level.</p>
            </summary>
            <remarks>
            <p>You can fill this structure by passing a D2D1_ FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS structure to <strong>ID2D1EffectContext::CheckFeatureSupport</strong>.</p>
            </remarks>
            <doc-id>hh871446</doc-id>
            <unmanaged>D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS</unmanaged>
            <unmanaged-short>D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FeatureDataD3D10XHardwareOptions.ComputeShadersPlusRawAndStructuredBuffersViaShader4X">
            <summary>
            <dd> <p>Shader model 4 compute shaders are supported.</p> </dd>
            </summary>
            <doc-id>hh871446</doc-id>
            <unmanaged>computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x</unmanaged>
            <unmanaged-short>computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.FeatureDataDoubles">
            <summary>
            <p>Describes the support for doubles in shaders.</p>
            </summary>
            <remarks>
            <p>Fill this structure by passing a D2D1_FEATURE_DOUBLES structure to <strong>ID2D1EffectContext::CheckFeatureSupport</strong>.</p>
            </remarks>
            <doc-id>hh871445</doc-id>
            <unmanaged>D2D1_FEATURE_DATA_DOUBLES</unmanaged>
            <unmanaged-short>D2D1_FEATURE_DATA_DOUBLES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.FeatureDataDoubles.DoublePrecisionFloatShaderOps">
            <summary>
            <dd> <p>TRUE is doubles are supported within the shaders.</p> </dd>
            </summary>
            <doc-id>hh871445</doc-id>
            <unmanaged>doublePrecisionFloatShaderOps</unmanaged>
            <unmanaged-short>doublePrecisionFloatShaderOps</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GradientMeshPatch">
            <summary>
            <p> Represents a tensor patch with 16 control points, 4 corner colors, and boundary flags. An <see cref = "T:SharpDX.Direct2D1.GradientMesh"/> is made up of 1 or more gradient mesh patches. Use the <strong>GradientMeshPatch function</strong> or the <strong>GradientMeshPatchFromCoonsPatch function</strong> to create one. </p>
            </summary>
            <remarks>
            <p>The following image shows the numbering of control points on a tensor grid.</p>
            </remarks>
            <doc-id>dn890726</doc-id>
            <unmanaged>D2D1_GRADIENT_MESH_PATCH</unmanaged>
            <unmanaged-short>D2D1_GRADIENT_MESH_PATCH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point00">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point00</unmanaged>
            <unmanaged-short>point00</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point01">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point01</unmanaged>
            <unmanaged-short>point01</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point02">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point02</unmanaged>
            <unmanaged-short>point02</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point03">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point03</unmanaged>
            <unmanaged-short>point03</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point10">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point10</unmanaged>
            <unmanaged-short>point10</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point11">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point11</unmanaged>
            <unmanaged-short>point11</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point12">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point12</unmanaged>
            <unmanaged-short>point12</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point13">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point13</unmanaged>
            <unmanaged-short>point13</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point20">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point20</unmanaged>
            <unmanaged-short>point20</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point21">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point21</unmanaged>
            <unmanaged-short>point21</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point22">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point22</unmanaged>
            <unmanaged-short>point22</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point23">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point23</unmanaged>
            <unmanaged-short>point23</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point30">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point30</unmanaged>
            <unmanaged-short>point30</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point31">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point31</unmanaged>
            <unmanaged-short>point31</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point32">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point32</unmanaged>
            <unmanaged-short>point32</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Point33">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>point33</unmanaged>
            <unmanaged-short>point33</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Color00">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>color00</unmanaged>
            <unmanaged-short>color00</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Color03">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>color03</unmanaged>
            <unmanaged-short>color03</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Color30">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>color30</unmanaged>
            <unmanaged-short>color30</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.Color33">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>color33</unmanaged>
            <unmanaged-short>color33</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.TopEdgeMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>topEdgeMode</unmanaged>
            <unmanaged-short>topEdgeMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.LeftEdgeMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>leftEdgeMode</unmanaged>
            <unmanaged-short>leftEdgeMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.BottomEdgeMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>bottomEdgeMode</unmanaged>
            <unmanaged-short>bottomEdgeMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientMeshPatch.RightEdgeMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890726</doc-id>
            <unmanaged>rightEdgeMode</unmanaged>
            <unmanaged-short>rightEdgeMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.GradientStop">
            <summary>
            <p> Contains the position and color of a gradient stop. </p>
            </summary>
            <remarks>
            <p>Gradient stops can be specified in any order if they are at different positions. Two stops may share a position. In this case, the first stop specified is treated as the "low" stop (nearer 0.0f) and subsequent stops are treated as "higher" (nearer 1.0f). This behavior is useful if a caller wants an instant transition in the middle of a stop.</p><p>Typically, there are at least two points in a collection, although creation with only one stop is permitted. For example, one point is at position 0.0f, another point is at position 1.0f, and additional points are distributed in the [0, 1] range. Where the gradient progression is beyond the range of [0, 1], the stops are stored, but may affect the gradient. </p><p>When drawn, the [0, 1] range of positions is mapped to the brush, in a brush-dependent way. For details, see <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrush"/></strong> and <strong><see cref = "T:SharpDX.Direct2D1.RadialGradientBrush"/></strong>. </p><p>Gradient stops with a position outside the [0, 1] range cannot be seen explicitly, but they can still affect the colors produced in the [0, 1] range. For example, a two-stop gradient 0.0f, Black}, {2.0f, White is indistinguishable visually from 0.0f, Black}, {1.0f, Mid-level gray. Also, the colors are clamped before interpolation.</p>
            </remarks>
            <doc-id>dd368119</doc-id>
            <unmanaged>D2D1_GRADIENT_STOP</unmanaged>
            <unmanaged-short>D2D1_GRADIENT_STOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientStop.Position">
            <summary>
            <dd> <p>A value that indicates the relative position of the gradient stop in the brush. This value must be in the [0.0f, 1.0f] range if the gradient stop is to be seen explicitly. </p> </dd>
            </summary>
            <doc-id>dd368119</doc-id>
            <unmanaged>position</unmanaged>
            <unmanaged-short>position</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.GradientStop.Color">
            <summary>
            <dd> <p>The color of the gradient stop.</p> </dd>
            </summary>
            <doc-id>dd368119</doc-id>
            <unmanaged>color</unmanaged>
            <unmanaged-short>color</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.HwndRenderTargetProperties">
            <summary>
            <p> Contains the <see cref = "T:System.IntPtr"/>, pixel size, and presentation options for an <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong>.</p>
            </summary>
            <remarks>
            <p>Use this structure when you call the <strong>CreateHwndRenderTarget</strong> method to create a new <strong><see cref = "T:SharpDX.Direct2D1.WindowRenderTarget"/></strong>.</p><p>For convenience, Direct2D provides the <strong>D2D1::HwndRenderTargetProperties</strong> function for creating new <strong><see cref = "T:SharpDX.Direct2D1.HwndRenderTargetProperties"/></strong> structures.</p>
            </remarks>
            <doc-id>dd368122</doc-id>
            <unmanaged>D2D1_HWND_RENDER_TARGET_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_HWND_RENDER_TARGET_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HwndRenderTargetProperties.Hwnd">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368122</doc-id>
            <unmanaged>hwnd</unmanaged>
            <unmanaged-short>hwnd</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HwndRenderTargetProperties.PixelSize">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368122</doc-id>
            <unmanaged>pixelSize</unmanaged>
            <unmanaged-short>pixelSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.HwndRenderTargetProperties.PresentOptions">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368122</doc-id>
            <unmanaged>presentOptions</unmanaged>
            <unmanaged-short>presentOptions</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.ImageBrushProperties">
            <summary>
            <p>Describes image brush features.</p>
            </summary>
            <doc-id>hh404308</doc-id>
            <unmanaged>D2D1_IMAGE_BRUSH_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_IMAGE_BRUSH_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageBrushProperties.SourceRectangle">
            <summary>
            <dd> <p>The source rectangle in the image space from which the image will be tiled or interpolated.</p> </dd>
            </summary>
            <doc-id>hh404308</doc-id>
            <unmanaged>sourceRectangle</unmanaged>
            <unmanaged-short>sourceRectangle</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageBrushProperties.ExtendModeX">
            <summary>
            <dd> <p>The extend mode in the image x-axis.</p> </dd>
            </summary>
            <doc-id>hh404308</doc-id>
            <unmanaged>extendModeX</unmanaged>
            <unmanaged-short>extendModeX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageBrushProperties.ExtendModeY">
            <summary>
            <dd> <p>The extend mode in the image y-axis.</p> </dd>
            </summary>
            <doc-id>hh404308</doc-id>
            <unmanaged>extendModeY</unmanaged>
            <unmanaged-short>extendModeY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.ImageBrushProperties.InterpolationMode">
            <summary>
            <dd> <p>The interpolation mode to use when scaling the image brush.</p> </dd>
            </summary>
            <doc-id>hh404308</doc-id>
            <unmanaged>interpolationMode</unmanaged>
            <unmanaged-short>interpolationMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InkBezierSegment">
            <summary>
            <p>Represents a Bezier segment to be used in the creation of an <strong><see cref = "T:SharpDX.Direct2D1.Ink"/></strong> object.  This structure differs from <strong><see cref = "T:SharpDX.Direct2D1.BezierSegment"/></strong> in that it is composed  of <strong><see cref = "T:SharpDX.Direct2D1.InkPoint"/></strong>s, which contain a radius in addition to x- and y-coordinates. </p>
            </summary>
            <doc-id>dn890751</doc-id>
            <unmanaged>D2D1_INK_BEZIER_SEGMENT</unmanaged>
            <unmanaged-short>D2D1_INK_BEZIER_SEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkBezierSegment.Point1">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890751</doc-id>
            <unmanaged>point1</unmanaged>
            <unmanaged-short>point1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkBezierSegment.Point2">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890751</doc-id>
            <unmanaged>point2</unmanaged>
            <unmanaged-short>point2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkBezierSegment.Point3">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890751</doc-id>
            <unmanaged>point3</unmanaged>
            <unmanaged-short>point3</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InkPoint">
            <summary>
            <p>Represents a point, radius pair that makes up part of a <strong><see cref = "T:SharpDX.Direct2D1.InkBezierSegment"/></strong>.</p>
            </summary>
            <doc-id>dn890752</doc-id>
            <unmanaged>D2D1_INK_POINT</unmanaged>
            <unmanaged-short>D2D1_INK_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkPoint.X">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890752</doc-id>
            <unmanaged>x</unmanaged>
            <unmanaged-short>x</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkPoint.Y">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890752</doc-id>
            <unmanaged>y</unmanaged>
            <unmanaged-short>y</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkPoint.Radius">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890752</doc-id>
            <unmanaged>radius</unmanaged>
            <unmanaged-short>radius</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.InkStyleProperties">
            <summary>
            <p> Defines the general pen tip shape and the transform used in an <strong><see cref = "T:SharpDX.Direct2D1.InkStyle"/></strong> object. </p>
            </summary>
            <doc-id>dn890737</doc-id>
            <unmanaged>D2D1_INK_STYLE_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_INK_STYLE_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkStyleProperties.NibShape">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890737</doc-id>
            <unmanaged>nibShape</unmanaged>
            <unmanaged-short>nibShape</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.InkStyleProperties.NibTransform">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn890737</doc-id>
            <unmanaged>nibTransform</unmanaged>
            <unmanaged-short>nibTransform</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.LinearGradientBrushProperties">
            <summary>
            <p> Contains the starting point and endpoint of the gradient axis for an <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrush"/></strong>. </p>
            </summary>
            <remarks>
            <p>Use this method when creating new <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrush"/></strong> objects with the <strong>CreateLinearGradientBrush</strong> method. For convenience, Direct2D provides the <strong>D2D1::LinearGradientBrushProperties</strong> helper function for creating new <strong><see cref = "T:SharpDX.Direct2D1.LinearGradientBrushProperties"/></strong> structures.</p><p>The following illustration shows how a linear gradient changes as you change its start and end points.  For the first gradient, the start point is set to (0,0) and the end point to (150, 50); this creates a diagonal gradient that starts at the upper-left corner and extends to the lower-right corner of the area being painted. When you set the start point to (0, 25) and the end point to (150, 25), a horizontal gradient is created. Similarly, setting the start point  to (75, 0) and the end point to (75, 50) creates a vertical gradient. Setting the start point to  (0, 50) and the end point to (150, 0)  creates a diagonal gradient that starts at the lower-left corner and extends to the upper-right corner of the area being painted.</p><p></p>
            </remarks>
            <doc-id>dd368128</doc-id>
            <unmanaged>D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearGradientBrushProperties.StartPoint">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368128</doc-id>
            <unmanaged>startPoint</unmanaged>
            <unmanaged-short>startPoint</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.LinearGradientBrushProperties.EndPoint">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368128</doc-id>
            <unmanaged>endPoint</unmanaged>
            <unmanaged-short>endPoint</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.MappedRectangle">
            <summary>
            <p> Describes mapped memory from the <strong>ID2D1Bitmap1::Map</strong> API.</p>
            </summary>
            <remarks>
            <p>The mapped rectangle is used to map a rectangle into the caller's address space.</p>
            </remarks>
            <doc-id>hh404314</doc-id>
            <unmanaged>D2D1_MAPPED_RECT</unmanaged>
            <unmanaged-short>D2D1_MAPPED_RECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MappedRectangle.Pitch">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404314</doc-id>
            <unmanaged>pitch</unmanaged>
            <unmanaged-short>pitch</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.MappedRectangle.Bits">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh404314</doc-id>
            <unmanaged>bits</unmanaged>
            <unmanaged-short>bits</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PointDescription">
            <summary>
            <p>Describes a point on a path geometry.</p>
            </summary>
            <doc-id>hh404318</doc-id>
            <unmanaged>D2D1_POINT_DESCRIPTION</unmanaged>
            <unmanaged-short>D2D1_POINT_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDescription.Point">
            <summary>
            <dd> <p>The end point after walking the path.</p> </dd>
            </summary>
            <doc-id>hh404318</doc-id>
            <unmanaged>point</unmanaged>
            <unmanaged-short>point</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDescription.UnitTangentVector">
            <summary>
            <dd> <p>A unit vector indicating the tangent point.</p> </dd>
            </summary>
            <doc-id>hh404318</doc-id>
            <unmanaged>unitTangentVector</unmanaged>
            <unmanaged-short>unitTangentVector</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDescription.EndSegment">
            <summary>
            <dd> <p>The index of the segment on which point resides. This index is global to the entire path, not just to a particular figure.</p> </dd>
            </summary>
            <doc-id>hh404318</doc-id>
            <unmanaged>endSegment</unmanaged>
            <unmanaged-short>endSegment</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDescription.EndFigure">
            <summary>
            <dd> <p>The index of the figure on which point resides.</p> </dd>
            </summary>
            <doc-id>hh404318</doc-id>
            <unmanaged>endFigure</unmanaged>
            <unmanaged-short>endFigure</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PointDescription.LengthToEndSegment">
            <summary>
            <dd> <p>The length of the section of the path stretching from the start of the path  to the start of <strong>endSegment</strong>.</p> </dd>
            </summary>
            <doc-id>hh404318</doc-id>
            <unmanaged>lengthToEndSegment</unmanaged>
            <unmanaged-short>lengthToEndSegment</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.PrintControlProperties">
            <summary>
            <p>The creation properties for a <strong><see cref = "T:SharpDX.Direct2D1.PrintControl"/></strong> object.</p>
            </summary>
            <doc-id>hh847949</doc-id>
            <unmanaged>D2D1_PRINT_CONTROL_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_PRINT_CONTROL_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrintControlProperties.FontSubset">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh847949</doc-id>
            <unmanaged>fontSubset</unmanaged>
            <unmanaged-short>fontSubset</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrintControlProperties.RasterDPI">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh847949</doc-id>
            <unmanaged>rasterDPI</unmanaged>
            <unmanaged-short>rasterDPI</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.PrintControlProperties.ColorSpace">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh847949</doc-id>
            <unmanaged>colorSpace</unmanaged>
            <unmanaged-short>colorSpace</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.QuadraticBezierSegment">
            <summary>
            <p> Contains the control point and end point for a quadratic Bezier segment.</p>
            </summary>
            <doc-id>dd368147</doc-id>
            <unmanaged>D2D1_QUADRATIC_BEZIER_SEGMENT</unmanaged>
            <unmanaged-short>D2D1_QUADRATIC_BEZIER_SEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.QuadraticBezierSegment.Point1">
            <summary>
            <dd> <p>The control point of the quadratic Bezier segment.</p> </dd>
            </summary>
            <doc-id>dd368147</doc-id>
            <unmanaged>point1</unmanaged>
            <unmanaged-short>point1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.QuadraticBezierSegment.Point2">
            <summary>
            <dd> <p>The end point of the quadratic Bezier segment.</p> </dd>
            </summary>
            <doc-id>dd368147</doc-id>
            <unmanaged>point2</unmanaged>
            <unmanaged-short>point2</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RadialGradientBrushProperties">
            <summary>
            <p> Contains the gradient origin offset and the size and position of the gradient ellipse for an <strong><see cref = "T:SharpDX.Direct2D1.RadialGradientBrush"/></strong>. </p>
            </summary>
            <remarks>
            <p>Different values for <em>center</em>,  <em>gradientOriginOffset</em>,  <em>radiusX</em> and/or <em>radiusY</em> produce different gradients.   The following illustration shows several radial gradients that have different gradient origin offsets, creating the appearance of the light illuminating the circles from different angles.</p><p></p><p>For convenience, Direct2D provides the <strong>D2D1::RadialGradientBrushProperties</strong> function for creating new <strong>D2D1_RADIAL_GRADIENT_BRUSH</strong> structures.</p>
            </remarks>
            <doc-id>dd368149</doc-id>
            <unmanaged>D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RadialGradientBrushProperties.Center">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368149</doc-id>
            <unmanaged>center</unmanaged>
            <unmanaged-short>center</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RadialGradientBrushProperties.GradientOriginOffset">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368149</doc-id>
            <unmanaged>gradientOriginOffset</unmanaged>
            <unmanaged-short>gradientOriginOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RadialGradientBrushProperties.RadiusX">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368149</doc-id>
            <unmanaged>radiusX</unmanaged>
            <unmanaged-short>radiusX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RadialGradientBrushProperties.RadiusY">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368149</doc-id>
            <unmanaged>radiusY</unmanaged>
            <unmanaged-short>radiusY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RenderingControls">
            <summary>
            <p>Describes limitations to be applied to an imaging effect renderer.</p>
            </summary>
            <remarks>
            <p>The renderer can allocate tiles larger than the minimum tile allocation. The allocated tiles will be powers of two of the minimum size on each axis, except that the size on each axis will not exceed the guaranteed maximum texture size for the device feature level. </p><p>The <strong>minimumPixelRenderExtent</strong> is the size of the square tile below which the renderer will expand the tile allocation rather than attempting to subdivide the rendering tile any further. When this threshold is reached, the allocation tile size is expanded. This might occur repeatedly until rendering can either proceed or it is determined that the graph cannot be rendered.</p><p>The buffer precision is used for intermediate buffers if it is otherwise unspecified by the effects or the internal effect topology. The application can also use the <strong>Output.BufferPrecision</strong> method to specify the output precision for a particular effect. This takes precedence over the context precision. In addition, the effect might set a different precision internally if required. If the buffer type on the context is <strong>D2D1_BUFFER_PRECISION_UNKNOWN</strong> and otherwise not specified by the effect or transform, the precision of the output will be the maximum precision of the inputs to the transform. The buffer precision does not affect the number of channels used. </p>
            </remarks>
            <doc-id>hh404322</doc-id>
            <unmanaged>D2D1_RENDERING_CONTROLS</unmanaged>
            <unmanaged-short>D2D1_RENDERING_CONTROLS</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderingControls.BufferPrecision">
            <summary>
            <dd> <p>The buffer precision used by default if the buffer precision is not otherwise specified by the effect or the transform.</p> </dd>
            </summary>
            <doc-id>hh404322</doc-id>
            <unmanaged>bufferPrecision</unmanaged>
            <unmanaged-short>bufferPrecision</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RenderingControls.TileSize">
            <summary>
            <dd> <p>The tile allocation size to be used by the imaging effect renderer.</p> </dd>
            </summary>
            <doc-id>hh404322</doc-id>
            <unmanaged>tileSize</unmanaged>
            <unmanaged-short>tileSize</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.RoundedRectangle">
            <summary>
            <p> Contains the dimensions and corner radii of a rounded rectangle.</p>
            </summary>
            <remarks>
            <p>Each corner of the rectangle specified by the <em>rect</em> is replaced with a quarter ellipse, with a radius in each direction specified by <em>radiusX</em> and <em>radiusY</em>.</p><p> If the <em>radiusX</em> is greater than or equal to half the width of the rectangle, and the <em>radiusY</em> is greater than or equal to one-half the height, the rounded rectangle is an ellipse with the same width and height of the <em>rect</em>. </p><p>Even when both <em>radiuX</em> and <em>radiusY</em> are zero, the rounded rectangle is different from a rectangle., When stroked, the corners of the rounded rectangle are roundly joined, not mitered (square). </p>
            </remarks>
            <doc-id>dd368158</doc-id>
            <unmanaged>D2D1_ROUNDED_RECT</unmanaged>
            <unmanaged-short>D2D1_ROUNDED_RECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RoundedRectangle.Rect">
            <summary>
            <dd> <p>The coordinates of the rectangle.</p> </dd>
            </summary>
            <doc-id>dd368158</doc-id>
            <unmanaged>rect</unmanaged>
            <unmanaged-short>rect</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RoundedRectangle.RadiusX">
            <summary>
            <dd> <p>The x-radius for the quarter ellipse that is drawn to replace every corner of the rectangle.</p> </dd>
            </summary>
            <doc-id>dd368158</doc-id>
            <unmanaged>radiusX</unmanaged>
            <unmanaged-short>radiusX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.RoundedRectangle.RadiusY">
            <summary>
            <dd> <p>The y-radius for the quarter ellipse that is drawn to replace every corner of the rectangle.</p> </dd>
            </summary>
            <doc-id>dd368158</doc-id>
            <unmanaged>radiusY</unmanaged>
            <unmanaged-short>radiusY</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SimpleColorProfile">
            <summary>
            <p>Creates a color context from a simple color profile. It is only valid to use this with the Color Management Effect in 'Best' mode.</p>
            </summary>
            <doc-id>mt797808</doc-id>
            <unmanaged>D2D1_SIMPLE_COLOR_PROFILE</unmanaged>
            <unmanaged-short>D2D1_SIMPLE_COLOR_PROFILE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SimpleColorProfile.RedPrimary">
            <summary>
            <dd>  <p>The simple color profile to create the color context from.</p> </dd>
            </summary>
            <doc-id>mt797808</doc-id>
            <unmanaged>redPrimary</unmanaged>
            <unmanaged-short>redPrimary</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SimpleColorProfile.GreenPrimary">
            <summary>
            <dd>  <p>The created color context.</p> </dd>
            </summary>
            <doc-id>mt797808</doc-id>
            <unmanaged>greenPrimary</unmanaged>
            <unmanaged-short>greenPrimary</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SimpleColorProfile.BluePrimary">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt797808</doc-id>
            <unmanaged>bluePrimary</unmanaged>
            <unmanaged-short>bluePrimary</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SimpleColorProfile.WhitePointXZ">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt797808</doc-id>
            <unmanaged>whitePointXZ</unmanaged>
            <unmanaged-short>whitePointXZ</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SimpleColorProfile.Gamma">
            <summary>
            No documentation.
            </summary>
            <doc-id>mt797808</doc-id>
            <unmanaged>gamma</unmanaged>
            <unmanaged-short>gamma</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.StrokeStyleProperties">
            <summary>
            <p> Describes the stroke that outlines a shape. </p>
            </summary>
            <remarks>
            <p>The following illustration shows different <em>dashOffset</em> values for the same custom dash style.</p><p></p>
            </remarks>
            <doc-id>dd368164</doc-id>
            <unmanaged>D2D1_STROKE_STYLE_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_STROKE_STYLE_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.StartCap">
            <summary>
            <dd> <p>The cap applied to the start of all the open figures in a stroked geometry.</p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>startCap</unmanaged>
            <unmanaged-short>startCap</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.EndCap">
            <summary>
            <dd> <p>The cap applied to the end of all the open figures in a stroked geometry.</p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>endCap</unmanaged>
            <unmanaged-short>endCap</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.DashCap">
            <summary>
            <dd> <p>The shape  at either end of each dash segment.</p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>dashCap</unmanaged>
            <unmanaged-short>dashCap</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.LineJoin">
            <summary>
            <dd> <p>A value that describes how segments are joined. This value is ignored for a vertex if the segment flags specify that the segment should have a smooth join. </p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>lineJoin</unmanaged>
            <unmanaged-short>lineJoin</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.MiterLimit">
            <summary>
            <dd> <p>The limit of the thickness of the join on a mitered corner. This value is always treated as though it is greater than or equal to 1.0f. </p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>miterLimit</unmanaged>
            <unmanaged-short>miterLimit</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.DashStyle">
            <summary>
            <dd> <p>A value that specifies whether the stroke has a dash pattern and, if so, the dash style. </p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>dashStyle</unmanaged>
            <unmanaged-short>dashStyle</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties.DashOffset">
            <summary>
            <dd> <p>A value that specifies an offset in the dash sequence.   A positive dash offset value  shifts the dash pattern, in units of  stroke width, toward the start of the stroked geometry.  A negative dash offset value  shifts the dash pattern, in units of  stroke width, toward the end of the stroked geometry.</p> </dd>
            </summary>
            <doc-id>dd368164</doc-id>
            <unmanaged>dashOffset</unmanaged>
            <unmanaged-short>dashOffset</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.StrokeStyleProperties1">
            <summary>
            <p>Describes the stroke that outlines a shape.</p>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>D2D1_STROKE_STYLE_PROPERTIES1</unmanaged>
            <unmanaged-short>D2D1_STROKE_STYLE_PROPERTIES1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.StartCap">
            <summary>
            <dd> <p>The cap to use at the start of each open figure.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>startCap</unmanaged>
            <unmanaged-short>startCap</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.EndCap">
            <summary>
            <dd> <p>The cap to use at the end of each open figure.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>endCap</unmanaged>
            <unmanaged-short>endCap</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.DashCap">
            <summary>
            <dd> <p>The cap to use at the start and end of each dash.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>dashCap</unmanaged>
            <unmanaged-short>dashCap</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.LineJoin">
            <summary>
            <dd> <p>The line join to use.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>lineJoin</unmanaged>
            <unmanaged-short>lineJoin</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.MiterLimit">
            <summary>
            <dd> <p>The limit beyond which miters are either clamped or converted to bevels.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>miterLimit</unmanaged>
            <unmanaged-short>miterLimit</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.DashStyle">
            <summary>
            <dd> <p>The type of dash to use.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>dashStyle</unmanaged>
            <unmanaged-short>dashStyle</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.DashOffset">
            <summary>
            <dd> <p>The location of the first dash, relative to the start of the figure. </p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>dashOffset</unmanaged>
            <unmanaged-short>dashOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.StrokeStyleProperties1.TransformType">
            <summary>
            <dd> <p>The rule that determines what render target properties affect the nib of the stroke.</p> </dd>
            </summary>
            <doc-id>hh404328</doc-id>
            <unmanaged>transformType</unmanaged>
            <unmanaged-short>transformType</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgLength">
            <summary>
            <p>A 3D vector that consists of three single-precision floating-point values (x, y, z).</p>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>D2D1_SVG_LENGTH</unmanaged>
            <unmanaged-short>D2D1_SVG_LENGTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLength.Value">
            <summary>
            <dd> <p>The x value of the vector.</p> </dd>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>value</unmanaged>
            <unmanaged-short>value</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgLength.Units">
            <summary>
            <dd> <p>The y value of the vector.</p> </dd>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>units</unmanaged>
            <unmanaged-short>units</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgPreserveAspectRatio">
            <summary>
            <p>A description of a single element to the vertex layout.</p>
            </summary>
            <remarks>
            <p>This structure is a subset of <strong><see cref = "!:SharpDX.Direct3D11.InputElement"/></strong> that omits fields required to define a vertex layout.</p><p>If the <strong>D2D1_APPEND_ALIGNED_ELEMENT</strong> constant is used for  <strong>alignedByteOffset</strong>, the elements will be packed contiguously for convenience.
            </p>
            </remarks>
            <doc-id>hh404312</doc-id>
            <unmanaged>D2D1_SVG_PRESERVE_ASPECT_RATIO</unmanaged>
            <unmanaged-short>D2D1_SVG_PRESERVE_ASPECT_RATIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPreserveAspectRatio.Defer">
            <summary>
            <dd> <p>The HLSL semantic associated with this element in a shader input-signature.</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>defer</unmanaged>
            <unmanaged-short>defer</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPreserveAspectRatio.Align">
            <summary>
            <dd> <p>The semantic index for the element. A semantic index modifies a semantic, with an integer index number. A semantic index is only needed in a case where there is more than one element with the same semantic. For example, a 4x4 matrix would have four components each with the semantic name matrix; however, each of the four components would have different semantic indices (0, 1, 2, and 3).</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>align</unmanaged>
            <unmanaged-short>align</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgPreserveAspectRatio.MeetOrSlice">
            <summary>
            <dd> <p>The data type of the element data.</p> </dd>
            </summary>
            <doc-id>hh404312</doc-id>
            <unmanaged>meetOrSlice</unmanaged>
            <unmanaged-short>meetOrSlice</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.SvgViewBox">
            <summary>
            <p>A 3D vector that consists of three single-precision floating-point values (x, y, z).</p>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>D2D1_SVG_VIEWBOX</unmanaged>
            <unmanaged-short>D2D1_SVG_VIEWBOX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgViewBox.X">
            <summary>
            <dd> <p>The x value of the vector.</p> </dd>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>x</unmanaged>
            <unmanaged-short>x</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgViewBox.Y">
            <summary>
            <dd> <p>The y value of the vector.</p> </dd>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>y</unmanaged>
            <unmanaged-short>y</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgViewBox.Width">
            <summary>
            <dd> <p>The z value of the vector.</p> </dd>
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.SvgViewBox.Height">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj219219</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.TransformedImageSourceProperties">
            <summary>
            <p>Properties of a transformed image source.</p>
            </summary>
            <doc-id>dn934350</doc-id>
            <unmanaged>D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES</unmanaged>
            <unmanaged-short>D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceProperties.Orientation">
            <summary>
            <dd> <p>The orientation at which the image source is drawn.</p> </dd>
            </summary>
            <doc-id>dn934350</doc-id>
            <unmanaged>orientation</unmanaged>
            <unmanaged-short>orientation</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceProperties.ScaleX">
            <summary>
            <dd> <p>The horizontal scale factor at which the image source is drawn.</p> </dd>
            </summary>
            <doc-id>dn934350</doc-id>
            <unmanaged>scaleX</unmanaged>
            <unmanaged-short>scaleX</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceProperties.ScaleY">
            <summary>
            <dd> <p>The vertical scale factor at which the image source is drawn.</p> </dd>
            </summary>
            <doc-id>dn934350</doc-id>
            <unmanaged>scaleY</unmanaged>
            <unmanaged-short>scaleY</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceProperties.InterpolationMode">
            <summary>
            <dd> <p>The interpolation mode used when the image source is drawn.  This is ignored if the image source is drawn using the DrawImage method, or using an image brush.</p> </dd>
            </summary>
            <doc-id>dn934350</doc-id>
            <unmanaged>interpolationMode</unmanaged>
            <unmanaged-short>interpolationMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.TransformedImageSourceProperties.Options">
            <summary>
            <dd> <p>Image sourc option flags.</p> </dd>
            </summary>
            <doc-id>dn934350</doc-id>
            <unmanaged>options</unmanaged>
            <unmanaged-short>options</unmanaged-short>
        </member>
        <member name="T:SharpDX.Direct2D1.Triangle">
            <summary>
            <p>Contains the three vertices that describe a triangle.</p>
            </summary>
            <doc-id>dd368172</doc-id>
            <unmanaged>D2D1_TRIANGLE</unmanaged>
            <unmanaged-short>D2D1_TRIANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Triangle.Point1">
            <summary>
            <dd> <p>The first vertex of a triangle.</p> </dd>
            </summary>
            <doc-id>dd368172</doc-id>
            <unmanaged>point1</unmanaged>
            <unmanaged-short>point1</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Triangle.Point2">
            <summary>
            <dd> <p>The second vertex of a triangle.</p> </dd>
            </summary>
            <doc-id>dd368172</doc-id>
            <unmanaged>point2</unmanaged>
            <unmanaged-short>point2</unmanaged-short>
        </member>
        <member name="F:SharpDX.Direct2D1.Triangle.Point3">
            <summary>
            <dd> <p>The third vertex of a triangle.</p> </dd>
            </summary>
            <doc-id>dd368172</doc-id>
            <unmanaged>point3</unmanaged>
            <unmanaged-short>point3</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.DrawGlyphRun(System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.RenderingParams,SharpDX.Mathematics.Interop.RawColorBGRA,SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>	
            <p> Draws a run of glyphs to a bitmap target at the specified position.</p>	
            </summary>	
            <param name="baselineOriginX"><dd>  <p> The horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>	
            <param name="baselineOriginY"><dd>  <p> The vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>	
            <param name="measuringMode"><dd>  <p> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</p> </dd></param>	
            <param name="glyphRun"><dd>  <p> The structure containing the properties of the glyph run.</p> </dd></param>	
            <param name="renderingParams"><dd>  <p> The object that controls rendering behavior.</p> </dd></param>	
            <param name="textColor"><dd>  <p> The foreground color of the text.</p> </dd></param>	
            <param name="blackBoxRect"><dd>  <p> The optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by  drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <remarks>	
            <p>You can use the <strong><see cref="M:SharpDX.DirectWrite.BitmapRenderTarget.DrawGlyphRun(System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.RenderingParams,SharpDX.Mathematics.Interop.RawColorBGRA,SharpDX.Mathematics.Interop.RawRectangle@)" /></strong> to render to a bitmap from a custom text renderer that you implement.  The custom text renderer should call this method from within the <strong><see cref="M:SharpDX.DirectWrite.TextRenderer.DrawGlyphRun(System.Object,System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.ComObject)" /></strong> callback method as shown in the following code.</p><pre>STDMETHODIMP GdiTextRenderer::DrawGlyphRun( __maybenull void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, <see cref="T:SharpDX.Direct2D1.MeasuringMode" /> measuringMode, __in <see cref="T:SharpDX.DirectWrite.GlyphRun" /> const* glyphRun, __in <see cref="T:SharpDX.DirectWrite.GlyphRunDescription" /> const* glyphRunDescription, <see cref="T:SharpDX.ComObject" />* clientDrawingEffect )	
            { <see cref="T:SharpDX.Result" /> hr = <see cref="F:SharpDX.Result.Ok" />; // Pass on the drawing call to the render target to do the real work. <see cref="T:SharpDX.Mathematics.Interop.RawRectangle" /> dirtyRect = {0}; hr = pRenderTarget_-&gt;DrawGlyphRun( baselineOriginX, baselineOriginY, measuringMode, glyphRun, pRenderingParams_, RGB(0,200,255), &amp;dirtyRect ); return hr;	
            }	
            </pre><p>The <em>baselineOriginX</em>, <em>baslineOriginY</em>, <em>measuringMethod</em>, and <em>glyphRun</em> parameters are provided (as arguments) when the callback method is invoked.  The <em>renderingParams</em>, <em>textColor</em> and <em>blackBoxRect</em> are not.</p><p>Default rendering params can be retrieved by using the <strong><see cref="M:SharpDX.DirectWrite.Factory.CreateMonitorRenderingParams(System.IntPtr,SharpDX.DirectWrite.RenderingParams)" /></strong> method.</p><p />	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDWriteBitmapRenderTarget::DrawGlyphRun']/*" />	
            <msdn-id>dd368167</msdn-id>	
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::DrawGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] IDWriteRenderingParams* renderingParams,[In] int textColor,[Out, Optional] RECT* blackBoxRect)</unmanaged>	
            <unmanaged-short>IDWriteBitmapRenderTarget::DrawGlyphRun</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.DrawGlyphRun(System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.RenderingParams,SharpDX.Mathematics.Interop.RawColorBGRA)">
            <summary>	
            Draws a run of glyphs to a bitmap target at the specified position.	
            </summary>	
            <remarks>	
            You can use the IDWriteBitmapRenderTarget::DrawGlyphRun to render to a bitmap from a custom text renderer that you implement.  The custom text renderer should call this method from within the <see cref="M:SharpDX.DirectWrite.TextRenderer.DrawGlyphRun(System.IntPtr,System.Single,System.Single,SharpDX.DirectWrite.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.ComObject)" /> callback method as shown in the following code. 	
            <code> STDMETHODIMP GdiTextRenderer::DrawGlyphRun( __maybenull void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuringMode, __in DWRITE_GLYPH_RUN const* glyphRun, __in DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription, IUnknown* clientDrawingEffect )	
            { HRESULT hr = S_OK; // Pass on the drawing call to the render target to do the real work. RECT dirtyRect = {0}; hr = pRenderTarget_-&gt;DrawGlyphRun( baselineOriginX, baselineOriginY, measuringMode, glyphRun, pRenderingParams_, RGB(0,200,255), &amp;dirtyRect ); return hr;	
            } </code>	
            
            The baselineOriginX, baslineOriginY, measuringMethod, and glyphRun parameters are provided (as arguments) when the callback method is invoked.  The renderingParams, textColor and blackBoxRect are not. Default rendering params can be retrieved by using the <see cref="M:SharpDX.DirectWrite.Factory.CreateMonitorRenderingParams(System.IntPtr,SharpDX.DirectWrite.RenderingParams@)" /> method.  	
            </remarks>	
            <param name="baselineOriginX">The horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB. </param>
            <param name="baselineOriginY">The vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB. </param>
            <param name="measuringMode">The measuring method for glyphs in the run, used with the other properties to determine the rendering mode. </param>
            <param name="glyphRun">The structure containing the properties of the glyph run. </param>
            <param name="renderingParams">The object that controls rendering behavior. </param>
            <param name="textColor">The foreground color of the text. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::DrawGlyphRun([None] float baselineOriginX,[None] float baselineOriginY,[None] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[None] IDWriteRenderingParams* renderingParams,[None] COLORREF textColor,[Out, Optional] RECT* blackBoxRect)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.BitmapRenderTarget.MemoryDC">
            <summary>
            <p> Gets a handle to the memory device context. </p>
            </summary>
            <remarks>
            <p> An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (<see cref = "T:System.IntPtr"/>) by calling <strong>GetCurrentObject</strong>. An application that wants information about the underlying bitmap, including a reference to the pixel data, can call <strong>GetObject</strong> to fill in a <strong>DIBSECTION</strong> structure. The bitmap is always a 32-bit  top-down DIB. </p><p>Note that this method takes no parameters and returns an <see cref = "T:System.IntPtr"/> variable, not an <see cref = "T:SharpDX.Result"/>.</p><pre>memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC();
            </pre><p>The <see cref = "T:System.IntPtr"/> returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.</p>
            </remarks>
            <doc-id>dd368171</doc-id>
            <unmanaged>GetMemoryDC</unmanaged>
            <unmanaged-short>GetMemoryDC</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.BitmapRenderTarget.PixelsPerDip">
            <summary>
            <p>Gets or sets the number of bitmap pixels per DIP.  </p>
            </summary>
            <remarks>
            <p>A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.</p>
            </remarks>
            <doc-id>dd368173</doc-id>
            <unmanaged>GetPixelsPerDip / SetPixelsPerDip</unmanaged>
            <unmanaged-short>GetPixelsPerDip</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.BitmapRenderTarget.CurrentTransform">
            <summary>
            <p>Gets or sets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. </p>
            </summary>
            <doc-id>dd368169</doc-id>
            <unmanaged>GetCurrentTransform / SetCurrentTransform</unmanaged>
            <unmanaged-short>GetCurrentTransform</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.BitmapRenderTarget.Size">
            <summary>
            <p> Gets the dimensions of the target bitmap. </p>
            </summary>
            <doc-id>dd368176</doc-id>
            <unmanaged>GetSize</unmanaged>
            <unmanaged-short>GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.DrawGlyphRun(System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.RenderingParams,System.Int32,SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>
            <p> Draws a run of glyphs to a bitmap target at the specified position.</p>
            </summary>
            <param name = "baselineOriginX"><dd>  <p> The horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
            <param name = "baselineOriginY"><dd>  <p> The vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p> The structure containing the properties of the glyph run.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p> The object that controls rendering behavior.</p> </dd></param>
            <param name = "textColor"><dd>  <p> The foreground color of the text.</p> </dd></param>
            <param name = "blackBoxRect"><dd>  <p> The optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by  drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You can use the <strong>IDWriteBitmapRenderTarget::DrawGlyphRun</strong> to render to a bitmap from a custom text renderer that you implement.  The custom text renderer should call this method from within the <strong>IDWriteTextRenderer::DrawGlyphRun</strong> callback method as shown in the following code.</p><pre>STDMETHODIMP GdiTextRenderer::DrawGlyphRun( __maybenull void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, <see cref = "T:SharpDX.Direct2D1.MeasuringMode"/> measuringMode, __in <see cref = "T:SharpDX.DirectWrite.GlyphRun"/> const* glyphRun, __in <see cref = "T:SharpDX.DirectWrite.GlyphRunDescription"/> const* glyphRunDescription, <see cref = "T:SharpDX.IUnknown"/>* clientDrawingEffect )
            { <see cref = "T:SharpDX.Result"/> hr = <see cref = "F:SharpDX.Result.Ok"/>; // Pass on the drawing call to the render target to do the real work. <see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/> dirtyRect = {0}; hr = pRenderTarget_-&gt;DrawGlyphRun( baselineOriginX, baselineOriginY, measuringMode, glyphRun, pRenderingParams_, RGB(0,200,255), &amp;dirtyRect ); return hr;
            }
            </pre><p>The <em>baselineOriginX</em>, <em>baslineOriginY</em>, <em>measuringMethod</em>, and <em>glyphRun</em> parameters are provided (as arguments) when the callback method is invoked.  The <em>renderingParams</em>, <em>textColor</em> and <em>blackBoxRect</em> are not.</p><p>Default rendering params can be retrieved by using the <strong>IDWriteFactory::CreateMonitorRenderingParams</strong> method.</p><p></p>
            </remarks>
            <doc-id>dd368167</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::DrawGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] IDWriteRenderingParams* renderingParams,[In] COLORREF textColor,[Out, Optional] RECT* blackBoxRect)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::DrawGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.GetMemoryDC">
            <summary>
            <p> Gets a handle to the memory device context. </p>
            </summary>
            <returns><p>Returns a device context handle to the memory device context.</p></returns>
            <remarks>
            <p> An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle (<see cref = "T:System.IntPtr"/>) by calling <strong>GetCurrentObject</strong>. An application that wants information about the underlying bitmap, including a reference to the pixel data, can call <strong>GetObject</strong> to fill in a <strong>DIBSECTION</strong> structure. The bitmap is always a 32-bit  top-down DIB. </p><p>Note that this method takes no parameters and returns an <see cref = "T:System.IntPtr"/> variable, not an <see cref = "T:SharpDX.Result"/>.</p><pre>memoryHdc = g_pBitmapRenderTarget-&gt;GetMemoryDC();
            </pre><p>The <see cref = "T:System.IntPtr"/> returned here is still owned by the bitmap render targer object and should not be released or deleted by the client.</p>
            </remarks>
            <doc-id>dd368171</doc-id>
            <unmanaged>HDC IDWriteBitmapRenderTarget::GetMemoryDC()</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::GetMemoryDC</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.GetPixelsPerDip">
            <summary>
            <p> Gets the number of bitmap pixels per DIP.  </p>
            </summary>
            <returns><p>The number of bitmap pixels per DIP.</p></returns>
            <remarks>
            <p>A DIP (device-independent pixel) is 1/96 inch. Therefore, this value is the number if pixels per inch divided by 96.</p>
            </remarks>
            <doc-id>dd368173</doc-id>
            <unmanaged>float IDWriteBitmapRenderTarget::GetPixelsPerDip()</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::GetPixelsPerDip</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.SetPixelsPerDip(System.Single)">
            <summary>
            <p> Sets the number of bitmap pixels per DIP (device-independent pixel). A DIP is 1/96 inch, so this value is the number if pixels per inch divided by 96. </p>
            </summary>
            <param name = "pixelsPerDip"><dd>  <p>A value that specifies the number of pixels per DIP.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368182</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::SetPixelsPerDip([In] float pixelsPerDip)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::SetPixelsPerDip</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.GetCurrentTransform(SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p> Gets the transform that maps abstract coordinates to DIPs. By default this is the identity  transform. Note that this is unrelated to the world transform of the underlying device context. </p>
            </summary>
            <param name = "transform"><dd>  <p>When this method returns, contains a transform matrix.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368169</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetCurrentTransform([Out] DWRITE_MATRIX* transform)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::GetCurrentTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.SetCurrentTransform(System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2})">
            <summary>
            <p> Sets the transform that maps abstract coordinate to DIPs (device-independent pixel). This does not affect the world transform of the underlying device context. </p>
            </summary>
            <param name = "transform"><dd>  <p> Specifies the new transform. This parameter can be <strong><c>null</c></strong>, in which case the identity transform is implied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368179</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::SetCurrentTransform([In, Optional] const DWRITE_MATRIX* transform)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::SetCurrentTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.GetSize(SharpDX.Size2@)">
            <summary>
            <p> Gets the dimensions of the target bitmap. </p>
            </summary>
            <param name = "size"><dd>  <p>Returns  the width and height of the bitmap in pixels.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368176</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::GetSize([Out] SIZE* size)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget.Resize(System.Int32,System.Int32)">
            <summary>
            <p> Resizes the bitmap. </p>
            </summary>
            <param name = "width"><dd>  <p>The new bitmap width, in pixels.</p> </dd></param>
            <param name = "height"><dd>  <p>The new bitmap height, in pixels.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368177</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget::Resize([In] unsigned int width,[In] unsigned int height)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget::Resize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.ColorGlyphRunEnumerator.MoveNext(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Move to the next glyph run in the enumerator.</p>
            </summary>
            <param name = "hasRun"><dd>  <p>Returns <strong>TRUE</strong> if there is a next glyph run.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280447</doc-id>
            <unmanaged>HRESULT IDWriteColorGlyphRunEnumerator::MoveNext([Out] BOOL* hasRun)</unmanaged>
            <unmanaged-short>IDWriteColorGlyphRunEnumerator::MoveNext</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.ColorGlyphRunEnumerator.GetCurrentRun(System.IntPtr@)">
            <summary>
            <p>Returns the current glyph run of the enumerator.</p>
            </summary>
            <param name = "colorGlyphRun"><dd>  <p>A reference to the current glyph run.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280446</doc-id>
            <unmanaged>HRESULT IDWriteColorGlyphRunEnumerator::GetCurrentRun([Out] const void** colorGlyphRun)</unmanaged>
            <unmanaged-short>IDWriteColorGlyphRunEnumerator::GetCurrentRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.ColorGlyphRunEnumerator1.GetCurrentRun(System.IntPtr@)">
            <summary>
            <p>Gets the current color glyph run.</p>
            </summary>
            <param name = "colorGlyphRun"><dd>  <p>Receives a reference to the color glyph run. The reference remains valid until the next call to MoveNext or until the interface is released.</p> </dd></param>
            <returns><p>Standard <see cref = "T:SharpDX.Result"/> error code. An error is returned if there is no current glyph run, i.e., if MoveNext has not yet been called or if the end of the sequence has been reached.</p></returns>
            <doc-id>mt761991</doc-id>
            <unmanaged>HRESULT IDWriteColorGlyphRunEnumerator1::GetCurrentRun([Out] const void** colorGlyphRun)</unmanaged>
            <unmanaged-short>IDWriteColorGlyphRunEnumerator1::GetCurrentRun</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.EllipsisTrimming">
            <summary>
            An inline object for trimming, using an ellipsis as the omission sign.
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.EllipsisTrimming.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DirectWrite.EllipsisTrimming"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.DirectWrite.EllipsisTrimming.#ctor(SharpDX.DirectWrite.Factory,SharpDX.DirectWrite.TextFormat)">
            <summary>	
            Creates an inline object for trimming, using an ellipsis as the omission sign. 	
            </summary>	
            <remarks>	
            The ellipsis will be created using the current settings of the format, including base font, style, and any effects. Alternate omission signs can be created by the application by implementing <see cref="T:SharpDX.DirectWrite.InlineObject"/>.  	
            </remarks>
            <param name="factory">a <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="textFormat">A text format object, created with {{CreateTextFormat}}, used for text layout. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateEllipsisTrimmingSign([None] IDWriteTextFormat* textFormat,[Out] IDWriteInlineObject** trimmingSign)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.#ctor">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory" />.
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.#ctor(SharpDX.DirectWrite.FactoryType)">
            <summary>
            Default Constructor for a <see cref = "T:SharpDX.Direct2D1.Factory" />.
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.RegisterFontCollectionLoader(SharpDX.DirectWrite.FontCollectionLoader)">
            <summary>	
            Registers a custom font collection loader with the factory object. 	
            </summary>	
            <remarks>	
            This function registers a font collection loader with DirectWrite. The font collection loader interface, which should be implemented by a singleton object, handles enumerating font files in a font collection given a particular type of key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistration operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation. 	
            </remarks>	
            <param name="fontCollectionLoader">Reference to a <see cref="T:SharpDX.DirectWrite.FontCollectionLoader"/> object to be registered. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteFactory::RegisterFontCollectionLoader([None] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.UnregisterFontCollectionLoader(SharpDX.DirectWrite.FontCollectionLoader)">
            <summary>	
            Unregisters a custom font collection loader that was previously registered using {{RegisterFontCollectionLoader}}. 	
            </summary>	
            <param name="fontCollectionLoader">Pointer to a <see cref="T:SharpDX.DirectWrite.FontCollectionLoader"/> object to be unregistered. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteFactory::UnregisterFontCollectionLoader([None] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.RegisterFontFileLoader(SharpDX.DirectWrite.FontFileLoader)">
            <summary>	
            Registers a font file loader with DirectWrite. 	
            </summary>	
            <remarks>	
            This function registers a font file loader with DirectWrite. The font file loader interface, which should be implemented   by a singleton object, handles loading font file resources of a particular type from a key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistration operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation.  	
            </remarks>	
            <param name="fontFileLoader">Pointer to a <see cref="T:SharpDX.DirectWrite.FontFileLoader"/> object for a particular file resource type. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteFactory::RegisterFontFileLoader([None] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.UnregisterFontFileLoader(SharpDX.DirectWrite.FontFileLoader)">
            <summary>	
            Unregisters a font file loader that was previously registered with the DirectWrite font system using {{RegisterFontFileLoader}}. 	
            </summary>	
            <remarks>	
            This function unregisters font file loader callbacks with the DirectWrite font system. You should implement the font file loader interface by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors and must not unregister themselves in their destructors, because registration and unregistration operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite should be performed outside of the font file loader implementation.  	
            </remarks>	
            <param name="fontFileLoader">Pointer to the file loader that was previously registered with the DirectWrite font system using {{RegisterFontFileLoader}}. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteFactory::UnregisterFontFileLoader([None] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.Factory.GdiInterop">
            <summary>
            <p> Creates an object that is used for interoperability with GDI. </p>
            </summary>
            <doc-id>dd368207</doc-id>
            <unmanaged>GetGdiInterop</unmanaged>
            <unmanaged-short>GetGdiInterop</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.GetSystemFontCollection(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> Gets an object which represents the set of installed fonts. </p>
            </summary>
            <param name = "checkForUpdates"><dd>  <p>If this parameter is nonzero, the function performs an immediate check for changes to the set of installed fonts. If this parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the function will still detect changes if the font cache service is running, but there may be some latency. For example, an application might specify <strong>TRUE</strong> if it has itself just installed a font and wants to  be sure the font collection contains that font.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of a reference to the system font collection object, or <strong><c>null</c></strong> in case of failure.</p> </dd></returns>
            <doc-id>dd368208</doc-id>
            <unmanaged>HRESULT IDWriteFactory::GetSystemFontCollection([Out] IDWriteFontCollection** fontCollection,[In] BOOL checkForUpdates)</unmanaged>
            <unmanaged-short>IDWriteFactory::GetSystemFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateCustomFontCollection(SharpDX.DirectWrite.FontCollectionLoader,System.IntPtr,System.Int32,SharpDX.DirectWrite.FontCollection)">
            <summary>
            <p> Creates a font collection using a custom font collection loader. </p>
            </summary>
            <param name = "collectionLoader"><dd>  <p>An application-defined font collection loader, which must have been previously registered using <strong>RegisterFontCollectionLoader</strong>.</p> </dd></param>
            <param name = "collectionKey"><dd>  <p>The key used by the loader to identify a collection of font files.  The buffer allocated for this key should at least be the size of <em>collectionKeySize</em>.</p> </dd></param>
            <param name = "collectionKeySize"><dd>  <p>The size, in bytes, of the collection key.</p> </dd></param>
            <param name = "fontCollection"><dd>  <p>Contains  an address of a reference to the system font collection object if the method succeeds, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368186</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateCustomFontCollection([In] IDWriteFontCollectionLoader* collectionLoader,[In, Buffer] const void* collectionKey,[In] unsigned int collectionKeySize,[Out, Fast] IDWriteFontCollection** fontCollection)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateCustomFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.RegisterFontCollectionLoader_(SharpDX.DirectWrite.FontCollectionLoader)">
            <summary>
            <p>Registers a custom font collection loader with the factory object. </p>
            </summary>
            <param name = "fontCollectionLoader"><dd>  <p>Pointer to a <strong><see cref = "T:SharpDX.DirectWrite.FontCollectionLoader"/></strong> object to be registered.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function registers a font collection loader with DirectWrite. The font collection loader interface, which should be implemented by a singleton object,  handles enumerating font files in a font collection given a particular type of key. A given instance can only be registered once. Succeeding attempts will return an error,  indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors,  and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively.  Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation.</p>
            </remarks>
            <doc-id>dd368209</doc-id>
            <unmanaged>HRESULT IDWriteFactory::RegisterFontCollectionLoader([In] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
            <unmanaged-short>IDWriteFactory::RegisterFontCollectionLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.UnregisterFontCollectionLoader_(SharpDX.DirectWrite.FontCollectionLoader)">
            <summary>
            <p> Unregisters a custom font collection loader that was previously registered using <strong>RegisterFontCollectionLoader</strong>. </p>
            </summary>
            <param name = "fontCollectionLoader">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368211</doc-id>
            <unmanaged>HRESULT IDWriteFactory::UnregisterFontCollectionLoader([In] IDWriteFontCollectionLoader* fontCollectionLoader)</unmanaged>
            <unmanaged-short>IDWriteFactory::UnregisterFontCollectionLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateFontFileReference(System.String,System.Nullable{System.Int64},SharpDX.DirectWrite.FontFile)">
            <summary>
            <p> Creates a font file reference object from a local font file. </p>
            </summary>
            <param name = "filePath"><dd>  <p>An array of characters that contains the absolute file path for the font file. Subsequent operations on the constructed object may fail if the user provided <em>filePath</em> doesn't correspond to a valid file on the disk.</p> </dd></param>
            <param name = "lastWriteTime"><dd>  <p>The last modified time of the input file path. If the parameter is omitted, the function will access the font file to obtain its last write time. You should specify this value to avoid extra disk access. Subsequent operations on the constructed object may fail if the user provided <em>lastWriteTime</em> doesn't match the file on the disk.</p> </dd></param>
            <param name = "fontFile"><dd>  <p>When this method returns, contains an address of a reference to the newly created font file reference object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368197</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFileReference([In] const wchar_t* filePath,[In, Optional] const FILETIME* lastWriteTime,[Out, Fast] IDWriteFontFile** fontFile)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateFontFileReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateCustomFontFileReference(System.IntPtr,System.Int32,SharpDX.DirectWrite.FontFileLoader,SharpDX.DirectWrite.FontFile)">
            <summary>
            <p> Creates a reference to an application-specific font file resource. </p>
            </summary>
            <param name = "fontFileReferenceKey"><dd>  <p>A font file reference key that uniquely identifies the font file resource during the lifetime of <em>fontFileLoader</em>.</p> </dd></param>
            <param name = "fontFileReferenceKeySize"><dd>  <p>The size of the font file reference key in bytes.</p> </dd></param>
            <param name = "fontFileLoader"><dd>  <p>The font file loader that will be used by the font system to load data from the file identified by <em>fontFileReferenceKey</em>.</p> </dd></param>
            <param name = "fontFile"><dd>  <p>Contains an address of a reference to the newly created font file object when this method succeeds, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function is provided for cases when an application or a document needs to use a private font without having to install it on the system. <em>fontFileReferenceKey</em> has to be unique only in the scope of the <em>fontFileLoader</em> used in this call. </p>
            </remarks>
            <doc-id>dd368188</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateCustomFontFileReference([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[In] IDWriteFontFileLoader* fontFileLoader,[Out, Fast] IDWriteFontFile** fontFile)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateCustomFontFileReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateFontFace(SharpDX.DirectWrite.FontFaceType,System.Int32,SharpDX.DirectWrite.FontFile[],System.Int32,SharpDX.DirectWrite.FontSimulations,SharpDX.DirectWrite.FontFace)">
            <summary>
            <p> Creates an object that represents a font face. </p>
            </summary>
            <param name = "fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>
            <param name = "numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>
            <param name = "fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref = "T:SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>
            <param name = "faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>
            <param name = "fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368196</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateRenderingParams(SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p> Creates a rendering parameters object with default settings for the primary monitor. Different monitors may have different rendering parameters, for more information see the How to Add Support for Multiple Monitors topic.</p>
            </summary>
            <param name = "renderingParams">No documentation.</param>
            <returns><p>Standard <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <doc-id>dd368201</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateRenderingParams([Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateMonitorRenderingParams(System.IntPtr,SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p> Creates a rendering parameters object with default settings for the specified monitor. In most cases, this is the preferred way to create a rendering parameters object.</p>
            </summary>
            <param name = "monitor"><dd>  <p>A handle for the specified monitor.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the rendering parameters object created by this method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368199</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateMonitorRenderingParams([In] HMONITOR monitor,[Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateMonitorRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateCustomRenderingParams(System.Single,System.Single,System.Single,SharpDX.DirectWrite.PixelGeometry,SharpDX.DirectWrite.RenderingMode,SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p>Creates a rendering parameters object with the specified properties.</p>
            </summary>
            <param name = "gamma"><dd>  <p>The gamma level to be set for the new rendering parameters object.</p> </dd></param>
            <param name = "enhancedContrast"><dd>  <p>The enhanced contrast level to be set for the new rendering parameters object.</p> </dd></param>
            <param name = "clearTypeLevel"><dd>  <p>The ClearType level to be set for the new rendering parameters object.</p> </dd></param>
            <param name = "pixelGeometry"><dd>  <p>Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the newly created rendering parameters object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368190</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[Out, Fast] IDWriteRenderingParams** renderingParams)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateCustomRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.RegisterFontFileLoader_(SharpDX.DirectWrite.FontFileLoader)">
            <summary>
            <p> Registers a font file loader with DirectWrite. </p>
            </summary>
            <param name = "fontFileLoader"><dd>  <p>Pointer to a <strong><see cref = "T:SharpDX.DirectWrite.FontFileLoader"/></strong> object for a particular file resource type.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function registers a font file loader with DirectWrite. The font file loader interface, which should be implemented   by a singleton object, handles loading font file resources of a particular type from a key. A given instance can only be registered once. Succeeding attempts will return an error, indicating that it has already been registered. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors, and must not unregister themselves inside their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration with DirectWrite of font file loaders should be performed outside of the font file loader implementation. </p>
            </remarks>
            <doc-id>dd368210</doc-id>
            <unmanaged>HRESULT IDWriteFactory::RegisterFontFileLoader([In] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
            <unmanaged-short>IDWriteFactory::RegisterFontFileLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.UnregisterFontFileLoader_(SharpDX.DirectWrite.FontFileLoader)">
            <summary>
            <p> Unregisters a font file loader that was previously registered with the DirectWrite font system using <strong>RegisterFontFileLoader</strong>. </p>
            </summary>
            <param name = "fontFileLoader">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This function unregisters font file loader callbacks with the DirectWrite font system. You should implement the font file loader interface by a singleton object. Note that font file loader implementations must not register themselves with DirectWrite inside their constructors and must not unregister themselves in their destructors, because registration and unregistraton operations increment and decrement the object reference count respectively. Instead, registration and unregistration of font file loaders with DirectWrite should be performed outside of the font file loader implementation. </p>
            </remarks>
            <doc-id>dd368212</doc-id>
            <unmanaged>HRESULT IDWriteFactory::UnregisterFontFileLoader([In] IDWriteFontFileLoader* fontFileLoader)</unmanaged>
            <unmanaged-short>IDWriteFactory::UnregisterFontFileLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateTextFormat(System.String,SharpDX.DirectWrite.FontCollection,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.FontStretch,System.Single,System.String,SharpDX.DirectWrite.TextFormat)">
            <summary>
            <p> Creates a text format object used for text layout. </p>
            </summary>
            <param name = "fontFamilyName"><dd>  <p>An array of characters that contains the name of the font family</p> </dd></param>
            <param name = "fontCollection"><dd>  <p>A reference to a font collection object. When this is <strong><c>null</c></strong>, indicates the system font collection.</p> </dd></param>
            <param name = "fontWeight"><dd>  <p>A value that indicates the font weight for the text object created by this method.</p> </dd></param>
            <param name = "fontStyle"><dd>  <p>A value that indicates the font style for the text object created by this method.</p> </dd></param>
            <param name = "fontStretch"><dd>  <p>A value that indicates the font stretch for the text object created by this method.</p> </dd></param>
            <param name = "fontSize"><dd>  <p>The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</p> </dd></param>
            <param name = "localeName"><dd>  <p>An array of characters that contains the locale name.</p> </dd></param>
            <param name = "textFormat"><dd>  <p>When this method returns, contains an address of a reference to a  newly created text format object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368203</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateTextFormat([In] const wchar_t* fontFamilyName,[In, Optional] IDWriteFontCollection* fontCollection,[In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_FONT_STYLE fontStyle,[In] DWRITE_FONT_STRETCH fontStretch,[In] float fontSize,[In] const wchar_t* localeName,[Out, Fast] IDWriteTextFormat** textFormat)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateTextFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateTypography(SharpDX.DirectWrite.Typography)">
            <summary>
            <p> Creates a typography object for use in a text layout. </p>
            </summary>
            <param name = "typography"><dd>  <p>When this method returns, contains the address of  a reference to a newly created typography object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368206</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateTypography([Out, Fast] IDWriteTypography** typography)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateTypography</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.GetGdiInterop(SharpDX.DirectWrite.GdiInterop@)">
            <summary>
            <p> Creates an object that is used for interoperability with GDI. </p>
            </summary>
            <param name = "gdiInterop"><dd>  <p>When this method returns, contains an address of a reference to a GDI interop object if successful, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368207</doc-id>
            <unmanaged>HRESULT IDWriteFactory::GetGdiInterop([Out] IDWriteGdiInterop** gdiInterop)</unmanaged>
            <unmanaged-short>IDWriteFactory::GetGdiInterop</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateTextLayout(System.String,System.Int32,SharpDX.DirectWrite.TextFormat,System.Single,System.Single,SharpDX.DirectWrite.TextLayout)">
            <summary>
            <p> Takes a string, text format, and associated constraints, and produces an object that represents the fully analyzed and formatted result. </p>
            </summary>
            <param name = "text"><dd>  <p>An array of characters that contains the string to create a new <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> object from. This array must be of length <em>stringLength</em> and can contain embedded <strong><c>null</c></strong> characters.</p> </dd></param>
            <param name = "stringLength"><dd>  <p>The number of characters in  the string.</p> </dd></param>
            <param name = "textFormat"><dd>  <p>A reference to an object that indicates the format to apply to the string.</p> </dd></param>
            <param name = "maxWidth"><dd>  <p>The width of the layout box.</p> </dd></param>
            <param name = "maxHeight"><dd>  <p>The height of the layout box.</p> </dd></param>
            <param name = "textLayout"><dd>  <p>When this method returns, contains an address of a reference to the resultant text layout object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368205</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateTextLayout([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] float maxWidth,[In] float maxHeight,[Out, Fast] IDWriteTextLayout** textLayout)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateTextLayout</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateGdiCompatibleTextLayout(System.String,System.Int32,SharpDX.DirectWrite.TextFormat,System.Single,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.TextLayout)">
            <summary>
            <p> Takes a string, format, and associated constraints, and produces an object representing the result, formatted for a particular display resolution and measuring mode.  </p>
            </summary>
            <param name = "text"><dd>  <p>An array of characters that contains the string to create a new <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> object from. This array must be of length <em>stringLength</em> and can contain embedded <strong><c>null</c></strong> characters.</p> </dd></param>
            <param name = "stringLength"><dd>  <p>The length of the string, in character count.</p> </dd></param>
            <param name = "textFormat"><dd>  <p>The text formatting object to apply to the string.</p> </dd></param>
            <param name = "layoutWidth"><dd>  <p>The width of the layout box.</p> </dd></param>
            <param name = "layoutHeight"><dd>  <p>The height of the layout box.</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI device <em>pixelsPerDip</em> is 1. If rendering onto a 120 DPI device <em>pixelsPerDip</em> is 1.25 (120/96).</p> </dd></param>
            <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specifies the font size and pixels per DIP.</p> </dd></param>
            <param name = "useGdiNatural"><dd>  <p> Instructs the text layout to use the same metrics as GDI bi-level text when set to <strong><see cref = "F:SharpDX.Result.False"/></strong>. When set to <strong>TRUE</strong>, instructs the text layout to use the same metrics as text measured by GDI using a font created with <strong>CLEARTYPE_NATURAL_QUALITY</strong>. </p> </dd></param>
            <param name = "textLayout"><dd>  <p>When this method returns, contains an address to the reference of the resultant text layout object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The resulting text layout should only be used for the intended resolution, and for cases where text scalability is desired <strong>CreateTextLayout</strong> should be used instead.</p>
            </remarks>
            <doc-id>dd368192</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateGdiCompatibleTextLayout([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] float layoutWidth,[In] float layoutHeight,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[Out, Fast] IDWriteTextLayout** textLayout)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateGdiCompatibleTextLayout</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateEllipsisTrimmingSign(SharpDX.DirectWrite.TextFormat,SharpDX.DirectWrite.InlineObjectNative)">
            <summary>
            <p> Creates an inline object for trimming, using an ellipsis as the omission sign. </p>
            </summary>
            <param name = "textFormat"><dd>  <p>A text format object, created with <strong>CreateTextFormat</strong>, used for text layout.</p> </dd></param>
            <param name = "trimmingSign"><dd>  <p>When this method returns, contains an address of a reference to the omission (that is, ellipsis trimming) sign created by this method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The ellipsis will be created using the current settings of the format, including base font, style, and any effects. Alternate omission signs can be created by the application by implementing <strong><see cref = "T:SharpDX.DirectWrite.InlineObject"/></strong>. </p>
            </remarks>
            <doc-id>dd368194</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateEllipsisTrimmingSign([In] IDWriteTextFormat* textFormat,[Out, Fast] IDWriteInlineObject** trimmingSign)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateEllipsisTrimmingSign</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateTextAnalyzer(SharpDX.DirectWrite.TextAnalyzer)">
            <summary>
            <p> Returns an interface for performing text analysis. </p>
            </summary>
            <param name = "textAnalyzer"><dd>  <p>When this method returns, contains an address of  a reference to the newly created text analyzer object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368202</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateTextAnalyzer([Out, Fast] IDWriteTextAnalyzer** textAnalyzer)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateTextAnalyzer</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateNumberSubstitution(SharpDX.DirectWrite.NumberSubstitutionMethod,System.String,SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.NumberSubstitution)">
            <summary>
            <p> Creates a number substitution object using a locale name, substitution method, and an indicator  whether to ignore user overrides (use NLS defaults for the given culture instead). </p>
            </summary>
            <param name = "substitutionMethod"><dd>  <p>A value that specifies how to apply number substitution on digits and related punctuation.</p> </dd></param>
            <param name = "localeName"><dd>  <p>The name of the locale to be used in the <em>numberSubstitution</em> object.</p> </dd></param>
            <param name = "ignoreUserOverride"><dd>  <p>A Boolean flag that indicates whether to ignore user overrides.</p> </dd></param>
            <param name = "numberSubstitution"><dd>  <p>When this method returns, contains an address to  a reference to the number substitution object created by this method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368200</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateNumberSubstitution([In] DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,[In] const wchar_t* localeName,[In] BOOL ignoreUserOverride,[Out, Fast] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateNumberSubstitution</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.DirectWrite.RenderingMode,SharpDX.Direct2D1.MeasuringMode,System.Single,System.Single,SharpDX.DirectWrite.GlyphRunAnalysis)">
            <summary>
            <p> Creates a glyph run analysis object, which encapsulates information used to render a glyph run. </p>
            </summary>
            <param name = "glyphRun"><dd>  <p>A structure that contains the properties of the glyph run (font face, advances, and so on).</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>Number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI bitmap then <em>pixelsPerDip</em> is 1. If rendering onto a 120 DPI bitmap then <em>pixelsPerDip</em> is 1.25.</p> </dd></param>
            <param name = "transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified the <em>emSize</em> and <em>pixelsPerDip</em>.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>A value that specifies the rendering mode, which must be one of the raster rendering modes (that is, not default and not outline).</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Specifies the measuring mode to use with glyphs.</p> </dd></param>
            <param name = "baselineOriginX"><dd>  <p>The horizontal position (X-coordinate) of the baseline origin, in DIPs.</p> </dd></param>
            <param name = "baselineOriginY"><dd>  <p>Vertical position (Y-coordinate) of the baseline origin, in DIPs.</p> </dd></param>
            <param name = "glyphRunAnalysis"><dd>  <p>When this method returns, contains an address of a reference to the newly created glyph run analysis object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The glyph run analysis object contains the results of analyzing the glyph run, including the positions of all the glyphs and references to all of the rasterized glyphs in the font cache. </p>
            </remarks>
            <doc-id>dd368198</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out, Fast] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateGlyphRunAnalysis</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateFontFace(SharpDX.DirectWrite.FontFaceType,System.Int32,SharpDX.ComArray{SharpDX.DirectWrite.FontFile},System.Int32,SharpDX.DirectWrite.FontSimulations,SharpDX.DirectWrite.FontFace)">
            <summary>
            <p> Creates an object that represents a font face. </p>
            </summary>
            <param name = "fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>
            <param name = "numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>
            <param name = "fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref = "T:SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>
            <param name = "faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>
            <param name = "fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368196</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory.CreateFontFace(SharpDX.DirectWrite.FontFaceType,System.Int32,System.IntPtr,System.Int32,SharpDX.DirectWrite.FontSimulations,System.IntPtr)">
            <summary>
            <p> Creates an object that represents a font face. </p>
            </summary>
            <param name = "fontFaceType"><dd>  <p>A value that indicates the type of file format of the font face.</p> </dd></param>
            <param name = "numberOfFiles"><dd>  <p>The number of font files, in element count, required to represent the font face.</p> </dd></param>
            <param name = "fontFiles"><dd>  <p>A font file object representing the font face.  Because <strong><see cref = "T:SharpDX.DirectWrite.FontFace"/></strong> maintains its own references to the input font file objects, you may release them after this call.</p> </dd></param>
            <param name = "faceIndex"><dd>  <p>The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero.</p> </dd></param>
            <param name = "fontFaceSimulationFlags"><dd>  <p>A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object, or <strong><c>null</c></strong> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd368196</doc-id>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFace([In] DWRITE_FONT_FACE_TYPE fontFaceType,[In] unsigned int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFactory::CreateFontFace</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Factory1">
            <summary>	
            <p>Creates a rendering parameters object with the specified properties.</p>	
            </summary>	
            <!-- No matching elements were found for the following include tag --><include file="..\Documentation\CodeComments.xml" path="/comments/comment[@id='IDWriteFactory1']/*" />	
            <msdn-id>Hh780402</msdn-id>	
            <unmanaged>IDWriteFactory1</unmanaged>	
            <unmanaged-short>IDWriteFactory1</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectWrite.Factory1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.DirectWrite.Factory1"/> class with the <see cref="F:SharpDX.DirectWrite.FactoryType.Shared"/> type.
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory1.#ctor(SharpDX.DirectWrite.FactoryType)">
            <summary>
            Creates a new instance of the <see cref="T:SharpDX.DirectWrite.Factory1"/> class.
            </summary>
            <param name="factoryType">The factory type.</param>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory1.GetEudcFontCollection(SharpDX.DirectWrite.FontCollection@,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Gets a font collection representing the set of EUDC (end-user defined characters) fonts.</p>
            </summary>
            <param name = "fontCollection"><dd>  <p>The font collection to fill.</p> </dd></param>
            <param name = "checkForUpdates"><dd>  <p>Whether to check for updates.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Note that if no EUDC is set on the system, the returned collection will be empty, meaning it will return success but GetFontFamilyCount will be zero.</p>
            </remarks>
            <doc-id>hh780403</doc-id>
            <unmanaged>HRESULT IDWriteFactory1::GetEudcFontCollection([Out] IDWriteFontCollection** fontCollection,[In] BOOL checkForUpdates)</unmanaged>
            <unmanaged-short>IDWriteFactory1::GetEudcFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory1.CreateCustomRenderingParams(System.Single,System.Single,System.Single,System.Single,SharpDX.DirectWrite.PixelGeometry,SharpDX.DirectWrite.RenderingMode,SharpDX.DirectWrite.RenderingParams1@)">
            <summary>
            <p>Creates a rendering parameters object with the specified properties.</p>
            </summary>
            <param name = "gamma"><dd>  <p>The gamma level to be set for the new rendering parameters object.</p> </dd></param>
            <param name = "enhancedContrast"><dd>  <p>The enhanced contrast level to be set for the new rendering parameters object.</p> </dd></param>
            <param name = "enhancedContrastGrayscale"><dd>  <p>The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</p> </dd></param>
            <param name = "clearTypeLevel"><dd>  <p>The ClearType level to be set for the new rendering parameters object.</p> </dd></param>
            <param name = "pixelGeometry"><dd>  <p>Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>A value that represents the method (for example, ClearType natural quality) for rendering glyphs.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p>When this method returns, contains an address of a reference to the newly created rendering parameters object.</p> </dd></param>
            <returns><p>Standard <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <doc-id>hh780402</doc-id>
            <unmanaged>HRESULT IDWriteFactory1::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float enhancedContrastGrayscale,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[Out] IDWriteRenderingParams1** renderingParams)</unmanaged>
            <unmanaged-short>IDWriteFactory1::CreateCustomRenderingParams</unmanaged-short>
        </member>
        <!-- Badly formed XML comment ignored for member "T:SharpDX.DirectWrite.Factory2" -->
        <member name="M:SharpDX.DirectWrite.Factory2.TranslateColorGlyphRun(System.Single,System.Single,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.MeasuringMode,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Int32,SharpDX.DirectWrite.ColorGlyphRunEnumerator@)">
            <summary>
            <p>This method is called on a glyph run to translate it in to multiple color glyph runs.</p>
            </summary>
            <param name = "baselineOriginX"><dd>  <p>The horizontal baseline origin of the original glyph run.</p> </dd></param>
            <param name = "baselineOriginY"><dd>  <p>The vertical baseline origin of the original glyph run.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>Original glyph run containing monochrome glyph IDs.</p> </dd></param>
            <param name = "glyphRunDescription"><dd>  <p>Optional glyph run description.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Measuring mode used to compute glyph positions if the run contains color glyphs.</p> </dd></param>
            <param name = "worldToDeviceTransform"><dd>  <p> World transform multiplied by any DPI scaling. This is needed to compute glyph positions if the run contains color glyphs and the  measuring mode is not <strong>DWRITE_MEASURING_MODE_NATURAL</strong>.  If this parameter is <strong><c>null</c></strong>, and identity transform is assumed. </p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p> Zero-based index of the color palette to use. Valid indices are less than the number of palettes in the font, as  returned by <strong>IDWriteFontFace2::GetColorPaletteCount</strong>. </p> </dd></param>
            <param name = "colorLayers"><dd>  <p> If the original glyph run contains color glyphs, this parameter receives a reference to  an <strong><see cref = "T:SharpDX.DirectWrite.ColorGlyphRunEnumerator"/></strong> interface.  The client uses the returned interface to get information about glyph runs and associated colors to render instead of the original glyph run.  If the original glyph run does not contain color glyphs, this method returns <strong>DWRITE_E_NOCOLOR</strong> and the output reference is <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If the code calls this method with a glyph run that contains no color information, the method returns <strong>DWRITE_E_NOCOLOR</strong> to  let the application know that it can just draw the original glyph run. If the glyph run contains color information, the function returns an object that can be enumerated through to expose runs and associated colors. The application then  calls <strong>DrawGlyphRun</strong> with each of the returned glyph runs and foreground colors. </p>
            </remarks>
            <msdn-id>dn280451</msdn-id>
            <unmanaged>HRESULT IDWriteFactory2::TranslateColorGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] const DWRITE_MATRIX* worldToDeviceTransform,[In] unsigned int colorPaletteIndex,[Out] IDWriteColorGlyphRunEnumerator** colorLayers)</unmanaged>
            <unmanaged-short>IDWriteFactory2::TranslateColorGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory2.TranslateColorGlyphRun(System.Single,System.Single,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.MeasuringMode,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Int32)">
            <summary>
            <p>This method is called on a glyph run to translate it in to multiple color glyph runs.</p>
            </summary>
            <param name = "baselineOriginX"><dd>  <p>The horizontal baseline origin of the original glyph run.</p> </dd></param>
            <param name = "baselineOriginY"><dd>  <p>The vertical baseline origin of the original glyph run.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>Original glyph run containing monochrome glyph IDs.</p> </dd></param>
            <param name = "glyphRunDescription"><dd>  <p>Optional glyph run description.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Measuring mode used to compute glyph positions if the run contains color glyphs.</p> </dd></param>
            <param name = "worldToDeviceTransform"><dd>  <p> World transform multiplied by any DPI scaling. This is needed to compute glyph positions if the run contains color glyphs and the  measuring mode is not <strong>DWRITE_MEASURING_MODE_NATURAL</strong>.  If this parameter is <strong><c>null</c></strong>, and identity transform is assumed. </p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p> Zero-based index of the color palette to use. Valid indices are less than the number of palettes in the font, as  returned by <strong>IDWriteFontFace2::GetColorPaletteCount</strong>. </p> </dd></param>
            <returns><dd>  <p> If the original glyph run contains color glyphs, this parameter receives a reference to  an <strong><see cref = "T:SharpDX.DirectWrite.ColorGlyphRunEnumerator"/></strong> interface.  The client uses the returned interface to get information about glyph runs and associated colors to render instead of the original glyph run.  If the original glyph run does not contain color glyphs, this method returns <strong>DWRITE_E_NOCOLOR</strong> and the output reference is <strong><c>null</c></strong>. </p> </dd></returns>
            <remarks>
            <p> If the code calls this method with a glyph run that contains no color information, the method returns <strong>DWRITE_E_NOCOLOR</strong> to  let the application know that it can just draw the original glyph run. If the glyph run contains color information, the function returns an object that can be enumerated through to expose runs and associated colors. The application then  calls <strong>DrawGlyphRun</strong> with each of the returned glyph runs and foreground colors. </p>
            </remarks>
            <msdn-id>dn280451</msdn-id>
            <unmanaged>HRESULT IDWriteFactory2::TranslateColorGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] const DWRITE_MATRIX* worldToDeviceTransform,[In] unsigned int colorPaletteIndex,[Out] IDWriteColorGlyphRunEnumerator** colorLayers)</unmanaged>
            <unmanaged-short>IDWriteFactory2::TranslateColorGlyphRun</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Factory2.SystemFontFallback">
            <summary>
            <p>Creates a font fallback object from the system font fallback list.</p>
            </summary>
            <doc-id>dn280450</doc-id>
            <unmanaged>GetSystemFontFallback</unmanaged>
            <unmanaged-short>GetSystemFontFallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory2.GetSystemFontFallback(SharpDX.DirectWrite.FontFallback@)">
            <summary>
            <p>Creates a font fallback object from the system font fallback list.</p>
            </summary>
            <param name = "fontFallback"><dd>  <p>Contains an address of a reference to the newly created font fallback object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280450</doc-id>
            <unmanaged>HRESULT IDWriteFactory2::GetSystemFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
            <unmanaged-short>IDWriteFactory2::GetSystemFontFallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory2.CreateFontFallbackBuilder(SharpDX.DirectWrite.FontFallbackBuilder@)">
            <summary>
            <p>Creates a font fallback builder object.</p><p>A font fall back builder allows you to create Unicode font fallback mappings and create a font fall back object from those mappings.</p>
            </summary>
            <param name = "fontFallbackBuilder"><dd>  <p>Contains an address of a reference to the newly created font fallback builder object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280449</doc-id>
            <unmanaged>HRESULT IDWriteFactory2::CreateFontFallbackBuilder([Out] IDWriteFontFallbackBuilder** fontFallbackBuilder)</unmanaged>
            <unmanaged-short>IDWriteFactory2::CreateFontFallbackBuilder</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory2.TryTranslateColorGlyphRun(System.Single,System.Single,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.MeasuringMode,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Int32,SharpDX.DirectWrite.ColorGlyphRunEnumerator@)">
            <summary>
            <p>This method is called on a glyph run to translate it in to multiple color glyph runs.</p>
            </summary>
            <param name = "baselineOriginX"><dd>  <p>The horizontal baseline origin of the original glyph run.</p> </dd></param>
            <param name = "baselineOriginY"><dd>  <p>The vertical baseline origin of the original glyph run.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>Original glyph run containing monochrome glyph IDs.</p> </dd></param>
            <param name = "glyphRunDescription"><dd>  <p>Optional glyph run description.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Measuring mode used to compute glyph positions if the run contains color glyphs.</p> </dd></param>
            <param name = "worldToDeviceTransform"><dd>  <p> World transform multiplied by any DPI scaling. This is needed to compute glyph positions if the run contains color glyphs and the  measuring mode is not <strong>DWRITE_MEASURING_MODE_NATURAL</strong>.  If this parameter is <strong><c>null</c></strong>, and identity transform is assumed. </p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p> Zero-based index of the color palette to use. Valid indices are less than the number of palettes in the font, as  returned by <strong>IDWriteFontFace2::GetColorPaletteCount</strong>. </p> </dd></param>
            <param name = "colorLayers"><dd>  <p> If the original glyph run contains color glyphs, this parameter receives a reference to  an <strong><see cref = "T:SharpDX.DirectWrite.ColorGlyphRunEnumerator"/></strong> interface.  The client uses the returned interface to get information about glyph runs and associated colors to render instead of the original glyph run.  If the original glyph run does not contain color glyphs, this method returns <strong>DWRITE_E_NOCOLOR</strong> and the output reference is <strong><c>null</c></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If the code calls this method with a glyph run that contains no color information, the method returns <strong>DWRITE_E_NOCOLOR</strong> to  let the application know that it can just draw the original glyph run. If the glyph run contains color information, the function returns an object that can be enumerated through to expose runs and associated colors. The application then  calls <strong>DrawGlyphRun</strong> with each of the returned glyph runs and foreground colors. </p>
            </remarks>
            <doc-id>dn280451</doc-id>
            <unmanaged>HRESULT IDWriteFactory2::TranslateColorGlyphRun([In] float baselineOriginX,[In] float baselineOriginY,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] const DWRITE_MATRIX* worldToDeviceTransform,[In] unsigned int colorPaletteIndex,[Out] IDWriteColorGlyphRunEnumerator** colorLayers)</unmanaged>
            <unmanaged-short>IDWriteFactory2::TranslateColorGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory2.CreateCustomRenderingParams(System.Single,System.Single,System.Single,System.Single,SharpDX.DirectWrite.PixelGeometry,SharpDX.DirectWrite.RenderingMode,SharpDX.DirectWrite.GridFitMode,SharpDX.DirectWrite.RenderingParams2@)">
            <summary>
            <p>Creates a rendering parameters object with the specified properties.</p>
            </summary>
            <param name = "gamma"><dd>  <p>The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</p> </dd></param>
            <param name = "enhancedContrast"><dd>  <p>The amount of contrast enhancement, zero or greater.</p> </dd></param>
            <param name = "grayscaleEnhancedContrast"><dd>  <p>The amount of contrast enhancement, zero or greater.</p> </dd></param>
            <param name = "clearTypeLevel"><dd>  <p>The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</p> </dd></param>
            <param name = "pixelGeometry"><dd>  <p>The geometry of a device pixel.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</p> </dd></param>
            <param name = "gridFitMode"><dd>  <p>How to grid fit glyph outlines. In most cases, this should be DWRITE_GRID_FIT_DEFAULT to automatically choose an appropriate mode.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p>Holds the newly created rendering parameters object, or <c>null</c> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894552</doc-id>
            <unmanaged>HRESULT IDWriteFactory2::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float grayscaleEnhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[Out] IDWriteRenderingParams2** renderingParams)</unmanaged>
            <unmanaged-short>IDWriteFactory2::CreateCustomRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory2.CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.DirectWrite.RenderingMode,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GridFitMode,SharpDX.DirectWrite.TextAntialiasMode,System.Single,System.Single,SharpDX.DirectWrite.GlyphRunAnalysis@)">
            <summary>
            <p>Creates a glyph run analysis object, which encapsulates information used to render a glyph run.</p>
            </summary>
            <param name = "glyphRun"><dd>  <p>Structure specifying the properties of the glyph run.</p> </dd></param>
            <param name = "transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the emSize and pixelsPerDip.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>Specifies the rendering mode, which must be one of the raster rendering modes (i.e., not default and not outline).</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Specifies the method to measure glyphs.</p> </dd></param>
            <param name = "gridFitMode"><dd>  <p>How to grid-fit glyph outlines. This must be non-default.</p> </dd></param>
            <param name = "antialiasMode"><dd>  <p>Specifies the antialias mode.</p> </dd></param>
            <param name = "baselineOriginX"><dd>  <p>Horizontal position of the baseline origin, in DIPs.</p> </dd></param>
            <param name = "baselineOriginY"><dd>  <p>Vertical position of the baseline origin, in DIPs.</p> </dd></param>
            <param name = "glyphRunAnalysis"><dd>  <p>Receives a reference to the newly created object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894553</doc-id>
            <unmanaged>HRESULT IDWriteFactory2::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
            <unmanaged-short>IDWriteFactory2::CreateGlyphRunAnalysis</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection.#ctor(SharpDX.DirectWrite.Factory,SharpDX.DirectWrite.FontCollectionLoader,SharpDX.DataPointer)">
            <summary>	
            Creates a font collection using a custom font collection loader. 	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="collectionLoader">An application-defined font collection loader, which must have been previously registered using <see cref="M:SharpDX.DirectWrite.Factory.RegisterFontCollectionLoader_(SharpDX.DirectWrite.FontCollectionLoader)"/>. </param>
            <param name="collectionKey">The key used by the loader to identify a collection of font files.  The buffer allocated for this key should at least be the size of collectionKeySize. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateCustomFontCollection([None] IDWriteFontCollectionLoader* collectionLoader,[In, Buffer] const void* collectionKey,[None] int collectionKeySize,[Out] IDWriteFontCollection** fontCollection)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.FontCollection.FontFamilyCount">
            <summary>
            <p> Gets the number of font families in the collection. </p>
            </summary>
            <doc-id>dd370974</doc-id>
            <unmanaged>GetFontFamilyCount</unmanaged>
            <unmanaged-short>GetFontFamilyCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection.GetFontFamilyCount">
            <summary>
            <p> Gets the number of font families in the collection. </p>
            </summary>
            <returns><p>The number of font families in the collection.</p></returns>
            <doc-id>dd370974</doc-id>
            <unmanaged>unsigned int IDWriteFontCollection::GetFontFamilyCount()</unmanaged>
            <unmanaged-short>IDWriteFontCollection::GetFontFamilyCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection.GetFontFamily(System.Int32)">
            <summary>
            <p> Creates a font family object given a zero-based font family index. </p>
            </summary>
            <param name = "index"><dd>  <p>Zero-based index of the font family.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of   a reference to the newly created font family object.</p> </dd></returns>
            <doc-id>dd370970</doc-id>
            <unmanaged>HRESULT IDWriteFontCollection::GetFontFamily([In] unsigned int index,[Out] IDWriteFontFamily** fontFamily)</unmanaged>
            <unmanaged-short>IDWriteFontCollection::GetFontFamily</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection.FindFamilyName(System.String,System.Int32@)">
            <summary>
            <p> Finds the font family with the specified family name. </p>
            </summary>
            <param name = "familyName"><dd>  <p>An array of characters, which is null-terminated, containing the name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</p> </dd></param>
            <param name = "index"><dd>  <p>When this method returns, contains the zero-based index of the matching font family if the family name was found; otherwise, <strong>UINT_MAX</strong>.</p> </dd></param>
            <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the family name exists; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <doc-id>dd368217</doc-id>
            <unmanaged>HRESULT IDWriteFontCollection::FindFamilyName([In] const wchar_t* familyName,[Out] unsigned int* index,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFontCollection::FindFamilyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection.GetFontFromFontFace(SharpDX.DirectWrite.FontFace)">
            <summary>
            <p> Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong  to the font collection. </p>
            </summary>
            <param name = "fontFace"><dd>  <p>A font face object that specifies the physical font.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created font object if successful; otherwise, <strong><c>null</c></strong>.</p> </dd></returns>
            <doc-id>dd370978</doc-id>
            <unmanaged>HRESULT IDWriteFontCollection::GetFontFromFontFace([In] IDWriteFontFace* fontFace,[Out] IDWriteFont** font)</unmanaged>
            <unmanaged-short>IDWriteFontCollection::GetFontFromFontFace</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollectionLoader.CreateEnumeratorFromKey(SharpDX.DirectWrite.Factory,SharpDX.DataPointer)">
            <summary>	
            Creates a font file enumerator object that encapsulates a collection of font files. The font system calls back to this interface to create a font collection. 	
            </summary>	
            <param name="factory">Pointer to the <see cref="T:SharpDX.DirectWrite.Factory"/> object that was used to create the current font collection. </param>
            <param name="collectionKey">A font collection key that uniquely identifies the collection of font files within the scope of the font collection loader being used. The buffer allocated for this key must be at least  the size, in bytes, specified by collectionKeySize. </param>
            <returns>a reference to the newly created font file enumerator.</returns>
            <unmanaged>HRESULT IDWriteFontCollectionLoader::CreateEnumeratorFromKey([None] IDWriteFactory* factory,[In, Buffer] const void* collectionKey,[None] int collectionKeySize,[Out] IDWriteFontFileEnumerator** fontFileEnumerator)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.FontCollectionLoaderShadow">
            <summary>
            Internal FontCollectionLoader Callback
            </summary>
        </member>
        <member name="T:SharpDX.DirectWrite.FontCollectionLoaderShadow.FontCollectionLoaderVtbl.CreateEnumeratorFromKeyDelegate">
            <unmanaged>HRESULT IDWriteFontCollectionLoader::CreateEnumeratorFromKey([None] IDWriteFactory* factory,[In, Buffer] const void* collectionKey,[None] int collectionKeySize,[Out] IDWriteFontFileEnumerator** fontFileEnumerator)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.#ctor(SharpDX.DirectWrite.Factory,SharpDX.DirectWrite.FontFaceType,SharpDX.DirectWrite.FontFile[],System.Int32,SharpDX.DirectWrite.FontSimulations)">
            <summary>	
            Creates an object that represents a font face. 	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="fontFaceType">A value that indicates the type of file format of the font face. </param>
            <param name="fontFiles">A font file object representing the font face. Because<see cref="T:SharpDX.DirectWrite.FontFace" /> maintains its own references to the input font file objects, you may release them after this call. </param>
            <param name="faceIndex">The zero-based index of a font face, in cases when the font files contain a collection of font faces. If the font files contain a single face, this value should be zero. </param>
            <param name="fontFaceSimulationFlags">A value that indicates which, if any, font face simulation flags for algorithmic means of making text bold or italic are applied to the current font face. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFace([None] DWRITE_FONT_FACE_TYPE fontFaceType,[None] int numberOfFiles,[In, Buffer] const IDWriteFontFile** fontFiles,[None] int faceIndex,[None] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out] IDWriteFontFace** fontFace)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.#ctor(SharpDX.DirectWrite.Font)">
            <summary>	
            Creates a font face object for the font. 	
            </summary>	
            <param name="font">the <see cref="T:SharpDX.DirectWrite.Font"/> to create the FontFace from.</param>
            <unmanaged>HRESULT IDWriteFont::CreateFontFace([Out] IDWriteFontFace** fontFace)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetDesignGlyphMetrics(System.Int16[],System.Boolean)">
            <summary>	
            Obtains ideal (resolution-independent) glyph metrics in font design units.  	
            </summary>	
            <remarks>	
            Design glyph metrics are used for glyph positioning. 	
            </remarks>	
            <param name="glyphIndices">An array of glyph indices for which to compute  metrics. The array must contain at least as many elements as specified by glyphCount. </param>
            <param name="isSideways">Indicates whether the font is being used in a sideways run. This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation </param>
            <returns>an array of <see cref="T:SharpDX.DirectWrite.GlyphMetrics"/> structures. </returns>
            <unmanaged>HRESULT IDWriteFontFace::GetDesignGlyphMetrics([In, Buffer] const short* glyphIndices,[None] int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[None] BOOL isSideways)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGdiCompatibleGlyphMetrics(System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Boolean,System.Int16[],System.Boolean)">
            <summary>	
            Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.	
            </summary>	
            <param name="fontSize">The logical size of the font in DIP units. </param>
            <param name="pixelsPerDip">The number of physical pixels per DIP. </param>
            <param name="transform">An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip. </param>
            <param name="useGdiNatural">When set to FALSE, the metrics are the same as the metrics of GDI aliased text.  When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY. </param>
            <param name="glyphIndices">An array of glyph indices for which to compute the metrics. </param>
            <param name="isSideways">A BOOL value that indicates whether the font is being used in a sideways run.  This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation. </param>
            <returns>An array of <see cref="T:SharpDX.DirectWrite.GlyphMetrics" /> structures filled by this function. The metrics are in font design units. </returns>
            <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleGlyphMetrics([None] float emSize,[None] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] BOOL useGdiNatural,[In, Buffer] const short* glyphIndices,[None] int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[None] BOOL isSideways)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGlyphIndices(System.Int32[])">
            <summary>	
            Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table. 	
            </summary>	
            <remarks>	
            Note that this mapping is primarily provided for line layout engines built on top of the physical font API. Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond to how a Unicode string will map to glyph indices when rendering using a particular font face. Also, note that Unicode variant selectors provide for alternate mappings for character to glyph. This call will always return the default variant.  	
            </remarks>	
            <param name="codePoints">An array of USC4 code points from which to obtain nominal glyph indices. The array must be allocated and be able to contain the number of elements specified by codePointCount. </param>
            <returns>a reference to an array of nominal glyph indices filled by this function.</returns>
            <unmanaged>HRESULT IDWriteFontFace::GetGlyphIndices([In, Buffer] const int* codePoints,[None] int codePointCount,[Out, Buffer] short* glyphIndices)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetFiles">
            <summary>	
            Obtains the font files representing a font face. 	
            </summary>	
            <remarks>	
            The IDWriteFontFace::GetFiles method should be called twice.  The first time you call GetFilesfontFiles should be NULL. When the method returns, numberOfFiles receives the number of font files that represent the font face. Then, call the method a second time, passing the numberOfFiles value that was output the first call, and a non-null buffer of the correct size to store the <see cref="T:SharpDX.DirectWrite.FontFile"/> references. 	
            </remarks>	
            <returns>An array that stores references to font files representing the font face. This parameter can be NULL if the user wants only the number of files representing the font face. This API increments reference count of the font file references returned according to COM conventions, and the client should release them when finished. </returns>
            <unmanaged>HRESULT IDWriteFontFace::GetFiles([InOut] int* numberOfFiles,[Out, Buffer, Optional] IDWriteFontFile** fontFiles)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.TryGetFontTable(System.Int32,SharpDX.DataPointer@,System.IntPtr@)">
            <summary>	
            Finds the specified OpenType font table if it exists and returns a reference to it. The function accesses the underlying font data through the <see cref="T:SharpDX.DirectWrite.FontFileStream" /> interface implemented by the font file loader. 	
            </summary>	
            <remarks>	
            The context for the same tag may be different for each call, so each one must be held and released separately.  	
            </remarks>	
            <param name="openTypeTableTag">The four-character tag of a OpenType font table to find. Use the DWRITE_MAKE_OPENTYPE_TAG macro to create it as an UINT32. Unlike GDI, it does not support the special TTCF and null tags to access the whole font. </param>
            <param name="tableData">When this method returns, contains the address of  a reference to the base of the table in memory. The reference is valid only as long as the font face used to get the font table still exists; (not any other font face, even if it actually refers to the same physical font).</param>
            <param name="tableContext">When this method returns, the address of a reference to  the opaque context, which must be freed by calling {{ReleaseFontTable}}. The context actually comes from the lower-level <see cref="T:SharpDX.DirectWrite.FontFileStream" />, which may be implemented by the application or DWrite itself. It is possible for a NULL tableContext to be returned, especially if the implementation performs direct memory mapping on the whole file. Nevertheless, always release it later, and do not use it as a test for function success. The same table can be queried multiple times, but because each returned context can be different, you must release each context separately.  </param>
            <returns>TRUE if the font table exists; otherwise, FALSE. </returns>
            <unmanaged>HRESULT IDWriteFontFace::TryGetFontTable([In] int openTypeTableTag,[Out, Buffer] const void** tableData,[Out] int* tableSize,[Out] void** tableContext,[Out] BOOL* exists)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace.FaceType">
            <summary>
            <p> Obtains the file format type of a font face. </p>
            </summary>
            <doc-id>dd371031</doc-id>
            <unmanaged>GetType</unmanaged>
            <unmanaged-short>GetType</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace.Index">
            <summary>
            <p> Obtains the index of a font face in the context of its font files. </p>
            </summary>
            <doc-id>dd371007</doc-id>
            <unmanaged>GetIndex</unmanaged>
            <unmanaged-short>GetIndex</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace.Simulations">
            <summary>
            <p> Obtains the algorithmic style simulation flags of a font face. </p>
            </summary>
            <doc-id>dd371018</doc-id>
            <unmanaged>GetSimulations</unmanaged>
            <unmanaged-short>GetSimulations</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace.IsSymbolFont">
            <summary>
            <p> Determines whether the font is a symbol font. </p>
            </summary>
            <doc-id>dd371034</doc-id>
            <unmanaged>IsSymbolFont</unmanaged>
            <unmanaged-short>IsSymbolFont</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace.Metrics">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <doc-id>dd371011</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace.GlyphCount">
            <summary>
            <p> Obtains the number of glyphs in the font face. </p>
            </summary>
            <doc-id>dd370993</doc-id>
            <unmanaged>GetGlyphCount</unmanaged>
            <unmanaged-short>GetGlyphCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetFaceType">
            <summary>
            <p> Obtains the file format type of a font face. </p>
            </summary>
            <returns><p>A value that indicates the type of format for the font face (such as Type 1, TrueType, vector, or bitmap).</p></returns>
            <doc-id>dd371031</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE IDWriteFontFace::GetType()</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetFiles(System.Int32@,SharpDX.DirectWrite.FontFile[])">
            <summary>
            <p> Obtains the font files representing a font face. </p>
            </summary>
            <param name = "numberOfFiles"><dd>  <p>If <em>fontFiles</em> is <strong><c>null</c></strong>, receives the number of files representing the font face.  Otherwise, the number of font files being requested should be passed.  See the Remarks section below for more information.</p> </dd></param>
            <param name = "fontFiles"><dd>  <p>When this method returns, contains a reference to a user-provided array that stores references to font files representing the font face. This parameter can be <strong><c>null</c></strong> if the user wants only the number of files representing the font face. This API increments reference count of the font file references returned according to COM conventions, and the client should release them when finished.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The <strong>IDWriteFontFace::GetFiles</strong> method should be called twice.  The first time you call <strong>GetFiles</strong><em>fontFiles</em> should be <strong><c>null</c></strong>. When the method returns, <em>numberOfFiles</em> receives the number of font files that represent the font face.</p><p>Then, call the method a second time, passing the <em>numberOfFiles</em> value that was output the first call, and a non-null buffer of the correct size to store the <strong><see cref = "T:SharpDX.DirectWrite.FontFile"/></strong> references.</p>
            </remarks>
            <doc-id>dd370989</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetFiles([InOut] unsigned int* numberOfFiles,[Out, Buffer, Optional] IDWriteFontFile** fontFiles)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetFiles</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetIndex">
            <summary>
            <p> Obtains the index of a font face in the context of its font files. </p>
            </summary>
            <returns><p>The zero-based index of a font face in cases when the font files contain a collection of font faces. If the font files contain a single face, this value is zero.</p></returns>
            <doc-id>dd371007</doc-id>
            <unmanaged>unsigned int IDWriteFontFace::GetIndex()</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetSimulations">
            <summary>
            <p> Obtains the algorithmic style simulation flags of a font face. </p>
            </summary>
            <returns><p>Font face simulation flags for algorithmic means of making text bold or italic.</p></returns>
            <doc-id>dd371018</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFontFace::GetSimulations()</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetSimulations</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.IsSymbolFont_">
            <summary>
            <p> Determines whether the font is a symbol font. </p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the font is a symbol font, otherwise <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <doc-id>dd371034</doc-id>
            <unmanaged>BOOL IDWriteFontFace::IsSymbolFont()</unmanaged>
            <unmanaged-short>IDWriteFontFace::IsSymbolFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetMetrics(SharpDX.DirectWrite.FontMetrics@)">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <param name = "fontFaceMetrics"><dd>  <p>When this method returns, a?<strong><see cref = "T:SharpDX.DirectWrite.FontMetrics"/></strong> structure that holds metrics (such as ascent, descent, or cap height) for the current font face element. The metrics returned by this function are in font design units.</p> </dd></param>
            <doc-id>dd371011</doc-id>
            <unmanaged>void IDWriteFontFace::GetMetrics([Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGlyphCount">
            <summary>
            <p> Obtains the number of glyphs in the font face. </p>
            </summary>
            <returns><p>The number of glyphs in the font face.</p></returns>
            <doc-id>dd370993</doc-id>
            <unmanaged>unsigned short IDWriteFontFace::GetGlyphCount()</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetGlyphCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetDesignGlyphMetrics(System.Int16[],System.Int32,SharpDX.DirectWrite.GlyphMetrics[],SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p> Obtains ideal (resolution-independent) glyph metrics in font design units.  </p>
            </summary>
            <param name = "glyphIndices"><dd>  <p> An array of glyph indices for which to compute  metrics. The array must contain at least as many elements as specified by <em>glyphCount</em>.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>The number of elements in the <em>glyphIndices</em> array.</p> </dd></param>
            <param name = "glyphMetrics"><dd>  <p>When this method returns, contains an array of <see cref = "T:SharpDX.DirectWrite.GlyphMetrics"/> structures.  <em>glyphMetrics</em> must be initialized with an empty buffer that contains at least as many elements as <em>glyphCount</em>. The metrics returned by this function are in font design units.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Indicates whether the font is being used in a sideways run. This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Design glyph metrics are used for glyph positioning.</p>
            </remarks>
            <doc-id>dd370986</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetDesignGlyphMetrics([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[In] BOOL isSideways)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetDesignGlyphMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGlyphIndices(System.Int32[],System.Int32,System.Int16[])">
            <summary>
            <p> Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table. </p>
            </summary>
            <param name = "codePoints"><dd>  <p>An array of USC4 code points from which to obtain nominal glyph indices. The array must be allocated and be able to contain the number of elements specified by <em>codePointCount</em>.</p> </dd></param>
            <param name = "codePointCount"><dd>  <p>The number of elements in the <em>codePoints</em> array.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>When this method returns, contains a reference to an array of nominal glyph indices filled by this function.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Note that this mapping is primarily provided for line layout engines built on top of the physical font API. Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond to how a Unicode string will map to glyph indices when rendering using a particular font face. Also, note that Unicode variant selectors provide for alternate mappings for character to glyph. This call will always return the default variant.</p><p> When characters are not present in the font this method returns the index 0, which is the undefined glyph or ".notdef" glyph.  If a character isn't in a font, IDWriteFont::HasCharacter returns false and GetUnicodeRanges doesn't return it in the range.</p>
            </remarks>
            <doc-id>dd370998</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetGlyphIndicesW([In, Buffer] const unsigned int* codePoints,[In] unsigned int codePointCount,[Out, Buffer] unsigned short* glyphIndices)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetGlyphIndicesW</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.TryGetFontTable(System.Int32,System.IntPtr,System.Int32@,System.IntPtr@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> Finds the specified OpenType font table if it exists and returns a reference to it. The function accesses the underlying font data through the <strong><see cref = "T:SharpDX.DirectWrite.FontFileStream"/></strong> interface implemented by the font file loader. </p>
            </summary>
            <param name = "openTypeTableTag">No documentation.</param>
            <param name = "tableData">No documentation.</param>
            <param name = "tableSize">No documentation.</param>
            <param name = "tableContext">No documentation.</param>
            <param name = "exists">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The context for the same tag may be different for each call, so each one must be held and released separately. </p>
            </remarks>
            <doc-id>dd371039</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::TryGetFontTable([In] unsigned int openTypeTableTag,[Out, Buffer] const void** tableData,[Out] unsigned int* tableSize,[Out] void** tableContext,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFontFace::TryGetFontTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.ReleaseFontTable(System.IntPtr)">
            <summary>
            <p> Releases the table obtained earlier from <strong>TryGetFontTable</strong>. </p>
            </summary>
            <param name = "tableContext">No documentation.</param>
            <doc-id>dd371036</doc-id>
            <unmanaged>void IDWriteFontFace::ReleaseFontTable([In] void* tableContext)</unmanaged>
            <unmanaged-short>IDWriteFontFace::ReleaseFontTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGlyphRunOutline(System.Single,System.Int16[],System.Single[],SharpDX.DirectWrite.GlyphOffset[],System.Int32,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,SharpDX.Direct2D1.SimplifiedGeometrySink)">
            <summary>
            <p> Computes the outline of a run of glyphs by calling back to the outline sink interface. </p>
            </summary>
            <param name = "emSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>An array of glyph indices. The glyphs are in logical order and the advance direction depends on the <em>isRightToLeft</em> parameter. The array must be allocated and be able to contain the number of elements specified by <em>glyphCount</em>.</p> </dd></param>
            <param name = "glyphAdvances"><dd>  <p>An optional array of glyph advances in DIPs. The advance of a glyph is the amount to advance the position (in the direction of the baseline) after drawing the glyph. <em>glyphAdvances</em> contains the number of elements specified by <em>glyphCount</em>.</p> </dd></param>
            <param name = "glyphOffsets"><dd>  <p>An optional array of glyph offsets, each of which specifies the offset along the baseline and offset perpendicular to the baseline of a glyph relative to the current pen position.   <em>glyphOffsets</em> contains the number of elements specified by <em>glyphCount</em>.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>The number of glyphs in the run.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>If <strong>TRUE</strong>, the ascender of the glyph runs alongside the baseline. If <strong><see cref = "F:SharpDX.Result.False"/></strong>, the glyph ascender runs perpendicular to the baseline. For example, an English alphabet on a vertical baseline would have <em>isSideways</em> set to <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> <p>A client can render a vertical run by setting <em>isSideways</em> to <strong>TRUE</strong> and rotating the resulting geometry 90 degrees to the right using a transform. The <em>isSideways</em> and <em>isRightToLeft</em> parameters cannot both be true.</p> </dd></param>
            <param name = "isRightToLeft"><dd>  <p>The visual order of the glyphs. If this parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>, then glyph advances are from left to right. If <strong>TRUE</strong>, the advance direction is right to left. By default, the advance direction is left to right.</p> </dd></param>
            <param name = "geometrySink"><dd>  <p>A reference to the interface that is called back to perform outline drawing operations.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371003</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetGlyphRunOutline([In] float emSize,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer, Optional] const float* glyphAdvances,[In, Buffer, Optional] const DWRITE_GLYPH_OFFSET* glyphOffsets,[In] unsigned int glyphCount,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetGlyphRunOutline</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetRecommendedRenderingMode(System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.RenderingParams)">
            <summary>
            <p> Determines the recommended rendering mode for the font, using the specified size and rendering parameters. </p>
            </summary>
            <param name = "emSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: </p> <ul> <li>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for <strong>DWRITE_MEASURING_MODE_NATURAL</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for <strong>DWRITE_MEASURING_MODE_GDI_CLASSIC</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for <strong>DWRITE_MEASURING_MODE_GDI_NATURAL</strong> </li> </ul> </dd></param>
            <param name = "renderingParams"><dd>  <p>A reference to an object that contains rendering settings such as gamma level, enhanced contrast, and ClearType level. This parameter is necessary in case the rendering parameters  object overrides the rendering mode.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a value that indicates the recommended rendering mode to use.</p> </dd></returns>
            <doc-id>dd371015</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetRecommendedRenderingMode([In] float emSize,[In] float pixelsPerDip,[In] DWRITE_MEASURING_MODE measuringMode,[In] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetRecommendedRenderingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGdiCompatibleMetrics(System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2})">
            <summary>
            <p>Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.</p>
            </summary>
            <param name = "emSize"><dd>  <p>The logical size of the font in DIP units.</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>
            <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>
            <returns><dd>  <p>A reference to a <strong>DWRITE_FONT_METRIC</strong>S structure to fill in. The metrics returned by this function are in font design units.</p> </dd></returns>
            <doc-id>dd941789</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS* fontFaceMetrics)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetGdiCompatibleMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace.GetGdiCompatibleGlyphMetrics(System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,System.Int16[],System.Int32,SharpDX.DirectWrite.GlyphMetrics[],SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.</p>
            </summary>
            <param name = "emSize"><dd>  <p>The ogical size of the font in DIP units.</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>
            <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>
            <param name = "useGdiNatural"><dd>  <p>When set to <strong><see cref = "F:SharpDX.Result.False"/></strong>, the metrics are the same as the metrics of GDI aliased text.  When set to <strong>TRUE</strong>, the metrics are the same as the metrics of text measured by GDI using a font created with <strong>CLEARTYPE_NATURAL_QUALITY</strong>.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>An array of glyph indices for which to compute the metrics.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>The number of elements in the <em>glyphIndices</em> array.</p> </dd></param>
            <param name = "glyphMetrics"><dd>  <p>An array of <strong><see cref = "T:SharpDX.DirectWrite.GlyphMetrics"/></strong> structures filled by this function. The metrics are in font design units.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>A <see cref = "T:SharpDX.Mathematics.Interop.RawBool"/> value that indicates whether the font is being used in a sideways run.  This can affect the glyph metrics if the font has oblique simulation because sideways oblique simulation differs from non-sideways oblique simulation.</p> </dd></param>
            <returns><p>Standard <strong><see cref = "T:SharpDX.Result"/></strong> error code. If any of the input glyph indices are outside of the valid glyph index range for the current font face, <strong>E_INVALIDARG</strong> will be returned.</p></returns>
            <doc-id>dd941788</doc-id>
            <unmanaged>HRESULT IDWriteFontFace::GetGdiCompatibleGlyphMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[Out, Buffer] DWRITE_GLYPH_METRICS* glyphMetrics,[In] BOOL isSideways)</unmanaged>
            <unmanaged-short>IDWriteFontFace::GetGdiCompatibleGlyphMetrics</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFeature">
            <summary>
            <p>Specifies properties used to identify and execute typographic features in the current font face.</p>
            </summary>
            <remarks>
            <p>A non-zero value generally enables the feature execution, while the zero value disables it. A feature requiring a selector uses this value to indicate the selector index.</p><p>The OpenType standard provides access to typographic features available in the font by means of a feature tag with the associated parameters. The OpenType feature tag is a 4-byte identifier of the registered name of a feature. For example, the 'kern' feature name tag is used to identify the 'Kerning' feature in OpenType font. Similarly, the OpenType feature tag for 'Standard Ligatures' and 'Fractions' is 'liga' and 'frac' respectively. Since a single run can be associated with more than one typographic features, the Text String API accepts typographic settings for a run as a list of features and are executed in the order they are specified.</p><p>The value of the tag member represents the OpenType name tag of the feature, while the param value represents additional parameter for the execution of the feature referred by the tag member. Both <strong>nameTag</strong> and <strong>parameter</strong> are stored as little endian, the same convention followed by GDI.  Most features treat the Param value as a binary value that indicates whether to turn the execution of the feature on or off, with it being off by default in the majority of cases. Some features, however, treat this value as an integral value representing the integer index to the list of alternate results it may produce during the execution; for instance, the feature 'Stylistic Alternates' or 'salt' uses the <strong>parameter</strong> value as an index to the list of alternate substituting glyphs it could produce for a specified glyph. </p>
            </remarks>
            <doc-id>dd368066</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFeature.#ctor(SharpDX.DirectWrite.FontFeatureTag,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DirectWrite.FontFeature"/> struct.
            </summary>
            <param name="nameTag">The name tag.</param>
            <param name="parameter">The parameter.</param>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeature.NameTag">
            <summary>
            <dd> <p>The feature OpenType name identifier.</p> </dd>
            </summary>
            <doc-id>dd368066</doc-id>
            <unmanaged>nameTag</unmanaged>
            <unmanaged-short>nameTag</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeature.Parameter">
            <summary>
            <dd> <p>The execution parameter of the feature.</p> </dd>
            </summary>
            <doc-id>dd368066</doc-id>
            <unmanaged>parameter</unmanaged>
            <unmanaged-short>parameter</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.#ctor(SharpDX.DirectWrite.Factory,System.String)">
            <summary>	
            Creates a font file reference object from a local font file. 	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="filePath">An array of characters that contains the absolute file path for the font file. Subsequent operations on the constructed object may fail if the user provided filePath doesn't correspond to a valid file on the disk. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFileReference([In] const wchar_t* filePath,[In, Optional] const __int64* lastWriteTime,[Out] IDWriteFontFile** fontFile)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.#ctor(SharpDX.DirectWrite.Factory,System.String,System.Nullable{System.Int64})">
            <summary>	
            Creates a font file reference object from a local font file. 	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="filePath">An array of characters that contains the absolute file path for the font file. Subsequent operations on the constructed object may fail if the user provided filePath doesn't correspond to a valid file on the disk. </param>
            <param name="lastWriteTime">The last modified time of the input file path. If the parameter is omitted, the function will access the font file to obtain its last write time. You should specify this value to avoid extra disk access. Subsequent operations on the constructed object may fail if the user provided lastWriteTime doesn't match the file on the disk. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateFontFileReference([In] const wchar_t* filePath,[In, Optional] const __int64* lastWriteTime,[Out] IDWriteFontFile** fontFile)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.#ctor(SharpDX.DirectWrite.Factory,System.IntPtr,System.Int32,SharpDX.DirectWrite.FontFileLoader)">
            <summary>
            Creates a reference to an application-specific font file resource.
            </summary>
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="fontFileReferenceKey">A font file reference key that uniquely identifies the font file resource during the lifetime of fontFileLoader.</param>
            <param name="fontFileReferenceKeySize">The size of the font file reference key in bytes.</param>
            <param name="fontFileLoader">The font file loader that will be used by the font system to load data from the file identified by fontFileReferenceKey.</param>
            <remarks>
            This function is provided for cases when an application or a document needs to use a private font without having to install it on the system. fontFileReferenceKey has to be unique only in the scope of the fontFileLoader used in this call.
            </remarks>
            <unmanaged>HRESULT IDWriteFactory::CreateCustomFontFileReference([In, Buffer] const void* fontFileReferenceKey,[None] int fontFileReferenceKeySize,[None] IDWriteFontFileLoader* fontFileLoader,[Out] IDWriteFontFile** fontFile)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFile.Loader">
            <summary>	
            Obtains the file loader associated with a font file object. 	
            </summary>	
            <unmanaged>HRESULT IDWriteFontFile::GetLoader([Out] IDWriteFontFileLoader** fontFileLoader)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.GetReferenceKey">
            <summary>	
            Obtains the reference to the reference key of a font file. The returned reference is valid until the font file object is released.  	
            </summary>	
            <returns>the reference to the reference key of a font file. </returns>
            <unmanaged>HRESULT IDWriteFontFile::GetReferenceKey([Out, Buffer] const void** fontFileReferenceKey,[Out] int* fontFileReferenceKeySize)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.GetReferenceKey(System.IntPtr,System.Int32@)">
            <summary>
            <p> Obtains the reference to the reference key of a font file. The returned reference is valid until the font file object is released.  </p>
            </summary>
            <param name = "fontFileReferenceKey"><dd>  <p>When this method returns, contains an address of  a reference to the font file reference key. Note that the reference value is only valid until the font file object it is obtained from is released. This parameter is passed uninitialized.</p> </dd></param>
            <param name = "fontFileReferenceKeySize"><dd>  <p>When this method returns, contains the size of the font file reference key in bytes. This parameter is passed uninitialized.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371108</doc-id>
            <unmanaged>HRESULT IDWriteFontFile::GetReferenceKey([Out, Buffer] const void** fontFileReferenceKey,[Out] unsigned int* fontFileReferenceKeySize)</unmanaged>
            <unmanaged-short>IDWriteFontFile::GetReferenceKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.GetLoader(SharpDX.DirectWrite.FontFileLoader@)">
            <summary>
            <p> Obtains the file loader associated with a font file object. </p>
            </summary>
            <param name = "fontFileLoader"><dd>  <p>When this method returns, contains the address of  a reference to the font file loader associated with the font file object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371104</doc-id>
            <unmanaged>HRESULT IDWriteFontFile::GetLoader([Out] IDWriteFontFileLoader** fontFileLoader)</unmanaged>
            <unmanaged-short>IDWriteFontFile::GetLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFile.Analyze(SharpDX.Mathematics.Interop.RawBool@,SharpDX.DirectWrite.FontFileType@,SharpDX.DirectWrite.FontFaceType@,System.Int32@)">
            <summary>
            <p> Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system. </p>
            </summary>
            <param name = "isSupportedFontType"><dd>  <p><strong>TRUE</strong> if the font type is supported by the font system; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <param name = "fontFileType"><dd>  <p>When this method returns, contains a value that indicates the type of the font file. Note that even if <em> isSupportedFontType</em> is <strong><see cref = "F:SharpDX.Result.False"/></strong>, the <em>fontFileType</em> value may be different from <strong>DWRITE_FONT_FILE_TYPE_UNKNOWN</strong>.</p> </dd></param>
            <param name = "fontFaceType"><dd>  <p>When this method returns, contains a value that indicates the type of the font face. If <em>fontFileType</em> is not equal to <strong>DWRITE_FONT_FILE_TYPE_UNKNOWN</strong>, then that can be constructed from the font file. </p> </dd></param>
            <param name = "numberOfFaces"><dd>  <p>When this method returns, contains the number of font faces contained in the font file.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <strong>Important</strong>??Certain font file types are recognized, but not supported by the font system. For example, the font system will recognize a file as a Type 1 font file but will not be able to construct a font face object from it. In such situations, <strong>Analyze</strong> will set <em>isSupportedFontType</em> output parameter to <strong><see cref = "F:SharpDX.Result.False"/></strong>.?
            </remarks>
            <doc-id>dd371099</doc-id>
            <unmanaged>HRESULT IDWriteFontFile::Analyze([Out] BOOL* isSupportedFontType,[Out] DWRITE_FONT_FILE_TYPE* fontFileType,[Out, Optional] DWRITE_FONT_FACE_TYPE* fontFaceType,[Out] unsigned int* numberOfFaces)</unmanaged>
            <unmanaged-short>IDWriteFontFile::Analyze</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileEnumerator.MoveNext">
            <summary>	
            Advances to the next font file in the collection. When it is first created, the enumerator is positioned before the first element of the collection and the first call to MoveNext advances to the first file. 	
            </summary>	
            <returns>the value TRUE if the enumerator advances to a file; otherwise, FALSE if the enumerator advances past the last file in the collection.</returns>
            <unmanaged>HRESULT IDWriteFontFileEnumerator::MoveNext([Out] BOOL* hasCurrentFile)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFileEnumerator.CurrentFontFile">
            <summary>	
            Gets a reference to the current font file. 	
            </summary>	
            <returns>a reference to the newly created <see cref="T:SharpDX.DirectWrite.FontFile"/> object.</returns>
            <unmanaged>HRESULT IDWriteFontFileEnumerator::GetCurrentFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileEnumeratorShadow">
            <summary>
            Internal FontFileEnumerator Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileEnumeratorShadow.ToIntPtr(SharpDX.DirectWrite.FontFileEnumerator)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileEnumeratorShadow.FontFileEnumeratorVtbl.MoveNextDelegate">
            <summary>	
            Advances to the next font file in the collection. When it is first created, the enumerator is positioned before the first element of the collection and the first call to MoveNext advances to the first file. 	
            </summary>	
            <returns>the value TRUE if the enumerator advances to a file; otherwise, FALSE if the enumerator advances past the last file in the collection.</returns>
            <unmanaged>HRESULT IDWriteFontFileEnumerator::MoveNext([Out] BOOL* hasCurrentFile)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileEnumeratorShadow.FontFileEnumeratorVtbl.GetCurrentFontFileDelegate">
            <summary>	
            Gets a reference to the current font file. 	
            </summary>	
            <returns>a reference to the newly created <see cref="T:SharpDX.DirectWrite.FontFile"/> object.</returns>
            <unmanaged>HRESULT IDWriteFontFileEnumerator::GetCurrentFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileLoader.CreateStreamFromKey(SharpDX.DataPointer)">
            <summary>	
            Creates a font file stream object that encapsulates an open file resource. 	
            </summary>	
            <remarks>	
            The resource is closed when the last reference to fontFileStream is released.  	
            </remarks>	
            <param name="fontFileReferenceKey">A reference to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by  fontFileReferenceKeySize. </param>
            <returns>a reference to the newly created <see cref="T:SharpDX.DirectWrite.FontFileStream"/> object. </returns>
            <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[None] int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileLoaderNative.CreateStreamFromKey(SharpDX.DataPointer)">
            <summary>	
            Creates a font file stream object that encapsulates an open file resource. 	
            </summary>	
            <remarks>	
            The resource is closed when the last reference to fontFileStream is released.  	
            </remarks>	
            <param name="fontFileReferenceKey">A reference to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by  fontFileReferenceKeySize. </param>
            <returns>a reference to the newly created <see cref="T:SharpDX.DirectWrite.FontFileStream"/> object. </returns>
            <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[None] int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileLoaderNative.CreateStreamFromKey_(System.IntPtr,System.Int32,SharpDX.DirectWrite.FontFileStream@)">
            <summary>
            <p> Creates a font file stream object that encapsulates an open file resource. </p>
            </summary>
            <param name = "fontFileReferenceKey"><dd>  <p>A reference to a font file reference key that uniquely identifies the font file resource within the scope of the font loader being used. The buffer allocated for this key must at least be the size, in bytes, specified by <em> fontFileReferenceKeySize</em>.</p> </dd></param>
            <param name = "fontFileReferenceKeySize"><dd>  <p>The size of font file reference key, in bytes.</p> </dd></param>
            <param name = "fontFileStream"><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref = "T:SharpDX.DirectWrite.FontFileStream"/></strong> object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The resource is closed when the last reference to <em>fontFileStream</em> is released. </p>
            </remarks>
            <doc-id>dd371077</doc-id>
            <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>
            <unmanaged-short>IDWriteFontFileLoader::CreateStreamFromKey</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileLoaderShadow">
            <summary>
            Internal FontFileLoader Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileLoaderShadow.ToIntPtr(SharpDX.DirectWrite.FontFileLoader)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileLoaderShadow.FontFileLoaderVtbl.CreateStreamFromKeyDelegate">
            <unmanaged>HRESULT IDWriteFontFileLoader::CreateStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[None] int fontFileReferenceKeySize,[Out] IDWriteFontFileStream** fontFileStream)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStream.ReadFileFragment(System.IntPtr@,System.Int64,System.Int64,System.IntPtr@)">
            <summary>	
            Reads a fragment from a font file. 	
            </summary>	
            <remarks>	
            Note that ReadFileFragment implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from ReadFileFragment.   {{DirectWrite}} may invoke <see cref="T:SharpDX.DirectWrite.FontFileStream"/> methods on the same object from multiple threads simultaneously. Therefore, ReadFileFragment implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section. 	
            </remarks>	
            <param name="fragmentStart">When this method returns, contains an address of a  reference to the start of the font file fragment.  This parameter is passed uninitialized. </param>
            <param name="fileOffset">The offset of the fragment, in bytes, from the beginning of the font file. </param>
            <param name="fragmentSize">The size of the file fragment, in bytes. </param>
            <param name="fragmentContext">When this method returns, contains the address of  </param>
            <returns>a reference to a reference to the client-defined context to be passed to {{ReleaseFileFragment}}. </returns>
            <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out, Buffer] const void** fragmentStart,[None] __int64 fileOffset,[None] __int64 fragmentSize,[Out] void** fragmentContext)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStream.ReleaseFileFragment(System.IntPtr)">
            <summary>	
            Releases a fragment from a file. 	
            </summary>	
            <param name="fragmentContext">A reference to the client-defined context of a font fragment returned from {{ReadFileFragment}}. </param>
            <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([None] void* fragmentContext)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStream.GetFileSize">
            <summary>	
            Obtains the total size of a file. 	
            </summary>	
            <remarks>	
            Implementing GetFileSize() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size).  	
            </remarks>	
            <returns>the total size of the file. </returns>
            <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] __int64* fileSize)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStream.GetLastWriteTime">
            <summary>	
            Obtains the last modified time of the file.  	
            </summary>	
            <remarks>	
            The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one. 	
            </remarks>	
            <returns>the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). </returns>
            <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] __int64* lastWriteTime)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.ReadFileFragment(System.IntPtr@,System.Int64,System.Int64,System.IntPtr@)">
            <summary>	
            Reads a fragment from a font file. 	
            </summary>	
            <remarks>	
            Note that ReadFileFragment implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from ReadFileFragment.   {{DirectWrite}} may invoke <see cref="T:SharpDX.DirectWrite.FontFileStream"/> methods on the same object from multiple threads simultaneously. Therefore, ReadFileFragment implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section. 	
            </remarks>	
            <param name="fragmentStart">When this method returns, contains an address of a  reference to the start of the font file fragment.  This parameter is passed uninitialized. </param>
            <param name="fileOffset">The offset of the fragment, in bytes, from the beginning of the font file. </param>
            <param name="fragmentSize">The size of the file fragment, in bytes. </param>
            <param name="fragmentContext">When this method returns, contains the address of  </param>
            <returns>a reference to a reference to the client-defined context to be passed to {{ReleaseFileFragment}}. </returns>
            <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out, Buffer] const void** fragmentStart,[None] __int64 fileOffset,[None] __int64 fragmentSize,[Out] void** fragmentContext)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.ReleaseFileFragment(System.IntPtr)">
            <summary>	
            Releases a fragment from a file. 	
            </summary>	
            <param name="fragmentContext">A reference to the client-defined context of a font fragment returned from {{ReadFileFragment}}. </param>
            <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([None] void* fragmentContext)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.GetFileSize">
            <summary>	
            Obtains the total size of a file. 	
            </summary>	
            <remarks>	
            Implementing GetFileSize() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size).  	
            </remarks>	
            <returns>the total size of the file. </returns>
            <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] __int64* fileSize)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.GetLastWriteTime">
            <summary>	
            Obtains the last modified time of the file.  	
            </summary>	
            <remarks>	
            The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one. 	
            </remarks>	
            <returns>the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). </returns>
            <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] __int64* lastWriteTime)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFileStreamNative.FileSize_">
            <summary>
            <p> Obtains the total size of a file. </p>
            </summary>
            <remarks>
            <p> Implementing <strong>GetFileSize</strong>() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). </p>
            </remarks>
            <doc-id>dd371084</doc-id>
            <unmanaged>GetFileSize</unmanaged>
            <unmanaged-short>GetFileSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFileStreamNative.LastWriteTime_">
            <summary>
            <p> Obtains the last modified time of the file.  </p>
            </summary>
            <remarks>
            <p>The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.</p>
            </remarks>
            <doc-id>dd371089</doc-id>
            <unmanaged>GetLastWriteTime</unmanaged>
            <unmanaged-short>GetLastWriteTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.ReadFileFragment_(System.IntPtr@,System.Int64,System.Int64,System.IntPtr@)">
            <summary>
            <p> Reads a fragment from a font file. </p>
            </summary>
            <param name = "fragmentStart"><dd>  <p>When this method returns, contains an address of a  reference to the start of the font file fragment.  This parameter is passed uninitialized.</p> </dd></param>
            <param name = "fileOffset"><dd>  <p>The offset of the fragment, in bytes, from the beginning of the font file.</p> </dd></param>
            <param name = "fragmentSize"><dd>  <p>The size of the file fragment, in bytes.</p> </dd></param>
            <param name = "fragmentContext"><dd>  <p>When this method returns, contains the address of a reference to a reference to the client-defined context to be passed to <strong>ReleaseFileFragment</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Note that <strong>ReadFileFragment</strong> implementations must check whether the requested font file fragment is within the file bounds. Otherwise, an error should be returned from <strong>ReadFileFragment</strong>. </p><p> DirectWrite may invoke <strong><see cref = "T:SharpDX.DirectWrite.FontFileStream"/></strong> methods on the same object from multiple threads simultaneously. Therefore, <strong>ReadFileFragment</strong> implementations that rely on internal mutable state must serialize access to such state across multiple threads. For example, an implementation that uses separate Seek and Read operations to read a file fragment must place the code block containing Seek and Read calls under a lock or a critical section.</p>
            </remarks>
            <doc-id>dd371091</doc-id>
            <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out] const void** fragmentStart,[In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize,[Out] void** fragmentContext)</unmanaged>
            <unmanaged-short>IDWriteFontFileStream::ReadFileFragment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.ReleaseFileFragment_(System.IntPtr)">
            <summary>
            <p> Releases a fragment from a file. </p>
            </summary>
            <param name = "fragmentContext"><dd>  <p>A reference to the client-defined context of a font fragment returned from <strong>ReadFileFragment</strong>.</p> </dd></param>
            <doc-id>dd371095</doc-id>
            <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([In] void* fragmentContext)</unmanaged>
            <unmanaged-short>IDWriteFontFileStream::ReleaseFileFragment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.GetFileSize_(System.Int64@)">
            <summary>
            <p> Obtains the total size of a file. </p>
            </summary>
            <param name = "fileSize"><dd>  <p>When this method returns, contains the total size of the file.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Implementing <strong>GetFileSize</strong>() for asynchronously loaded font files may require downloading the complete file contents. Therefore, this method should be used only for operations that either require a complete font file to be loaded (for example, copying a font file) or that need to make decisions based on the value of the file size (for example, validation against a persisted file size). </p>
            </remarks>
            <doc-id>dd371084</doc-id>
            <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] unsigned longlong* fileSize)</unmanaged>
            <unmanaged-short>IDWriteFontFileStream::GetFileSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamNative.GetLastWriteTime_(System.Int64@)">
            <summary>
            <p> Obtains the last modified time of the file.  </p>
            </summary>
            <param name = "lastWriteTime"><dd>  <p>When this method returns, contains  the last modified time of the file in the format that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The "last modified time" is used by DirectWrite font selection algorithms to determine whether one font resource is more up to date than another one.</p>
            </remarks>
            <doc-id>dd371089</doc-id>
            <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] unsigned longlong* lastWriteTime)</unmanaged>
            <unmanaged-short>IDWriteFontFileStream::GetLastWriteTime</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileStreamShadow">
            <summary>
            Internal FontFileStream Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFileStreamShadow.ToIntPtr(SharpDX.DirectWrite.FontFileStream)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileStreamShadow.FontFileStreamVtbl.ReadFileFragmentDelegate">
            <unmanaged>HRESULT IDWriteFontFileStream::ReadFileFragment([Out, Buffer] const void** fragmentStart,[None] __int64 fileOffset,[None] __int64 fragmentSize,[Out] void** fragmentContext)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileStreamShadow.FontFileStreamVtbl.ReleaseFileFragmentDelegate">
            <unmanaged>void IDWriteFontFileStream::ReleaseFileFragment([None] void* fragmentContext)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileStreamShadow.FontFileStreamVtbl.GetFileSizeDelegate">
            <unmanaged>HRESULT IDWriteFontFileStream::GetFileSize([Out] __int64* fileSize)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileStreamShadow.FontFileStreamVtbl.GetLastWriteTimeDelegate">
            <unmanaged>HRESULT IDWriteFontFileStream::GetLastWriteTime([Out] __int64* lastWriteTime)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.FromLogFont(System.Object)">
            <summary>	
            Creates a font object that matches the properties specified by the LOGFONT structure. 	
            </summary>	
            <param name="logFont">A structure containing a GDI-compatible font description. </param>
            <returns>a  reference to a newly created <see cref="T:SharpDX.DirectWrite.Font"/>. </returns>
            <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFromLOGFONT([In] const LOGFONTW* logFont,[Out] IDWriteFont** font)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.ToLogFont(SharpDX.DirectWrite.Font,System.Object)">
            <summary>	
            Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font. 	
            </summary>	
            <remarks>	
            The conversion to a  LOGFONT by using ConvertFontToLOGFONT operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a LOGFONT as the <see cref="T:SharpDX.DirectWrite.Font"/> object that was converted. 	
            </remarks>	
            <param name="font">An <see cref="T:SharpDX.DirectWrite.Font"/> object to be converted into a GDI-compatible LOGFONT structure. </param>
            <param name="logFont">When this method returns, contains a structure that receives a GDI-compatible font description. </param>
            <returns> TRUE if the specified font object is part of the system font collection; otherwise, FALSE. </returns>
            <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontToLOGFONT([None] IDWriteFont* font,[In] LOGFONTW* logFont,[Out] BOOL* isSystemFont)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.CreateFontFromLOGFONT(System.IntPtr,SharpDX.DirectWrite.Font@)">
            <summary>
            <p> Creates a font object that matches the properties specified by the <strong><see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure. </p>
            </summary>
            <param name = "logFont"><dd>  <p>A structure containing a GDI-compatible font description.</p> </dd></param>
            <param name = "font"><dd>  <p>When this method returns, contains an address of a  reference to a newly created <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> object if successful; otherwise, <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371187</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFromLOGFONT([In] const void* logFont,[Out] IDWriteFont** font)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop::CreateFontFromLOGFONT</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.ConvertFontToLOGFONT(SharpDX.DirectWrite.Font,System.IntPtr,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> Initializes a <strong><see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure based on the GDI-compatible properties of the specified font. </p>
            </summary>
            <param name = "font"><dd>  <p>An <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> object to be converted into a GDI-compatible <strong><see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> structure.</p> </dd></param>
            <param name = "logFont"><dd>  <p>When this method returns, contains a structure that receives a GDI-compatible font description.</p> </dd></param>
            <param name = "isSystemFont"><dd>  <p>When this method returns, contains <strong>TRUE</strong> if the specified font object is part of the system font collection; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The conversion to a  <strong><see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> by using <strong>ConvertFontToLOGFONT</strong> operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a <strong><see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/></strong> as the <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> object that was converted.</p>
            </remarks>
            <doc-id>dd371177</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontToLOGFONT([In] IDWriteFont* font,[In] void* logFont,[Out] BOOL* isSystemFont)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop::ConvertFontToLOGFONT</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.ConvertFontFaceToLOGFONT(SharpDX.DirectWrite.FontFace,System.IntPtr)">
            <summary>
            <p> Initializes a <see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/> structure based on the GDI-compatible properties of the specified font. </p>
            </summary>
            <param name = "font"><dd>  <p>An <strong><see cref = "T:SharpDX.DirectWrite.FontFace"/></strong> object to be converted into a GDI-compatible <see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/> structure.</p> </dd></param>
            <param name = "logFont"><dd>  <p>When this method returns, contains a reference to a structure that receives a GDI-compatible font description.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The conversion to a  <see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/> by using <strong>ConvertFontFaceToLOGFONT</strong> operates at the logical font level and does not guarantee that it will map to a specific physical font. It is not guaranteed that GDI will select the same physical font for displaying  text formatted by a <see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/> as the <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> object that was converted.</p>
            </remarks>
            <doc-id>dd371175</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop::ConvertFontFaceToLOGFONT([In] IDWriteFontFace* font,[In] void* logFont)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop::ConvertFontFaceToLOGFONT</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.CreateFontFaceFromHdc(System.IntPtr)">
            <summary>
            <p> Creates an <strong><see cref = "T:SharpDX.DirectWrite.FontFace"/></strong> object that corresponds to the currently selected <strong>HFONT</strong> of the specified <strong><see cref = "T:System.IntPtr"/></strong>. </p>
            </summary>
            <param name = "hdc"><dd>  <p>A handle to a device context into which a font has been selected. It is assumed that the client has already performed font mapping and that the font selected into the device context is the actual font to be used  for rendering glyphs.</p> </dd></param>
            <returns><dd>  <p>Contains an address of a reference to  the newly created font face object, or <strong><c>null</c></strong> in case of failure. The font face returned is guaranteed to reference the same physical typeface that would be used for drawing glyphs (but not necessarily characters) using ExtTextOut.</p> </dd></returns>
            <remarks>
            <p>This function is intended for scenarios in which an application wants to use GDI and Uniscribe 1.x for text layout and shaping, but  DirectWrite for final rendering. This function assumes the client is performing text output using glyph indexes.</p>
            </remarks>
            <doc-id>dd371185</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop::CreateFontFaceFromHdc([In] HDC hdc,[Out] IDWriteFontFace** fontFace)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop::CreateFontFaceFromHdc</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop.CreateBitmapRenderTarget(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            <p> Creates an object that encapsulates a bitmap and memory DC (device context) which can be used for rendering glyphs. </p>
            </summary>
            <param name = "hdc"><dd>  <p>A handle to the optional device context used to create a compatible memory DC (device context).</p> </dd></param>
            <param name = "width"><dd>  <p>The width of the bitmap render target.</p> </dd></param>
            <param name = "height"><dd>  <p>The height of the bitmap render target.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains an address of a reference to the newly created <strong><see cref = "T:SharpDX.DirectWrite.BitmapRenderTarget"/></strong> object.</p> </dd></returns>
            <doc-id>dd371182</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop::CreateBitmapRenderTarget([In, Optional] HDC hdc,[In] unsigned int width,[In] unsigned int height,[Out] IDWriteBitmapRenderTarget** renderTarget)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop::CreateBitmapRenderTarget</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphRun">
            <summary>
            <p>Contains the information needed by renderers to draw glyph runs.  All coordinates are in device independent pixels (DIPs). </p>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>DWRITE_GLYPH_RUN</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_RUN</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.GlyphRun.FontFace">
            <summary>
            Gets or sets the <see cref="P:SharpDX.DirectWrite.GlyphRun.FontFace"/> associated with this GlypRun.
            </summary>
            <value>The font face.</value>
        </member>
        <member name="P:SharpDX.DirectWrite.GlyphRun.Indices">
            <summary>
            An array of glyph indices. This array contains <see cref="F:SharpDX.DirectWrite.GlyphRun.GlyphCount"/> elements.
            </summary>
        </member>
        <member name="P:SharpDX.DirectWrite.GlyphRun.Advances">
            <summary>
            An optional array of glyph advances. This array could be null or contains <see cref="F:SharpDX.DirectWrite.GlyphRun.GlyphCount"/> elements.
            </summary>
        </member>
        <member name="P:SharpDX.DirectWrite.GlyphRun.Offsets">
            <summary>
            An optional array of glyph offsets. This array could be null or contains <see cref="F:SharpDX.DirectWrite.GlyphRun.GlyphCount"/> elements.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.FontFacePointer">
            <summary>
            <dd> <p>The physical font face object to draw with.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>fontFace</unmanaged>
            <unmanaged-short>fontFace</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.FontSize">
            <summary>
            <dd> <p>The logical size of the font in DIPs (equals 1/96 inch), not points.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>fontEmSize</unmanaged>
            <unmanaged-short>fontEmSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.GlyphCount">
            <summary>
            <dd> <p>The number of glyphs in the glyph run.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>glyphCount</unmanaged>
            <unmanaged-short>glyphCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.GlyphIndicesPointer">
            <summary>
            <dd> <p>A reference to an array of indices to render for the glyph run.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>glyphIndices</unmanaged>
            <unmanaged-short>glyphIndices</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.GlyphAdvancesPointer">
            <summary>
            <dd> <p>A reference to an array containing glyph advance widths for the glyph run.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>glyphAdvances</unmanaged>
            <unmanaged-short>glyphAdvances</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.GlyphOffsetsPointer">
            <summary>
            <dd> <p>A reference to an array containing glyph offsets for the glyph run.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>glyphOffsets</unmanaged>
            <unmanaged-short>glyphOffsets</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.IsSideways">
            <summary>
            <dd> <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying <strong>isSideways</strong> = true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>isSideways</unmanaged>
            <unmanaged-short>isSideways</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRun.BidiLevel">
            <summary>
            <dd> <p>The implicit resolved bidi level of the run. Odd levels indicate right-to-left languages like Hebrew and Arabic, while even levels indicate left-to-right languages like English and Japanese (when written horizontally). For right-to-left languages, the text origin is on the right, and text should be drawn to the left.</p> </dd>
            </summary>
            <doc-id>dd368089</doc-id>
            <unmanaged>bidiLevel</unmanaged>
            <unmanaged-short>bidiLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GlyphRunAnalysis.#ctor(SharpDX.DirectWrite.Factory,SharpDX.DirectWrite.GlyphRun,System.Single,SharpDX.DirectWrite.RenderingMode,SharpDX.Direct2D1.MeasuringMode,System.Single,System.Single)">
            <summary>
            Creates a glyph run analysis object, which encapsulates information used to render a glyph run.
            </summary>
            <param name="factory">The factory.</param>
            <param name="glyphRun">A structure that contains the properties of the glyph run (font face, advances, and so on).</param>
            <param name="pixelsPerDip">Number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI bitmap then pixelsPerDip is 1. If rendering onto a 120 DPI bitmap then pixelsPerDip is 1.25.</param>
            <param name="renderingMode">A value that specifies the rendering mode, which must be one of the raster rendering modes (that is, not default and not outline).</param>
            <param name="measuringMode">Specifies the measuring mode to use with glyphs.</param>
            <param name="baselineOriginX">The horizontal position (X-coordinate) of the baseline origin, in DIPs.</param>
            <param name="baselineOriginY">Vertical position (Y-coordinate) of the baseline origin, in DIPs.</param>
            <remarks>
            The glyph run analysis object contains the results of analyzing the glyph run, including the positions of all the glyphs and references to all of the rasterized glyphs in the font cache.
            </remarks>
            <unmanaged>HRESULT IDWriteFactory::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[None] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] DWRITE_RENDERING_MODE renderingMode,[None] DWRITE_MEASURING_MODE measuringMode,[None] float baselineOriginX,[None] float baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.GlyphRunAnalysis.#ctor(SharpDX.DirectWrite.Factory,SharpDX.DirectWrite.GlyphRun,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.DirectWrite.RenderingMode,SharpDX.Direct2D1.MeasuringMode,System.Single,System.Single)">
            <summary>
            Creates a glyph run analysis object, which encapsulates information used to render a glyph run.
            </summary>
            <param name="factory">The factory.</param>
            <param name="glyphRun">A structure that contains the properties of the glyph run (font face, advances, and so on).</param>
            <param name="pixelsPerDip">Number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI bitmap then pixelsPerDip is 1. If rendering onto a 120 DPI bitmap then pixelsPerDip is 1.25.</param>
            <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified the emSize and pixelsPerDip.</param>
            <param name="renderingMode">A value that specifies the rendering mode, which must be one of the raster rendering modes (that is, not default and not outline).</param>
            <param name="measuringMode">Specifies the measuring mode to use with glyphs.</param>
            <param name="baselineOriginX">The horizontal position (X-coordinate) of the baseline origin, in DIPs.</param>
            <param name="baselineOriginY">Vertical position (Y-coordinate) of the baseline origin, in DIPs.</param>
            <remarks>
            The glyph run analysis object contains the results of analyzing the glyph run, including the positions of all the glyphs and references to all of the rasterized glyphs in the font cache.
            </remarks>
            <unmanaged>HRESULT IDWriteFactory::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[None] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] DWRITE_RENDERING_MODE renderingMode,[None] DWRITE_MEASURING_MODE measuringMode,[None] float baselineOriginX,[None] float baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.GlyphRunAnalysis.GetAlphaTextureBounds(SharpDX.DirectWrite.TextureType)">
            <summary>
            <p> Gets the bounding rectangle of the physical pixels affected by the glyph run. </p>
            </summary>
            <param name = "textureType"><dd>  <p>Specifies the type of texture requested. If a bi-level texture is requested, the bounding rectangle includes only bi-level glyphs. Otherwise, the bounding rectangle includes only antialiased glyphs.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the bounding rectangle of the physical pixels affected by the glyph run, or an empty rectangle if there are no glyphs of the specified texture type.</p> </dd></returns>
            <doc-id>dd371215</doc-id>
            <unmanaged>HRESULT IDWriteGlyphRunAnalysis::GetAlphaTextureBounds([In] DWRITE_TEXTURE_TYPE textureType,[Out] RECT* textureBounds)</unmanaged>
            <unmanaged-short>IDWriteGlyphRunAnalysis::GetAlphaTextureBounds</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GlyphRunAnalysis.CreateAlphaTexture(SharpDX.DirectWrite.TextureType,SharpDX.Mathematics.Interop.RawRectangle,System.Byte[],System.Int32)">
            <summary>
            <p> Creates an alpha texture of the specified type for glyphs within a specified bounding rectangle. </p>
            </summary>
            <param name = "textureType"><dd>  <p>A value that specifies the type of texture requested. This can be <strong>DWRITE_TEXTURE_BILEVEL_1x1</strong> or <strong>DWRITE_TEXTURE_CLEARTYPE_3x1</strong>. If a bi-level texture is requested, the texture contains only bi-level glyphs. Otherwise, the texture contains only antialiased glyphs.</p> </dd></param>
            <param name = "textureBounds"><dd>  <p>The bounding rectangle of the texture, which can be different than the bounding rectangle returned by <strong>GetAlphaTextureBounds</strong>.</p> </dd></param>
            <param name = "alphaValues"><dd>  <p>When this method returns, contains  the array of alpha values from the texture. The buffer allocated for this array must be at least the size of <em>bufferSize</em>.</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The size of the <em>alphaValues</em> array, in bytes. The minimum size depends on the dimensions of the rectangle and the type of texture requested.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371189</doc-id>
            <unmanaged>HRESULT IDWriteGlyphRunAnalysis::CreateAlphaTexture([In] DWRITE_TEXTURE_TYPE textureType,[In] const RECT* textureBounds,[Out, Buffer] unsigned char* alphaValues,[In] unsigned int bufferSize)</unmanaged>
            <unmanaged-short>IDWriteGlyphRunAnalysis::CreateAlphaTexture</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GlyphRunAnalysis.GetAlphaBlendParams(SharpDX.DirectWrite.RenderingParams,System.Single@,System.Single@,System.Single@)">
            <summary>
            <p> Gets alpha blending properties required for ClearType blending. </p>
            </summary>
            <param name = "renderingParams"><dd>  <p>An object that specifies the ClearType level and enhanced contrast, gamma, pixel geometry, and rendering mode. In most cases, the values returned by the output parameters of this method are based on the properties of this object, unless a GDI-compatible rendering mode was specified.</p> </dd></param>
            <param name = "blendGamma"><dd>  <p>When this method returns, contains  the gamma value to use for gamma correction.</p> </dd></param>
            <param name = "blendEnhancedContrast"><dd>  <p>When this method returns, contains the enhanced contrast value to be used for blending.</p> </dd></param>
            <param name = "blendClearTypeLevel"><dd>  <p>When this method returns, contains  the ClearType level used in the alpha blending.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371190</doc-id>
            <unmanaged>HRESULT IDWriteGlyphRunAnalysis::GetAlphaBlendParams([In] IDWriteRenderingParams* renderingParams,[Out] float* blendGamma,[Out] float* blendEnhancedContrast,[Out] float* blendClearTypeLevel)</unmanaged>
            <unmanaged-short>IDWriteGlyphRunAnalysis::GetAlphaBlendParams</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphRunDescription">
            <summary>
            <p>Contains additional properties related to those in <strong><see cref = "T:SharpDX.DirectWrite.GlyphRun"/></strong>.</p>
            </summary>
            <doc-id>dd368091</doc-id>
            <unmanaged>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_RUN_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunDescription.LocaleName">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368091</doc-id>
            <unmanaged>localeName</unmanaged>
            <unmanaged-short>localeName</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunDescription.Text">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368091</doc-id>
            <unmanaged>string</unmanaged>
            <unmanaged-short>string</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunDescription.TextLength">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368091</doc-id>
            <unmanaged>stringLength</unmanaged>
            <unmanaged-short>stringLength</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunDescription.ClusterMap">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368091</doc-id>
            <unmanaged>clusterMap</unmanaged>
            <unmanaged-short>clusterMap</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunDescription.TextPosition">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368091</doc-id>
            <unmanaged>textPosition</unmanaged>
            <unmanaged-short>textPosition</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphRunItem">
            <summary>
            A <see cref="T:SharpDX.DirectWrite.GlyphRunItem"/> Item.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunItem.Index">
            <summary>
            A glyph index
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunItem.Advance">
            <summary>
            A glyph advance
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphRunItem.Offset">
            <summary>
            A glyph offset
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObject.Draw(System.Object,SharpDX.DirectWrite.TextRenderer,System.Single,System.Single,System.Boolean,System.Boolean,SharpDX.ComObject)">
            <summary>	
            The application implemented rendering callback (<see cref="M:SharpDX.DirectWrite.TextRenderer.DrawInlineObject(System.Object,System.Single,System.Single,SharpDX.DirectWrite.InlineObject,System.Boolean,System.Boolean,SharpDX.ComObject)"/>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. 	
            </summary>	
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.  This parameter may be NULL. </param>
            <param name="renderer">The same renderer passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/> as the object's containing parent.  This is useful if the inline object is recursive such as a nested layout. </param>
            <param name="originX">The x-coordinate at the upper-left corner of the inline object. </param>
            <param name="originY">The y-coordinate at the upper-left corner of the inline object. </param>
            <param name="isSideways">A Boolean flag that indicates whether the object's baseline runs alongside the baseline axis of the line. </param>
            <param name="isRightToLeft">A Boolean flag that indicates whether the object is in a right-to-left context and should be drawn flipped. </param>
            <param name="clientDrawingEffect">The drawing effect set in <see cref="M:SharpDX.DirectWrite.TextLayout.SetDrawingEffect(SharpDX.ComObject,SharpDX.DirectWrite.TextRange)"/>.  Usually this effect is a foreground brush that  is used in glyph drawing. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] float originX,[None] float originY,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.InlineObject.Metrics">
            <summary>	
            <see cref="T:SharpDX.DirectWrite.TextLayout"/> calls this callback function to get the measurement of the inline object. 	
            </summary>	
            <returns>A structure describing the geometric measurement of an application-defined inline object.  These metrics are in relation to the baseline of the adjacent text. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.InlineObject.OverhangMetrics">
            <summary>	
            TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.	
            </summary>	
            <returns>Overshoot of visible extents (in DIPs) outside the object. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObject.GetBreakConditions(SharpDX.DirectWrite.BreakCondition@,SharpDX.DirectWrite.BreakCondition@)">
            <summary>	
            Layout uses this to determine the line-breaking behavior of the inline object among the text. 	
            </summary>	
            <param name="breakConditionBefore">When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it. </param>
            <param name="breakConditionAfter">When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectNative.Draw(System.Object,SharpDX.DirectWrite.TextRenderer,System.Single,System.Single,System.Boolean,System.Boolean,SharpDX.ComObject)">
            <summary>	
            The application implemented rendering callback (<see cref="M:SharpDX.DirectWrite.TextRenderer.DrawInlineObject(System.Object,System.Single,System.Single,SharpDX.DirectWrite.InlineObject,System.Boolean,System.Boolean,SharpDX.ComObject)"/>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. 	
            </summary>	
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.  This parameter may be NULL. </param>
            <param name="renderer">The same renderer passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/> as the object's containing parent.  This is useful if the inline object is recursive such as a nested layout. </param>
            <param name="originX">The x-coordinate at the upper-left corner of the inline object. </param>
            <param name="originY">The y-coordinate at the upper-left corner of the inline object. </param>
            <param name="isSideways">A Boolean flag that indicates whether the object's baseline runs alongside the baseline axis of the line. </param>
            <param name="isRightToLeft">A Boolean flag that indicates whether the object is in a right-to-left context and should be drawn flipped. </param>
            <param name="clientDrawingEffect">The drawing effect set in <see cref="M:SharpDX.DirectWrite.TextLayout.SetDrawingEffect(SharpDX.ComObject,SharpDX.DirectWrite.TextRange)"/>.  Usually this effect is a foreground brush that  is used in glyph drawing. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] float originX,[None] float originY,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.InlineObjectNative.Metrics">
            <summary>	
            <see cref="T:SharpDX.DirectWrite.TextLayout"/> calls this callback function to get the measurement of the inline object. 	
            </summary>	
            <returns>A structure describing the geometric measurement of an application-defined inline object.  These metrics are in relation to the baseline of the adjacent text. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.InlineObjectNative.OverhangMetrics">
            <summary>	
            TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.	
            </summary>	
            <returns>Overshoot of visible extents (in DIPs) outside the object. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectNative.GetBreakConditions(SharpDX.DirectWrite.BreakCondition@,SharpDX.DirectWrite.BreakCondition@)">
            <summary>	
            Layout uses this to determine the line-breaking behavior of the inline object among the text. 	
            </summary>	
            <param name="breakConditionBefore">When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it. </param>
            <param name="breakConditionAfter">When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.InlineObjectNative.Metrics_">
            <summary>
            <p> <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the measurement of the inline object. </p>
            </summary>
            <doc-id>dd371232</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.InlineObjectNative.OverhangMetrics_">
            <summary>
            <p> <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.</p><p>The overhangs should be returned relative to the reported size of the object (see <strong><see cref = "T:SharpDX.DirectWrite.InlineObjectMetrics"/></strong>), and should not be baseline adjusted.</p>
            </summary>
            <doc-id>dd371235</doc-id>
            <unmanaged>GetOverhangMetrics</unmanaged>
            <unmanaged-short>GetOverhangMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectNative.Draw_(System.IntPtr,SharpDX.DirectWrite.TextRenderer,System.Single,System.Single,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,System.IntPtr)">
            <summary>
            <p> The application implemented rendering callback (<strong>IDWriteTextRenderer::DrawInlineObject</strong>) can use this to draw the inline object without needing to cast or query the object type. The text layout does not call this method directly. </p>
            </summary>
            <param name = "clientDrawingContext">No documentation.</param>
            <param name = "renderer">No documentation.</param>
            <param name = "originX">No documentation.</param>
            <param name = "originY">No documentation.</param>
            <param name = "isSideways">No documentation.</param>
            <param name = "isRightToLeft">No documentation.</param>
            <param name = "clientDrawingEffect">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371225</doc-id>
            <unmanaged>HRESULT IDWriteInlineObject::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In, Optional] IUnknown* clientDrawingEffect)</unmanaged>
            <unmanaged-short>IDWriteInlineObject::Draw</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectNative.GetMetrics_(SharpDX.DirectWrite.InlineObjectMetrics@)">
            <summary>
            <p> <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the measurement of the inline object. </p>
            </summary>
            <param name = "metrics">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371232</doc-id>
            <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
            <unmanaged-short>IDWriteInlineObject::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectNative.GetOverhangMetrics_(SharpDX.DirectWrite.OverhangMetrics@)">
            <summary>
            <p> <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> calls this callback function to get the visible extents (in DIPs) of the inline object. In the case of a simple bitmap, with no padding and no overhang, all the overhangs will simply be zeroes.</p><p>The overhangs should be returned relative to the reported size of the object (see <strong><see cref = "T:SharpDX.DirectWrite.InlineObjectMetrics"/></strong>), and should not be baseline adjusted.</p>
            </summary>
            <param name = "overhangs">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371235</doc-id>
            <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
            <unmanaged-short>IDWriteInlineObject::GetOverhangMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectNative.GetBreakConditions_(SharpDX.DirectWrite.BreakCondition@,SharpDX.DirectWrite.BreakCondition@)">
            <summary>
            <p> Layout uses this to determine the line-breaking behavior of the inline object among the text. </p>
            </summary>
            <param name = "breakConditionBefore"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately preceding it.</p> </dd></param>
            <param name = "breakConditionAfter"><dd>  <p>When this method returns, contains a value which indicates the line-breaking condition between the object and the content immediately following it.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371229</doc-id>
            <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>
            <unmanaged-short>IDWriteInlineObject::GetBreakConditions</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.InlineObjectShadow">
            <summary>
            Internal InlineObject Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.InlineObjectShadow.ToIntPtr(SharpDX.DirectWrite.InlineObject)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.InlineObjectShadow.InlineObjectVtbl.DrawDelegate">
            <unmanaged>HRESULT IDWriteInlineObject::Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] float originX,[None] float originY,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.InlineObjectShadow.InlineObjectVtbl.GetMetricsDelegate">
            <unmanaged>HRESULT IDWriteInlineObject::GetMetrics([Out] DWRITE_INLINE_OBJECT_METRICS* metrics)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.InlineObjectShadow.InlineObjectVtbl.GetOverhangMetricsDelegate">
            <unmanaged>HRESULT IDWriteInlineObject::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.InlineObjectShadow.InlineObjectVtbl.GetBreakConditionsDelegate">
            <unmanaged>HRESULT IDWriteInlineObject::GetBreakConditions([Out] DWRITE_BREAK_CONDITION* breakConditionBefore,[Out] DWRITE_BREAK_CONDITION* breakConditionAfter)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.LineBreakpoint">
            <summary>
            <p>Line breakpoint characteristics of a character.</p>
            </summary>
            <doc-id>dd368098</doc-id>
            <unmanaged>DWRITE_LINE_BREAKPOINT</unmanaged>
            <unmanaged-short>DWRITE_LINE_BREAKPOINT</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.BreakConditionBefore">
            <summary>	
            Indicates a breaking condition before the character. 	
            </summary>	
            <unmanaged>byte breakConditionBefore</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.BreakConditionAfter">
            <summary>	
            Indicates a breaking condition after the character. 	
            </summary>	
            <unmanaged>byte breakConditionAfter</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.BreakConditionBefore_">
            <summary>
            <dd> <p>Indicates a breaking condition before the character.</p> </dd>
            </summary>
            <doc-id>dd368098</doc-id>
            <unmanaged>breakConditionBefore</unmanaged>
            <unmanaged-short>breakConditionBefore</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.BreakConditionAfter_">
            <summary>
            <dd> <p>Indicates a breaking condition after the character.</p> </dd>
            </summary>
            <doc-id>dd368098</doc-id>
            <unmanaged>breakConditionAfter</unmanaged>
            <unmanaged-short>breakConditionAfter</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.IsWhitespace">
            <summary>
            <dd> <p>Indicates that the character is some form of whitespace, which may be meaningful for justification.</p> </dd>
            </summary>
            <doc-id>dd368098</doc-id>
            <unmanaged>isWhitespace</unmanaged>
            <unmanaged-short>isWhitespace</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.IsSoftHyphen">
            <summary>
            <dd> <p>Indicates that the character is a soft hyphen, often used to indicate hyphenation points inside words.</p> </dd>
            </summary>
            <doc-id>dd368098</doc-id>
            <unmanaged>isSoftHyphen</unmanaged>
            <unmanaged-short>isSoftHyphen</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.LineBreakpoint.Padding">
            <summary>
            <dd> <p>Reserved for future use.</p> </dd>
            </summary>
            <doc-id>dd368098</doc-id>
            <unmanaged>padding</unmanaged>
            <unmanaged-short>padding</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalFontFileLoader.GetFilePath(SharpDX.DataPointer)">
            <summary>	
            <p>Obtains the absolute font file path from the font file reference key.</p>	
            </summary>	
            <param name="referenceKey"><dd> <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>	
            <returns><p>If this method succeeds, the absolute font file path from the font file reference key.</p></returns>	
            <msdn-id>dd371241</msdn-id>	
            <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out, Buffer] wchar_t* filePath,[In] unsigned int filePathSize)</unmanaged>	
            <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathFromKey</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectWrite.LocalFontFileLoader.GetLastWriteTime(SharpDX.DataPointer)">
            <summary>	
            <p>Obtains the last write time of the file from the font file reference key.</p>	
            </summary>	
            <param name="referenceKey"><dd> <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>	
            <returns><dd> <p>The time of the last font file modification.</p> </dd></returns>	
            <msdn-id>dd371247</msdn-id>	
            <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] FILETIME* lastWriteTime)</unmanaged>	
            <unmanaged-short>IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectWrite.LocalFontFileLoader.GetFilePathLengthFromKey(System.IntPtr,System.Int32)">
            <summary>
            <p>Obtains the length of the absolute file path from the font file reference key.</p>
            </summary>
            <param name = "fontFileReferenceKey"><dd>  <p>Font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>
            <param name = "fontFileReferenceKeySize"><dd>  <p>Size of font file reference key in bytes.</p> </dd></param>
            <returns><dd>  <p>Length of the file path string, not including the terminated <strong><c>null</c></strong> character.</p> </dd></returns>
            <doc-id>dd371244</doc-id>
            <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathLengthFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] unsigned int* filePathLength)</unmanaged>
            <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathLengthFromKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalFontFileLoader.GetFilePathFromKey(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <p>Obtains the absolute font file path from the font file reference key.</p>
            </summary>
            <param name = "fontFileReferenceKey"><dd>  <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>
            <param name = "fontFileReferenceKeySize"><dd>  <p>The size of font file reference key in bytes.</p> </dd></param>
            <param name = "filePath"><dd>  <p>The character array that receives the local file path.</p> </dd></param>
            <param name = "filePathSize"><dd>  <p>The length of the file path character array.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371241</doc-id>
            <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetFilePathFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out, Buffer] wchar_t* filePath,[In] unsigned int filePathSize)</unmanaged>
            <unmanaged-short>IDWriteLocalFontFileLoader::GetFilePathFromKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalFontFileLoader.GetLastWriteTimeFromKey(System.IntPtr,System.Int32)">
            <summary>
            <p>Obtains the last write time of the file from the font file reference key.</p>
            </summary>
            <param name = "fontFileReferenceKey"><dd>  <p>The font file reference key that uniquely identifies the local font file within the scope of the font loader being used.</p> </dd></param>
            <param name = "fontFileReferenceKeySize"><dd>  <p>The size of font file reference key in bytes.</p> </dd></param>
            <returns><dd>  <p>The time of the last font file modification.</p> </dd></returns>
            <doc-id>dd371247</doc-id>
            <unmanaged>HRESULT IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] FILETIME* lastWriteTime)</unmanaged>
            <unmanaged-short>IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetLocaleName(System.Int32)">
            <summary>	
            Get the locale name from the language.	
            </summary>	
            <param name="index">Zero-based index of the locale name to be retrieved. </param>
            <returns>The locale name from the language </returns>
            <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleName([None] int index,[Out, Buffer] wchar_t* localeName,[None] int size)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetString(System.Int32)">
            <summary>	
            Get the string from the language/string pair.
            </summary>	
            <param name="index">Zero-based index of the string from the language/string pair to be retrieved. </param>
            <returns>The locale name from the language </returns>
            <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleName([None] int index,[Out, Buffer] wchar_t* localeName,[None] int size)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.LocalizedStrings.Count">
            <summary>
            <p> Gets the number of language/string pairs. </p>
            </summary>
            <doc-id>dd371256</doc-id>
            <unmanaged>GetCount</unmanaged>
            <unmanaged-short>GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetCount">
            <summary>
            <p> Gets the number of language/string pairs. </p>
            </summary>
            <returns><p>The number of language/string pairs.</p></returns>
            <doc-id>dd371256</doc-id>
            <unmanaged>unsigned int IDWriteLocalizedStrings::GetCount()</unmanaged>
            <unmanaged-short>IDWriteLocalizedStrings::GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.FindLocaleName(System.String,System.Int32@)">
            <summary>
            <p> Gets the zero-based index of the locale name/string pair with the specified locale name. </p>
            </summary>
            <param name = "localeName"><dd>  <p>A null-terminated array of characters containing the locale name to look for.</p> </dd></param>
            <param name = "index"><dd>  <p>The zero-based index of the locale name/string pair. This method initializes <em>index</em> to <strong>UINT_MAX</strong>.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains <strong>TRUE</strong> if the locale name exists; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. This method initializes <em>exists</em> to <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <remarks>
            <p>Note that if the locale name does not exist, the return value is a success and the <em>exists</em> parameter is <strong><see cref = "F:SharpDX.Result.False"/></strong>. If you are getting the font family name for a font and the specified locale name does not exist, one option is to set the index to 0 as shown below.  There is always at least one locale for a font family.</p><pre>UINT32 index = 0;
            <see cref = "T:SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))
            { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp; &amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }
            } // If the specified locale doesn't exist, select the first on the list.
            if (!exists) index = 0;
            </pre>
            </remarks>
            <doc-id>dd371254</doc-id>
            <unmanaged>HRESULT IDWriteLocalizedStrings::FindLocaleName([In] const wchar_t* localeName,[Out] unsigned int* index,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteLocalizedStrings::FindLocaleName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetLocaleNameLength(System.Int32,System.Int32@)">
            <summary>
            <p> Gets the length in characters (not including the null terminator) of the locale name with the specified index. </p>
            </summary>
            <param name = "index"><dd>  <p>Zero-based index of the locale name to be retrieved.</p> </dd></param>
            <param name = "length"><dd>  <p>When this method returns, contains the length in characters of the locale name, not including the null terminator.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371262</doc-id>
            <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleNameLength([In] unsigned int index,[Out] unsigned int* length)</unmanaged>
            <unmanaged-short>IDWriteLocalizedStrings::GetLocaleNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetLocaleName(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <p> Copies the locale name with the specified index to the specified array. </p>
            </summary>
            <param name = "index"><dd>  <p>Zero-based index of the locale name to be retrieved.</p> </dd></param>
            <param name = "localeName"><dd>  <p>When this method returns, contains a character array, which is null-terminated, that receives the locale name from the language/string pair.  The buffer allocated for this array must be at least the size of <em>size</em>, in element count.</p> </dd></param>
            <param name = "size"><dd>  <p>The size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371259</doc-id>
            <unmanaged>HRESULT IDWriteLocalizedStrings::GetLocaleName([In] unsigned int index,[Out, Buffer] wchar_t* localeName,[In] unsigned int size)</unmanaged>
            <unmanaged-short>IDWriteLocalizedStrings::GetLocaleName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetStringLength(System.Int32,System.Int32@)">
            <summary>
            <p> Gets the length in characters (not including the null terminator) of the string with the specified index. </p>
            </summary>
            <param name = "index"><dd>  <p>A zero-based index of the language/string pair.</p> </dd></param>
            <param name = "length"><dd>  <p>The length in characters of the string, not including the null terminator, from the language/string pair.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Use <strong>GetStringLength</strong> to get the string length before calling the <strong>IDWriteLocalizedStrings::GetString</strong> method, as shown in the following code.</p><pre>UINT32 length = 0; // Get the string length.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
            } // Allocate a string big enough to hold the name.
            wchar_t* name = new (std::nothrow) wchar_t[length+1];
            if (name == <c>null</c>)
            { hr = E_OUTOFMEMORY;
            } // Get the family name.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetString(index, name, length+1);
            }
            </pre>
            </remarks>
            <doc-id>dd371269</doc-id>
            <unmanaged>HRESULT IDWriteLocalizedStrings::GetStringLength([In] unsigned int index,[Out] unsigned int* length)</unmanaged>
            <unmanaged-short>IDWriteLocalizedStrings::GetStringLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.LocalizedStrings.GetString(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <p> Copies the string with the specified index to the specified array. </p>
            </summary>
            <param name = "index"><dd>  <p>The zero-based index of the language/string pair to be examined.</p> </dd></param>
            <param name = "stringBuffer"><dd>  <p>The null terminated array of characters that receives the string from the language/string pair.  The buffer allocated for this array should be at least the size of <em>size</em>. <strong>GetStringLength</strong> can be used to get the size of the array before using this method.</p> </dd></param>
            <param name = "size"><dd>  <p>The size of the array in characters. The size must include space for the terminating null character. <strong>GetStringLength</strong> can be used to get the size of the array before using this method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The string returned must be allocated by the caller.  You can get the size of the string by using the <strong>GetStringLength</strong> method prior to calling <strong>GetString</strong>, as shown in the following example.</p><pre>UINT32 length = 0; // Get the string length.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
            } // Allocate a string big enough to hold the name.
            wchar_t* name = new (std::nothrow) wchar_t[length+1];
            if (name == <c>null</c>)
            { hr = E_OUTOFMEMORY;
            } // Get the family name.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetString(index, name, length+1);
            }
            </pre>
            </remarks>
            <doc-id>dd371267</doc-id>
            <unmanaged>HRESULT IDWriteLocalizedStrings::GetString([In] unsigned int index,[Out, Buffer] wchar_t* stringBuffer,[In] unsigned int size)</unmanaged>
            <unmanaged-short>IDWriteLocalizedStrings::GetString</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.DirectWrite"/> namespace provides a managed DirectWrite API.
            </summary>
            <msdn-id>dd368038</msdn-id>
            <unmanaged>DirectWrite</unmanaged>	
            <unmanaged-short>DirectWrite</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectWrite.NumberSubstitution.#ctor(SharpDX.DirectWrite.Factory,SharpDX.DirectWrite.NumberSubstitutionMethod,System.String,System.Boolean)">
            <summary>	
            Creates a number substitution object using a locale name, substitution method, and an indicator  whether to ignore user overrides (use NLS defaults for the given culture instead). 	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="substitutionMethod">A value that specifies how to apply number substitution on digits and related punctuation. </param>
            <param name="localeName">The name of the locale to be used in the numberSubstitution object. </param>
            <param name="ignoreUserOverride">A Boolean flag that indicates whether to ignore user overrides. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateNumberSubstitution([In] DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,[In] const wchar_t* localeName,[In] BOOL ignoreUserOverride,[Out] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.PixelSnapping.IsPixelSnappingDisabled(System.Object)">
            <summary>
            Determines whether pixel snapping is disabled. The recommended default is FALSE,
            unless doing animation that requires subpixel vertical placement.
            </summary>
            <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
            <returns>Receives TRUE if pixel snapping is disabled or FALSE if it not. </returns>
            <unmanaged>HRESULT IsPixelSnappingDisabled([None] void* clientDrawingContext,[Out] BOOL* isDisabled)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.PixelSnapping.GetCurrentTransform(System.Object)">
            <summary>	
             Gets a transform that maps abstract coordinates to DIPs. 	
            </summary>	
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <returns>a structure which has transform information for  pixel snapping.</returns>
            <unmanaged>HRESULT GetCurrentTransform([None] void* clientDrawingContext,[Out] DWRITE_MATRIX* transform)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.PixelSnapping.GetPixelsPerDip(System.Object)">
            <summary>	
             Gets the number of physical pixels per DIP. 	
            </summary>	
            <remarks>	
             Because a DIP (device-independent pixel) is 1/96 inch,  the pixelsPerDip value is the number of logical pixels per inch divided by 96.	
            </remarks>	
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <returns>the number of physical pixels per DIP</returns>
            <unmanaged>HRESULT GetPixelsPerDip([None] void* clientDrawingContext,[Out] FLOAT* pixelsPerDip)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.PixelSnappingShadow">
            <summary>
            Internal TessellationSink Callback
            </summary>
        </member>
        <member name="T:SharpDX.DirectWrite.PixelSnappingShadow.PixelSnappingVtbl.IsPixelSnappingDisabledDelegate">
            <summary>
            Determines whether pixel snapping is disabled. The recommended default is FALSE,
            unless doing animation that requires subpixel vertical placement.
            </summary>
            <param name="thisPtr">This pointer</param>
            <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
            <param name="isDisabled">Output disabled</param>
            <returns>Receives TRUE if pixel snapping is disabled or FALSE if it not. </returns>
            <unmanaged>HRESULT IsPixelSnappingDisabled([None] void* clientDrawingContext,[Out] BOOL* isDisabled)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.PixelSnappingShadow.PixelSnappingVtbl.GetCurrentTransformDelegate">
            <summary>	
             Gets a transform that maps abstract coordinates to DIPs. 	
            </summary>
            <param name="thisPtr">This pointer</param>
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <param name="transform">Matrix transform</param>
            <returns>a structure which has transform information for  pixel snapping.</returns>
            <unmanaged>HRESULT GetCurrentTransform([None] void* clientDrawingContext,[Out] DWRITE_MATRIX* transform)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.PixelSnappingShadow.PixelSnappingVtbl.GetPixelsPerDipDelegate">
            <summary>	
             Gets the number of physical pixels per DIP. 	
            </summary>	
            <remarks>	
             Because a DIP (device-independent pixel) is 1/96 inch,  the pixelsPerDip value is the number of logical pixels per inch divided by 96.	
            </remarks>
            <param name="thisPtr">This pointer</param>
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <param name="pixelPerDip">Dip</param>
            <returns>the number of physical pixels per DIP</returns>
            <unmanaged>HRESULT GetPixelsPerDip([None] void* clientDrawingContext,[Out] FLOAT* pixelsPerDip)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.#ctor(SharpDX.DirectWrite.Factory)">
            <summary>	
            Creates a rendering parameters object with default settings for the primary monitor. Different monitors may have different rendering parameters, for more information see the {{How to Add Support for Multiple Monitors}} topic.	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <unmanaged>HRESULT IDWriteFactory::CreateRenderingParams([Out] IDWriteRenderingParams** renderingParams)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.#ctor(SharpDX.DirectWrite.Factory,System.IntPtr)">
            <summary>	
            Creates a rendering parameters object with default settings for the specified monitor. In most cases, this is the preferred way to create a rendering parameters object.	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="monitorHandle">A handle for the specified monitor. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateMonitorRenderingParams([None] void* monitor,[Out] IDWriteRenderingParams** renderingParams)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.#ctor(SharpDX.DirectWrite.Factory,System.Single,System.Single,System.Single,SharpDX.DirectWrite.PixelGeometry,SharpDX.DirectWrite.RenderingMode)">
            <summary>	
            Creates a rendering parameters object with the specified properties. 	
            </summary>	
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <param name="gamma">The gamma level to be set for the new rendering parameters object. </param>
            <param name="enhancedContrast">The enhanced contrast level to be set for the new rendering parameters object. </param>
            <param name="clearTypeLevel">The ClearType level to be set for the new rendering parameters object. </param>
            <param name="pixelGeometry">Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text. </param>
            <param name="renderingMode">A value that represents the method (for example, ClearType natural quality) for rendering glyphs. </param>
            <unmanaged>HRESULT IDWriteFactory::CreateCustomRenderingParams([None] float gamma,[None] float enhancedContrast,[None] float clearTypeLevel,[None] DWRITE_PIXEL_GEOMETRY pixelGeometry,[None] DWRITE_RENDERING_MODE renderingMode,[Out] IDWriteRenderingParams** renderingParams)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams.Gamma">
            <summary>
            <p>Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p>
            </summary>
            <remarks>
            <p>The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.</p>
            </remarks>
            <doc-id>dd371295</doc-id>
            <unmanaged>GetGamma</unmanaged>
            <unmanaged-short>GetGamma</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams.EnhancedContrast">
            <summary>
            <p>Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.</p>
            </summary>
            <remarks>
            <p>Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.</p>
            </remarks>
            <doc-id>dd371290</doc-id>
            <unmanaged>GetEnhancedContrast</unmanaged>
            <unmanaged-short>GetEnhancedContrast</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams.ClearTypeLevel">
            <summary>
            <p>Gets the ClearType level of the rendering parameters object. </p>
            </summary>
            <remarks>
            <p>The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)</p>
            </remarks>
            <doc-id>dd371288</doc-id>
            <unmanaged>GetClearTypeLevel</unmanaged>
            <unmanaged-short>GetClearTypeLevel</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams.PixelGeometry">
            <summary>
            <p>Gets the pixel geometry of the rendering parameters object.</p>
            </summary>
            <doc-id>dd371297</doc-id>
            <unmanaged>GetPixelGeometry</unmanaged>
            <unmanaged-short>GetPixelGeometry</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams.RenderingMode">
            <summary>
            <p>Gets the rendering mode of the rendering parameters object.</p>
            </summary>
            <remarks>
            <p>By default, the rendering mode is initialized to DWRITE_RENDERING_MODE_DEFAULT, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <strong>IDWriteFontFace::GetRecommendedRenderingMode</strong> method.</p>
            </remarks>
            <doc-id>dd371300</doc-id>
            <unmanaged>GetRenderingMode</unmanaged>
            <unmanaged-short>GetRenderingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.GetGamma">
            <summary>
            <p>Gets the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p>
            </summary>
            <returns><p>Returns the gamma value used for gamma correction. Valid values must be greater than zero and cannot exceed 256.</p></returns>
            <remarks>
            <p>The gamma value is used for gamma correction, which compensates for the non-linear luminosity response of most monitors.</p>
            </remarks>
            <doc-id>dd371295</doc-id>
            <unmanaged>float IDWriteRenderingParams::GetGamma()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams::GetGamma</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.GetEnhancedContrast">
            <summary>
            <p>Gets the enhanced contrast property of the rendering parameters object. Valid values are greater than or equal to zero.</p>
            </summary>
            <returns><p>Returns the amount of contrast enhancement. Valid values are greater than or equal to zero.</p></returns>
            <remarks>
            <p>Enhanced contrast is the amount to increase the darkness of text, and typically ranges from 0 to 1. Zero means no contrast enhancement.</p>
            </remarks>
            <doc-id>dd371290</doc-id>
            <unmanaged>float IDWriteRenderingParams::GetEnhancedContrast()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams::GetEnhancedContrast</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.GetClearTypeLevel">
            <summary>
            <p>Gets the ClearType level of the rendering parameters object. </p>
            </summary>
            <returns><p>The ClearType level of the rendering parameters object.</p></returns>
            <remarks>
            <p>The ClearType level represents the amount of ClearType ? that is, the degree to which the red, green, and blue subpixels of each pixel are treated differently. Valid values range from zero (meaning no ClearType, which is equivalent to grayscale anti-aliasing) to one (meaning full ClearType)</p>
            </remarks>
            <doc-id>dd371288</doc-id>
            <unmanaged>float IDWriteRenderingParams::GetClearTypeLevel()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams::GetClearTypeLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.GetPixelGeometry">
            <summary>
            <p>Gets the pixel geometry of the rendering parameters object.</p>
            </summary>
            <returns><p> A value that indicates the type of  pixel geometry used in the rendering parameters object.</p></returns>
            <doc-id>dd371297</doc-id>
            <unmanaged>DWRITE_PIXEL_GEOMETRY IDWriteRenderingParams::GetPixelGeometry()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams::GetPixelGeometry</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams.GetRenderingMode">
            <summary>
            <p>Gets the rendering mode of the rendering parameters object.</p>
            </summary>
            <returns><p>A value that indicates the rendering mode of the rendering parameters object.</p></returns>
            <remarks>
            <p>By default, the rendering mode is initialized to DWRITE_RENDERING_MODE_DEFAULT, which means the rendering mode is determined automatically based on the font and size. To determine the recommended rendering mode to use for a given font and size and rendering parameters object, use the <strong>IDWriteFontFace::GetRecommendedRenderingMode</strong> method.</p>
            </remarks>
            <doc-id>dd371300</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE IDWriteRenderingParams::GetRenderingMode()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams::GetRenderingMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ScriptJustify">
            <summary>
            Defines glyph characteristic information that an application needs to implement justification.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.None">
            <summary>
            Justification cannot be applied at the glyph.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicBlank">
            <summary>
            The glyph represents a blank in an Arabic run.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.Character">
            <summary>
            An inter-character justification point follows the glyph.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.Blank">
            <summary>
            The glyph represents a blank outside an Arabic run.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicNormal">
            <summary>
            Normal middle-of-word glyph that connects to the right (begin).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicKashida">
            <summary>
            Kashida (U+0640) in the middle of the word.
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicAlef">
            <summary>
            Final form of an alef-like (U+0627, U+0625, U+0623, U+0622).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicHa">
            <summary>
            Final form of Ha (U+0647).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicRa">
            <summary>
            Final form of Ra (U+0631).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicBa">
            <summary>
            Final form of Ba (U+0628).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicBaRa">
            <summary>
            Ligature of alike (U+0628,U+0631).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicSeen">
            <summary>
            Highest priority: initial shape of Seen class (U+0633).
            </summary>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptJustify.ArabicSeenMedial">
            <summary>
            Highest priority: medial shape of Seen class (U+0633).
            </summary>
        </member>
        <member name="T:SharpDX.DirectWrite.ShapingGlyphProperties">
            <summary>
            <p>Contains shaping output properties for an output glyph.</p>
            </summary>
            <doc-id>dd368123</doc-id>
            <unmanaged>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged>
            <unmanaged-short>DWRITE_SHAPING_GLYPH_PROPERTIES</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingGlyphProperties.Justification">
            <summary>	
            Indicates that the glyph has justification applied. 	
            </summary>	
            <unmanaged>short justification</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingGlyphProperties.Justification_">
            <summary>
            <dd> <p>Indicates that the glyph has justification applied.</p> </dd>
            </summary>
            <doc-id>dd368123</doc-id>
            <unmanaged>justification</unmanaged>
            <unmanaged-short>justification</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingGlyphProperties.IsClusterStart">
            <summary>
            <dd> <p>Indicates that the glyph is the start of a cluster.</p> </dd>
            </summary>
            <doc-id>dd368123</doc-id>
            <unmanaged>isClusterStart</unmanaged>
            <unmanaged-short>isClusterStart</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingGlyphProperties.IsDiacritic">
            <summary>
            <dd> <p>Indicates that the glyph is a diacritic mark.</p> </dd>
            </summary>
            <doc-id>dd368123</doc-id>
            <unmanaged>isDiacritic</unmanaged>
            <unmanaged-short>isDiacritic</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingGlyphProperties.IsZeroWidthSpace">
            <summary>
            <dd> <p>Indicates that the glyph is a word boundary with no visible space.</p> </dd>
            </summary>
            <doc-id>dd368123</doc-id>
            <unmanaged>isZeroWidthSpace</unmanaged>
            <unmanaged-short>isZeroWidthSpace</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingGlyphProperties.Reserved">
            <summary>
            <dd> <p>Reserved for future use.</p> </dd>
            </summary>
            <doc-id>dd368123</doc-id>
            <unmanaged>reserved</unmanaged>
            <unmanaged-short>reserved</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSink.SetScriptAnalysis(System.Int32,System.Int32,SharpDX.DirectWrite.ScriptAnalysis)">
            <summary>	
            Reports script analysis for the specified text range.	
            </summary>	
            <param name="textPosition">The starting position from which to report. </param>
            <param name="textLength">The number of UTF16 units of the reported range. </param>
            <param name="scriptAnalysis">A reference to a structure that contains a zero-based index representation of a writing system script and a value indicating whether additional shaping of text is required. </param>
            <returns>A successful code or error code to stop analysis. </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetScriptAnalysis([None] int textPosition,[None] int textLength,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSink.SetLineBreakpoints(System.Int32,System.Int32,SharpDX.DirectWrite.LineBreakpoint[])">
            <summary>	
            Sets line-break opportunities for each character, starting from the specified position.	
            </summary>	
            <param name="textPosition">The starting text position from which to report. </param>
            <param name="textLength">The number of UTF16 units of the reported range. </param>
            <param name="lineBreakpoints">A reference to a structure that contains breaking conditions set for each character from the starting position to the end of the specified range. </param>
            <returns>A successful code or error code to stop analysis. </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetLineBreakpoints([None] int textPosition,[None] int textLength,[In, Buffer] const DWRITE_LINE_BREAKPOINT* lineBreakpoints)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSink.SetBidiLevel(System.Int32,System.Int32,System.Byte,System.Byte)">
            <summary>	
            Sets a bidirectional level on the range, which is  called once per  run change (either explicit or resolved implicit).	
            </summary>	
            <param name="textPosition">The starting position from which to report. </param>
            <param name="textLength">The number of UTF16 units of the reported range. </param>
            <param name="explicitLevel">The explicit level from the paragraph reading direction and any embedded control codes RLE/RLO/LRE/LRO/PDF, which is determined before any additional rules. </param>
            <param name="resolvedLevel">The final implicit level considering the explicit level and characters' natural directionality, after all Bidi rules have been applied. </param>
            <returns>A successful code or error code to stop analysis. </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetBidiLevel([None] int textPosition,[None] int textLength,[None] int explicitLevel,[None] int resolvedLevel)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSink.SetNumberSubstitution(System.Int32,System.Int32,SharpDX.DirectWrite.NumberSubstitution)">
            <summary>	
            Sets the number substitution on the text range affected by the text analysis.	
            </summary>	
            <param name="textPosition">The starting position from which to report. </param>
            <param name="textLength">The number of UTF16 units of the reported range. </param>
            <param name="numberSubstitution">An object that holds the appropriate digits and numeric punctuation for a given locale. Use <see cref="M:SharpDX.DirectWrite.Factory.CreateNumberSubstitution(SharpDX.DirectWrite.NumberSubstitutionMethod,System.String,SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.NumberSubstitution)"/> to create this object. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetNumberSubstitution([None] int textPosition,[None] int textLength,[None] IDWriteNumberSubstitution* numberSubstitution)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSink1.SetGlyphOrientation(System.Int32,System.Int32,SharpDX.DirectWrite.GlyphOrientationAngle,System.Byte,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool)">
            <summary>	
            <p>The text analyzer calls back to this to report the actual orientation of each character for shaping and drawing.</p>	
            </summary>	
            <param name="textPosition"><dd>  <p>The starting position to report from.</p> </dd></param>	
            <param name="textLength"><dd>  <p>Number of UTF-16 units of the reported range.</p> </dd></param>	
            <param name="glyphOrientationAngle"><dd>  <p>A <strong><see cref="T:SharpDX.DirectWrite.GlyphOrientationAngle" /></strong>-typed value that specifies the angle of the glyphs within the text range (pass to <strong><see cref="M:SharpDX.DirectWrite.TextAnalyzer1.GetGlyphOrientationTransform(SharpDX.DirectWrite.GlyphOrientationAngle,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawMatrix3x2@)" /></strong> to get the world relative transform).</p> </dd></param>	
            <param name="adjustedBidiLevel"><dd>  <p>The adjusted bidi level to be used by the client layout for reordering runs. This will differ from the resolved bidi level retrieved from the source for cases such as Arabic stacked top-to-bottom, where the glyphs are still shaped as RTL, but the runs are TTB along with any CJK or Latin.</p> </dd></param>	
            <param name="isSideways"><dd>  <p>Whether the glyphs are rotated on their side, which is the default case for CJK and the case stacked Latin</p> </dd></param>	
            <param name="isRightToLeft"><dd>  <p>Whether the script should be shaped as right-to-left. For Arabic stacked top-to-bottom, even when the adjusted bidi level is coerced to an even level, this will still be true.</p> </dd></param>	
            <returns><p>Returns a successful code or an error code to abort analysis.</p></returns>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDWriteTextAnalysisSink1::SetGlyphOrientation']/*" />	
            <msdn-id>Hh780425</msdn-id>	
            <unmanaged>HRESULT IDWriteTextAnalysisSink1::SetGlyphOrientation([In] unsigned int textPosition,[In] unsigned int textLength,[In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] unsigned char adjustedBidiLevel,[In] BOOL isSideways,[In] BOOL isRightToLeft)</unmanaged>	
            <unmanaged-short>IDWriteTextAnalysisSink1::SetGlyphOrientation</unmanaged-short>	
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSink1Shadow">
            <summary>
            Internal TextAnalysisSink1 Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSink1Shadow.ToIntPtr(SharpDX.DirectWrite.TextAnalysisSink1)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSink1Shadow.TextAnalysisSink1Vtbl.SetGlyphOrientationDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSink1::SetGlyphOrientation([In] unsigned int textPosition,[In] unsigned int textLength,[In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] unsigned char adjustedBidiLevel,[In] BOOL isSideways,[In] BOOL isRightToLeft)</unmanaged>	
            <unmanaged-short>IDWriteTextAnalysisSink1::SetGlyphOrientation</unmanaged-short>	
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSinkShadow">
            <summary>
            Internal TextAnalysisSink Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSinkShadow.ToIntPtr(SharpDX.DirectWrite.TextAnalysisSink)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSinkShadow.TextAnalysisSinkVtbl.SetScriptAnalysisDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetScriptAnalysis([None] int textPosition,[None] int textLength,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSinkShadow.TextAnalysisSinkVtbl.SetLineBreakpointsDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetLineBreakpoints([None] int textPosition,[None] int textLength,[In, Buffer] const DWRITE_LINE_BREAKPOINT* lineBreakpoints)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSinkShadow.TextAnalysisSinkVtbl.SetBidiLevelDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetBidiLevel([None] int textPosition,[None] int textLength,[None] int explicitLevel,[None] int resolvedLevel)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSinkShadow.TextAnalysisSinkVtbl.SetNumberSubstitutionDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSink::SetNumberSubstitution([None] int textPosition,[None] int textLength,[None] IDWriteNumberSubstitution* numberSubstitution)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSource.GetTextAtPosition(System.Int32)">
            <summary>	
            Gets a block of text starting at the specified text position. 	
            </summary>	
            <remarks>	
            Returning NULL indicates the end of text, which is the position after the last character. This function is called iteratively for each consecutive block, tying together several fragmented blocks in the backing store into a virtual contiguous string. Although applications can implement sparse textual content that  maps only part of the backing store, the application must map any text that is in the range passed to any analysis functions. 	
            </remarks>	
            <param name="textPosition">The first position of the piece to obtain. All positions are in UTF16 code units, not whole characters, which matters when supplementary characters are used. </param>      
            <returns>a block of text </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetTextAtPosition([None] int textPosition,[Out] const wchar_t** textString,[Out] int* textLength)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSource.GetTextBeforePosition(System.Int32)">
            <summary>	
            Gets a block of text immediately preceding the specified position.	
            </summary>	
            <remarks>	
            NULL indicates no chunk available at the specified position, either because textPosition equals 0,  textPosition is greater than the entire text content length, or the queried position is not mapped into the application's backing store. Although applications can implement sparse textual content that  maps only part of the backing store, the application must map any text that is in the range passed to any analysis functions. 	
            </remarks>	
            <param name="textPosition">The position immediately after the last position of the block of text to obtain. </param>
            <returns>text immediately preceding the specified position </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetTextBeforePosition([None] int textPosition,[Out] const wchar_t** textString,[Out] int* textLength)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.TextAnalysisSource.ReadingDirection">
            <summary>	
            Gets the paragraph reading direction.	
            </summary>	
            <returns>The reading direction of the current paragraph. </returns>
            <unmanaged>DWRITE_READING_DIRECTION IDWriteTextAnalysisSource::GetParagraphReadingDirection()</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSource.GetLocaleName(System.Int32,System.Int32@)">
            <summary>
            Gets the locale name on the range affected by the text analysis.
            </summary>
            <param name="textPosition">The text position to examine.</param>
            <param name="textLength">Contains the length of the text being affected by the text analysis up to the next differing locale.</param>
            <returns>
            the locale name on the range affected by the text analysis
            </returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetLocaleName([None] int textPosition,[Out] int* textLength,[Out] const wchar_t** localeName)</unmanaged>
            <remarks>
            The localeName reference must remain valid until the next call or until the analysis returns.
            </remarks>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSource.GetNumberSubstitution(System.Int32,System.Int32@)">
            <summary>	
            Gets the number substitution from the text range affected by the text analysis.	
            </summary>	
            <remarks>	
            Any implementation should return the number substitution with an incremented reference count, and the analysis will release when finished with it (either before the next call or before it returns). However, the sink callback may hold onto it after that. 	
            </remarks>	
            <param name="textPosition">The starting position from which to report. </param>
            <param name="textLength">Contains  the length of the text, in characters, remaining in the text range up to the next differing number substitution. </param>
            <returns>the number substitution from the text range affected by the text analysis.</returns>
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetNumberSubstitution([None] int textPosition,[Out] int* textLength,[Out] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSource1.GetVerticalGlyphOrientation(System.Int32,System.Int32@,SharpDX.DirectWrite.VerticalGlyphOrientation@,System.Byte@)">
            <summary>	
            <p>Used by the text analyzer to obtain the desired glyph orientation and resolved bidi level.</p>	
            </summary>	
            <param name="textPosition"><dd>  <p>The text position.</p> </dd></param>	
            <param name="textLength"><dd>  <p>A reference to the text length.</p> </dd></param>	
            <param name="glyphOrientation"><dd>  <p>A <strong><see cref="T:SharpDX.DirectWrite.VerticalGlyphOrientation" /></strong>-typed value that specifies the desired kind of glyph orientation for the text.</p> </dd></param>	
            <param name="bidiLevel"><dd>  <p>A reference to the resolved bidi level.</p> </dd></param>	
            <returns><p>Returning an error will abort the analysis.</p></returns>	
            <remarks>	
            <p>The text analyzer calls back to this to get the desired glyph orientation and resolved bidi level, which it uses along with the script properties of the text to determine the actual orientation of each character, which it reports back to the client via the sink SetGlyphOrientation method.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation']/*" />	
            <msdn-id>Hh780427</msdn-id>	
            <unmanaged>HRESULT IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation([In] unsigned int textPosition,[Out] unsigned int* textLength,[Out] DWRITE_VERTICAL_GLYPH_ORIENTATION* glyphOrientation,[Out] unsigned char* bidiLevel)</unmanaged>	
            <unmanaged-short>IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation</unmanaged-short>	
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSource1Shadow">
            <summary>
            Internal TextAnalysisSource1 Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSource1Shadow.ToIntPtr(SharpDX.DirectWrite.TextAnalysisSource1)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSource1Shadow.TextAnalysisSource1Vtbl.GetVerticalGlyphOrientationDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSource1::GetVerticalGlyphOrientation([In] unsigned int textPosition,[Out] unsigned int* textLength,[Out] DWRITE_VERTICAL_GLYPH_ORIENTATION* glyphOrientation,[Out] unsigned char* bidiLevel)</unmanaged>	
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSourceShadow">
            <summary>
            Internal TextAnalysisSource Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalysisSourceShadow.ToIntPtr(SharpDX.DirectWrite.TextAnalysisSource)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSourceShadow.TextAnalysisSourceVtbl.GetTextAtPositionDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetTextAtPosition([None] int textPosition,[Out] const wchar_t** textString,[Out] int* textLength)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSourceShadow.TextAnalysisSourceVtbl.GetTextBeforePositionDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetTextBeforePosition([None] int textPosition,[Out] const wchar_t** textString,[Out] int* textLength)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSourceShadow.TextAnalysisSourceVtbl.GetParagraphReadingDirectionDelegate">
            <unmanaged>DWRITE_READING_DIRECTION IDWriteTextAnalysisSource::GetParagraphReadingDirection()</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSourceShadow.TextAnalysisSourceVtbl.GetLocaleNameDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetLocaleName([None] int textPosition,[Out] int* textLength,[Out] const wchar_t** localeName)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAnalysisSourceShadow.TextAnalysisSourceVtbl.GetNumberSubstitutionDelegate">
            <unmanaged>HRESULT IDWriteTextAnalysisSource::GetNumberSubstitution([None] int textPosition,[Out] int* textLength,[Out] IDWriteNumberSubstitution** numberSubstitution)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.#ctor(SharpDX.DirectWrite.Factory)">
            <summary>
            Returns an interface for performing text analysis.
            </summary>
            <param name="factory">A reference to a DirectWrite factory <see cref="T:SharpDX.DirectWrite.Factory"/></param>
            <unmanaged>HRESULT IDWriteFactory::CreateTextAnalyzer([Out] IDWriteTextAnalyzer** textAnalyzer)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.GetGlyphs(System.String,System.Int32,SharpDX.DirectWrite.FontFace,System.Boolean,System.Boolean,SharpDX.DirectWrite.ScriptAnalysis,System.String,SharpDX.DirectWrite.NumberSubstitution,SharpDX.DirectWrite.FontFeature[][],System.Int32[],System.Int32,System.Int16[],SharpDX.DirectWrite.ShapingTextProperties[],System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32@)">
            <summary>
            Gets the glyphs (TODO doc)
            </summary>
            <param name="textString">The text string.</param>
            <param name="textLength">Length of the text.</param>
            <param name="fontFace">The font face.</param>
            <param name="isSideways">if set to <c>true</c> [is sideways].</param>
            <param name="isRightToLeft">if set to <c>true</c> [is right to left].</param>
            <param name="scriptAnalysis">The script analysis.</param>
            <param name="localeName">Name of the locale.</param>
            <param name="numberSubstitution">The number substitution.</param>
            <param name="features">The features.</param>
            <param name="featureRangeLengths">The feature range lengths.</param>
            <param name="maxGlyphCount">The max glyph count.</param>
            <param name="clusterMap">The cluster map.</param>
            <param name="textProps">The text props.</param>
            <param name="glyphIndices">The glyph indices.</param>
            <param name="glyphProps">The glyph props.</param>
            <param name="actualGlyphCount">The actual glyph count.</param>
            <returns>
            If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>.
            </returns>
            <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphs([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Buffer, Optional] const wchar_t* localeName,[In, Optional] IDWriteNumberSubstitution* numberSubstitution,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[In] unsigned int maxGlyphCount,[Out, Buffer] unsigned short* clusterMap,[Out, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[Out, Buffer] unsigned short* glyphIndices,[Out, Buffer] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[Out] unsigned int* actualGlyphCount)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.GetGlyphPlacements(System.String,System.Int16[],SharpDX.DirectWrite.ShapingTextProperties[],System.Int32,System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32,SharpDX.DirectWrite.FontFace,System.Single,System.Boolean,System.Boolean,SharpDX.DirectWrite.ScriptAnalysis,System.String,SharpDX.DirectWrite.FontFeature[][],System.Int32[],System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            Gets the glyph placements.
            </summary>
            <param name="textString">The text string.</param>
            <param name="clusterMap">The cluster map.</param>
            <param name="textProps">The text props.</param>
            <param name="textLength">Length of the text.</param>
            <param name="glyphIndices">The glyph indices.</param>
            <param name="glyphProps">The glyph props.</param>
            <param name="glyphCount">The glyph count.</param>
            <param name="fontFace">The font face.</param>
            <param name="fontEmSize">Size of the font in ems.</param>
            <param name="isSideways">if set to <c>true</c> [is sideways].</param>
            <param name="isRightToLeft">if set to <c>true</c> [is right to left].</param>
            <param name="scriptAnalysis">The script analysis.</param>
            <param name="localeName">Name of the locale.</param>
            <param name="features">The features.</param>
            <param name="featureRangeLengths">The feature range lengths.</param>
            <param name="glyphAdvances">The glyph advances.</param>
            <param name="glyphOffsets">The glyph offsets.</param>
            <returns>
            If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>.
            </returns>
            <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Buffer, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.GetGdiCompatibleGlyphPlacements(System.String,System.Int16[],SharpDX.DirectWrite.ShapingTextProperties[],System.Int32,System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32,SharpDX.DirectWrite.FontFace,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Boolean,System.Boolean,System.Boolean,SharpDX.DirectWrite.ScriptAnalysis,System.String,SharpDX.DirectWrite.FontFeature[][],System.Int32[],System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            Gets the GDI compatible glyph placements.
            </summary>
            <param name="textString">The text string.</param>
            <param name="clusterMap">The cluster map.</param>
            <param name="textProps">The text props.</param>
            <param name="textLength">Length of the text.</param>
            <param name="glyphIndices">The glyph indices.</param>
            <param name="glyphProps">The glyph props.</param>
            <param name="glyphCount">The glyph count.</param>
            <param name="fontFace">The font face.</param>
            <param name="fontEmSize">Size of the font em.</param>
            <param name="pixelsPerDip">The pixels per dip.</param>
            <param name="transform">The transform.</param>
            <param name="useGdiNatural">if set to <c>true</c> [use GDI natural].</param>
            <param name="isSideways">if set to <c>true</c> [is sideways].</param>
            <param name="isRightToLeft">if set to <c>true</c> [is right to left].</param>
            <param name="scriptAnalysis">The script analysis.</param>
            <param name="localeName">Name of the locale.</param>
            <param name="features">The features.</param>
            <param name="featureRangeLengths">The feature range lengths.</param>
            <param name="glyphAdvances">The glyph advances.</param>
            <param name="glyphOffsets">The glyph offsets.</param>
            <returns>
            If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>.
            </returns>
            <unmanaged>HRESULT IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Buffer, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.AllocateFeatures(SharpDX.DirectWrite.FontFeature[][])">
            <summary>
            Allocates the features from the jagged array..
            </summary>
            <param name="features">The features.</param>
            <returns>A pointer to the allocated native features or 0 if features is null or empty.</returns>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.AnalyzeScript(SharpDX.DirectWrite.TextAnalysisSource,System.Int32,System.Int32,SharpDX.DirectWrite.TextAnalysisSink)">
            <summary>
            <p> Analyzes a text range for script boundaries, reading text attributes from the source and reporting the Unicode script ID to the sink  callback <strong>SetScript</strong>. </p>
            </summary>
            <param name = "analysisSource">No documentation.</param>
            <param name = "textPosition">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "analysisSink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316620</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeScript([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::AnalyzeScript</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.AnalyzeBidi(SharpDX.DirectWrite.TextAnalysisSource,System.Int32,System.Int32,SharpDX.DirectWrite.TextAnalysisSink)">
            <summary>
            <p> Analyzes a text range for script directionality, reading attributes from the source and reporting levels to the sink callback <strong>SetBidiLevel</strong>. </p>
            </summary>
            <param name = "analysisSource">No documentation.</param>
            <param name = "textPosition">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "analysisSink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> While the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs. Otherwise, the returned levels may be wrong, because the Bidi algorithm is meant to apply to the paragraph as a whole. </p>
            </remarks>
            <doc-id>dd316610</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeBidi([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::AnalyzeBidi</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.AnalyzeNumberSubstitution(SharpDX.DirectWrite.TextAnalysisSource,System.Int32,System.Int32,SharpDX.DirectWrite.TextAnalysisSink)">
            <summary>
            <p> Analyzes a text range for spans where number substitution is applicable, reading attributes from the source and reporting substitutable ranges to the sink callback <strong>SetNumberSubstitution</strong>. </p>
            </summary>
            <param name = "analysisSource">No documentation.</param>
            <param name = "textPosition">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "analysisSink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Although the function can handle multiple ranges of differing number substitutions, the text ranges should not arbitrarily split the middle of numbers. Otherwise, it will treat the numbers separately and will not translate any intervening punctuation. </p>
            </remarks>
            <doc-id>dd316616</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeNumberSubstitution([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::AnalyzeNumberSubstitution</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.AnalyzeLineBreakpoints(SharpDX.DirectWrite.TextAnalysisSource,System.Int32,System.Int32,SharpDX.DirectWrite.TextAnalysisSink)">
            <summary>
            <p> Analyzes a text range for potential breakpoint opportunities, reading attributes from the source and reporting breakpoint opportunities to the sink callback <strong>SetLineBreakpoints</strong>. </p>
            </summary>
            <param name = "analysisSource">No documentation.</param>
            <param name = "textPosition">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "analysisSink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Although the function can handle multiple paragraphs, the text range should not arbitrarily split the middle of paragraphs, unless the specified text span is considered a whole unit. Otherwise, the returned properties for the first and last characters will inappropriately allow breaks. </p>
            </remarks>
            <doc-id>dd316613</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::AnalyzeLineBreakpoints([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink* analysisSink)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::AnalyzeLineBreakpoints</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.GetGlyphs(System.String,System.Int32,SharpDX.DirectWrite.FontFace,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.ScriptAnalysis,System.String,SharpDX.DirectWrite.NumberSubstitution,System.IntPtr,System.Int32[],System.Int32,System.Int32,System.Int16[],SharpDX.DirectWrite.ShapingTextProperties[],System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32@)">
            <summary>
            <p> Parses the input text string and maps it to the set of glyphs and associated glyph data according to the font and the writing system's rendering rules. </p>
            </summary>
            <param name = "textString"><dd>  <p>An array of characters to convert to glyphs.</p> </dd></param>
            <param name = "textLength"><dd>  <p>The length of <em>textString</em>.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>The font face that is the source of the output glyphs.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>A Boolean flag set to <strong>TRUE</strong> if the text is intended to be drawn vertically.</p> </dd></param>
            <param name = "isRightToLeft"><dd>  <p>A Boolean flag set to <strong>TRUE</strong> for right-to-left text.</p> </dd></param>
            <param name = "scriptAnalysis"><dd>  <p>A reference to a Script analysis result from an <strong>AnalyzeScript</strong> call.</p> </dd></param>
            <param name = "localeName"><dd>  <p>The locale to use when selecting glyphs. For example the same character may map to different glyphs for ja-jp versus zh-chs. If this is <strong><c>null</c></strong>, then the default mapping based on the script is used.</p> </dd></param>
            <param name = "numberSubstitution"><dd>  <p>A reference to an optional number substitution which selects the appropriate glyphs for digits and related numeric characters, depending on the results obtained from <strong>AnalyzeNumberSubstitution</strong>. Passing <strong><c>null</c></strong> indicates that no substitution is needed and that the digits should receive nominal glyphs.</p> </dd></param>
            <param name = "features"><dd>  <p>An array of references to the sets of typographic  features to use in each feature range.</p> </dd></param>
            <param name = "featureRangeLengths"><dd>  <p>The length of each feature range, in characters.   The sum of all lengths should be equal to <em>textLength</em>.</p> </dd></param>
            <param name = "featureRanges"><dd>  <p>The number of feature ranges.</p> </dd></param>
            <param name = "maxGlyphCount"><dd>  <p>The maximum number of glyphs that can be returned.</p> </dd></param>
            <param name = "clusterMap"><dd>  <p>When this method returns, contains the mapping from character ranges to glyph  ranges.</p> </dd></param>
            <param name = "textProps"><dd>  <p>When this method returns, contains a reference to an array of structures that contains  shaping properties for each character.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>The output glyph indices.</p> </dd></param>
            <param name = "glyphProps"><dd>  <p>When this method returns, contains a reference to an array of structures that contain  shaping properties for each output glyph.</p> </dd></param>
            <param name = "actualGlyphCount"><dd>  <p>When this method returns, contains the actual number of glyphs returned if the call succeeds.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Note that the mapping from characters to glyphs is, in general, many-to-many.  The recommended estimate for the per-glyph output buffers is (3 * <em>textLength</em> / 2 + 16).  This is not guaranteed to be sufficient. The value of the <em>actualGlyphCount</em> parameter is only valid if the call succeeds.  In the event that <em>maxGlyphCount</em> is not big enough, <strong>HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)</strong> will be returned.  The application should  allocate a larger buffer and try again. </p>
            </remarks>
            <doc-id>dd316625</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphs([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] IDWriteNumberSubstitution* numberSubstitution,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[In] unsigned int maxGlyphCount,[Out, Buffer] unsigned short* clusterMap,[Out, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[Out, Buffer] unsigned short* glyphIndices,[Out, Buffer] DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[Out] unsigned int* actualGlyphCount)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::GetGlyphs</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.GetGlyphPlacements(System.String,System.Int16[],SharpDX.DirectWrite.ShapingTextProperties[],System.Int32,System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32,SharpDX.DirectWrite.FontFace,System.Single,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.ScriptAnalysis,System.String,System.IntPtr,System.Int32[],System.Int32,System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            <p> Places glyphs output from the <strong>GetGlyphs</strong> method according to the font  and the writing system's rendering rules. </p>
            </summary>
            <param name = "textString">No documentation.</param>
            <param name = "clusterMap">No documentation.</param>
            <param name = "textProps">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "glyphIndices">No documentation.</param>
            <param name = "glyphProps">No documentation.</param>
            <param name = "glyphCount">No documentation.</param>
            <param name = "fontFace">No documentation.</param>
            <param name = "fontEmSize">No documentation.</param>
            <param name = "isSideways">No documentation.</param>
            <param name = "isRightToLeft">No documentation.</param>
            <param name = "scriptAnalysis">No documentation.</param>
            <param name = "localeName">No documentation.</param>
            <param name = "features">No documentation.</param>
            <param name = "featureRangeLengths">No documentation.</param>
            <param name = "featureRanges">No documentation.</param>
            <param name = "glyphAdvances">No documentation.</param>
            <param name = "glyphOffsets">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316622</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::GetGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::GetGlyphPlacements</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer.GetGdiCompatibleGlyphPlacements(System.String,System.Int16[],SharpDX.DirectWrite.ShapingTextProperties[],System.Int32,System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32,SharpDX.DirectWrite.FontFace,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.ScriptAnalysis,System.String,System.IntPtr,System.Int32[],System.Int32,System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            <p>Place glyphs output from the <strong>GetGlyphs</strong> method according to the font  and the writing system's rendering rules.</p>
            </summary>
            <param name = "textString">No documentation.</param>
            <param name = "clusterMap">No documentation.</param>
            <param name = "textProps">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "glyphIndices">No documentation.</param>
            <param name = "glyphProps">No documentation.</param>
            <param name = "glyphCount">No documentation.</param>
            <param name = "fontFace">No documentation.</param>
            <param name = "fontEmSize">No documentation.</param>
            <param name = "pixelsPerDip">No documentation.</param>
            <param name = "transform">No documentation.</param>
            <param name = "useGdiNatural">No documentation.</param>
            <param name = "isSideways">No documentation.</param>
            <param name = "isRightToLeft">No documentation.</param>
            <param name = "scriptAnalysis">No documentation.</param>
            <param name = "localeName">No documentation.</param>
            <param name = "features">No documentation.</param>
            <param name = "featureRangeLengths">No documentation.</param>
            <param name = "featureRanges">No documentation.</param>
            <param name = "glyphAdvances">No documentation.</param>
            <param name = "glyphOffsets">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd941790</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements([In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] DWRITE_SHAPING_TEXT_PROPERTIES* textProps,[In] unsigned int textLength,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,[In] unsigned int glyphCount,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] BOOL isRightToLeft,[In] const DWRITE_SCRIPT_ANALYSIS* scriptAnalysis,[In, Optional] const wchar_t* localeName,[In, Optional] const void** features,[In, Buffer, Optional] const unsigned int* featureRangeLengths,[In] unsigned int featureRanges,[Out, Buffer] float* glyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* glyphOffsets)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.#ctor(SharpDX.DirectWrite.Factory,System.String,System.Single)">
            <summary>	
             Creates a text format object used for text layout with normal weight, style and stretch.
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="fontFamilyName">An array of characters that contains the name of the font family</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</param>
            <unmanaged>HRESULT CreateTextFormat([In] const wchar* fontFamilyName,[None] IDWriteFontCollection* fontCollection,[None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_FONT_STRETCH fontStretch,[None] FLOAT fontSize,[In] const wchar* localeName,[Out] IDWriteTextFormat** textFormat)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStyle,System.Single)">
            <summary>	
             Creates a text format object used for text layout with normal stretch.
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="fontFamilyName">An array of characters that contains the name of the font family</param>
            <param name="fontWeight">A value that indicates the font weight for the text object created by this method.</param>
            <param name="fontStyle">A value that indicates the font style for the text object created by this method.</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</param>
            <unmanaged>HRESULT CreateTextFormat([In] const wchar* fontFamilyName,[None] IDWriteFontCollection* fontCollection,[None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_FONT_STRETCH fontStretch,[None] FLOAT fontSize,[In] const wchar* localeName,[Out] IDWriteTextFormat** textFormat)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.FontStretch,System.Single)">
            <summary>	
             Creates a text format object used for text layout. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="fontFamilyName">An array of characters that contains the name of the font family</param>
            <param name="fontWeight">A value that indicates the font weight for the text object created by this method.</param>
            <param name="fontStyle">A value that indicates the font style for the text object created by this method.</param>
            <param name="fontStretch">A value that indicates the font stretch for the text object created by this method.</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</param>
            <unmanaged>HRESULT CreateTextFormat([In] const wchar* fontFamilyName,[None] IDWriteFontCollection* fontCollection,[None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_FONT_STRETCH fontStretch,[None] FLOAT fontSize,[In] const wchar* localeName,[Out] IDWriteTextFormat** textFormat)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.FontCollection,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.FontStretch,System.Single)">
            <summary>	
             Creates a text format object used for text layout. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="fontFamilyName">An array of characters that contains the name of the font family</param>
            <param name="fontCollection">A pointer to a font collection object. When this is NULL, indicates the system font collection.</param>
            <param name="fontWeight">A value that indicates the font weight for the text object created by this method.</param>
            <param name="fontStyle">A value that indicates the font style for the text object created by this method.</param>
            <param name="fontStretch">A value that indicates the font stretch for the text object created by this method.</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</param>
            <unmanaged>HRESULT CreateTextFormat([In] const wchar* fontFamilyName,[None] IDWriteFontCollection* fontCollection,[None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_FONT_STRETCH fontStretch,[None] FLOAT fontSize,[In] const wchar* localeName,[Out] IDWriteTextFormat** textFormat)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.FontCollection,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.FontStretch,System.Single,System.String)">
            <summary>	
             Creates a text format object used for text layout. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="fontFamilyName">An array of characters that contains the name of the font family</param>
            <param name="fontCollection">A pointer to a font collection object. When this is NULL, indicates the system font collection.</param>
            <param name="fontWeight">A value that indicates the font weight for the text object created by this method.</param>
            <param name="fontStyle">A value that indicates the font style for the text object created by this method.</param>
            <param name="fontStretch">A value that indicates the font stretch for the text object created by this method.</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIP equals 1/96 inch.</param>
            <param name="localeName">An array of characters that contains the locale name.</param>
            <unmanaged>HRESULT CreateTextFormat([In] const wchar* fontFamilyName,[None] IDWriteFontCollection* fontCollection,[None] DWRITE_FONT_WEIGHT fontWeight,[None] DWRITE_FONT_STYLE fontStyle,[None] DWRITE_FONT_STRETCH fontStretch,[None] FLOAT fontSize,[In] const wchar* localeName,[Out] IDWriteTextFormat** textFormat)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FontFamilyName">
            <summary>	
            Gets a copy of the font family name. 	
            </summary>	
            <returns>the current font family name. </returns>
            <unmanaged>HRESULT IDWriteTextFormat::GetFontFamilyName([Out, Buffer] wchar_t* fontFamilyName,[None] int nameSize)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.LocaleName">
            <summary>	
            Gets a copy of the locale name. 	
            </summary>	
            <returns>the current locale name.</returns>
            <unmanaged>HRESULT IDWriteTextFormat::GetLocaleName([Out, Buffer] wchar_t* localeName,[None] int nameSize)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.TextAlignment">
            <summary>
            <p>Gets or sets the alignment option of text relative to the layout box's leading and trailing edge. </p>
            </summary>
            <doc-id>dd316681</doc-id>
            <unmanaged>GetTextAlignment / SetTextAlignment</unmanaged>
            <unmanaged-short>GetTextAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.ParagraphAlignment">
            <summary>
            <p>Gets or sets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. </p>
            </summary>
            <doc-id>dd316675</doc-id>
            <unmanaged>GetParagraphAlignment / SetParagraphAlignment</unmanaged>
            <unmanaged-short>GetParagraphAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.WordWrapping">
            <summary>
            <p>Gets or sets the word wrapping option. </p>
            </summary>
            <doc-id>dd316688</doc-id>
            <unmanaged>GetWordWrapping / SetWordWrapping</unmanaged>
            <unmanaged-short>GetWordWrapping</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.ReadingDirection">
            <summary>
            <p>Gets or sets the  current reading direction for text in a paragraph. </p>
            </summary>
            <doc-id>dd316678</doc-id>
            <unmanaged>GetReadingDirection / SetReadingDirection</unmanaged>
            <unmanaged-short>GetReadingDirection</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FlowDirection">
            <summary>
            <p>Gets or sets the direction that text lines flow. </p>
            </summary>
            <doc-id>dd316631</doc-id>
            <unmanaged>GetFlowDirection / SetFlowDirection</unmanaged>
            <unmanaged-short>GetFlowDirection</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.IncrementalTabStop">
            <summary>
            <p>Gets or sets the  incremental tab stop position. </p>
            </summary>
            <doc-id>dd316655</doc-id>
            <unmanaged>GetIncrementalTabStop / SetIncrementalTabStop</unmanaged>
            <unmanaged-short>GetIncrementalTabStop</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FontCollection">
            <summary>
            <p> Gets the current font collection. </p>
            </summary>
            <doc-id>dd316633</doc-id>
            <unmanaged>GetFontCollection</unmanaged>
            <unmanaged-short>GetFontCollection</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FontWeight">
            <summary>
            <p> Gets the font weight of the text. </p>
            </summary>
            <doc-id>dd316652</doc-id>
            <unmanaged>GetFontWeight</unmanaged>
            <unmanaged-short>GetFontWeight</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FontStyle">
            <summary>
            <p> Gets the font style of the text.</p>
            </summary>
            <doc-id>dd316649</doc-id>
            <unmanaged>GetFontStyle</unmanaged>
            <unmanaged-short>GetFontStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FontStretch">
            <summary>
            <p> Gets the font stretch of the text. </p>
            </summary>
            <doc-id>dd316646</doc-id>
            <unmanaged>GetFontStretch</unmanaged>
            <unmanaged-short>GetFontStretch</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat.FontSize">
            <summary>
            <p> Gets the font  size in DIP unites. </p>
            </summary>
            <doc-id>dd316643</doc-id>
            <unmanaged>GetFontSize</unmanaged>
            <unmanaged-short>GetFontSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetTextAlignment(SharpDX.DirectWrite.TextAlignment)">
            <summary>
            <p>Sets the alignment of text in a paragraph, relative to the leading and trailing edge of a layout box for a <strong><see cref = "T:SharpDX.DirectWrite.TextFormat"/></strong> interface.</p>
            </summary>
            <param name = "textAlignment">No documentation.</param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The method succeeded.</p> </td></tr> <tr><td> <dl> <dt><strong>E_INVALIDARG</strong></dt> </dl> </td><td> <p>The textAlignment argument is invalid.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> The text can be aligned to the leading or trailing edge of the layout box, or it can be centered.  The following illustration shows text with the alignment set to <strong>DWRITE_TEXT_ALIGNMENT_LEADING</strong>, <strong>DWRITE_TEXT_ALIGNMENT_CENTER</strong>, and <strong>DWRITE_TEXT_ALIGNMENT_TRAILING</strong>, respectively.  </p><p></p><strong>Note</strong>??The alignment is dependent on reading direction, the above is for left-to-right reading direction.  For right-to-left reading direction it would be the opposite.?<p>See <strong><see cref = "T:SharpDX.DirectWrite.TextAlignment"/></strong> for more information. </p>
            </remarks>
            <doc-id>dd316709</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetTextAlignment([In] DWRITE_TEXT_ALIGNMENT textAlignment)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetTextAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetParagraphAlignment(SharpDX.DirectWrite.ParagraphAlignment)">
            <summary>
            <p> Sets the alignment option of a paragraph relative to the layout box's top and bottom edge. </p>
            </summary>
            <param name = "paragraphAlignment"><dd>  <p>The paragraph alignment option being set for a paragraph; see <strong><see cref = "T:SharpDX.DirectWrite.ParagraphAlignment"/></strong> for more information.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316702</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetParagraphAlignment([In] DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetParagraphAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetWordWrapping(SharpDX.DirectWrite.WordWrapping)">
            <summary>
            <p> Sets the word wrapping option. </p>
            </summary>
            <param name = "wordWrapping"><dd>  <p>The word wrapping option being set for a paragraph; see <strong><see cref = "T:SharpDX.DirectWrite.WordWrapping"/></strong> for more information.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316715</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetWordWrapping([In] DWRITE_WORD_WRAPPING wordWrapping)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetWordWrapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetReadingDirection(SharpDX.DirectWrite.ReadingDirection)">
            <summary>
            <p> Sets the paragraph reading direction. </p>
            </summary>
            <param name = "readingDirection"><dd>  <p> The text reading direction (for example, <strong>DWRITE_READING_DIRECTION_RIGHT_TO_LEFT</strong> for languages, such as  Arabic, that read from right to left) for a paragraph. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The reading direction and flow direction must always be set 90 degrees orthogonal to each other, or else you will get the error DWRITE_E_FLOWDIRECTIONCONFLICTS when you  use layout functions like Draw or GetMetrics. So if you set a vertical reading direction (for example, to DWRITE_READING_DIRECTION_TOP_TO_BOTTOM), then you must also  use SetFlowDirection to set the flow direction appropriately (for example, to DWRITE_FLOW_DIRECTION_RIGHT_TO_LEFT). </p>
            </remarks>
            <doc-id>dd316705</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetReadingDirection([In] DWRITE_READING_DIRECTION readingDirection)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetReadingDirection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetFlowDirection(SharpDX.DirectWrite.FlowDirection)">
            <summary>
            <p> Sets the  paragraph flow direction. </p>
            </summary>
            <param name = "flowDirection"><dd>  <p>The paragraph flow direction; see <strong><see cref = "T:SharpDX.DirectWrite.FlowDirection"/></strong> for more information.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316691</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetFlowDirection([In] DWRITE_FLOW_DIRECTION flowDirection)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetFlowDirection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetIncrementalTabStop(System.Single)">
            <summary>
            <p> Sets a fixed distance between two adjacent tab stops. </p>
            </summary>
            <param name = "incrementalTabStop"><dd>  <p>The fixed distance between two adjacent tab stops.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316695</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetIncrementalTabStop([In] float incrementalTabStop)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetIncrementalTabStop</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetTrimming(SharpDX.DirectWrite.Trimming,SharpDX.DirectWrite.InlineObject)">
            <summary>
            <p> Sets trimming options for text overflowing the layout width. </p>
            </summary>
            <param name = "trimmingOptions"><dd>  <p>Text trimming options.</p> </dd></param>
            <param name = "trimmingSign"><dd>  <p>Application-defined omission sign. This parameter may be <strong><c>null</c></strong>. See <strong><see cref = "T:SharpDX.DirectWrite.InlineObject"/></strong> for more information.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316712</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetTrimming([In] const DWRITE_TRIMMING* trimmingOptions,[In, Optional] IDWriteInlineObject* trimmingSign)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetTrimming</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.SetLineSpacing(SharpDX.DirectWrite.LineSpacingMethod,System.Single,System.Single)">
            <summary>
            <p> Sets the  line spacing. </p>
            </summary>
            <param name = "lineSpacingMethod"><dd>  <p>Specifies how line height is being determined; see <strong><see cref = "T:SharpDX.DirectWrite.LineSpacingMethod"/></strong> for more information.</p> </dd></param>
            <param name = "lineSpacing"><dd>  <p>The line height, or distance between one baseline to another.</p> </dd></param>
            <param name = "baseline"><dd>  <p>The distance from top of line to baseline. A reasonable ratio to <em>lineSpacing</em> is 80 percent.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> For the default method, spacing depends solely on the content. For uniform spacing, the specified line height overrides the content. </p>
            </remarks>
            <doc-id>dd316698</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::SetLineSpacing([In] DWRITE_LINE_SPACING_METHOD lineSpacingMethod,[In] float lineSpacing,[In] float baseline)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::SetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetTextAlignment">
            <summary>
            <p> Gets the alignment option of text relative to the layout box's leading and trailing edge. </p>
            </summary>
            <returns><p>Returns the text alignment option of the current paragraph.</p></returns>
            <doc-id>dd316681</doc-id>
            <unmanaged>DWRITE_TEXT_ALIGNMENT IDWriteTextFormat::GetTextAlignment()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetTextAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetParagraphAlignment">
            <summary>
            <p> Gets the alignment option of a paragraph which is  relative to the top and bottom edges of a layout box. </p>
            </summary>
            <returns><p>A value that indicates the current paragraph alignment option.</p></returns>
            <doc-id>dd316675</doc-id>
            <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT IDWriteTextFormat::GetParagraphAlignment()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetParagraphAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetWordWrapping">
            <summary>
            <p> Gets the word wrapping option. </p>
            </summary>
            <returns><p>Returns the word wrapping option; see <strong><see cref = "T:SharpDX.DirectWrite.WordWrapping"/></strong> for more information.</p></returns>
            <doc-id>dd316688</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING IDWriteTextFormat::GetWordWrapping()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetWordWrapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetReadingDirection">
            <summary>
            <p> Gets the  current reading direction for text in a paragraph. </p>
            </summary>
            <returns><p>A value that indicates the current reading direction for text in a  paragraph.</p></returns>
            <doc-id>dd316678</doc-id>
            <unmanaged>DWRITE_READING_DIRECTION IDWriteTextFormat::GetReadingDirection()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetReadingDirection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFlowDirection">
            <summary>
            <p> Gets the direction that text lines flow. </p>
            </summary>
            <returns><p>The direction that text lines flow within their parent container.  For example, <strong>DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM</strong> indicates that text lines are placed from top to bottom.</p></returns>
            <doc-id>dd316631</doc-id>
            <unmanaged>DWRITE_FLOW_DIRECTION IDWriteTextFormat::GetFlowDirection()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFlowDirection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetIncrementalTabStop">
            <summary>
            <p> Gets the  incremental tab stop position. </p>
            </summary>
            <returns><p>The incremental tab stop value.</p></returns>
            <doc-id>dd316655</doc-id>
            <unmanaged>float IDWriteTextFormat::GetIncrementalTabStop()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetIncrementalTabStop</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetTrimming(SharpDX.DirectWrite.Trimming@,SharpDX.DirectWrite.InlineObject@)">
            <summary>
            <p> Gets the trimming options for text that overflows the layout box. </p>
            </summary>
            <param name = "trimmingOptions"><dd>  <p>When this method returns, it contains a reference to a <strong><see cref = "T:SharpDX.DirectWrite.Trimming"/></strong> structure that holds the text trimming options for the overflowing text.</p> </dd></param>
            <param name = "trimmingSign"><dd>  <p>When this method returns, contains an address of a reference to a trimming omission sign. This parameter may be <strong><c>null</c></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316684</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::GetTrimming([Out] DWRITE_TRIMMING* trimmingOptions,[Out] IDWriteInlineObject** trimmingSign)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetTrimming</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetLineSpacing(SharpDX.DirectWrite.LineSpacingMethod@,System.Single@,System.Single@)">
            <summary>
            <p> Gets the line spacing adjustment set for a multiline text paragraph. </p>
            </summary>
            <param name = "lineSpacingMethod"><dd>  <p>A value that indicates how line height is determined.</p> </dd></param>
            <param name = "lineSpacing"><dd>  <p>When this method returns, contains the line height, or  distance between one baseline to another.</p> </dd></param>
            <param name = "baseline"><dd>  <p>When this method returns, contains the distance from top of line to baseline. A reasonable ratio to <em>lineSpacing</em> is 80 percent.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316657</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::GetLineSpacing([Out] DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,[Out] float* lineSpacing,[Out] float* baseline)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontCollection(SharpDX.DirectWrite.FontCollection@)">
            <summary>
            <p> Gets the current font collection. </p>
            </summary>
            <param name = "fontCollection"><dd>  <p>When this method returns, contains an address of a reference to the font collection being used for the current text.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316633</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontFamilyNameLength">
            <summary>
            <p> Gets the length of the font family name. </p>
            </summary>
            <returns><p>The size of the character array, in character count, not including the terminated <strong><c>null</c></strong> character.</p></returns>
            <doc-id>dd316640</doc-id>
            <unmanaged>unsigned int IDWriteTextFormat::GetFontFamilyNameLength()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontFamilyNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontFamilyName(System.IntPtr,System.Int32)">
            <summary>
            <p> Gets a copy of the font family name. </p>
            </summary>
            <param name = "fontFamilyName"><dd>  <p>When this method returns, contains a reference to a character array, which is null-terminated, that receives the current font family name. The buffer allocated for this array should be at least the size, in elements, of <em>nameSize</em>.</p> </dd></param>
            <param name = "nameSize"><dd>  <p>The size of the <em>fontFamilyName</em> character array, in character count, including the terminated <strong><c>null</c></strong> character.  To find the size of <em>fontFamilyName</em>, use <strong>GetFontFamilyNameLength</strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316636</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::GetFontFamilyName([Out, Buffer] wchar_t* fontFamilyName,[In] unsigned int nameSize)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontFamilyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontWeight">
            <summary>
            <p> Gets the font weight of the text. </p>
            </summary>
            <returns><p>A value that indicates the type of weight (such as normal, bold, or black). </p></returns>
            <doc-id>dd316652</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT IDWriteTextFormat::GetFontWeight()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontWeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontStyle">
            <summary>
            <p> Gets the font style of the text.</p>
            </summary>
            <returns><p>A value which indicates the type of font style (such as  slope or incline).</p></returns>
            <doc-id>dd316649</doc-id>
            <unmanaged>DWRITE_FONT_STYLE IDWriteTextFormat::GetFontStyle()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontStretch">
            <summary>
            <p> Gets the font stretch of the text. </p>
            </summary>
            <returns><p>A value which indicates the type of font stretch (such as  normal or condensed).</p></returns>
            <doc-id>dd316646</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH IDWriteTextFormat::GetFontStretch()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontStretch</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetFontSize">
            <summary>
            <p> Gets the font  size in DIP unites. </p>
            </summary>
            <returns><p>The current font size in DIP units.</p></returns>
            <doc-id>dd316643</doc-id>
            <unmanaged>float IDWriteTextFormat::GetFontSize()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetFontSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetLocaleNameLength">
            <summary>
            <p> Gets the length of the locale name. </p>
            </summary>
            <returns><p>The size of the character array in character count, not including the terminated <strong><c>null</c></strong> character.</p></returns>
            <doc-id>dd316674</doc-id>
            <unmanaged>unsigned int IDWriteTextFormat::GetLocaleNameLength()</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetLocaleNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat.GetLocaleName(System.IntPtr,System.Int32)">
            <summary>
            <p> Gets a copy of the locale name. </p>
            </summary>
            <param name = "localeName"><dd>  <p>Contains a character array that receives the current locale name.</p> </dd></param>
            <param name = "nameSize"><dd>  <p>The size of the character array, in character count, including the terminated <strong><c>null</c></strong> character. Use <strong>GetLocaleNameLength</strong> to get the size of the locale name character array.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316659</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat::GetLocaleName([Out, Buffer] wchar_t* localeName,[In] unsigned int nameSize)</unmanaged>
            <unmanaged-short>IDWriteTextFormat::GetLocaleName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.TextFormat,System.Single,System.Single)">
            <summary>	
             Takes a string, text format, and associated constraints, and produces an object that represents the fully analyzed and formatted result. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="text">An array of characters that contains the string to create a new <see cref="T:SharpDX.DirectWrite.TextLayout"/> object from. This array must be of length stringLength and can contain embedded NULL characters.</param>
            <param name="textFormat">A pointer to an object that indicates the format to apply to the string.</param>
            <param name="maxWidth">The width of the layout box.</param>
            <param name="maxHeight">The height of the layout box.</param>
            <unmanaged>HRESULT CreateTextLayout([In, Buffer] const wchar* string,[None] UINT32 stringLength,[None] IDWriteTextFormat* textFormat,[None] FLOAT maxWidth,[None] FLOAT maxHeight,[Out] IDWriteTextLayout** textLayout)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.TextFormat,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>	
            Create a Gdi Compatible TextLayout. Takes a string, format, and associated constraints, and produces an object representing the result, formatted for a particular display resolution and measuring mode.  	
            </summary>	
            <remarks>	
            The resulting text layout should only be used for the intended resolution, and for cases where text scalability is desired {{CreateTextLayout}} should be used instead. 	
            </remarks>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="text">An array of characters that contains the string to create a new <see cref="T:SharpDX.DirectWrite.TextLayout" /> object from. This array must be of length stringLength and can contain embedded NULL characters. </param>
            <param name="textFormat">The text formatting object to apply to the string. </param>
            <param name="layoutWidth">The width of the layout box. </param>
            <param name="layoutHeight">The height of the layout box. </param>
            <param name="pixelsPerDip">The number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI device pixelsPerDip is 1. If rendering onto a 120 DPI device pixelsPerDip is 1.25 (120/96). </param>
            <param name="useGdiNatural">Instructs the text layout to use the same metrics as GDI bi-level text when set to FALSE. When set to TRUE, instructs the text layout to use the same metrics as text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY.  </param>
            <unmanaged>HRESULT IDWriteFactory::CreateGdiCompatibleTextLayout([In, Buffer] const wchar_t* string,[None] int stringLength,[None] IDWriteTextFormat* textFormat,[None] float layoutWidth,[None] float layoutHeight,[None] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] BOOL useGdiNatural,[Out] IDWriteTextLayout** textLayout)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.#ctor(SharpDX.DirectWrite.Factory,System.String,SharpDX.DirectWrite.TextFormat,System.Single,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Boolean)">
            <summary>	
            Create a GDI Compatible TextLayout. Takes a string, format, and associated constraints, and produces an object representing the result, formatted for a particular display resolution and measuring mode.  	
            </summary>	
            <remarks>	
            The resulting text layout should only be used for the intended resolution, and for cases where text scalability is desired {{CreateTextLayout}} should be used instead. 	
            </remarks>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <param name="text">An array of characters that contains the string to create a new <see cref="T:SharpDX.DirectWrite.TextLayout" /> object from. This array must be of length stringLength and can contain embedded NULL characters. </param>
            <param name="textFormat">The text formatting object to apply to the string. </param>
            <param name="layoutWidth">The width of the layout box. </param>
            <param name="layoutHeight">The height of the layout box. </param>
            <param name="pixelsPerDip">The number of physical pixels per DIP (device independent pixel). For example, if rendering onto a 96 DPI device pixelsPerDip is 1. If rendering onto a 120 DPI device pixelsPerDip is 1.25 (120/96). </param>
            <param name="transform">An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specifies the font size and pixels per DIP. </param>
            <param name="useGdiNatural">Instructs the text layout to use the same metrics as GDI bi-level text when set to FALSE. When set to TRUE, instructs the text layout to use the same metrics as text measured by GDI using a font created with CLEARTYPE_NATURAL_QUALITY.  </param>
            <unmanaged>HRESULT IDWriteFactory::CreateGdiCompatibleTextLayout([In, Buffer] const wchar_t* string,[None] int stringLength,[None] IDWriteTextFormat* textFormat,[None] float layoutWidth,[None] float layoutHeight,[None] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[None] BOOL useGdiNatural,[Out] IDWriteTextLayout** textLayout)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.Draw(SharpDX.DirectWrite.TextRenderer,System.Single,System.Single)">
            <summary>	
             Draws text using the specified client drawing context.	
            </summary>	
            <remarks>	
            To draw text with this method, a textLayout object needs to be created by the application using <see cref="M:SharpDX.DirectWrite.Factory.CreateTextLayout(System.String,System.Int32,SharpDX.DirectWrite.TextFormat,System.Single,System.Single,SharpDX.DirectWrite.TextLayout)"/>. After the textLayout object is obtained, the application calls the  IDWriteTextLayout::Draw method  to draw the text, decorations, and inline objects. The actual drawing is done through the callback interface passed in as the textRenderer argument; there, the corresponding DrawGlyphRun API is called. 	
            </remarks>	
            <param name="renderer">Pointer to the set of callback functions used to draw parts of a text string.</param>
            <param name="originX">The x-coordinate of the layout's left side.</param>
            <param name="originY">The y-coordinate of the layout's top side.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] FLOAT originX,[None] FLOAT originY)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.Draw(System.Object,SharpDX.DirectWrite.TextRenderer,System.Single,System.Single)">
            <summary>	
             Draws text using the specified client drawing context.	
            </summary>	
            <remarks>	
            To draw text with this method, a textLayout object needs to be created by the application using <see cref="M:SharpDX.DirectWrite.Factory.CreateTextLayout(System.String,System.Int32,SharpDX.DirectWrite.TextFormat,System.Single,System.Single,SharpDX.DirectWrite.TextLayout)"/>. After the textLayout object is obtained, the application calls the  IDWriteTextLayout::Draw method  to draw the text, decorations, and inline objects. The actual drawing is done through the callback interface passed in as the textRenderer argument; there, the corresponding DrawGlyphRun API is called. 	
            </remarks>	
            <param name="clientDrawingContext">An application-defined drawing context. </param>
            <param name="renderer">Pointer to the set of callback functions used to draw parts of a text string.</param>
            <param name="originX">The x-coordinate of the layout's left side.</param>
            <param name="originY">The y-coordinate of the layout's top side.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT Draw([None] void* clientDrawingContext,[None] IDWriteTextRenderer* renderer,[None] FLOAT originX,[None] FLOAT originY)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetClusterMetrics">
            <summary>	
            Retrieves logical properties and measurements of each glyph cluster. 	
            </summary>	
            <remarks>	
            If maxClusterCount is not large enough, then E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and actualClusterCount is set to the number of clusters needed.  	
            </remarks>	
            <returns>Returns metrics, such as line-break or total advance width, for a glyph cluster. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetClusterMetrics([Out, Buffer, Optional] DWRITE_CLUSTER_METRICS* clusterMetrics,[None] int maxClusterCount,[Out] int* actualClusterCount)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetDrawingEffect(SharpDX.ComObject,SharpDX.DirectWrite.TextRange)">
            <summary>	
            Sets the application-defined drawing effect. 	
            </summary>	
            <remarks>	
            An <see cref="T:SharpDX.Direct2D1.Brush"/>, such as a color or gradient brush, can be set as a drawing effect if you are using the <see cref="!:RenderTarget.DrawTextLayout(System.Drawing.PointF,SharpDX.DirectWrite.TextLayout,SharpDX.Direct2D1.Brush,SharpDX.Direct2D1.DrawTextOptions)"/> to draw text and that brush will be used to draw the specified range of text.  This drawing effect is associated with the specified range and will be passed back to the application by way of the callback when the range is drawn at drawing time.  	
            </remarks>	
            <param name="drawingEffect">Application-defined drawing effects that apply to the range. This data object will be passed back to the application's drawing callbacks for final rendering. </param>
            <param name="textRange">The text range to which this change applies. </param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::SetDrawingEffect([None] IUnknown* drawingEffect,[None] DWRITE_TEXT_RANGE textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetDrawingEffect(System.Int32)">
            <summary>	
            Gets the application-defined drawing effect at the specified text position. 	
            </summary>	
            <param name="currentPosition">The position of the text whose drawing effect is to be retrieved. </param>
            <returns>a reference to  the current application-defined drawing effect. Usually this effect is a foreground brush that  is used in glyph drawing. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetDrawingEffect([None] int currentPosition,[Out] IUnknown** drawingEffect,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetDrawingEffect(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>	
            Gets the application-defined drawing effect at the specified text position. 	
            </summary>	
            <param name="currentPosition">The position of the text whose drawing effect is to be retrieved. </param>
            <param name="textRange">Contains the range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the drawing effect. </param>
            <returns>a reference to  the current application-defined drawing effect. Usually this effect is a foreground brush that  is used in glyph drawing. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetDrawingEffect([None] int currentPosition,[Out] IUnknown** drawingEffect,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontCollection(System.Int32)">
            <summary>	
            Gets the font collection associated with the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>a  reference to the current font collection.</returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontCollection([None] int currentPosition,[Out] IDWriteFontCollection** fontCollection,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontFamilyName(System.Int32)">
            <summary>	
            Gets the font family name of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to examine. </param>
            <returns>the font family name </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyName([None] int currentPosition,[Out, Buffer] wchar_t* fontFamilyName,[None] int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontFamilyName(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>	
            Gets the font family name of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to examine. </param>
            <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the font family name. </param>
            <returns>the font family name </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyName([None] int currentPosition,[Out, Buffer] wchar_t* fontFamilyName,[None] int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontSize(System.Int32)">
            <summary>	
            Gets the font em height of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>The size of the font in ems of the text at the specified position. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontSize([None] int currentPosition,[Out] float* fontSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontStretch(System.Int32)">
            <summary>	
            Gets the font stretch of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>a value which indicates the type of font stretch (also known as width) being applied at the specified position.</returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontStretch([None] int currentPosition,[Out] DWRITE_FONT_STRETCH* fontStretch,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontStyle(System.Int32)">
            <summary>	
            Gets the font style (also known as slope) of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>a value which indicates the type of font style (also known as slope or incline) being applied at the specified position.</returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontStyle([None] int currentPosition,[Out] DWRITE_FONT_STYLE* fontStyle,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontWeight(System.Int32)">
            <summary>	
            Gets the font weight of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>a value which indicates the type of font weight being applied at the specified position.</returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontWeight([None] int currentPosition,[Out] DWRITE_FONT_WEIGHT* fontWeight,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetInlineObject(System.Int32)">
            <summary>	
            Gets the inline object at the specified position. 	
            </summary>	
            <param name="currentPosition">The specified text position. </param>
            <returns>an application-defined inline object. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetInlineObject([None] int currentPosition,[Out] IDWriteInlineObject** inlineObject,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetLineMetrics">
            <summary>	
            Retrieves the information about each individual text line of the  text string. 	
            </summary>	
            <remarks>	
            If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and *actualLineCount is set to the number of lines needed.  	
            </remarks>	
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS* lineMetrics,[None] int maxLineCount,[Out] int* actualLineCount)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetLocaleName(System.Int32)">
            <summary>	
            Gets the locale name of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>the locale name of the text at the specified position. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetLocaleName([None] int currentPosition,[Out, Buffer] wchar_t* localeName,[None] int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetLocaleName(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>	
            Gets the locale name of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <param name="textRange">The range of text that has the same  formatting as the text at the position specified by currentPosition.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name. </param>
            <returns>the locale name of the text at the specified position. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetLocaleName([None] int currentPosition,[Out, Buffer] wchar_t* localeName,[None] int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HasStrikethrough(System.Int32)">
            <summary>	
            Get the strikethrough presence of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>A Boolean  flag that indicates whether strikethrough is present at the position indicated by currentPosition. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetStrikethrough([None] int currentPosition,[Out] BOOL* hasStrikethrough,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetTypography(System.Int32)">
            <summary>	
            Gets the typography setting of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The position of the text to inspect. </param>
            <returns>a  reference to the current typography setting. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetTypography([None] int currentPosition,[Out] IDWriteTypography** typography,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HasUnderline(System.Int32)">
            <summary>	
            Gets the underline presence of the text at the specified position. 	
            </summary>	
            <param name="currentPosition">The current text position. </param>
            <returns>A Boolean  flag that indicates whether underline is present at the position indicated by currentPosition. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::GetUnderline([None] int currentPosition,[Out] BOOL* hasUnderline,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HitTestTextRange(System.Int32,System.Int32,System.Single,System.Single)">
            <summary>	
            The application calls this function to get a set of hit-test metrics corresponding to a range of text positions. 
            One of the main usages is to implement highlight selection of the text string. 
            The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), 
            when the buffer size of hitTestMetrics is too small to hold all the regions calculated by the function. 
            In this situation, the function sets the output value *actualHitTestMetricsCount to the number of geometries calculated. 
            The application is responsible for allocating a new buffer of greater size and calling the function again. 
            A good value to use as an initial value for maxHitTestMetricsCount may be calculated from the following equation: 
            maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth where lineCount is obtained from the value of the output argument *actualLineCount (from the function IDWriteTextLayout::GetLineLengths), and the maxBidiReorderingDepth value from the DWRITE_TEXT_METRICS structure of the output argument *textMetrics (from the function IDWriteFactory::CreateTextLayout). 	
            </summary>	
            <param name="textPosition">The first text position of the specified range. </param>
            <param name="textLength">The number of positions of the specified range. </param>
            <param name="originX">The origin pixel location X at the left of the layout box. This offset is added to the hit-test metrics returned. </param>
            <param name="originY">The origin pixel location Y at the top of the layout box. This offset is added to the hit-test metrics returned. </param>
            <returns>a reference to a buffer of the output geometry fully enclosing the specified position range.  The buffer must be at least as large as maxHitTestMetricsCount. </returns>
            <unmanaged>HRESULT IDWriteTextLayout::HitTestTextRange([None] int textPosition,[None] int textLength,[None] float originX,[None] float originY,[Out, Buffer, Optional] DWRITE_HIT_TEST_METRICS* hitTestMetrics,[None] int maxHitTestMetricsCount,[Out] int* actualHitTestMetricsCount)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout.MaxWidth">
            <summary>
            <p>Gets or sets the layout maximum width. </p>
            </summary>
            <doc-id>dd316781</doc-id>
            <unmanaged>GetMaxWidth / SetMaxWidth</unmanaged>
            <unmanaged-short>GetMaxWidth</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout.MaxHeight">
            <summary>
            <p>Gets or sets the layout maximum height. </p>
            </summary>
            <doc-id>dd316776</doc-id>
            <unmanaged>GetMaxHeight / SetMaxHeight</unmanaged>
            <unmanaged-short>GetMaxHeight</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout.Metrics">
            <summary>
            <p> Retrieves overall metrics for the formatted string. </p>
            </summary>
            <doc-id>dd316785</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout.OverhangMetrics">
            <summary>
            <p>Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.</p>
            </summary>
            <remarks>
            <p>Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.</p>
            </remarks>
            <doc-id>dd316790</doc-id>
            <unmanaged>GetOverhangMetrics</unmanaged>
            <unmanaged-short>GetOverhangMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetMaxWidth(System.Single)">
            <summary>
            <p> Sets the layout maximum width.</p>
            </summary>
            <param name = "maxWidth"><dd>  <p>A value that indicates the maximum width of the layout box.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371511</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetMaxWidth([In] float maxWidth)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetMaxWidth</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetMaxHeight(System.Single)">
            <summary>
            <p> Sets the layout maximum height. </p>
            </summary>
            <param name = "maxHeight"><dd>  <p>A value that indicates the maximum height of the layout box. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371507</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetMaxHeight([In] float maxHeight)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetMaxHeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetFontCollection(SharpDX.DirectWrite.FontCollection,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the font collection. </p>
            </summary>
            <param name = "fontCollection"><dd>  <p>The font collection to set.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371481</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetFontCollection([In] IDWriteFontCollection* fontCollection,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetFontFamilyName(System.String,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets null-terminated font family name for text within a specified  text range. </p>
            </summary>
            <param name = "fontFamilyName"><dd>  <p>The font family name that applies to the entire text string within the range specified by <em>textRange</em>.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371487</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetFontFamilyName([In] const wchar_t* fontFamilyName,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetFontFamilyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetFontWeight(SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the font weight for text within a text range specified by a <strong><see cref = "T:SharpDX.DirectWrite.TextRange"/></strong> structure. </p>
            </summary>
            <param name = "fontWeight">No documentation.</param>
            <param name = "textRange">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The font weight can be set to one of the predefined font weight values provided in the <strong><see cref = "T:SharpDX.DirectWrite.FontWeight"/></strong> enumeration or an integer from 1 to 999.  Values outside this range will cause the method to fail with an <strong>E_INVALIDARG</strong> return value.</p><p>The following illustration shows an example of Normal and UltraBold weights for the Palatino Linotype typeface.</p>
            </remarks>
            <doc-id>dd371498</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetFontWeight([In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetFontWeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetFontStyle(SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the font style for  text within a text range specified by a <strong><see cref = "T:SharpDX.DirectWrite.TextRange"/></strong> structure.</p>
            </summary>
            <param name = "fontStyle">No documentation.</param>
            <param name = "textRange">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The font style can be set to Normal, Italic or Oblique. The following illustration shows  three styles for the Palatino font.  For more information, see <strong><see cref = "T:SharpDX.DirectWrite.FontStyle"/></strong>.</p><p></p>
            </remarks>
            <doc-id>dd371495</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetFontStyle([In] DWRITE_FONT_STYLE fontStyle,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetFontStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetFontStretch(SharpDX.DirectWrite.FontStretch,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the  font stretch for text within a specified text range. </p>
            </summary>
            <param name = "fontStretch"><dd>  <p>A value which indicates the type of font stretch for text within the range specified by <em>textRange</em>.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371493</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetFontStretch([In] DWRITE_FONT_STRETCH fontStretch,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetFontStretch</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetFontSize(System.Single,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p>Sets the font size in DIP units for text within a specified text range. </p>
            </summary>
            <param name = "fontSize"><dd>  <p>The  font size in DIP units to be set for   text in the range specified by <em>textRange</em>. </p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371490</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetFontSize([In] float fontSize,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetFontSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetUnderline(SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> interface represents a block of text after it has been fully analyzed and formatted.</p>
            </summary>
            <param name = "hasUnderline">No documentation.</param>
            <param name = "textRange">No documentation.</param>
            <returns>No documentation.</returns>
            <remarks>
            <p>To get a reference to the <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> interface, the application must call the <strong>IDWriteFactory::CreateTextLayout</strong> method, as shown in the following code.  </p><pre> // Create a text layout using the text format.
            if (SUCCEEDED(hr))
            { <see cref = "T:SharpDX.Mathematics.Interop.RawRectangle"/> rect; GetClientRect(hwnd_, &amp;rect);  float width  = rect.right  / dpiScaleX_; float height = rect.bottom / dpiScaleY_; hr = pDWriteFactory_-&gt;CreateTextLayout( wszText_,      // The string to be laid out and formatted. cTextLength_,  // The length of the string. pTextFormat_,  // The text format to apply to the string (contains font information, etc). width,         // The width of the layout box. height,        // The height of the layout box. &amp;pTextLayout_  // The <see cref = "T:SharpDX.DirectWrite.TextLayout"/> interface reference. );
            } </pre><p>The <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> interface allows the application to change the format for ranges of the text it represents, specified by a <strong><see cref = "T:SharpDX.DirectWrite.TextRange"/></strong> structure.   The following example shows how to set the font weight for a text range.</p><pre> // Set the font weight to bold for the first 5 letters.
            <see cref = "T:SharpDX.DirectWrite.TextRange"/> textRange = {0, 4}; if (SUCCEEDED(hr))
            { hr = pTextLayout_-&gt;SetFontWeight(DWRITE_FONT_WEIGHT_BOLD, textRange);
            } </pre><p><strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> also provides methods for adding strikethrough,  underline, and inline objects to the text.</p><p>To draw the block of text represented by an <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> object, Direct2D provides the <strong>ID2D1RenderTarget::DrawTextLayout</strong> method. To draw using a custom renderer implement an <strong><see cref = "T:SharpDX.DirectWrite.TextRenderer"/></strong> interface and  call the  <strong>IDWriteTextLayout::Draw</strong> method</p>
            </remarks>
            <doc-id>dd316718</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetUnderline([In] BOOL hasUnderline,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetUnderline</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetStrikethrough(SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p>Sets strikethrough for text within a specified text range. </p>
            </summary>
            <param name = "hasStrikethrough"><dd>  <p>A Boolean flag that indicates whether strikethrough takes place in the range specified by <em>textRange</em>.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371514</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetStrikethrough([In] BOOL hasStrikethrough,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetStrikethrough</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetDrawingEffect(System.IntPtr,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the application-defined drawing effect. </p>
            </summary>
            <param name = "drawingEffect"><dd>  <p>Application-defined drawing effects that apply to the range. This data object will be passed back to the application's drawing callbacks for final rendering.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>An <strong><see cref = "T:SharpDX.Direct2D1.Brush"/></strong>, such as a color or gradient brush, can be set as a drawing effect if you are using the <strong>ID2D1RenderTarget::DrawTextLayout</strong> to draw text and that brush will be used to draw the specified range of text.</p><p> This drawing effect is associated with the specified range and will be passed back to the application by way of the callback when the range is drawn at drawing time. </p>
            </remarks>
            <doc-id>dd371477</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetDrawingEffect([In] IUnknown* drawingEffect,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetDrawingEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetInlineObject(SharpDX.DirectWrite.InlineObject,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the inline object. </p>
            </summary>
            <param name = "inlineObject"><dd>  <p>An application-defined inline object. </p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The application may call this function to specify the set of properties describing an application-defined inline object for specific range.</p><p> This inline object applies to the specified range and will be passed back to the application by way of the <strong>DrawInlineObject</strong> callback when the range is drawn. Any text in that range will be suppressed. </p>
            </remarks>
            <doc-id>dd371500</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetInlineObject([In] IDWriteInlineObject* inlineObject,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetInlineObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetTypography(SharpDX.DirectWrite.Typography,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets  font typography features for text within a specified text range. </p>
            </summary>
            <param name = "typography"><dd>  <p>Pointer to font typography settings. </p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371517</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetTypography([In] IDWriteTypography* typography,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetTypography</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.SetLocaleName(System.String,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p> Sets the locale name for text within a specified text range.</p>
            </summary>
            <param name = "localeName"><dd>  <p>A null-terminated locale name string.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371503</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::SetLocaleName([In] const wchar_t* localeName,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::SetLocaleName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetMaxWidth">
            <summary>
            <p> Gets the layout maximum width. </p>
            </summary>
            <returns><p>Returns the layout maximum width.</p></returns>
            <doc-id>dd316781</doc-id>
            <unmanaged>float IDWriteTextLayout::GetMaxWidth()</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetMaxWidth</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetMaxHeight">
            <summary>
            <p> Gets the layout maximum height. </p>
            </summary>
            <returns><p>The layout maximum height.</p></returns>
            <doc-id>dd316776</doc-id>
            <unmanaged>float IDWriteTextLayout::GetMaxHeight()</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetMaxHeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontCollection(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the font collection associated with the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</p> </dd></param>
            <returns><dd>  <p>Contains an address of a  reference to the current font collection.</p> </dd></returns>
            <doc-id>dd316735</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontCollection([In] unsigned int currentPosition,[Out] IDWriteFontCollection** fontCollection,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontFamilyNameLength(System.Int32,System.Int32@,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Get the length of the font family name at the current position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
            <param name = "nameLength"><dd>  <p>When this method returns, contains the size of the character array containing the font family name, in character count, not including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font family.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316741</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyNameLength([In] unsigned int currentPosition,[Out] unsigned int* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontFamilyNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontFamilyName(System.Int32,System.IntPtr,System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Copies the font family name of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to examine.</p> </dd></param>
            <param name = "fontFamilyName"><dd>  <p>When this method returns, contains an array of characters that receives the current font family name. You must allocate storage for this parameter.</p> </dd></param>
            <param name = "nameSize"><dd>  <p>The size of the character array in character count including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font family name.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316738</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontFamilyName([In] unsigned int currentPosition,[Out, Buffer] wchar_t* fontFamilyName,[In] unsigned int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontFamilyName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontWeight(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the font weight of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font weight.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a value which indicates the type of font weight being applied at the specified position.</p> </dd></returns>
            <doc-id>dd316753</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontWeight([In] unsigned int currentPosition,[Out] DWRITE_FONT_WEIGHT* fontWeight,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontWeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontStyle(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the font style (also known as slope) of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font style.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a value which indicates the type of font style (also known as slope or incline) being applied at the specified position.</p> </dd></returns>
            <doc-id>dd316750</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontStyle([In] unsigned int currentPosition,[Out] DWRITE_FONT_STYLE* fontStyle,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontStretch(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the font stretch of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font stretch.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains a value which indicates the type of font stretch (also known as width) being applied at the specified position.</p> </dd></returns>
            <doc-id>dd316747</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontStretch([In] unsigned int currentPosition,[Out] DWRITE_FONT_STRETCH* fontStretch,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontStretch</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetFontSize(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the font em height of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the font size.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the size of the font in ems  of the text at the specified position.</p> </dd></returns>
            <doc-id>dd316745</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetFontSize([In] unsigned int currentPosition,[Out] float* fontSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetFontSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HasUnderline(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the underline presence of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the underline.</p> </dd></param>
            <returns><dd>  <p>A Boolean  flag that indicates whether underline is present at the position indicated by <em>currentPosition</em>.</p> </dd></returns>
            <doc-id>dd371463</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetUnderline([In] unsigned int currentPosition,[Out] BOOL* hasUnderline,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetUnderline</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HasStrikethrough(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Get the strikethrough presence of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Contains the range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to strikethrough.</p> </dd></param>
            <returns><dd>  <p>A Boolean  flag that indicates whether strikethrough is present at the position indicated by <em>currentPosition</em>.</p> </dd></returns>
            <doc-id>dd316793</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetStrikethrough([In] unsigned int currentPosition,[Out] BOOL* hasStrikethrough,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetStrikethrough</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetDrawingEffect_(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the application-defined drawing effect at the specified text position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text whose drawing effect is to be retrieved.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Contains the range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the drawing effect.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains an address of a reference to  the current application-defined drawing effect. Usually this effect is a foreground brush that  is used in glyph drawing.</p> </dd></returns>
            <doc-id>dd316732</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetDrawingEffect([In] unsigned int currentPosition,[Out] IUnknown** drawingEffect,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetDrawingEffect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetInlineObject(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the inline object at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The specified text position.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the inline object.</p> </dd></param>
            <returns><dd>  <p>Contains the application-defined inline object.</p> </dd></returns>
            <doc-id>dd316758</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetInlineObject([In] unsigned int currentPosition,[Out] IDWriteInlineObject** inlineObject,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetInlineObject</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetTypography(System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the typography setting of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the typography.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains an address of a  reference to the current typography setting.</p> </dd></returns>
            <doc-id>dd371459</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetTypography([In] unsigned int currentPosition,[Out] IDWriteTypography** typography,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetTypography</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetLocaleNameLength(System.Int32,System.Int32@,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the length of the locale name of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "nameLength"><dd>  <p>Size of the character array, in character count, not including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316771</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetLocaleNameLength([In] unsigned int currentPosition,[Out] unsigned int* nameLength,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetLocaleNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetLocaleName(System.Int32,System.IntPtr,System.Int32,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p> Gets the locale name of the text at the specified position. </p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The position of the text to inspect.</p> </dd></param>
            <param name = "localeName"><dd>  <p>When this method returns, contains the character array receiving the current locale name.</p> </dd></param>
            <param name = "nameSize"><dd>  <p>Size of the character array, in character count, including the terminated <strong><c>null</c></strong> character.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The range of text that has the same  formatting as the text at the position specified by <em>currentPosition</em>.  This means the run has the exact  formatting as the position specified, including but not limited to the locale name.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316767</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetLocaleName([In] unsigned int currentPosition,[Out, Buffer] wchar_t* localeName,[In] unsigned int nameSize,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetLocaleName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.Draw(System.IntPtr,SharpDX.DirectWrite.TextRenderer,System.Single,System.Single)">
            <summary>
            <p> Draws text using the specified client drawing context.</p>
            </summary>
            <param name = "clientDrawingContext"><dd>  <p>An application-defined drawing context. </p> </dd></param>
            <param name = "renderer"><dd>  <p>Pointer to the set of callback functions used to draw parts of a text string.</p> </dd></param>
            <param name = "originX"><dd>  <p>The x-coordinate of the layout's left side.</p> </dd></param>
            <param name = "originY"><dd>  <p>The y-coordinate of the layout's top side.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To draw text with this method, a <em>textLayout</em> object needs to be created by the application using <strong>IDWriteFactory::CreateTextLayout</strong>. </p><p>After the <em>textLayout</em> object is obtained, the application calls the  <strong>IDWriteTextLayout::Draw</strong> method  to draw the text, decorations, and inline objects. The actual drawing is done through the callback interface passed in as the <em>textRenderer</em> argument; there, the corresponding <strong>DrawGlyphRun</strong> API is called. </p><p>If you set a vertical text reading direction on <see cref = "T:SharpDX.DirectWrite.TextLayout"/> via SetReadingDirection with DWRITE_READING_DIRECTION_TOP_TO_BOTTOM (or bottom to top), then you must pass an interface that implements <see cref = "T:SharpDX.DirectWrite.TextRenderer1"/>. Otherwise you get the error DWRITE_E_TEXTRENDERERINCOMPATIBLE because the original <see cref = "T:SharpDX.DirectWrite.TextRenderer"/> interface only supported horizontal text.</p>
            </remarks>
            <doc-id>dd316726</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::Draw([In, Optional] void* clientDrawingContext,[In] IDWriteTextRenderer* renderer,[In] float originX,[In] float originY)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::Draw</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetLineMetrics(SharpDX.DirectWrite.LineMetrics[],System.Int32,System.Int32@)">
            <summary>
            <p> Retrieves the information about each individual text line of the  text string. </p>
            </summary>
            <param name = "lineMetrics"><dd>  <p>When this method returns, contains a reference to an array of structures containing various calculated length values of individual text lines.</p> </dd></param>
            <param name = "maxLineCount"><dd>  <p>The maximum size of the <em>lineMetrics</em> array.</p> </dd></param>
            <param name = "actualLineCount"><dd>  <p>When this method returns, contains the actual size of the <em>lineMetrics</em> array that is needed.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If <em>maxLineCount</em> is not large enough E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and <em>*actualLineCount</em> is set to the number of lines needed. </p>
            </remarks>
            <doc-id>dd316763</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS* lineMetrics,[In] unsigned int maxLineCount,[Out] unsigned int* actualLineCount)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetLineMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetMetrics(SharpDX.DirectWrite.TextMetrics@)">
            <summary>
            <p> Retrieves overall metrics for the formatted string. </p>
            </summary>
            <param name = "textMetrics"><dd>  <p>When this method returns, contains the measured distances of text and associated content after being formatted.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd316785</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetMetrics([Out] DWRITE_TEXT_METRICS* textMetrics)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetOverhangMetrics(SharpDX.DirectWrite.OverhangMetrics@)">
            <summary>
            <p>Returns the overhangs (in DIPs) of the layout and all objects contained in it, including text glyphs and inline objects.</p>
            </summary>
            <param name = "overhangs"><dd>  <p>Overshoots of visible extents (in DIPs) outside the layout.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Underlines and strikethroughs do not contribute to the black box determination, since these are actually drawn by the renderer, which is allowed to draw them in any variety of styles.</p>
            </remarks>
            <doc-id>dd316790</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetOverhangMetrics([Out] DWRITE_OVERHANG_METRICS* overhangs)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetOverhangMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.GetClusterMetrics(SharpDX.DirectWrite.ClusterMetrics[],System.Int32,System.Int32@)">
            <summary>
            <p> Retrieves logical properties and measurements of each glyph cluster. </p>
            </summary>
            <param name = "clusterMetrics"><dd>  <p>When this method returns, contains metrics, such as line-break or total advance width, for a glyph cluster.</p> </dd></param>
            <param name = "maxClusterCount"><dd>  <p>The maximum size of the <em>clusterMetrics</em> array.</p> </dd></param>
            <param name = "actualClusterCount"><dd>  <p>When this method returns, contains the actual size of the <em>clusterMetrics</em> array that is needed.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If <em>maxClusterCount</em> is not large enough, then E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), is returned and <em>actualClusterCount</em> is set to the number of clusters needed. </p>
            </remarks>
            <doc-id>dd316729</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::GetClusterMetrics([Out, Buffer, Optional] DWRITE_CLUSTER_METRICS* clusterMetrics,[In] unsigned int maxClusterCount,[Out] unsigned int* actualClusterCount)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::GetClusterMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.DetermineMinWidth">
            <summary>
            <p>Determines the minimum possible width the layout can be set to without emergency breaking between the characters of whole words occurring.</p>
            </summary>
            <returns><dd>  <p>Minimum width.</p> </dd></returns>
            <doc-id>dd316723</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::DetermineMinWidth([Out] float* minWidth)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::DetermineMinWidth</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HitTestPoint(System.Single,System.Single,SharpDX.Mathematics.Interop.RawBool@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p> The application calls this function passing in a specific pixel location relative to the top-left location of the layout box and obtains the information about the correspondent hit-test metrics of the text string where the hit-test has occurred. When the specified pixel location is outside the text string, the function sets the output value <em>*isInside</em> to <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p>
            </summary>
            <param name = "pointX"><dd>  <p>The pixel location X to hit-test, relative to the top-left location of the layout box.</p> </dd></param>
            <param name = "pointY"><dd>  <p>The pixel location Y to hit-test, relative to the top-left location of the layout box.</p> </dd></param>
            <param name = "isTrailingHit"><dd>  <p>An output flag that indicates whether the hit-test location is at the leading or the trailing side of the character. When the output <em>*isInside</em> value is set to <strong><see cref = "F:SharpDX.Result.False"/></strong>, this value is set according to the output <em>hitTestMetrics-&gt;textPosition</em> value to represent the edge closest to the hit-test location.</p> </dd></param>
            <param name = "isInside"><dd>  <p>An output flag that indicates whether the hit-test location is inside the text string. When <strong><see cref = "F:SharpDX.Result.False"/></strong>, the position nearest the text's edge is returned.</p> </dd></param>
            <returns><dd>  <p>The output geometry fully enclosing the hit-test location. When the output <em>*isInside</em> value is set to <strong><see cref = "F:SharpDX.Result.False"/></strong>, this structure represents the geometry enclosing the edge closest to the hit-test location.</p> </dd></returns>
            <doc-id>dd371464</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::HitTestPoint([In] float pointX,[In] float pointY,[Out] BOOL* isTrailingHit,[Out] BOOL* isInside,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::HitTestPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HitTestTextPosition(System.Int32,SharpDX.Mathematics.Interop.RawBool,System.Single@,System.Single@)">
            <summary>
            <p> The application calls this function to get the pixel location relative to the top-left of the layout box given the text position and the logical side of the position. This function is normally used as part of caret positioning of text where the caret is drawn at the location corresponding to the current text editing position. It may also be used as a way to programmatically obtain the geometry of a particular text position in UI automation. </p>
            </summary>
            <param name = "textPosition"><dd>  <p>The text position used to get the pixel location.</p> </dd></param>
            <param name = "isTrailingHit"><dd>  <p>A Boolean flag that indicates whether the pixel location is of the leading or the trailing side of the specified text position.</p> </dd></param>
            <param name = "ointXRef"><dd>  <p>When this method returns, contains the output pixel location X, relative to the top-left location of the layout box.</p> </dd></param>
            <param name = "ointYRef"><dd>  <p>When this method returns, contains the output pixel location Y, relative to the top-left location of the layout box.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the output geometry fully enclosing the specified text position.</p> </dd></returns>
            <doc-id>dd371469</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::HitTestTextPosition([In] unsigned int textPosition,[In] BOOL isTrailingHit,[Out] float* pointX,[Out] float* pointY,[Out] DWRITE_HIT_TEST_METRICS* hitTestMetrics)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::HitTestTextPosition</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout.HitTestTextRange(System.Int32,System.Int32,System.Single,System.Single,SharpDX.DirectWrite.HitTestMetrics[],System.Int32,System.Int32@)">
            <summary>
            <p> The application calls this function to get a set of hit-test metrics corresponding to a range of text positions. One of the main usages is to implement highlight selection of the text string. The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), when the buffer size of hitTestMetrics is too small to hold all the regions calculated by the function. In this situation, the function sets the output value *actualHitTestMetricsCount to the number of geometries calculated. The application is responsible for allocating a new buffer of greater size and calling the function again. A good value to use as an initial value for maxHitTestMetricsCount may be calculated from the following equation: maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth where lineCount is obtained from the value of the output argument *actualLineCount (from the function <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong>::GetLineLengths), and the maxBidiReorderingDepth value from the <strong><see cref = "T:SharpDX.DirectWrite.TextMetrics"/></strong> structure of the output argument *textMetrics (from the function <strong><see cref = "T:SharpDX.DirectWrite.Factory"/></strong>::<strong>CreateTextLayout</strong>). </p>
            </summary>
            <param name = "textPosition">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "originX">No documentation.</param>
            <param name = "originY">No documentation.</param>
            <param name = "hitTestMetrics">No documentation.</param>
            <param name = "maxHitTestMetricsCount">No documentation.</param>
            <param name = "actualHitTestMetricsCount">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371473</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout::HitTestTextRange([In] unsigned int textPosition,[In] unsigned int textLength,[In] float originX,[In] float originY,[Out, Buffer, Optional] DWRITE_HIT_TEST_METRICS* hitTestMetrics,[In] unsigned int maxHitTestMetricsCount,[Out] unsigned int* actualHitTestMetricsCount)</unmanaged>
            <unmanaged-short>IDWriteTextLayout::HitTestTextRange</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRange">
            <summary>
            <p>Specifies a range of text positions where format is applied in the text represented by an <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> object.</p>
            </summary>
            <doc-id>dd368137</doc-id>
            <unmanaged>DWRITE_TEXT_RANGE</unmanaged>
            <unmanaged-short>DWRITE_TEXT_RANGE</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.DirectWrite.TextRange"/> struct.
            </summary>
            <param name="startPosition">The start position.</param>
            <param name="length">The length.</param>
        </member>
        <member name="F:SharpDX.DirectWrite.TextRange.StartPosition">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368137</doc-id>
            <unmanaged>startPosition</unmanaged>
            <unmanaged-short>startPosition</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextRange.Length">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368137</doc-id>
            <unmanaged>length</unmanaged>
            <unmanaged-short>length</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRenderer.DrawGlyphRun(System.Object,System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this function to instruct the client to render a run of glyphs. 	
            </summary>	
            <remarks>	
            The <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/> function calls this callback function with all the information about glyphs to render. The application implements this callback by mostly delegating the call to the underlying platform's graphics API such as {{Direct2D}} to draw glyphs on the drawing context. An application that uses GDI can implement this callback in terms of the <see cref="!:BitmapRenderTarget.DrawGlyphRun(float,float,MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.RenderingParams,RawColor4)"/> method.	
            </remarks>	
            <param name="clientDrawingContext">The application-defined drawing context passed to  <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the glyph run.</param>
            <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the glyph run.</param>
            <param name="measuringMode"> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</param>
            <param name="glyphRun">Pointer to the glyph run instance to render. </param>
            <param name="glyphRunDescription">A pointer to the optional glyph run description instance which contains properties of the characters  associated with this run.</param>
            <param name="clientDrawingEffect">Application-defined drawing effects for the glyphs to render. Usually this argument represents effects such as the foreground brush filling the interior of text.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawGlyphRun([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[None] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRenderer.DrawUnderline(System.Object,System.Single,System.Single,SharpDX.DirectWrite.Underline@,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this function to instruct the client to draw an underline. 	
            </summary>	
            <remarks>	
             A single underline can be broken into multiple calls, depending on how the formatting changes attributes. If font sizes/styles change within an underline, the thickness and offset will be averaged weighted according to characters. To get an appropriate starting pixel position, add underline::offset to the baseline. Otherwise there will be no spacing between the text. The x coordinate will always be passed as the left side, regardless of text directionality. This simplifies drawing and reduces the problem of round-off that could potentially cause gaps or a double stamped alpha blend. To avoid alpha overlap, round the end points to the nearest device pixel. 	
            </remarks>	
            <param name="clientDrawingContext">The application-defined drawing context passed to  IDWriteTextLayout::Draw.</param>
            <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the run where underline applies.</param>
            <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the run where underline applies.</param>
            <param name="underline">Pointer to  a structure containing underline logical information.</param>
            <param name="clientDrawingEffect"> Application-defined effect to apply to the underline. Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawUnderline([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_UNDERLINE* underline,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRenderer.DrawStrikethrough(System.Object,System.Single,System.Single,SharpDX.DirectWrite.Strikethrough@,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this function to instruct the client to draw a strikethrough. 	
            </summary>	
            <remarks>	
             A single strikethrough can be broken into multiple calls, depending on how the formatting changes attributes. Strikethrough is not averaged across font sizes/styles changes. To get an appropriate starting pixel position, add strikethrough::offset to the baseline. Like underlines, the x coordinate will always be passed as the left side, regardless of text directionality. 	
            </remarks>	
            <param name="clientDrawingContext">The application-defined drawing context passed to  IDWriteTextLayout::Draw.</param>
            <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the run where strikethrough applies.</param>
            <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the run where strikethrough applies.</param>
            <param name="strikethrough">Pointer to  a structure containing strikethrough logical information.</param>
            <param name="clientDrawingEffect">Application-defined effect to apply to the strikethrough.  Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawStrikethrough([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_STRIKETHROUGH* strikethrough,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRenderer.DrawInlineObject(System.Object,System.Single,System.Single,SharpDX.DirectWrite.InlineObject,System.Boolean,System.Boolean,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this application callback when it needs to draw an inline object. 	
            </summary>	
            <param name="clientDrawingContext">The application-defined drawing context passed to IDWriteTextLayout::Draw.</param>
            <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
            <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
            <param name="inlineObject">The application-defined inline object set using IDWriteTextFormat::SetInlineObject.</param>
            <param name="isSideways">A Boolean flag that indicates whether the object's baseline runs alongside the baseline axis of the line.</param>
            <param name="isRightToLeft">A Boolean flag that indicates whether the object is in a right-to-left context, hinting that the drawing may want to mirror the normal image.</param>
            <param name="clientDrawingEffect">Application-defined drawing effects for the glyphs to render. Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawInlineObject([None] void* clientDrawingContext,[None] FLOAT originX,[None] FLOAT originY,[None] IDWriteInlineObject* inlineObject,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRendererBase">
            <summary>
            Default abstract implementation of TextRenderer. Need to implement a least a DrawXXX method to use it.
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.IsPixelSnappingDisabled(System.Object)">
            <summary>
            Determines whether pixel snapping is disabled. The recommended default is FALSE,
            unless doing animation that requires subpixel vertical placement.
            </summary>
            <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
            <returns>Receives TRUE if pixel snapping is disabled or FALSE if it not. </returns>
            <unmanaged>HRESULT IsPixelSnappingDisabled([None] void* clientDrawingContext,[Out] BOOL* isDisabled)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.GetCurrentTransform(System.Object)">
            <summary>	
             Gets a transform that maps abstract coordinates to DIPs. 	
            </summary>	
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <returns>a structure which has transform information for  pixel snapping.</returns>
            <unmanaged>HRESULT GetCurrentTransform([None] void* clientDrawingContext,[Out] DWRITE_MATRIX* transform)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.GetPixelsPerDip(System.Object)">
            <summary>	
             Gets the number of physical pixels per DIP. 	
            </summary>	
            <remarks>	
             Because a DIP (device-independent pixel) is 1/96 inch,  the pixelsPerDip value is the number of logical pixels per inch divided by 96.	
            </remarks>	
            <param name="clientDrawingContext">The drawing context passed to <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <returns>the number of physical pixels per DIP</returns>
            <unmanaged>HRESULT GetPixelsPerDip([None] void* clientDrawingContext,[Out] FLOAT* pixelsPerDip)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.DrawGlyphRun(System.Object,System.Single,System.Single,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this function to instruct the client to render a run of glyphs. 	
            </summary>	
            <remarks>	
            The <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/> function calls this callback function with all the information about glyphs to render. The application implements this callback by mostly delegating the call to the underlying platform's graphics API such as {{Direct2D}} to draw glyphs on the drawing context. An application that uses GDI can implement this callback in terms of the <see cref="!:BitmapRenderTarget.DrawGlyphRun(float,float,MeasuringMode,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.RenderingParams,RawColor4)"/> method.	
            </remarks>	
            <param name="clientDrawingContext">The application-defined drawing context passed to  <see cref="!:SharpDX.DirectWrite.TextLayout.Draw_"/>.</param>
            <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the glyph run.</param>
            <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the glyph run.</param>
            <param name="measuringMode"> The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</param>
            <param name="glyphRun">Pointer to the glyph run instance to render. </param>
            <param name="glyphRunDescription">A pointer to the optional glyph run description instance which contains properties of the characters  associated with this run.</param>
            <param name="clientDrawingEffect">Application-defined drawing effects for the glyphs to render. Usually this argument represents effects such as the foreground brush filling the interior of text.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawGlyphRun([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[None] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.DrawUnderline(System.Object,System.Single,System.Single,SharpDX.DirectWrite.Underline@,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this function to instruct the client to draw an underline. 	
            </summary>	
            <remarks>	
             A single underline can be broken into multiple calls, depending on how the formatting changes attributes. If font sizes/styles change within an underline, the thickness and offset will be averaged weighted according to characters. To get an appropriate starting pixel position, add underline::offset to the baseline. Otherwise there will be no spacing between the text. The x coordinate will always be passed as the left side, regardless of text directionality. This simplifies drawing and reduces the problem of round-off that could potentially cause gaps or a double stamped alpha blend. To avoid alpha overlap, round the end points to the nearest device pixel. 	
            </remarks>	
            <param name="clientDrawingContext">The application-defined drawing context passed to  IDWriteTextLayout::Draw.</param>
            <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the run where underline applies.</param>
            <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the run where underline applies.</param>
            <param name="underline">Pointer to  a structure containing underline logical information.</param>
            <param name="clientDrawingEffect"> Application-defined effect to apply to the underline. Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawUnderline([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_UNDERLINE* underline,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.DrawStrikethrough(System.Object,System.Single,System.Single,SharpDX.DirectWrite.Strikethrough@,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this function to instruct the client to draw a strikethrough. 	
            </summary>	
            <remarks>	
             A single strikethrough can be broken into multiple calls, depending on how the formatting changes attributes. Strikethrough is not averaged across font sizes/styles changes. To get an appropriate starting pixel position, add strikethrough::offset to the baseline. Like underlines, the x coordinate will always be passed as the left side, regardless of text directionality. 	
            </remarks>	
            <param name="clientDrawingContext">The application-defined drawing context passed to  IDWriteTextLayout::Draw.</param>
            <param name="baselineOriginX">The pixel location (X-coordinate) at the baseline origin of the run where strikethrough applies.</param>
            <param name="baselineOriginY">The pixel location (Y-coordinate) at the baseline origin of the run where strikethrough applies.</param>
            <param name="strikethrough">Pointer to  a structure containing strikethrough logical information.</param>
            <param name="clientDrawingEffect">Application-defined effect to apply to the strikethrough.  Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawStrikethrough([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_STRIKETHROUGH* strikethrough,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererBase.DrawInlineObject(System.Object,System.Single,System.Single,SharpDX.DirectWrite.InlineObject,System.Boolean,System.Boolean,SharpDX.ComObject)">
            <summary>	
             IDWriteTextLayout::Draw calls this application callback when it needs to draw an inline object. 	
            </summary>	
            <param name="clientDrawingContext">The application-defined drawing context passed to IDWriteTextLayout::Draw.</param>
            <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
            <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
            <param name="inlineObject">The application-defined inline object set using IDWriteTextFormat::SetInlineObject.</param>
            <param name="isSideways">A Boolean flag that indicates whether the object's baseline runs alongside the baseline axis of the line.</param>
            <param name="isRightToLeft">A Boolean flag that indicates whether the object is in a right-to-left context, hinting that the drawing may want to mirror the normal image.</param>
            <param name="clientDrawingEffect">Application-defined drawing effects for the glyphs to render. Usually this argument represents effects such as the foreground brush filling the interior of a line.</param>
            <returns>If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <unmanaged>HRESULT DrawInlineObject([None] void* clientDrawingContext,[None] FLOAT originX,[None] FLOAT originY,[None] IDWriteInlineObject* inlineObject,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRendererShadow">
            <summary>
            Internal TextRenderer Callback
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.TextRendererShadow.ToIntPtr(SharpDX.DirectWrite.TextRenderer)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRendererShadow.TextRendererVtbl.DrawGlyphRunDelegate">
            <unmanaged>HRESULT DrawGlyphRun([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[None] DWRITE_MEASURING_MODE measuringMode,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRendererShadow.TextRendererVtbl.DrawUnderlineDelegate">
            <unmanaged>HRESULT DrawUnderline([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_UNDERLINE* underline,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRendererShadow.TextRendererVtbl.DrawStrikethroughDelegate">
            <unmanaged>HRESULT DrawStrikethrough([None] void* clientDrawingContext,[None] FLOAT baselineOriginX,[None] FLOAT baselineOriginY,[In] const DWRITE_STRIKETHROUGH* strikethrough,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="T:SharpDX.DirectWrite.TextRendererShadow.TextRendererVtbl.DrawInlineObjectDelegate">
            <unmanaged>HRESULT DrawInlineObject([None] void* clientDrawingContext,[None] FLOAT originX,[None] FLOAT originY,[None] IDWriteInlineObject* inlineObject,[None] BOOL isSideways,[None] BOOL isRightToLeft,[None] IUnknown* clientDrawingEffect)</unmanaged>
        </member>
        <member name="M:SharpDX.DirectWrite.Typography.#ctor(SharpDX.DirectWrite.Factory)">
            <summary>	
            Creates a typography object for use in a text layout. 	
            </summary>	
            <param name="factory">an instance of <see cref = "T:SharpDX.DirectWrite.Factory" /></param>
            <unmanaged>HRESULT IDWriteFactory::CreateTypography([Out] IDWriteTypography** typography)</unmanaged>
        </member>
        <member name="P:SharpDX.DirectWrite.Typography.FontFeatureCount">
            <summary>
            <p> Gets the number of OpenType font features for the current font. </p>
            </summary>
            <remarks>
            <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref = "T:SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>
            </remarks>
            <doc-id>dd371549</doc-id>
            <unmanaged>GetFontFeatureCount</unmanaged>
            <unmanaged-short>GetFontFeatureCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Typography.AddFontFeature(SharpDX.DirectWrite.FontFeature)">
            <summary>
            <p> Adds an OpenType font feature. </p>
            </summary>
            <param name = "fontFeature"><dd>  <p>A structure that contains the OpenType name identifier and the execution parameter for the font feature being added.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371545</doc-id>
            <unmanaged>HRESULT IDWriteTypography::AddFontFeature([In] DWRITE_FONT_FEATURE fontFeature)</unmanaged>
            <unmanaged-short>IDWriteTypography::AddFontFeature</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Typography.GetFontFeatureCount">
            <summary>
            <p> Gets the number of OpenType font features for the current font. </p>
            </summary>
            <returns><p>The number of font features for the current text format.</p></returns>
            <remarks>
            <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref = "T:SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>
            </remarks>
            <doc-id>dd371549</doc-id>
            <unmanaged>unsigned int IDWriteTypography::GetFontFeatureCount()</unmanaged>
            <unmanaged-short>IDWriteTypography::GetFontFeatureCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Typography.GetFontFeature(System.Int32)">
            <summary>
            <p> Gets the font feature at the specified index. </p>
            </summary>
            <param name = "fontFeatureIndex"><dd>  <p>The zero-based index of the font feature to retrieve.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the font feature which is at the specified index.</p> </dd></returns>
            <remarks>
            <p>A single run of text can be associated with more than one typographic feature. The <strong><see cref = "T:SharpDX.DirectWrite.Typography"/></strong> object holds a list of these font features.</p>
            </remarks>
            <doc-id>dd371546</doc-id>
            <unmanaged>HRESULT IDWriteTypography::GetFontFeature([In] unsigned int fontFeatureIndex,[Out] DWRITE_FONT_FEATURE* fontFeature)</unmanaged>
            <unmanaged-short>IDWriteTypography::GetFontFeature</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Baseline">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.Baseline"/></strong> enumeration contains values that specify the baseline for text alignment.</p>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE</unmanaged>
            <unmanaged-short>DWRITE_BASELINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Default">
            <summary>
            <dd> <p>The Roman baseline for horizontal; the Central baseline for vertical.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Roman">
            <summary>
            <dd> <p>The baseline that is used by alphabetic scripts such as Latin, Greek, and Cyrillic.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_ROMAN</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_ROMAN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Central">
            <summary>
            <dd> <p>Central baseline, which is generally used for vertical text.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_CENTRAL</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_CENTRAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Math">
            <summary>
            <dd> <p>Mathematical baseline, which math characters are centered on.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_MATH</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_MATH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Hanging">
            <summary>
            <dd> <p>Hanging baseline, which is used in scripts like Devanagari.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_HANGING</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_HANGING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.IdeographicBottom">
            <summary>
            <dd> <p>Ideographic bottom baseline for CJK, left in vertical.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_IDEOGRAPHIC_BOTTOM</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_IDEOGRAPHIC_BOTTOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.IdeographicTop">
            <summary>
            <dd> <p>Ideographic top baseline for CJK, right in vertical.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_IDEOGRAPHIC_TOP</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_IDEOGRAPHIC_TOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Minimum">
            <summary>
            <dd> <p>The bottom-most extent in horizontal, left-most in vertical.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_MINIMUM</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_MINIMUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Baseline.Maximum">
            <summary>
            <dd> <p>The top-most extent in horizontal, right-most in vertical.</p> </dd>
            </summary>
            <doc-id>jj126257</doc-id>
            <unmanaged>DWRITE_BASELINE_MAXIMUM</unmanaged>
            <unmanaged-short>DWRITE_BASELINE_MAXIMUM</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.BreakCondition">
            <summary>
            <p> Indicates the condition at the edges of inline object or text used to determine line-breaking behavior.</p>
            </summary>
            <doc-id>dd368051</doc-id>
            <unmanaged>DWRITE_BREAK_CONDITION</unmanaged>
            <unmanaged-short>DWRITE_BREAK_CONDITION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.BreakCondition.Neutral">
            <summary>
            <dd> <p> Indicates whether a break is allowed by determining  the condition of the neighboring text span or inline object.</p> </dd>
            </summary>
            <doc-id>dd368051</doc-id>
            <unmanaged>DWRITE_BREAK_CONDITION_NEUTRAL</unmanaged>
            <unmanaged-short>DWRITE_BREAK_CONDITION_NEUTRAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.BreakCondition.CanBreak">
            <summary>
            <dd> <p> Indicates that a line break is allowed, unless overruled by the condition of the neighboring text span or inline object, either prohibited by a "may not break" condition or forced by a "must break" condition.				 </p> </dd>
            </summary>
            <doc-id>dd368051</doc-id>
            <unmanaged>DWRITE_BREAK_CONDITION_CAN_BREAK</unmanaged>
            <unmanaged-short>DWRITE_BREAK_CONDITION_CAN_BREAK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.BreakCondition.MayNotBreak">
            <summary>
            <dd> <p> Indicates that there should be no line  break, unless overruled by a "must break" condition from the neighboring text span or inline object.		 </p> </dd>
            </summary>
            <doc-id>dd368051</doc-id>
            <unmanaged>DWRITE_BREAK_CONDITION_MAY_NOT_BREAK</unmanaged>
            <unmanaged-short>DWRITE_BREAK_CONDITION_MAY_NOT_BREAK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.BreakCondition.MustBreak">
            <summary>
            <dd> <p> Indicates that the line break must happen, regardless of the condition of the adjacent text span or inline object.			 </p> </dd>
            </summary>
            <doc-id>dd368051</doc-id>
            <unmanaged>DWRITE_BREAK_CONDITION_MUST_BREAK</unmanaged>
            <unmanaged-short>DWRITE_BREAK_CONDITION_MUST_BREAK</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ContainerType">
            <summary>
            <p>Represents the degree to which a font has been stretched compared to a font's normal aspect ratio. The enumerated values correspond to the <em>usWidthClass</em> definition in the OpenType specification. The usWidthClass represents an integer value between 1 and 9?lower values indicate narrower widths; higher values indicate wider widths.</p>
            </summary>
            <remarks>
            <p>A font stretch describes the degree to which a font form is stretched from its normal aspect ratio, which is the original width to height ratio specified for the glyphs in the font. 
            The following illustration shows an example of Normal and Condensed stretches for the Rockwell Bold typeface.</p><p></p><strong>Note</strong>??Values other than the ones defined in the enumeration are considered to be invalid, and are rejected by font API functions.?
            </remarks>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_CONTAINER_TYPE</unmanaged>
            <unmanaged-short>DWRITE_CONTAINER_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ContainerType.Unknown">
            <summary>
            <dd> <p>Predefined font stretch : Not known (0).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_CONTAINER_TYPE_UNKNOWN</unmanaged>
            <unmanaged-short>DWRITE_CONTAINER_TYPE_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ContainerType.Woff">
            <summary>
            <dd> <p>Predefined font stretch : Ultra-condensed (1).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_CONTAINER_TYPE_WOFF</unmanaged>
            <unmanaged-short>DWRITE_CONTAINER_TYPE_WOFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ContainerType.Woff2">
            <summary>
            <dd> <p>Predefined font stretch : Extra-condensed (2).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_CONTAINER_TYPE_WOFF2</unmanaged>
            <unmanaged-short>DWRITE_CONTAINER_TYPE_WOFF2</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FactoryType">
            <summary>
            <p>Specifies the type of DirectWrite factory object.</p>
            </summary>
            <remarks>
            <p>A DirectWrite factory object contains information about its internal state, such as font loader registration and cached font data. In most cases you should use the shared factory object, because it allows multiple components that use DirectWrite to share internal DirectWrite state information, thereby reducing memory usage. However, there are cases when it is desirable to reduce the impact of a component on the rest of the process, such as a plug-in from an untrusted source,  by sandboxing and isolating it from the rest of the process components. In such cases, you should use an isolated factory for the sandboxed component.</p>
            </remarks>
            <doc-id>dd368057</doc-id>
            <unmanaged>DWRITE_FACTORY_TYPE</unmanaged>
            <unmanaged-short>DWRITE_FACTORY_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FactoryType.Shared">
            <summary>
            <dd> <p>Indicates that the DirectWrite factory is a shared factory and that it allows for the reuse of cached font data across multiple in-process components. Such factories also take advantage of cross process font caching components for better performance.</p> </dd>
            </summary>
            <doc-id>dd368057</doc-id>
            <unmanaged>DWRITE_FACTORY_TYPE_SHARED</unmanaged>
            <unmanaged-short>DWRITE_FACTORY_TYPE_SHARED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FactoryType.Isolated">
            <summary>
            <dd> <p>Indicates that the DirectWrite factory object is isolated. Objects created from the isolated factory do not interact with internal DirectWrite state from other components.</p> </dd>
            </summary>
            <doc-id>dd368057</doc-id>
            <unmanaged>DWRITE_FACTORY_TYPE_ISOLATED</unmanaged>
            <unmanaged-short>DWRITE_FACTORY_TYPE_ISOLATED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FlowDirection">
            <summary>
            <p> Indicates the direction of how lines of text are placed relative to one another. </p>
            </summary>
            <doc-id>dd368060</doc-id>
            <unmanaged>DWRITE_FLOW_DIRECTION</unmanaged>
            <unmanaged-short>DWRITE_FLOW_DIRECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FlowDirection.TopToBottom">
            <summary>
            <dd> <p>Specifies that text lines are placed from top to bottom.</p> </dd>
            </summary>
            <doc-id>dd368060</doc-id>
            <unmanaged>DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM</unmanaged>
            <unmanaged-short>DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FlowDirection.BottomToTop">
            <summary>
            <dd> <p>Specifies that text lines are placed from bottom to top.</p> </dd>
            </summary>
            <doc-id>dd368060</doc-id>
            <unmanaged>DWRITE_FLOW_DIRECTION_BOTTOM_TO_TOP</unmanaged>
            <unmanaged-short>DWRITE_FLOW_DIRECTION_BOTTOM_TO_TOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FlowDirection.LeftToRight">
            <summary>
            <dd> <p>Specifies that text lines are placed from left to right.</p> </dd>
            </summary>
            <doc-id>dd368060</doc-id>
            <unmanaged>DWRITE_FLOW_DIRECTION_LEFT_TO_RIGHT</unmanaged>
            <unmanaged-short>DWRITE_FLOW_DIRECTION_LEFT_TO_RIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FlowDirection.RightToLeft">
            <summary>
            <dd> <p>Specifies that text lines are placed from right to left.</p> </dd>
            </summary>
            <doc-id>dd368060</doc-id>
            <unmanaged>DWRITE_FLOW_DIRECTION_RIGHT_TO_LEFT</unmanaged>
            <unmanaged-short>DWRITE_FLOW_DIRECTION_RIGHT_TO_LEFT</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFaceType">
            <summary>
            <p>Indicates the file format of a complete font face.</p>
            </summary>
            <remarks>
            <p>Font formats that consist of multiple files, such as Type 1 .PFM and .PFB, have a single enum entry.</p>
            </remarks>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.Cff">
            <summary>
            <dd> <p>OpenType font face with CFF outlines.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_CFF</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_CFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.Truetype">
            <summary>
            <dd> <p>OpenType font face with TrueType outlines.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_TRUETYPE</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_TRUETYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.OpenTypeCollection">
            <summary>
            <dd> <p>OpenType font face with TrueType outlines.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_OPENTYPE_COLLECTION</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_OPENTYPE_COLLECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.Type1">
            <summary>
            <dd> <p>A Type 1 font face.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_TYPE1</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_TYPE1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.Vector">
            <summary>
            <dd> <p>A vector .FON format font face.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_VECTOR</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_VECTOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.Bitmap">
            <summary>
            <dd> <p>A bitmap .FON format font face.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_BITMAP</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_BITMAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.Unknown">
            <summary>
            <dd> <p>Font face type is not recognized by the DirectWrite font system.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_UNKNOWN</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.RawCff">
            <summary>
            <dd> <p>The font data includes only the CFF table from an OpenType CFF font. This font face type can be used only for embedded fonts (i.e., custom font file loaders) and the resulting font face object supports only the minimum functionality necessary to render glyphs.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_RAW_CFF</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_RAW_CFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFaceType.TruetypeCollection">
            <summary>
            <dd> <p>OpenType font face that is a part of a TrueType collection.</p> </dd>
            </summary>
            <doc-id>dd368063</doc-id>
            <unmanaged>DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION</unmanaged>
            <unmanaged-short>DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFeatureTag">
            <summary>
            <p>A value that indicates the typographic feature of text supplied by the font.</p>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.AlternativeFractions">
            <summary>
            <dd> <p> Replaces figures separated by a slash with an alternative form.</p> <p><strong>Equivalent OpenType tag:</strong> 'afrc' </p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.PetiteCapitalsFromCapitals">
            <summary>
            <dd> <p> Turns capital characters into petite capitals. It is generally used for words which would otherwise be set in all caps, such as acronyms, but which are desired in petite-cap form to avoid disrupting the flow of text. See the pcap feature description for notes on the relationship of caps, smallcaps and petite caps.</p> <p><strong>Equivalent OpenType tag:</strong> 'c2pc'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.SmallCapitalsFromCapitals">
            <summary>
            <dd> <p>Turns capital characters into small capitals. It is generally used for words which would otherwise be set in all caps, such as acronyms, but which are desired in small-cap form to avoid disrupting the flow of text. </p> <p><strong>Equivalent OpenType tag:</strong> 'c2sc'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ContextualAlternates">
            <summary>
            <dd> <p> In specified situations, replaces default glyphs with alternate forms which provide better joining behavior. Used in script typefaces which are designed to have some or all of their glyphs join.</p> <p><strong>Equivalent OpenType tag:</strong> 'calt'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.CaseSensitiveForms">
            <summary>
            <dd> <p> Shifts various punctuation marks up to a position that works better with all-capital sequences or sets of lining figures; also changes oldstyle figures to lining figures. By default, glyphs in a text face are designed to work with lowercase characters. Some characters should be shifted vertically to fit the higher visual center of all-capital or lining text. Also, lining figures are the same height (or close to it) as capitals, and fit much better with all-capital text.</p> <p><strong>Equivalent OpenType tag:</strong> 'case'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.GlyphCompositionDecomposition">
            <summary>
            <dd> <p> To minimize the number of glyph alternates, it is sometimes desired to decompose a character into two glyphs. Additionally, it may be preferable to compose two characters into a single glyph for better glyph processing. This feature permits such composition/decomposition. The feature should be processed as the first feature processed, and should be processed only when it is called.</p> <p><strong>Equivalent OpenType tag:</strong> 'ccmp'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ContextualLigatures">
            <summary>
            <dd> <p> Replaces a sequence of glyphs with a single glyph which is preferred for typographic purposes. Unlike other ligature features, clig specifies the context in which the ligature is recommended. This capability is important in some script designs and for swash ligatures.</p> <p><strong>Equivalent OpenType tag:</strong> 'clig'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.CapitalSpacing">
            <summary>
            <dd> <p> Globally adjusts inter-glyph spacing for all-capital text. Most typefaces contain capitals and lowercase characters, and the capitals are positioned to work with the lowercase. When capitals are used for words, they need more space between them for legibility and esthetics. This feature would not apply to monospaced designs. Of course the user may want to override this behavior in order to do more pronounced letterspacing for esthetic reasons. </p> <p><strong>Equivalent OpenType tag:</strong> 'cpsp'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ContextualSwash">
            <summary>
            <dd> <p>Replaces default character glyphs with corresponding swash glyphs in a specified context. Note that there may be more than one swash alternate for a given character. </p> <p><strong>Equivalent OpenType tag:</strong> 'cswh'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.CursivePositioning">
            <summary>
            <dd> <p> In cursive scripts like Arabic, this feature cursively positions adjacent glyphs.</p> <p><strong>Equivalent OpenType tag:</strong> 'curs'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Default">
            <summary>
            <dd> <p> Globally adjusts inter-glyph spacing for all-capital text. Most typefaces contain capitals and lowercase characters, and the capitals are positioned to work with the lowercase. When capitals are used for words, they need more space between them for legibility and esthetics. This feature would not apply to monospaced designs. Of course the user may want to override this behavior in order to do more pronounced letterspacing for esthetic reasons. </p> <p><strong>Equivalent OpenType tag:</strong> 'cpsp'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.DiscretionaryLigatures">
            <summary>
            <dd> <p> Replaces a sequence of glyphs with a single glyph which is preferred for typographic purposes. This feature covers those ligatures which may be used for special effect, at the user's preference.</p> <p><strong>Equivalent OpenType tag:</strong> 'dlig'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ExpertForms">
            <summary>
            <dd> <p> Replaces standard forms in Japanese fonts with corresponding forms preferred by typographers.  For example, a user would invoke this feature to replace kanji character U+5516 with U+555E.
            </p> <p><strong>Equivalent OpenType tag:</strong> 'expt'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Fractions">
            <summary>
            <dd> <p> Replaces figures separated by a slash with 'common' (diagonal) fractions.</p> <p><strong>Equivalent OpenType tag:</strong> 'frac'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_FRACTIONS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_FRACTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.FullWidth">
            <summary>
            <dd> <p> Replaces glyphs set on other widths with glyphs set on full (usually em) widths. In a CJKV font, this may include "lower ASCII" Latin characters and various symbols. In a European font, this feature replaces proportionally-spaced glyphs with monospaced glyphs, which are generally set on widths of 0.6 em. For example, a user may invoke this feature in a Japanese font to get full monospaced Latin glyphs instead of the corresponding proportionally-spaced versions.</p> <p><strong>Equivalent OpenType tag:</strong> 'fwid'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_FULL_WIDTH</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_FULL_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HalfForms">
            <summary>
            <dd> <p> Produces the half forms of consonants in Indic scripts. For example, in Hindi (Devanagari script), the conjunct KKa, obtained by doubling the Ka, is denoted with a half form of Ka followed by the full form. </p> <p><strong>Equivalent OpenType tag:</strong> 'half'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HALF_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HALF_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HalantForms">
            <summary>
            <dd> <p> Produces the halant forms of consonants in Indic scripts. For example, in Sanskrit (Devanagari script), syllable final consonants are frequently required in their halant form.</p> <p><strong>Equivalent OpenType tag:</strong> 'haln'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HALANT_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HALANT_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.AlternateHalfWidth">
            <summary>
            <dd> <p> Respaces glyphs designed to be set on full-em widths, fitting them onto half-em widths. This differs from hwid in that it does not substitute new glyphs.</p> <p><strong>Equivalent OpenType tag:</strong> 'halt'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HistoricalForms">
            <summary>
            <dd> <p> Replaces the default (current) forms with the historical alternates. While some ligatures are also used for historical effect, this feature deals only with single characters. Some fonts include the historical forms as alternates, so they can be used for a 'period' effect.  </p> <p><strong>Equivalent OpenType tag:</strong> 'hist'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HorizontalKanaAlternates">
            <summary>
            <dd> <p> Replaces standard kana with forms that have been specially designed for only horizontal writing. This is a typographic optimization for improved fit and more even color.</p> <p><strong>Equivalent OpenType tag:</strong> 'hkna'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HistoricalLigatures">
            <summary>
            <dd> <p> Replaces the default (current) forms with the historical alternates. Some ligatures were in common use in the past, but appear anachronistic today. Some fonts include the historical forms as alternates, so they can be used for a 'period' effect.</p> <p><strong>Equivalent OpenType tag:</strong> 'hlig'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HalfWidth">
            <summary>
            <dd> <p> Replaces glyphs on proportional widths, or fixed widths other than half an em, with glyphs on half-em (en) widths. Many CJKV fonts have glyphs which are set on multiple widths; this feature selects the half-em version. There are various contexts in which this is the preferred behavior, including compatibility with older desktop documents.</p> <p><strong>Equivalent OpenType tag:</strong> 'hwid'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HALF_WIDTH</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HALF_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.HojoKanjiForms">
            <summary>
            <dd> <p> Used to access the JIS X 0212-1990 glyphs for the cases when the JIS X 0213:2004 form is encoded. The JIS X 0212-1990 (aka, "Hojo Kanji") and JIS X 0213:2004 character sets overlap significantly. In some cases their prototypical glyphs differ. When building fonts that support both JIS X 0212-1990 and JIS X 0213:2004 (such as those supporting the Adobe-Japan 1-6 character collection), it is recommended that JIS X 0213:2004 forms be the preferred encoded form.</p> <p><strong>Equivalent OpenType tag:</strong> 'hojo'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Jis04Forms">
            <summary>
            <dd> <p> The National Language Council (NLC) of Japan has defined new glyph shapes for a number of JIS characters, which were incorporated into JIS X 0213:2004 as new prototypical forms. The 'jp04' feature is A subset of the 'nlck' feature, and is used to access these prototypical glyphs in a manner that maintains the integrity of JIS X 0213:2004.</p> <p><strong>Equivalent OpenType tag:</strong> 'jp04'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_JIS04_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_JIS04_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Jis78Forms">
            <summary>
            <dd> <p>Replaces default (JIS90) Japanese glyphs with the corresponding forms from the JIS C 6226-1978 (JIS78) specification.</p> <p><strong>Equivalent OpenType tag:</strong> 'jp78'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_JIS78_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_JIS78_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Jis83Forms">
            <summary>
            <dd> <p>Replaces default (JIS90) Japanese glyphs with the corresponding forms from the JIS X 0208-1983 (JIS83) specification.</p> <p><strong>Equivalent OpenType tag:</strong> 'jp83'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_JIS83_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_JIS83_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Jis90Forms">
            <summary>
            <dd> <p> Replaces Japanese glyphs from the JIS78 or JIS83 specifications with the corresponding forms from the JIS X 0208-1990 (JIS90) specification.</p> <p><strong>Equivalent OpenType tag:</strong> 'jp90'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_JIS90_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_JIS90_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Kerning">
            <summary>
            <dd> <p> Adjusts amount of space between glyphs, generally to provide optically consistent spacing between glyphs. Although a well-designed typeface has consistent inter-glyph spacing overall, some glyph combinations require adjustment for improved legibility. Besides standard adjustment in the horizontal direction, this feature can supply size-dependent kerning data via device tables, "cross-stream" kerning in the Y text direction, and adjustment of glyph placement independent of the advance adjustment. Note that this feature may apply to runs of more than two glyphs, and would not be used in monospaced fonts. Also note that this feature does not apply to text set vertically.</p> <p><strong>Equivalent OpenType tag:</strong> 'kern'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_KERNING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_KERNING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StandardLigatures">
            <summary>
            <dd> <p> Replaces a sequence of glyphs with a single glyph which is preferred for typographic purposes. This feature covers the ligatures which the designer/manufacturer judges should be used in normal conditions.</p> <p><strong>Equivalent OpenType tag:</strong> 'liga'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.LiningFigures">
            <summary>
            <dd> <p>Changes selected figures from oldstyle to the default lining form. For example, a user may invoke this feature in order to get lining figures, which fit better with all-capital text. This feature overrides results of the Oldstyle Figures feature (onum).</p> <p><strong>Equivalent OpenType tag:</strong> 'lnum'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_LINING_FIGURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_LINING_FIGURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.LocalizedForms">
            <summary>
            <dd> <p> Enables localized forms of glyphs to be substituted for default forms. Many scripts used to write multiple languages over wide geographical areas have developed localized variant forms of specific letters, which are used by individual literary communities. For example, a number of letters in the Bulgarian and Serbian alphabets have forms distinct from their Russian counterparts and from each other. In some cases the localized form differs only subtly from the script 'norm', in others the forms are radically distinct. </p> <p><strong>Equivalent OpenType tag:</strong> 'locl'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.MarkPositioning">
            <summary>
            <dd> <p> Positions mark glyphs with respect to base glyphs. For example, in Arabic script positioning the Hamza above the Yeh.</p> <p><strong>Equivalent OpenType tag: </strong> 'mark'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.MathematicalGreek">
            <summary>
            <dd> <p> Replaces standard typographic forms of Greek glyphs with corresponding forms commonly used in mathematical notation (which are a subset of the Greek alphabet).</p> <p><strong>Equivalent OpenType tag:</strong> 'mgrk'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.MarkToMarkPositioning">
            <summary>
            <dd> <p> Positions marks with respect to other marks. Required in various non-Latin scripts like Arabic. For example, in Arabic, the ligaturised mark Ha with Hamza above it can also be obtained by positioning these marks relative to one another.</p> <p><strong>Equivalent OpenType tag:</strong> 'mkmk'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.AlternateAnnotationForms">
            <summary>
            <dd> <p> Replaces default glyphs with various notational forms (such as glyphs placed in open or solid circles, squares, parentheses, diamonds or rounded boxes). In some cases an annotation form may already be present, but the user may want a different one.</p> <p><strong>Equivalent OpenType tag:</strong> 'nalt'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.NlcKanjiForms">
            <summary>
            <dd> <p> Used to access  glyphs made from glyph shapes defined by the National Language Council (NLC) of Japan for a number of JIS characters in 2000. </p> <p><strong>Equivalent OpenType tag:</strong> 'nlck'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.OldStyleFigures">
            <summary>
            <dd> <p> Changes selected figures from the default lining style to oldstyle form. For example, a user may invoke this feature to get oldstyle figures, which fit better into the flow of normal upper- and lowercase text. This feature overrides results of the Lining Figures feature (lnum).</p> <p><strong>Equivalent OpenType tag:</strong> 'onum'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Ordinals">
            <summary>
            <dd> <p> Replaces default alphabetic glyphs with the corresponding ordinal forms for use after figures. One exception to the follows-a-figure rule is the numero character (U+2116), which is actually a ligature substitution, but is best accessed through this feature.</p> <p><strong>Equivalent OpenType tag:</strong> 'ordn'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_ORDINALS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_ORDINALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ProportionalAlternateWidth">
            <summary>
            <dd> <p> Respaces glyphs designed to be set on full-em widths, fitting them onto individual (more or less proportional) horizontal widths. This differs from pwid in that it does not substitute new glyphs (GPOS, not GSUB feature). The user may prefer the monospaced form, or may simply want to ensure that the glyph is well-fit and not rotated in vertical setting (Latin forms designed for proportional spacing would be rotated).</p> <p><strong>Equivalent OpenType tag:</strong> 'palt'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.PetiteCapitals">
            <summary>
            <dd> <p>Turns lowercase characters into petite capitals. Forms related to petite capitals, such as specially designed figures, may be included. Some fonts contain an additional size of capital letters, shorter than the regular smallcaps and it is referred to as petite caps. Such forms are most likely to be found in designs with a small lowercase x-height, where they better harmonise with lowercase text than the taller smallcaps (for examples of petite caps, see the Emigre type families Mrs Eaves and Filosofia). </p> <p><strong>Equivalent OpenType tag:</strong> 'pcap'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ProportionalFigures">
            <summary>
            <dd> <p> Replaces figure glyphs set on uniform (tabular) widths with corresponding glyphs set on glyph-specific (proportional) widths. Tabular widths will generally be the default, but this cannot be safely assumed. Of course this feature would not be present in monospaced designs.</p> <p><strong>Equivalent OpenType tag:</strong> 'pnum'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ProportionalWidths">
            <summary>
            <dd> <p> Replaces glyphs set on uniform widths (typically full or half-em) with proportionally spaced glyphs. The proportional variants are often used for the Latin characters in CJKV fonts, but may also be used for Kana in Japanese fonts.</p> <p><strong>Equivalent OpenType tag:</strong> 'pwid'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.QuarterWidths">
            <summary>
            <dd> <p> Replaces glyphs on other widths with glyphs set on widths of one quarter of an em (half an en). The characters involved are normally figures and some forms of punctuation.</p> <p><strong>Equivalent OpenType tag:</strong> 'qwid'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.RequiredLigatures">
            <summary>
            <dd> <p> Replaces a sequence of glyphs with a single glyph which is preferred for typographic purposes. This feature covers those ligatures, which the script determines as required to be used in normal conditions. This feature is important for some scripts to ensure correct glyph formation. </p> <p><strong>Equivalent OpenType tag:</strong> 'rlig'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.RubyNotationForms">
            <summary>
            <dd> <p> Identifies glyphs in the font which have been designed for "ruby", from the old typesetting term for four-point-sized type. Japanese typesetting often uses smaller kana glyphs, generally in superscripted form, to clarify the meaning of kanji which may be unfamiliar to the reader. </p> <p><strong>Equivalent OpenType tag:</strong> 'ruby'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticAlternates">
            <summary>
            <dd> <p> Replaces the default forms with the stylistic alternates. Many fonts contain alternate glyph designs for a purely esthetic effect; these don't always fit into a clear category like swash or historical. As in the case of swash glyphs, there may be more than one alternate form.  </p> <p><strong>Equivalent OpenType tag:</strong> 'salt'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ScientificInferiors">
            <summary>
            <dd> <p> Replaces lining or oldstyle figures with inferior figures (smaller glyphs which sit lower than the standard baseline, primarily for chemical or mathematical notation). May also replace lowercase characters with alphabetic inferiors.</p> <p><strong>Equivalent OpenType tag:</strong> 'sinf'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.SmallCapitals">
            <summary>
            <dd> <p> Turns lowercase characters into small capitals. This corresponds to the common SC font layout. It is generally used for display lines set in Large &amp; small caps, such as titles. Forms related to small capitals, such as oldstyle figures, may be included.</p> <p><strong>Equivalent OpenType tag:</strong> 'smcp'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.SimplifiedForms">
            <summary>
            <dd> <p> Replaces 'traditional' Chinese or Japanese forms with the corresponding 'simplified' forms.</p> <p><strong>Equivalent OpenType tag:</strong> 'smpl'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet1">
            <summary>
            <dd> <p> In addition to, or instead of, stylistic alternatives of individual glyphs (see 'salt' feature), some fonts may contain sets of stylistic variant glyphs corresponding to portions of the character set, such as multiple variants for lowercase letters in a Latin font. Glyphs in stylistic sets may be designed to harmonise visually, interract in particular ways, or otherwise work together. Examples of fonts including stylistic sets are Zapfino Linotype and Adobe's Poetica. Individual features numbered sequentially with the tag name convention 'ss01' 'ss02' 'ss03' . 'ss20' provide a mechanism for glyphs in these sets to be associated via GSUB lookup indexes to default forms and to each other, and for users to select from available stylistic sets</p> <p><strong>Equivalent OpenType tag:</strong> 'ss01'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet2">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss02'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet3">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss03'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet4">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss04'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet5">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss05'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet6">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss06'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet7">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss07'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet8">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss08'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet9">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss09'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet10">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss10'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet11">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss11'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet12">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss12'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet13">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss13'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet14">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss14'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet15">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss15'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet16">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss16'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet17">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss17'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet18">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss18'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet19">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss19'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.StylisticSet20">
            <summary>
            <dd> <p>See the description for <strong>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1</strong>.</p> <p><strong>Equivalent OpenType tag:</strong> 'ss20'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Subscript">
            <summary>
            <dd> <p> May replace a default glyph with a subscript glyph, or it may combine a glyph substitution with positioning adjustments for proper placement.</p> <p><strong>Equivalent OpenType tag:</strong> 'subs'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SUBSCRIPT</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SUBSCRIPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Superscript">
            <summary>
            <dd> <p> Replaces lining or oldstyle figures with superior figures (primarily for footnote indication), and replaces lowercase letters with superior letters (primarily for abbreviated French titles).</p> <p><strong>Equivalent OpenType tag:</strong> 'sups'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Swash">
            <summary>
            <dd> <p> Replaces default character glyphs with corresponding swash glyphs. Note that there may be more than one swash alternate for a given character.</p> <p><strong>Equivalent OpenType tag:</strong> 'swsh'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SWASH</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SWASH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Titling">
            <summary>
            <dd> <p> Replaces the default glyphs with corresponding forms designed specifically for titling. These may be all-capital and/or larger on the body, and adjusted for viewing at larger sizes.</p> <p><strong>Equivalent OpenType tag:</strong> 'titl'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_TITLING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_TITLING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.TraditionalNameForms">
            <summary>
            <dd> <p> Replaces 'simplified' Japanese kanji forms with the corresponding 'traditional' forms. This is equivalent to the Traditional Forms feature, but explicitly limited to the traditional forms considered proper for use in personal names (as many as 205 glyphs in some fonts).</p> <p><strong>Equivalent OpenType tag:</strong> 'tnam'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.TabularFigures">
            <summary>
            <dd> <p> Replaces figure glyphs set on proportional widths with corresponding glyphs set on uniform (tabular) widths. Tabular widths will generally be the default, but this cannot be safely assumed. Of course this feature would not be present in monospaced designs.</p> <p><strong>Equivalent OpenType tag:</strong> 'tnum'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.TraditionalForms">
            <summary>
            <dd> <p> Replaces 'simplified' Chinese hanzi or Japanese kanji forms with the corresponding 'traditional' forms.</p> <p><strong>Equivalent OpenType tag:</strong> 'trad'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.ThirdWidths">
            <summary>
            <dd> <p> Replaces glyphs on other widths with glyphs set on widths of one third of an em. The characters involved are normally figures and some forms of punctuation.</p> <p><strong>Equivalent OpenType tag:</strong> 'twid'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.Unicase">
            <summary>
            <dd> <p> Maps upper- and lowercase letters to a mixed set of lowercase and small capital forms, resulting in a single case alphabet (for an example of unicase, see the Emigre type family Filosofia). The letters substituted may vary from font to font, as appropriate to the design. If aligning to the x-height, smallcap glyphs may be substituted, or specially designed unicase forms might be used. Substitutions might also include specially designed figures.
            </p> <p><strong>Equivalent OpenType tag:</strong> 'unic'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_UNICASE</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_UNICASE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.VerticalWriting">
            <summary>
            <dd> <p>Indicates that the font is displayed vertically.</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_VERTICAL_WRITING</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_VERTICAL_WRITING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.VerticalAlternatesAndRotation">
            <summary>
            <dd> <p>Replaces normal figures with figures adjusted for vertical display.</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_VERTICAL_ALTERNATES_AND_ROTATION</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_VERTICAL_ALTERNATES_AND_ROTATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFeatureTag.SlashedZero">
            <summary>
            <dd> <p>Allows the user to change from the default 0 to a slashed form. Some fonts contain both a default form of zero, and an alternative form which uses a diagonal slash through the counter. Especially in condensed designs, it can be difficult to distinguish between 0 and O (zero and capital O) in any situation where capitals and lining figures may be arbitrarily mixed. </p> <p><strong>Equivalent OpenType tag:</strong> 'zero'</p> </dd>
            </summary>
            <doc-id>dd368069</doc-id>
            <unmanaged>DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO</unmanaged>
            <unmanaged-short>DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontFileType">
            <summary>
            <p>The type of a font represented by a single font file. Font formats that consist of multiple files, for example Type 1 .PFM and .PFB, have separate enum values for each of the file types.</p>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Unknown">
            <summary>
            <dd> <p>Font type is not recognized by the DirectWrite font system.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_UNKNOWN</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_UNKNOWN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Cff">
            <summary>
            <dd> <p>OpenType font with CFF outlines.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_CFF</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_CFF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Truetype">
            <summary>
            <dd> <p>OpenType font with TrueType outlines.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_TRUETYPE</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_TRUETYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.OpenTypeCollection">
            <summary>
            <dd> <p>OpenType font that contains a TrueType collection.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_OPENTYPE_COLLECTION</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_OPENTYPE_COLLECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Type1Pfm">
            <summary>
            <dd> <p>Type 1 PFM font.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_TYPE1_PFM</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_TYPE1_PFM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Type1Pfb">
            <summary>
            <dd> <p>Type 1 PFB font.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_TYPE1_PFB</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_TYPE1_PFB</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Vector">
            <summary>
            <dd> <p>Vector .FON font.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_VECTOR</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_VECTOR</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.Bitmap">
            <summary>
            <dd> <p>Bitmap .FON font.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_BITMAP</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_BITMAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontFileType.TruetypeCollection">
            <summary>
            <dd> <p>OpenType font that contains a TrueType collection.</p> </dd>
            </summary>
            <doc-id>dd368072</doc-id>
            <unmanaged>DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION</unmanaged>
            <unmanaged-short>DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontLineGapUsage">
            <summary>
            <p>Specify whether <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics"/></strong>::lineGap value should be part of the line metrics</p>
            </summary>
            <doc-id>dn933211</doc-id>
            <unmanaged>DWRITE_FONT_LINE_GAP_USAGE</unmanaged>
            <unmanaged-short>DWRITE_FONT_LINE_GAP_USAGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontLineGapUsage.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn933211</doc-id>
            <unmanaged>DWRITE_FONT_LINE_GAP_USAGE_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_FONT_LINE_GAP_USAGE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontLineGapUsage.Disabled">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn933211</doc-id>
            <unmanaged>DWRITE_FONT_LINE_GAP_USAGE_DISABLED</unmanaged>
            <unmanaged-short>DWRITE_FONT_LINE_GAP_USAGE_DISABLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontLineGapUsage.Enabled">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn933211</doc-id>
            <unmanaged>DWRITE_FONT_LINE_GAP_USAGE_ENABLED</unmanaged>
            <unmanaged-short>DWRITE_FONT_LINE_GAP_USAGE_ENABLED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontPropertyId">
            <summary>
            <p>Identifies a string in a font.</p>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.None">
            <summary>
            <dd> <p>Unspecified font property identifier.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_NONE</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.WeightStretchStyleFamilyName">
            <summary>
            <dd> <p>Family name for the weight-width-slope model.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.TypographicFamilyName">
            <summary>
            <dd> <p>Family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with GDI. This name is typically only present if it differs from the GDI-compatible family name.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.WeightStretchStyleFaceName">
            <summary>
            <dd> <p>Face name of the font, for example Regular or Bold.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FACE_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_WEIGHT_STRETCH_STYLE_FACE_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.FullName">
            <summary>
            <dd> <p>The full name of the font, for example "Arial Bold", from name id 4 in the name table.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_FULL_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_FULL_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.Win32FamilyName">
            <summary>
            <dd> <p>GDI-compatible family name. Because GDI allows a maximum of four fonts per family, fonts in the same family may have different GDI-compatible family names, for example "Arial", "Arial Narrow", "Arial Black".</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_WIN32_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_WIN32_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.PostscriptName">
            <summary>
            <dd> <p>The postscript name of the font, for example "GillSans-Bold", from name id 6 in the name table.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_POSTSCRIPT_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_POSTSCRIPT_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.DesignScriptLanguageTag">
            <summary>
            <dd> <p>Script/language tag to identify the scripts or languages that the font was primarily designed to support.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_DESIGN_SCRIPT_LANGUAGE_TAG</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_DESIGN_SCRIPT_LANGUAGE_TAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.SupportedScriptLanguageTag">
            <summary>
            <dd> <p>Script/language tag to identify the scripts or languages that the font declares it is able to support.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_SUPPORTED_SCRIPT_LANGUAGE_TAG</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_SUPPORTED_SCRIPT_LANGUAGE_TAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.SemanticTag">
            <summary>
            <dd> <p>Semantic tag to describe the font, for example Fancy, Decorative, Handmade, Sans-serif, Swiss, Pixel, Futuristic.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_SEMANTIC_TAG</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_SEMANTIC_TAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.Weight">
            <summary>
            <dd> <p>Weight of the font represented as a decimal string in the range 1-999.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_WEIGHT</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_WEIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.Stretch">
            <summary>
            <dd> <p>Stretch of the font represented as a decimal string in the range 1-9.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_STRETCH</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_STRETCH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.Style">
            <summary>
            <dd> <p>Style of the font represented as a decimal string in the range 0-2.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_STYLE</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.TypographicFaceName">
            <summary>
            <dd> <p>Total number of properties.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FACE_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_TYPOGRAPHIC_FACE_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.Total">
            <summary>
            <dd> <p>Total number of properties.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_TOTAL</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_TOTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.TotalRasterizer3">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_TOTAL_RS3</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_TOTAL_RS3</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.PreferRedFamilyName">
            <summary>
            <dd> <p>Family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with GDI. This name is typically only present if it differs from the GDI-compatible family name.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_PREFERRED_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_PREFERRED_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.FamilyName">
            <summary>
            <dd> <p>Family name for the weight-width-slope model.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontPropertyId.FaceName">
            <summary>
            <dd> <p>Face name of the font, for example Regular or Bold.</p> </dd>
            </summary>
            <doc-id>dn933213</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY_ID_FACE_NAME</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY_ID_FACE_NAME</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontSimulations">
            <summary>
            <p>Specifies algorithmic style simulations to be applied to the font face. Bold and oblique simulations can be combined via bitwise OR operation.</p>
            </summary>
            <remarks>
            <p> Style simulations are not recommended for good typographic quality.</p>
            </remarks>
            <doc-id>dd368076</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS</unmanaged>
            <unmanaged-short>DWRITE_FONT_SIMULATIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontSimulations.None">
            <summary>
            <dd> <p>Indicates that no simulations are applied to the font face.</p> </dd>
            </summary>
            <doc-id>dd368076</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS_NONE</unmanaged>
            <unmanaged-short>DWRITE_FONT_SIMULATIONS_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontSimulations.Bold">
            <summary>
            <dd> <p>Indicates that algorithmic emboldening is applied to the font face.  <strong>DWRITE_FONT_SIMULATIONS_BOLD</strong> increases weight by applying a widening algorithm to the glyph outline. This may  be used to simulate a bold weight where no designed bold weight is available.</p> </dd>
            </summary>
            <doc-id>dd368076</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS_BOLD</unmanaged>
            <unmanaged-short>DWRITE_FONT_SIMULATIONS_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontSimulations.Oblique">
            <summary>
            <dd> <p>Indicates that algorithmic italicization is applied to the font face. <strong>DWRITE_FONT_SIMULATIONS_OBLIQUE</strong> applies obliquing (shear) to the glyph outline. This may be used to simulate an oblique/italic style where no designed oblique/italic style is available.</p> </dd>
            </summary>
            <doc-id>dd368076</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS_OBLIQUE</unmanaged>
            <unmanaged-short>DWRITE_FONT_SIMULATIONS_OBLIQUE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontStretch">
            <summary>
            <p>Represents the degree to which a font has been stretched compared to a font's normal aspect ratio. The enumerated values correspond to the <em>usWidthClass</em> definition in the OpenType specification. The usWidthClass represents an integer value between 1 and 9?lower values indicate narrower widths; higher values indicate wider widths.</p>
            </summary>
            <remarks>
            <p>A font stretch describes the degree to which a font form is stretched from its normal aspect ratio, which is the original width to height ratio specified for the glyphs in the font. 
            The following illustration shows an example of Normal and Condensed stretches for the Rockwell Bold typeface.</p><p></p><strong>Note</strong>??Values other than the ones defined in the enumeration are considered to be invalid, and are rejected by font API functions.?
            </remarks>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.Undefined">
            <summary>
            <dd> <p>Predefined font stretch : Not known (0).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_UNDEFINED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_UNDEFINED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.UltraCondensed">
            <summary>
            <dd> <p>Predefined font stretch : Ultra-condensed (1).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_ULTRA_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_ULTRA_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.ExtraCondensed">
            <summary>
            <dd> <p>Predefined font stretch : Extra-condensed (2).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_EXTRA_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_EXTRA_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.Condensed">
            <summary>
            <dd> <p>Predefined font stretch : Condensed (3).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.SemiCondensed">
            <summary>
            <dd> <p>Predefined font stretch : Semi-condensed (4).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_SEMI_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_SEMI_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.Normal">
            <summary>
            <dd> <p>Predefined font stretch : Normal (5).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_NORMAL</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.Medium">
            <summary>
            <dd> <p>Predefined font stretch : Medium (5).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_MEDIUM</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.SemiExpanded">
            <summary>
            <dd> <p>Predefined font stretch : Semi-expanded (6).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_SEMI_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_SEMI_EXPANDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.Expanded">
            <summary>
            <dd> <p>Predefined font stretch : Expanded (7).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_EXPANDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.ExtraExpanded">
            <summary>
            <dd> <p>Predefined font stretch : Extra-expanded (8).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_EXTRA_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_EXTRA_EXPANDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStretch.UltraExpanded">
            <summary>
            <dd> <p>Predefined font stretch : Ultra-expanded (9).</p> </dd>
            </summary>
            <doc-id>dd368078</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH_ULTRA_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_FONT_STRETCH_ULTRA_EXPANDED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontStyle">
            <summary>
            <p>Represents the style of a font face as normal, italic, or oblique.</p>
            </summary>
            <remarks>
            <p>Three terms categorize the slant of a font: normal, italic, and oblique. </p><table> <tr><th>Font style</th><th>Description</th></tr> <tr><td>Normal</td><td>The characters in a normal, or roman, font are upright. 
            </td></tr> <tr><td>Italic 
            </td><td>The characters in an italic font are truly slanted and appear as they were designed. 
            </td></tr> <tr><td>Oblique</td><td>The characters in an oblique font are artificially slanted.</td></tr> </table><p>?</p><p>For Oblique, the slant is achieved by performing a shear transformation on the characters from a normal font. When a true italic font is not available on a computer or printer, an oblique style can be generated from the normal font and used to simulate an italic font.  The following illustration shows the normal, italic, and oblique font styles for the Palatino Linotype font. Notice how the italic font style has a more flowing and visually appealing appearance than the oblique font style, which is simply created by skewing the normal font style version of the text.</p><p></p><strong>Note</strong>?? Values other than the ones defined in the enumeration are considered to be invalid, and they are rejected by font API functions.?
            </remarks>
            <doc-id>dd368080</doc-id>
            <unmanaged>DWRITE_FONT_STYLE</unmanaged>
            <unmanaged-short>DWRITE_FONT_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStyle.Normal">
            <summary>
            <dd> <p>Font style : Normal.</p> </dd>
            </summary>
            <doc-id>dd368080</doc-id>
            <unmanaged>DWRITE_FONT_STYLE_NORMAL</unmanaged>
            <unmanaged-short>DWRITE_FONT_STYLE_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStyle.Oblique">
            <summary>
            <dd> <p>Font style : Oblique. </p> </dd>
            </summary>
            <doc-id>dd368080</doc-id>
            <unmanaged>DWRITE_FONT_STYLE_OBLIQUE</unmanaged>
            <unmanaged-short>DWRITE_FONT_STYLE_OBLIQUE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontStyle.Italic">
            <summary>
            <dd> <p>Font style : Italic.</p> </dd>
            </summary>
            <doc-id>dd368080</doc-id>
            <unmanaged>DWRITE_FONT_STYLE_ITALIC</unmanaged>
            <unmanaged-short>DWRITE_FONT_STYLE_ITALIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontWeight">
            <summary>
            <p>Represents the density of a typeface, in terms of the lightness or heaviness of the strokes. The enumerated values correspond to the usWeightClass definition in the OpenType specification. The <em>usWeightClass</em> represents an integer value between 1 and 999. Lower values indicate lighter weights; higher values indicate heavier weights.</p>
            </summary>
            <remarks>
            <p>Weight differences are generally differentiated by an increased stroke or thickness that is associated with a given character in a typeface, as compared to a "normal" character from that same typeface. 
            The following illustration shows an example of Normal and UltraBold weights for the Palatino Linotype typeface.</p><p></p><strong>Note</strong>??Not all weights are available for all typefaces. When a weight is not available for a typeface, the closest matching weight is returned.?<p>Font weight values less than 1 or greater than 999 are considered invalid, and they are rejected by font API functions.</p>
            </remarks>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Thin">
            <summary>
            <dd> <p>Predefined font weight : Thin (100).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_THIN</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_THIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.ExtraLight">
            <summary>
            <dd> <p>Predefined font weight : Extra-light (200).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_EXTRA_LIGHT</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_EXTRA_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.UltraLight">
            <summary>
            <dd> <p>Predefined font weight : Ultra-light (200).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_ULTRA_LIGHT</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_ULTRA_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Light">
            <summary>
            <dd> <p>Predefined font weight : Light (300).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_LIGHT</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.SemiLight">
            <summary>
            <dd> <p>Predefined font weight : Semi-Light (350).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_SEMI_LIGHT</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_SEMI_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Normal">
            <summary>
            <dd> <p>Predefined font weight : Normal (400).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_NORMAL</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Regular">
            <summary>
            <dd> <p>Predefined font weight : Regular (400).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_REGULAR</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_REGULAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Medium">
            <summary>
            <dd> <p>Predefined font weight : Medium (500).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_MEDIUM</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.DemiBold">
            <summary>
            <dd> <p>Predefined font weight : Demi-bold (600).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_DEMI_BOLD</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_DEMI_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.SemiBold">
            <summary>
            <dd> <p>Predefined font weight : Semi-bold (600).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_SEMI_BOLD</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_SEMI_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Bold">
            <summary>
            <dd> <p>Predefined font weight : Bold (700).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_BOLD</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.ExtraBold">
            <summary>
            <dd> <p>Predefined font weight : Extra-bold (800).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_EXTRA_BOLD</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_EXTRA_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.UltraBold">
            <summary>
            <dd> <p>Predefined font weight : Ultra-bold (800).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_ULTRA_BOLD</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_ULTRA_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Black">
            <summary>
            <dd> <p>Predefined font weight : Black (900).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_BLACK</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_BLACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.Heavy">
            <summary>
            <dd> <p>Predefined font weight : Heavy (900).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_HEAVY</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_HEAVY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.ExtraBlack">
            <summary>
            <dd> <p>Predefined font weight : Extra-black (950).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_EXTRA_BLACK</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_EXTRA_BLACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontWeight.UltraBlack">
            <summary>
            <dd> <p>Predefined font weight : Ultra-black (950).</p> </dd>
            </summary>
            <doc-id>dd368082</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT_ULTRA_BLACK</unmanaged>
            <unmanaged-short>DWRITE_FONT_WEIGHT_ULTRA_BLACK</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphOrientationAngle">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.GlyphOrientationAngle"/></strong> enumeration contains values that specify how the glyph is oriented to the x-axis.</p>
            </summary>
            <remarks>
            <p>The text analyzer outputs <strong><see cref = "T:SharpDX.DirectWrite.GlyphOrientationAngle"/></strong> values. The value that it outputs depends on the desired orientation, bidi level, and character properties.</p>
            </remarks>
            <doc-id>jj126260</doc-id>
            <unmanaged>DWRITE_GLYPH_ORIENTATION_ANGLE</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_ORIENTATION_ANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphOrientationAngle.Degrees0">
            <summary>
            <dd> <p>Glyph orientation is upright.</p> </dd>
            </summary>
            <doc-id>jj126260</doc-id>
            <unmanaged>DWRITE_GLYPH_ORIENTATION_ANGLE_0_DEGREES</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_ORIENTATION_ANGLE_0_DEGREES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphOrientationAngle.Degrees90">
            <summary>
            <dd> <p>Glyph orientation is rotated 90 degrees clockwise.</p> </dd>
            </summary>
            <doc-id>jj126260</doc-id>
            <unmanaged>DWRITE_GLYPH_ORIENTATION_ANGLE_90_DEGREES</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_ORIENTATION_ANGLE_90_DEGREES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphOrientationAngle.Degrees180">
            <summary>
            <dd> <p>Glyph orientation is upside-down.</p> </dd>
            </summary>
            <doc-id>jj126260</doc-id>
            <unmanaged>DWRITE_GLYPH_ORIENTATION_ANGLE_180_DEGREES</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_ORIENTATION_ANGLE_180_DEGREES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphOrientationAngle.Degrees270">
            <summary>
            <dd> <p>Glyph orientation is rotated 270 degrees clockwise.</p> </dd>
            </summary>
            <doc-id>jj126260</doc-id>
            <unmanaged>DWRITE_GLYPH_ORIENTATION_ANGLE_270_DEGREES</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_ORIENTATION_ANGLE_270_DEGREES</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GridFitMode">
            <summary>
            <p>Specifies whether to enable grid-fitting of glyph outlines (also known as hinting).</p>
            </summary>
            <doc-id>dn890718</doc-id>
            <unmanaged>DWRITE_GRID_FIT_MODE</unmanaged>
            <unmanaged-short>DWRITE_GRID_FIT_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GridFitMode.Default">
            <summary>
            <dd> <p>Choose grid fitting based on the font's table information.</p> </dd>
            </summary>
            <doc-id>dn890718</doc-id>
            <unmanaged>DWRITE_GRID_FIT_MODE_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_GRID_FIT_MODE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GridFitMode.Disabled">
            <summary>
            <dd> <p>Always disable grid fitting, using the ideal glyph outlines.</p> </dd>
            </summary>
            <doc-id>dn890718</doc-id>
            <unmanaged>DWRITE_GRID_FIT_MODE_DISABLED</unmanaged>
            <unmanaged-short>DWRITE_GRID_FIT_MODE_DISABLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GridFitMode.Enabled">
            <summary>
            <dd> <p>Enable grid fitting, adjusting glyph outlines for device pixel display.</p> </dd>
            </summary>
            <doc-id>dn890718</doc-id>
            <unmanaged>DWRITE_GRID_FIT_MODE_ENABLED</unmanaged>
            <unmanaged-short>DWRITE_GRID_FIT_MODE_ENABLED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.InformationalStringId">
            <summary>
            <p>The informational string enumeration which identifies a string embedded in a font file.</p>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_ID</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_ID</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.None">
            <summary>
            <dd> <p>Indicates the string containing the unspecified name ID.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_NONE</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.CopyrightNotice">
            <summary>
            <dd> <p>Indicates the string containing the copyright notice provided by the font.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.VersionStrings">
            <summary>
            <dd> <p>Indicates the string containing a version number.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.Trademark">
            <summary>
            <dd> <p>Indicates the string containing the trademark information provided by the font.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_TRADEMARK</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_TRADEMARK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.Manufacturer">
            <summary>
            <dd> <p>Indicates the string containing the name of the font manufacturer.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_MANUFACTURER</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_MANUFACTURER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.Designer">
            <summary>
            <dd> <p>Indicates the string containing the name of the font designer.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_DESIGNER</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_DESIGNER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.DesignerUrl">
            <summary>
            <dd> <p>Indicates the string containing the URL of the font designer (with protocol, e.g., http://, ftp://).</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_DESIGNER_URL</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_DESIGNER_URL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.Description">
            <summary>
            <dd> <p>Indicates the string containing the description of the font. This may also contain revision information, usage recommendations, history, features, and so on.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_DESCRIPTION</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.FontVendorUrl">
            <summary>
            <dd> <p>Indicates the string containing the URL of the font vendor (with protocol, e.g., http://, ftp://). If a unique serial number is embedded in the URL, it can be used to register the font.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.LicenseDescription">
            <summary>
            <dd> <p>Indicates the string containing the description of how the font may be legally used, or different example scenarios for licensed use.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.LicenseInformationUrl">
            <summary>
            <dd> <p>Indicates the string containing the URL where additional licensing information can be found.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.Win32FamilyNames">
            <summary>
            <dd> <p>Indicates the string containing the GDI-compatible family name. Since GDI allows a maximum of four fonts per family, fonts in the same family may have different GDI-compatible family names (e.g., "Arial", "Arial Narrow", "Arial Black").</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.Win32SubFamilyNames">
            <summary>
            <dd> <p>Indicates the string containing a GDI-compatible subfamily name.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.TypographicFamilyNames">
            <summary>
            <dd> <p>Indicates the string containing a GDI-compatible subfamily name.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_TYPOGRAPHIC_FAMILY_NAMES</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_TYPOGRAPHIC_FAMILY_NAMES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.TypographicSubFamilyNames">
            <summary>
            <dd> <p>Indicates the string containing the family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with GDI. This name is typically only present if it differs from the GDI-compatible family name.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_TYPOGRAPHIC_SUBFAMILY_NAMES</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_TYPOGRAPHIC_SUBFAMILY_NAMES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.SampleText">
            <summary>
            <dd> <p>Contains sample text for display in font lists. This can be the font name or any other text that the designer thinks is the best  example to display the font in.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.FullName">
            <summary>
            <dd> <p>The full name of the font, like Arial Bold, from <em>name id 4</em> in the name table</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_FULL_NAME</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_FULL_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.PostscriptName">
            <summary>
            <dd> <p>The postscript name of the font, like GillSans-Bold, from <em>name id 6</em> in the name table.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.PostscriptCidName">
            <summary>
            <dd> <p>The postscript CID findfont name, from <em>name id 20</em> in the name table</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_CID_NAME</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_CID_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.WeightStretchStyleFamilyName">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_WEIGHT_STRETCH_STYLE_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_WEIGHT_STRETCH_STYLE_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.DesignScriptLanguageTag">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_DESIGN_SCRIPT_LANGUAGE_TAG</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_DESIGN_SCRIPT_LANGUAGE_TAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.SupportedScriptLanguageTag">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_SUPPORTED_SCRIPT_LANGUAGE_TAG</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_SUPPORTED_SCRIPT_LANGUAGE_TAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.PreferRedFamilyNames">
            <summary>
            <dd> <p>Indicates the string containing the family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with GDI. This name is typically only present if it differs from the GDI-compatible family name.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.PreferRedSubFamilyNames">
            <summary>
            <dd> <p>Indicates the string containing the subfamily name preferred by the designer. This name is typically only present if it differs from the GDI-compatible subfamily name.</p> </dd>
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InformationalStringId.WwsFamilyName">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368094</doc-id>
            <unmanaged>DWRITE_INFORMATIONAL_STRING_WWS_FAMILY_NAME</unmanaged>
            <unmanaged-short>DWRITE_INFORMATIONAL_STRING_WWS_FAMILY_NAME</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.LineSpacingMethod">
            <summary>
            <p>The method used for line spacing in a text layout.</p>
            </summary>
            <remarks>
            <p>The line spacing method is set by using the <strong>SetLineSpacing</strong> method of the <strong><see cref = "T:SharpDX.DirectWrite.TextFormat"/></strong> or <strong><see cref = "T:SharpDX.DirectWrite.TextLayout"/></strong> interfaces.  To get  the current line spacing method of a text format or text layou use the <strong>GetLineSpacing</strong>.</p>
            </remarks>
            <doc-id>dd368101</doc-id>
            <unmanaged>DWRITE_LINE_SPACING_METHOD</unmanaged>
            <unmanaged-short>DWRITE_LINE_SPACING_METHOD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacingMethod.Default">
            <summary>
            <dd> <p>Line spacing depends solely on the content, adjusting to accommodate the size of fonts and inline objects.</p> </dd>
            </summary>
            <doc-id>dd368101</doc-id>
            <unmanaged>DWRITE_LINE_SPACING_METHOD_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_LINE_SPACING_METHOD_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacingMethod.Uniform">
            <summary>
            <dd> <p>Lines are explicitly set to uniform spacing, regardless of the size of fonts and inline objects. This can be useful to avoid the uneven appearance that can occur from font fallback.</p> </dd>
            </summary>
            <doc-id>dd368101</doc-id>
            <unmanaged>DWRITE_LINE_SPACING_METHOD_UNIFORM</unmanaged>
            <unmanaged-short>DWRITE_LINE_SPACING_METHOD_UNIFORM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacingMethod.Proportional">
            <summary>
            <dd> <p>Line spacing and baseline distances are proportional to the computed values based on the content, the size of the fonts and inline objects. </p> <strong>Note</strong>??This value is only available on Windows?10 or later and it can be used with <strong>IDWriteTextLayout3::SetLineSpacing</strong>,  but can not be used with <strong>IDWriteTextFormat::SetLineSpacing</strong>. ? </dd>
            </summary>
            <doc-id>dd368101</doc-id>
            <unmanaged>DWRITE_LINE_SPACING_METHOD_PROPORTIONAL</unmanaged>
            <unmanaged-short>DWRITE_LINE_SPACING_METHOD_PROPORTIONAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Locality">
            <summary>
            <p>Specifies the location of a resource.</p>
            </summary>
            <doc-id>dn890740</doc-id>
            <unmanaged>DWRITE_LOCALITY</unmanaged>
            <unmanaged-short>DWRITE_LOCALITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Locality.Remote">
            <summary>
            <dd> <p>The resource is remote, and information about it is unknown, including the file size and date. If you attempt to create a font or file stream, the creation will fail until locality becomes at least partial. </p> </dd>
            </summary>
            <doc-id>dn890740</doc-id>
            <unmanaged>DWRITE_LOCALITY_REMOTE</unmanaged>
            <unmanaged-short>DWRITE_LOCALITY_REMOTE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Locality.Partial">
            <summary>
            <dd> <p>The resource is partially local, which means you can query the size and date of the file stream. With this type, you also might be able to create a font face and retrieve the particular glyphs for metrics and drawing, but not all the glyphs will be present.</p> </dd>
            </summary>
            <doc-id>dn890740</doc-id>
            <unmanaged>DWRITE_LOCALITY_PARTIAL</unmanaged>
            <unmanaged-short>DWRITE_LOCALITY_PARTIAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Locality.Local">
            <summary>
            <dd> <p>The resource is completely local, and all font functions can be called without concern of missing data or errors related to network connectivity.</p> </dd>
            </summary>
            <doc-id>dn890740</doc-id>
            <unmanaged>DWRITE_LOCALITY_LOCAL</unmanaged>
            <unmanaged-short>DWRITE_LOCALITY_LOCAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.NumberSubstitutionMethod">
            <summary>
            <p>Specifies how to apply number substitution on digits and related punctuation.</p>
            </summary>
            <doc-id>dd368107</doc-id>
            <unmanaged>DWRITE_NUMBER_SUBSTITUTION_METHOD</unmanaged>
            <unmanaged-short>DWRITE_NUMBER_SUBSTITUTION_METHOD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.NumberSubstitutionMethod.FromCulture">
            <summary>
            <dd> <p>Specifies that the substitution method should be determined based on the LOCALE_IDIGITSUBSTITUTION value of the specified text culture.</p> </dd>
            </summary>
            <doc-id>dd368107</doc-id>
            <unmanaged>DWRITE_NUMBER_SUBSTITUTION_METHOD_FROM_CULTURE</unmanaged>
            <unmanaged-short>DWRITE_NUMBER_SUBSTITUTION_METHOD_FROM_CULTURE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.NumberSubstitutionMethod.Contextual">
            <summary>
            <dd> <p>If the culture is Arabic or Persian, specifies that the number shapes depend on the context. Either traditional or nominal number shapes are used, depending on the nearest preceding strong character or (if there is none) the reading direction of the paragraph.</p> </dd>
            </summary>
            <doc-id>dd368107</doc-id>
            <unmanaged>DWRITE_NUMBER_SUBSTITUTION_METHOD_CONTEXTUAL</unmanaged>
            <unmanaged-short>DWRITE_NUMBER_SUBSTITUTION_METHOD_CONTEXTUAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.NumberSubstitutionMethod.None">
            <summary>
            <dd> <p>Specifies that code points 0x30-0x39 are always rendered as nominal numeral shapes (ones of the European number), that is, no substitution is performed.</p> </dd>
            </summary>
            <doc-id>dd368107</doc-id>
            <unmanaged>DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE</unmanaged>
            <unmanaged-short>DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.NumberSubstitutionMethod.National">
            <summary>
            <dd> <p>Specifies that numbers are rendered using the national number shapes as specified by the LOCALE_SNATIVEDIGITS value of the specified text culture.</p> </dd>
            </summary>
            <doc-id>dd368107</doc-id>
            <unmanaged>DWRITE_NUMBER_SUBSTITUTION_METHOD_NATIONAL</unmanaged>
            <unmanaged-short>DWRITE_NUMBER_SUBSTITUTION_METHOD_NATIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.NumberSubstitutionMethod.Traditional">
            <summary>
            <dd> <p>Specifies that numbers are rendered using the traditional shapes for the specified culture. For most cultures, this is the same as NativeNational. However, NativeNational results in Latin numbers for some Arabic cultures, whereasDWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL results in arabic numbers for all Arabic cultures.</p> </dd>
            </summary>
            <doc-id>dd368107</doc-id>
            <unmanaged>DWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL</unmanaged>
            <unmanaged-short>DWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.OptimizationIcalAlignment">
            <summary>
            <p>The optical margin alignment mode.</p><p> By default, glyphs are aligned to the margin by the default origin and side-bearings of the glyph.  If you specify <strong>DWRITE_OPTICAL_ALIGNMENT_NO_SIDE_BEARINGS</strong>, then the alignment uses the side bearings to offset the glyph  from the aligned edge to ensure the ink of the glyphs are aligned. </p>
            </summary>
            <doc-id>dn280421</doc-id>
            <unmanaged>DWRITE_OPTICAL_ALIGNMENT</unmanaged>
            <unmanaged-short>DWRITE_OPTICAL_ALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OptimizationIcalAlignment.None">
            <summary>
            <dd> <p>Align to the default origin and side-bearings of the glyph.</p> </dd>
            </summary>
            <doc-id>dn280421</doc-id>
            <unmanaged>DWRITE_OPTICAL_ALIGNMENT_NONE</unmanaged>
            <unmanaged-short>DWRITE_OPTICAL_ALIGNMENT_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OptimizationIcalAlignment.NoSideBearings">
            <summary>
            <dd> <p>Align to the ink of the glyphs, such that the black box abuts the margins.</p> </dd>
            </summary>
            <doc-id>dn280421</doc-id>
            <unmanaged>DWRITE_OPTICAL_ALIGNMENT_NO_SIDE_BEARINGS</unmanaged>
            <unmanaged-short>DWRITE_OPTICAL_ALIGNMENT_NO_SIDE_BEARINGS</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.OutlineThreshold">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.OutlineThreshold"/></strong> enumeration contains values that specify the policy used by the <strong>IDWriteFontFace1::GetRecommendedRenderingMode</strong> method to determine whether to render glyphs in outline mode.</p>
            </summary>
            <remarks>
            <p>Glyphs are rendered in outline mode by default at large sizes for performance reasons, but how large (that is, the outline threshold) depends on the quality of outline rendering. If the graphics system renders anti-aliased outlines, a relatively low threshold is used. But if the graphics system renders aliased outlines, a much higher threshold is used.</p>
            </remarks>
            <doc-id>jj126262</doc-id>
            <unmanaged>DWRITE_OUTLINE_THRESHOLD</unmanaged>
            <unmanaged-short>DWRITE_OUTLINE_THRESHOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OutlineThreshold.Antialiased">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj126262</doc-id>
            <unmanaged>DWRITE_OUTLINE_THRESHOLD_ANTIALIASED</unmanaged>
            <unmanaged-short>DWRITE_OUTLINE_THRESHOLD_ANTIALIASED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OutlineThreshold.Aliased">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj126262</doc-id>
            <unmanaged>DWRITE_OUTLINE_THRESHOLD_ALIASED</unmanaged>
            <unmanaged-short>DWRITE_OUTLINE_THRESHOLD_ALIASED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseArmStyle">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseArmStyle"/></strong> enumeration contains values that specify the style of termination of stems and rounded letterforms for text.</p>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.Any">
            <summary>
            <dd> <p>Any arm style.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.NoFit">
            <summary>
            <dd> <p>No fit arm style.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsHorizontal">
            <summary>
            <dd> <p>The arm style is straight horizontal.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORIZONTAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsWedge">
            <summary>
            <dd> <p>The arm style is straight wedge.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_WEDGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_WEDGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsVertical">
            <summary>
            <dd> <p>The arm style is straight vertical.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERTICAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsSingleSerif">
            <summary>
            <dd> <p>The arm style is straight single serif.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_SINGLE_SERIF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_SINGLE_SERIF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsDoubleSerif">
            <summary>
            <dd> <p>The arm style is straight double serif.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_DOUBLE_SERIF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_DOUBLE_SERIF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.NonstraightArmsHorizontal">
            <summary>
            <dd> <p>The arm style is non-straight horizontal.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_HORIZONTAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.NonstraightArmsWedge">
            <summary>
            <dd> <p>The arm style is non-straight wedge.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_WEDGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_WEDGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.NonstraightArmsVertical">
            <summary>
            <dd> <p>The arm style is non-straight vertical.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_VERTICAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.NonstraightArmsSingleSerif">
            <summary>
            <dd> <p>The arm style is non-straight single serif.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_SINGLE_SERIF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_SINGLE_SERIF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.NonstraightArmsDoubleSerif">
            <summary>
            <dd> <p>The arm style is non-straight double serif.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_DOUBLE_SERIF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_NONSTRAIGHT_ARMS_DOUBLE_SERIF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsHorz">
            <summary>
            <dd> <p>The arm style is straight horizontal.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORZ</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_HORZ</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.StraightArmsVert">
            <summary>
            <dd> <p>The arm style is straight vertical.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_STRAIGHT_ARMS_VERT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.BentArmsHorz">
            <summary>
            <dd> <p>The arm style is non-straight horizontal.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_HORZ</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_HORZ</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.BentArmsWedge">
            <summary>
            <dd> <p>The arm style is non-straight wedge.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_WEDGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_WEDGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.BentArmsVert">
            <summary>
            <dd> <p>The arm style is non-straight vertical.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_VERT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_VERT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.BentArmsSingleSerif">
            <summary>
            <dd> <p>The arm style is non-straight single serif.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_SINGLE_SERIF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_SINGLE_SERIF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseArmStyle.BentArmsDoubleSerif">
            <summary>
            <dd> <p>The arm style is non-straight double serif.</p> </dd>
            </summary>
            <doc-id>hh997721</doc-id>
            <unmanaged>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_DOUBLE_SERIF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ARM_STYLE_BENT_ARMS_DOUBLE_SERIF</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseAspect">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseAspect"/></strong> enumeration contains values that specify the ratio between the width and height of the character face.</p>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.Any">
            <summary>
            <dd> <p>Any aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.NoFit">
            <summary>
            <dd> <p>No fit for aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.SuperCondensed">
            <summary>
            <dd> <p>Super condensed aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_SUPER_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_SUPER_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.VeryCondensed">
            <summary>
            <dd> <p>Very condensed aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_VERY_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_VERY_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.Condensed">
            <summary>
            <dd> <p>Condensed aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.Normal">
            <summary>
            <dd> <p>Normal aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_NORMAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.Extended">
            <summary>
            <dd> <p>Extended aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_EXTENDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_EXTENDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.VeryExtended">
            <summary>
            <dd> <p>Very extended aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_VERY_EXTENDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_VERY_EXTENDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.SuperExtended">
            <summary>
            <dd> <p>Super extended aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_SUPER_EXTENDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_SUPER_EXTENDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspect.Monospaced">
            <summary>
            <dd> <p>Monospace aspect.</p> </dd>
            </summary>
            <doc-id>hh997722</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_MONOSPACED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_MONOSPACED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseAspectRatio">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseAspectRatio"/></strong> enumeration contains values that specify info about the ratio between width and height of the character face.</p>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.Any">
            <summary>
            <dd> <p>Any aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.NoFit">
            <summary>
            <dd> <p>No fit for aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.VeryCondensed">
            <summary>
            <dd> <p>Very condensed aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_VERY_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_VERY_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.Condensed">
            <summary>
            <dd> <p>Condensed aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.Normal">
            <summary>
            <dd> <p>Normal aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_NORMAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.Expanded">
            <summary>
            <dd> <p>Expanded aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_EXPANDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseAspectRatio.VeryExpanded">
            <summary>
            <dd> <p>Very expanded aspect ratio.</p> </dd>
            </summary>
            <doc-id>hh997723</doc-id>
            <unmanaged>DWRITE_PANOSE_ASPECT_RATIO_VERY_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_ASPECT_RATIO_VERY_EXPANDED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseCharacterRanges">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseCharacterRanges"/></strong> enumeration contains values that specify the type of characters available in the font.</p>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseCharacterRanges.Any">
            <summary>
            <dd> <p>Any range.</p> </dd>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseCharacterRanges.NoFit">
            <summary>
            <dd> <p>No fit for range.</p> </dd>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseCharacterRanges.ExtendedCollection">
            <summary>
            <dd> <p>The range includes extended collection.</p> </dd>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES_EXTENDED_COLLECTION</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES_EXTENDED_COLLECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseCharacterRanges.Literals">
            <summary>
            <dd> <p>The range includes literals.</p> </dd>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES_LITERALS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES_LITERALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseCharacterRanges.NoLowerCase">
            <summary>
            <dd> <p>The range doesn't include lower case.</p> </dd>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES_NO_LOWER_CASE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES_NO_LOWER_CASE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseCharacterRanges.SmallCaps">
            <summary>
            <dd> <p>The range includes small capitals.</p> </dd>
            </summary>
            <doc-id>hh997724</doc-id>
            <unmanaged>DWRITE_PANOSE_CHARACTER_RANGES_SMALL_CAPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CHARACTER_RANGES_SMALL_CAPS</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseContrast">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseContrast"/></strong> enumeration contains values that specify the ratio between thickest and thinnest point of the stroke for a letter such as uppercase 'O'.</p>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.Any">
            <summary>
            <dd> <p>Any contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.NoFit">
            <summary>
            <dd> <p>No fit contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.None">
            <summary>
            <dd> <p>No contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_NONE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.VeryLow">
            <summary>
            <dd> <p>Very low contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_VERY_LOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_VERY_LOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.Low">
            <summary>
            <dd> <p>Low contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_LOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_LOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.MediumLow">
            <summary>
            <dd> <p>Medium low contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_MEDIUM_LOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_MEDIUM_LOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.Medium">
            <summary>
            <dd> <p>Medium contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_MEDIUM</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.MediumHigh">
            <summary>
            <dd> <p>Medium high contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_MEDIUM_HIGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_MEDIUM_HIGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.High">
            <summary>
            <dd> <p>High contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_HIGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_HIGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.VeryHigh">
            <summary>
            <dd> <p>Very high contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_VERY_HIGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_VERY_HIGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.HorizontalLow">
            <summary>
            <dd> <p>Horizontal low contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_HORIZONTAL_LOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_HORIZONTAL_LOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.HorizontalMedium">
            <summary>
            <dd> <p>Horizontal medium contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_HORIZONTAL_MEDIUM</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_HORIZONTAL_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.HorizontalHigh">
            <summary>
            <dd> <p>Horizontal high contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_HORIZONTAL_HIGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_HORIZONTAL_HIGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseContrast.Broken">
            <summary>
            <dd> <p>Broken contrast.</p> </dd>
            </summary>
            <doc-id>hh997725</doc-id>
            <unmanaged>DWRITE_PANOSE_CONTRAST_BROKEN</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_CONTRAST_BROKEN</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseDecorativeClass">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseDecorativeClass"/></strong> enumeration contains values that specify the general look of the character face.</p>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Any">
            <summary>
            <dd> <p>Any class of decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.NoFit">
            <summary>
            <dd> <p>No fit for decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Derivative">
            <summary>
            <dd> <p>Derivative decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_DERIVATIVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_DERIVATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.NonStandardTopology">
            <summary>
            <dd> <p>Nonstandard topology decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_TOPOLOGY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_TOPOLOGY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.NonStandardElements">
            <summary>
            <dd> <p>Nonstandard elements decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_ELEMENTS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_ELEMENTS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.NonStandardAspect">
            <summary>
            <dd> <p>Nonstandard aspect decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_ASPECT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_NONSTANDARD_ASPECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Initials">
            <summary>
            <dd> <p>Initials decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_INITIALS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_INITIALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Cartoon">
            <summary>
            <dd> <p>Cartoon decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_CARTOON</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_CARTOON</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.PictureStems">
            <summary>
            <dd> <p>Picture stems decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_PICTURE_STEMS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_PICTURE_STEMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Ornamented">
            <summary>
            <dd> <p>Ornamented decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_ORNAMENTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_ORNAMENTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.TextAndBackground">
            <summary>
            <dd> <p>Text and background decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_TEXT_AND_BACKGROUND</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_TEXT_AND_BACKGROUND</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Collage">
            <summary>
            <dd> <p>Collage decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_COLLAGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_COLLAGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeClass.Montage">
            <summary>
            <dd> <p>Montage decorative typeface.</p> </dd>
            </summary>
            <doc-id>hh997726</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_CLASS_MONTAGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_CLASS_MONTAGE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseDecorativeTopology">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseDecorativeTopology"/></strong> enumeration contains values that specify the overall shape characteristics of the font.</p>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.Any">
            <summary>
            <dd> <p>Any decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.NoFit">
            <summary>
            <dd> <p>No fit for decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.Standard">
            <summary>
            <dd> <p>Standard decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_STANDARD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_STANDARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.Square">
            <summary>
            <dd> <p>Square decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_SQUARE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_SQUARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.MultipleSegment">
            <summary>
            <dd> <p>Multiple segment decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_MULTIPLE_SEGMENT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_MULTIPLE_SEGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.ArtDeco">
            <summary>
            <dd> <p>Art deco decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_ART_DECO</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_ART_DECO</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.UnevenWeighting">
            <summary>
            <dd> <p>Uneven weighting decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_UNEVEN_WEIGHTING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_UNEVEN_WEIGHTING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.DiverseArms">
            <summary>
            <dd> <p>Diverse arms decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_DIVERSE_ARMS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_DIVERSE_ARMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.DiverseForms">
            <summary>
            <dd> <p>Diverse forms decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_DIVERSE_FORMS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_DIVERSE_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.LombardicForms">
            <summary>
            <dd> <p>Lombardic forms decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_LOMBARDIC_FORMS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_LOMBARDIC_FORMS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.UpperCaseInLowerCase">
            <summary>
            <dd> <p>Upper case in lower case decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_UPPER_CASE_IN_LOWER_CASE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_UPPER_CASE_IN_LOWER_CASE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.ImpliedTopology">
            <summary>
            <dd> <p>The decorative topology is implied.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_IMPLIED_TOPOLOGY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_IMPLIED_TOPOLOGY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.HorseshoeEAndA">
            <summary>
            <dd> <p>Horseshoe E and A decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_HORSESHOE_E_AND_A</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_HORSESHOE_E_AND_A</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.Cursive">
            <summary>
            <dd> <p>Cursive decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_CURSIVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_CURSIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.Blackletter">
            <summary>
            <dd> <p>Blackletter decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_BLACKLETTER</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_BLACKLETTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorativeTopology.SwashVariance">
            <summary>
            <dd> <p>Swash variance decorative topology.</p> </dd>
            </summary>
            <doc-id>hh997727</doc-id>
            <unmanaged>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_SWASH_VARIANCE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_DECORATIVE_TOPOLOGY_SWASH_VARIANCE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseFamily">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseFamily"/></strong> enumeration contains values that specify the kind of typeface classification.</p>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.Any">
            <summary>
            <dd> <p>Any typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.NoFit">
            <summary>
            <dd> <p>No fit typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.TextDisplay">
            <summary>
            <dd> <p>Text display typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_TEXT_DISPLAY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_TEXT_DISPLAY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.Script">
            <summary>
            <dd> <p>Script (or hand written) typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_SCRIPT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_SCRIPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.Decorative">
            <summary>
            <dd> <p>Decorative typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_DECORATIVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_DECORATIVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.Symbol">
            <summary>
            <dd> <p>Symbol typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_SYMBOL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_SYMBOL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFamily.Pictorial">
            <summary>
            <dd> <p>Pictorial (or symbol) typeface classification.</p> </dd>
            </summary>
            <doc-id>hh995028</doc-id>
            <unmanaged>DWRITE_PANOSE_FAMILY_PICTORIAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FAMILY_PICTORIAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseFill">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseFill"/></strong> enumeration contains values that specify the type of fill and line treatment.</p>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.Any">
            <summary>
            <dd> <p>Any fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.NoFit">
            <summary>
            <dd> <p>No fit for fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.StandardSolidFill">
            <summary>
            <dd> <p>The fill is the standard solid fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_STANDARD_SOLID_FILL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_STANDARD_SOLID_FILL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.NoFill">
            <summary>
            <dd> <p>No fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_NO_FILL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_NO_FILL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.PatternedFill">
            <summary>
            <dd> <p>The fill is patterned fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_PATTERNED_FILL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_PATTERNED_FILL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.ComplexFill">
            <summary>
            <dd> <p>The fill is complex fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_COMPLEX_FILL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_COMPLEX_FILL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.ShapedFill">
            <summary>
            <dd> <p>The fill is shaped fill.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_SHAPED_FILL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_SHAPED_FILL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFill.DrawnDistressed">
            <summary>
            <dd> <p>The fill is drawn distressed.</p> </dd>
            </summary>
            <doc-id>hh997728</doc-id>
            <unmanaged>DWRITE_PANOSE_FILL_DRAWN_DISTRESSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FILL_DRAWN_DISTRESSED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseFinials">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseFinials"/></strong> enumeration contains values that specify how character ends and miniscule ascenders are treated.</p>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.Any">
            <summary>
            <dd> <p>Any finials.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.NoFit">
            <summary>
            <dd> <p>No fit for finials.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.NoneNoLoops">
            <summary>
            <dd> <p>No loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_NONE_NO_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_NONE_NO_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.NoneClosedLoops">
            <summary>
            <dd> <p>No closed loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_NONE_CLOSED_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_NONE_CLOSED_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.NoneOpenLoops">
            <summary>
            <dd> <p>No open loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_NONE_OPEN_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_NONE_OPEN_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.SharpNoLoops">
            <summary>
            <dd> <p>Sharp with no loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_SHARP_NO_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_SHARP_NO_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.SharpClosedLoops">
            <summary>
            <dd> <p>Sharp with closed loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_SHARP_CLOSED_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_SHARP_CLOSED_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.SharpOpenLoops">
            <summary>
            <dd> <p>Sharp with open loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_SHARP_OPEN_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_SHARP_OPEN_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.TaperedNoLoops">
            <summary>
            <dd> <p>Tapered with no loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_TAPERED_NO_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_TAPERED_NO_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.TaperedClosedLoops">
            <summary>
            <dd> <p>Tapered with closed loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_TAPERED_CLOSED_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_TAPERED_CLOSED_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.TaperedOpenLoops">
            <summary>
            <dd> <p>Tapered with open loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_TAPERED_OPEN_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_TAPERED_OPEN_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.RoundNoLoops">
            <summary>
            <dd> <p>Round with no loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_ROUND_NO_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_ROUND_NO_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.RoundClosedLoops">
            <summary>
            <dd> <p>Round with closed loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_ROUND_CLOSED_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_ROUND_CLOSED_LOOPS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseFinials.RoundOpenLoops">
            <summary>
            <dd> <p>Round with open loops.</p> </dd>
            </summary>
            <doc-id>hh997729</doc-id>
            <unmanaged>DWRITE_PANOSE_FINIALS_ROUND_OPEN_LOOPS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_FINIALS_ROUND_OPEN_LOOPS</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseLetterform">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseLetterform"/></strong> enumeration contains values that specify the roundness of letterform for text.</p>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.Any">
            <summary>
            <dd> <p>Any letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NoFit">
            <summary>
            <dd> <p>No fit letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalContact">
            <summary>
            <dd> <p>Normal contact letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_CONTACT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_CONTACT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalWeighted">
            <summary>
            <dd> <p>Normal weighted letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_WEIGHTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_WEIGHTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalBoxed">
            <summary>
            <dd> <p>Normal boxed letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_BOXED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_BOXED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalFlattened">
            <summary>
            <dd> <p>Normal flattened letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_FLATTENED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_FLATTENED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalRounded">
            <summary>
            <dd> <p>Normal rounded letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_ROUNDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_ROUNDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalOffCenter">
            <summary>
            <dd> <p>Normal off-center letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_OFF_CENTER</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_OFF_CENTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.NormalSquare">
            <summary>
            <dd> <p>Normal square letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_NORMAL_SQUARE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_NORMAL_SQUARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueContact">
            <summary>
            <dd> <p>Oblique contact letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_CONTACT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_CONTACT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueWeighted">
            <summary>
            <dd> <p>Oblique weighted letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_WEIGHTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_WEIGHTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueBoxed">
            <summary>
            <dd> <p>Oblique boxed letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_BOXED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_BOXED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueFlattened">
            <summary>
            <dd> <p>Oblique flattened letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_FLATTENED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_FLATTENED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueRounded">
            <summary>
            <dd> <p>Oblique rounded letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_ROUNDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_ROUNDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueOffCenter">
            <summary>
            <dd> <p>Oblique off-center letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_OFF_CENTER</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_OFF_CENTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLetterform.ObliqueSquare">
            <summary>
            <dd> <p>Oblique square letterform.</p> </dd>
            </summary>
            <doc-id>hh997730</doc-id>
            <unmanaged>DWRITE_PANOSE_LETTERFORM_OBLIQUE_SQUARE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LETTERFORM_OBLIQUE_SQUARE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseLining">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseLining"/></strong> enumeration contains values that specify the handling of the outline for the decorative typeface.</p>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Any">
            <summary>
            <dd> <p>Any lining.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.NoFit">
            <summary>
            <dd> <p>No fit for lining.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.None">
            <summary>
            <dd> <p>No lining.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_NONE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Inline">
            <summary>
            <dd> <p>The lining is inline.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_INLINE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_INLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Outline">
            <summary>
            <dd> <p>The lining is outline.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_OUTLINE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_OUTLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Engraved">
            <summary>
            <dd> <p>The lining is engraved.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_ENGRAVED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_ENGRAVED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Shadow">
            <summary>
            <dd> <p>The lining is shadowed.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_SHADOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_SHADOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Relief">
            <summary>
            <dd> <p>The lining is relief.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_RELIEF</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_RELIEF</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseLining.Backdrop">
            <summary>
            <dd> <p>The lining is backdrop.</p> </dd>
            </summary>
            <doc-id>hh997731</doc-id>
            <unmanaged>DWRITE_PANOSE_LINING_BACKDROP</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_LINING_BACKDROP</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseMidline">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseMidline"/></strong> enumeration contains values that specify info about the placement of midline across uppercase characters and the treatment of diagonal stem apexes.</p>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.Any">
            <summary>
            <dd> <p>Any midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.NoFit">
            <summary>
            <dd> <p>No fit midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.StandardTrimmed">
            <summary>
            <dd> <p>Standard trimmed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_STANDARD_TRIMMED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_STANDARD_TRIMMED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.StandardPointed">
            <summary>
            <dd> <p>Standard pointed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_STANDARD_POINTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_STANDARD_POINTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.StandardSerifed">
            <summary>
            <dd> <p>Standard serifed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_STANDARD_SERIFED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_STANDARD_SERIFED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.HighTrimmed">
            <summary>
            <dd> <p>High trimmed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_HIGH_TRIMMED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_HIGH_TRIMMED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.HighPointed">
            <summary>
            <dd> <p>High pointed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_HIGH_POINTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_HIGH_POINTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.HighSerifed">
            <summary>
            <dd> <p>High serifed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_HIGH_SERIFED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_HIGH_SERIFED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.ConstantTrimmed">
            <summary>
            <dd> <p>Constant trimmed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_CONSTANT_TRIMMED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_CONSTANT_TRIMMED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.ConstantPointed">
            <summary>
            <dd> <p>Constant pointed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_CONSTANT_POINTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_CONSTANT_POINTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.ConstantSerifed">
            <summary>
            <dd> <p>Constant serifed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_CONSTANT_SERIFED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_CONSTANT_SERIFED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.LowTrimmed">
            <summary>
            <dd> <p>Low trimmed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_LOW_TRIMMED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_LOW_TRIMMED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.LowPointed">
            <summary>
            <dd> <p>Low pointed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_LOW_POINTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_LOW_POINTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseMidline.LowSerifed">
            <summary>
            <dd> <p>Low serifed midline.</p> </dd>
            </summary>
            <doc-id>hh997732</doc-id>
            <unmanaged>DWRITE_PANOSE_MIDLINE_LOW_SERIFED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_MIDLINE_LOW_SERIFED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseProportion">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseProportion"/></strong> enumeration contains values that specify the proportion of the glyph shape by considering additional detail to standard characters.</p>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.Any">
            <summary>
            <dd> <p>Any proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.NoFit">
            <summary>
            <dd> <p>No fit proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.OldStyle">
            <summary>
            <dd> <p>Old style proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_OLD_STYLE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_OLD_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.Modern">
            <summary>
            <dd> <p>Modern proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_MODERN</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_MODERN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.EvenWidth">
            <summary>
            <dd> <p>Extra width proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_EVEN_WIDTH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_EVEN_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.Expanded">
            <summary>
            <dd> <p>Expanded proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_EXPANDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.Condensed">
            <summary>
            <dd> <p>Condensed proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.VeryExpanded">
            <summary>
            <dd> <p>Very expanded proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_VERY_EXPANDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_VERY_EXPANDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.VeryCondensed">
            <summary>
            <dd> <p>Very condensed proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_VERY_CONDENSED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_VERY_CONDENSED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseProportion.Monospaced">
            <summary>
            <dd> <p>Monospaced proportion for the text.</p> </dd>
            </summary>
            <doc-id>hh995029</doc-id>
            <unmanaged>DWRITE_PANOSE_PROPORTION_MONOSPACED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_PROPORTION_MONOSPACED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseScriptForm">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseScriptForm"/></strong> enumeration contains values that specify the general look of the character face, with consideration of its  slope and tails.</p>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.Any">
            <summary>
            <dd> <p>Any script form.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.NoFit">
            <summary>
            <dd> <p>No fit for script form.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.UprightNoWrapping">
            <summary>
            <dd> <p>Script form is upright with no wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_NO_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_NO_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.UprightSomeWrapping">
            <summary>
            <dd> <p>Script form is upright with some wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_SOME_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_SOME_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.UprightMoreWrapping">
            <summary>
            <dd> <p>Script form is upright with more wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_MORE_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_MORE_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.UprightExtremeWrapping">
            <summary>
            <dd> <p>Script form is upright with extreme wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_EXTREME_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_UPRIGHT_EXTREME_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ObliqueNoWrapping">
            <summary>
            <dd> <p>Script form is oblique with no wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_NO_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_NO_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ObliqueSomeWrapping">
            <summary>
            <dd> <p>Script form is oblique with some wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_SOME_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_SOME_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ObliqueMoreWrapping">
            <summary>
            <dd> <p>Script form is oblique with more wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_MORE_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_MORE_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ObliqueExtremeWrapping">
            <summary>
            <dd> <p>Script form is oblique with extreme wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_EXTREME_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_OBLIQUE_EXTREME_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ExaggeratedNoWrapping">
            <summary>
            <dd> <p>Script form is exaggerated with no wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_NO_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_NO_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ExaggeratedSomeWrapping">
            <summary>
            <dd> <p>Script form is exaggerated with some wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_SOME_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_SOME_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ExaggeratedMoreWrapping">
            <summary>
            <dd> <p>Script form is exaggerated with more wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_MORE_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_MORE_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptForm.ExaggeratedExtremeWrapping">
            <summary>
            <dd> <p>Script form is exaggerated with extreme wrapping.</p> </dd>
            </summary>
            <doc-id>hh997733</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_EXTREME_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_FORM_EXAGGERATED_EXTREME_WRAPPING</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseScriptTopology">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseScriptTopology"/></strong> enumeration contains values that specify the topology of letterforms.</p>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.Any">
            <summary>
            <dd> <p>Any script topology.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.NoFit">
            <summary>
            <dd> <p>No fit for script topology.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.RomanDisconnected">
            <summary>
            <dd> <p>Script topology is roman disconnected.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_DISCONNECTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_DISCONNECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.RomanTrailing">
            <summary>
            <dd> <p>Script topology is roman trailing.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_TRAILING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_TRAILING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.RomanConnected">
            <summary>
            <dd> <p>Script topology is roman connected.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_CONNECTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_ROMAN_CONNECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.CursiveDisconnected">
            <summary>
            <dd> <p>Script topology is cursive disconnected.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_DISCONNECTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_DISCONNECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.CursiveTrailing">
            <summary>
            <dd> <p>Script topology is cursive trailing.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_TRAILING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_TRAILING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.CursiveConnected">
            <summary>
            <dd> <p>Script topology is cursive connected.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_CONNECTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_CURSIVE_CONNECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.BlackletterDisconnected">
            <summary>
            <dd> <p>Script topology is black-letter disconnected.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_DISCONNECTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_DISCONNECTED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.BlackletterTrailing">
            <summary>
            <dd> <p>Script topology is black-letter trailing.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_TRAILING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_TRAILING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScriptTopology.BlackletterConnected">
            <summary>
            <dd> <p>Script topology is black-letter connected.</p> </dd>
            </summary>
            <doc-id>hh997734</doc-id>
            <unmanaged>DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_CONNECTED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SCRIPT_TOPOLOGY_BLACKLETTER_CONNECTED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseSerifStyle">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseSerifStyle"/></strong> enumeration contains values that specify the appearance of the serif text.</p>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Any">
            <summary>
            <dd> <p>Any appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.NoFit">
            <summary>
            <dd> <p>No fit appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Cove">
            <summary>
            <dd> <p>Cove appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_COVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_COVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.ObtuseCove">
            <summary>
            <dd> <p>Obtuse cove appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_OBTUSE_COVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_OBTUSE_COVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.SquareCove">
            <summary>
            <dd> <p>Square cove appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_SQUARE_COVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_SQUARE_COVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.ObtuseSquareCove">
            <summary>
            <dd> <p>Obtuse square cove appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_OBTUSE_SQUARE_COVE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_OBTUSE_SQUARE_COVE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Square">
            <summary>
            <dd> <p>Square appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_SQUARE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_SQUARE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Thin">
            <summary>
            <dd> <p>Thin appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_THIN</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_THIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Oval">
            <summary>
            <dd> <p>Oval appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_OVAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_OVAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Exaggerated">
            <summary>
            <dd> <p>Exaggerated appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_EXAGGERATED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_EXAGGERATED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Triangle">
            <summary>
            <dd> <p>Triangle appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_TRIANGLE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_TRIANGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.NormalSans">
            <summary>
            <dd> <p>Normal sans appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_NORMAL_SANS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_NORMAL_SANS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.ObtuseSans">
            <summary>
            <dd> <p>Obtuse sans appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_OBTUSE_SANS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_OBTUSE_SANS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.PerpendicularSans">
            <summary>
            <dd> <p>Perpendicular sans appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_PERPENDICULAR_SANS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_PERPENDICULAR_SANS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Flared">
            <summary>
            <dd> <p>Flared appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_FLARED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_FLARED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Rounded">
            <summary>
            <dd> <p>Rounded appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_ROUNDED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_ROUNDED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Script">
            <summary>
            <dd> <p>Script appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_SCRIPT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_SCRIPT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.PerpSans">
            <summary>
            <dd> <p>Perpendicular sans appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_PERP_SANS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_PERP_SANS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSerifStyle.Bone">
            <summary>
            <dd> <p>Oval appearance of the serif text.</p> </dd>
            </summary>
            <doc-id>hh995030</doc-id>
            <unmanaged>DWRITE_PANOSE_SERIF_STYLE_BONE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SERIF_STYLE_BONE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseSpacing">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseSpacing"/></strong> enumeration contains values that specify character spacing (monospace versus proportional).</p>
            </summary>
            <doc-id>hh997735</doc-id>
            <unmanaged>DWRITE_PANOSE_SPACING</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SPACING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSpacing.Any">
            <summary>
            <dd> <p>Any spacing.</p> </dd>
            </summary>
            <doc-id>hh997735</doc-id>
            <unmanaged>DWRITE_PANOSE_SPACING_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SPACING_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSpacing.NoFit">
            <summary>
            <dd> <p>No fit for spacing.</p> </dd>
            </summary>
            <doc-id>hh997735</doc-id>
            <unmanaged>DWRITE_PANOSE_SPACING_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SPACING_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSpacing.ProportionalSpaced">
            <summary>
            <dd> <p>Spacing is proportional.</p> </dd>
            </summary>
            <doc-id>hh997735</doc-id>
            <unmanaged>DWRITE_PANOSE_SPACING_PROPORTIONAL_SPACED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SPACING_PROPORTIONAL_SPACED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSpacing.Monospaced">
            <summary>
            <dd> <p>Spacing is monospace.</p> </dd>
            </summary>
            <doc-id>hh997735</doc-id>
            <unmanaged>DWRITE_PANOSE_SPACING_MONOSPACED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SPACING_MONOSPACED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseStrokeVariation">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseStrokeVariation"/></strong> enumeration contains values that specify the relationship between thin and thick stems of text characters.</p>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.Any">
            <summary>
            <dd> <p>Any stroke variation for text characters.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.NoFit">
            <summary>
            <dd> <p>No fit stroke variation for text characters.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.NoVariation">
            <summary>
            <dd> <p>No stroke variation for text characters.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_NO_VARIATION</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_NO_VARIATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.GradualDiagonal">
            <summary>
            <dd> <p>The stroke variation for text characters is gradual diagonal.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_DIAGONAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_DIAGONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.GradualTransitional">
            <summary>
            <dd> <p>The stroke variation for text characters is gradual transitional.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_TRANSITIONAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_TRANSITIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.GradualVertical">
            <summary>
            <dd> <p>The stroke variation for text characters is gradual vertical.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_VERTICAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.GradualHorizontal">
            <summary>
            <dd> <p>The stroke variation for text characters is gradual horizontal.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_HORIZONTAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_GRADUAL_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.RapidVertical">
            <summary>
            <dd> <p>The stroke variation for text characters is rapid vertical.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_RAPID_VERTICAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_RAPID_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.RapidHorizontal">
            <summary>
            <dd> <p>The stroke variation for text characters is rapid horizontal.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_RAPID_HORIZONTAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_RAPID_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.InstantVertical">
            <summary>
            <dd> <p>The stroke variation for text characters is instant vertical.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_INSTANT_VERTICAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_INSTANT_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseStrokeVariation.InstantHorizontal">
            <summary>
            <dd> <p>The stroke variation for text characters is instant horizontal.</p> </dd>
            </summary>
            <doc-id>hh997736</doc-id>
            <unmanaged>DWRITE_PANOSE_STROKE_VARIATION_INSTANT_HORIZONTAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_STROKE_VARIATION_INSTANT_HORIZONTAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseSymbolAspectRatio">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseSymbolAspectRatio"/></strong> enumeration contains values that specify the aspect ratio of symbolic characters.</p>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.Any">
            <summary>
            <dd> <p>Any aspect ratio of symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.NoFit">
            <summary>
            <dd> <p>No fit for aspect ratio of symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.NoWidth">
            <summary>
            <dd> <p>No width aspect ratio of symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NO_WIDTH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NO_WIDTH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.ExceptionallyWide">
            <summary>
            <dd> <p>Exceptionally wide symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_EXCEPTIONALLY_WIDE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_EXCEPTIONALLY_WIDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.SuperWide">
            <summary>
            <dd> <p>Super wide symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_SUPER_WIDE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_SUPER_WIDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.VeryWide">
            <summary>
            <dd> <p>Very wide symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_VERY_WIDE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_VERY_WIDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.Wide">
            <summary>
            <dd> <p>Wide symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_WIDE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_WIDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.Normal">
            <summary>
            <dd> <p>Normal aspect ratio of symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NORMAL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NORMAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.Narrow">
            <summary>
            <dd> <p>Narrow symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NARROW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_NARROW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolAspectRatio.VeryNarrow">
            <summary>
            <dd> <p>Very narrow symbolic characters.</p> </dd>
            </summary>
            <doc-id>jj126263</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_VERY_NARROW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_ASPECT_RATIO_VERY_NARROW</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseSymbolKind">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseSymbolKind"/></strong> enumeration contains values that specify the kind of symbol set.</p>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Any">
            <summary>
            <dd> <p>Any kind of symbol set.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.NoFit">
            <summary>
            <dd> <p>No fit for the kind of symbol set.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Montages">
            <summary>
            <dd> <p>The kind of symbol set is montages.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_MONTAGES</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_MONTAGES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Pictures">
            <summary>
            <dd> <p>The kind of symbol set is pictures.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_PICTURES</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_PICTURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Shapes">
            <summary>
            <dd> <p>The kind of symbol set is shapes.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_SHAPES</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_SHAPES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Scientific">
            <summary>
            <dd> <p>The kind of symbol set is scientific symbols.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_SCIENTIFIC</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_SCIENTIFIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Music">
            <summary>
            <dd> <p>The kind of symbol set is music symbols.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_MUSIC</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_MUSIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Expert">
            <summary>
            <dd> <p>The kind of symbol set is expert symbols.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_EXPERT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_EXPERT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Patterns">
            <summary>
            <dd> <p>The kind of symbol set is patterns.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_PATTERNS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_PATTERNS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Boarders">
            <summary>
            <dd> <p>The kind of symbol set is boarders.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_BOARDERS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_BOARDERS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Icons">
            <summary>
            <dd> <p>The kind of symbol set is icons.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_ICONS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_ICONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.Logos">
            <summary>
            <dd> <p>The kind of symbol set is logos.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_LOGOS</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_LOGOS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbolKind.IndustrySpecific">
            <summary>
            <dd> <p>The kind of symbol set is industry specific.</p> </dd>
            </summary>
            <doc-id>hh997737</doc-id>
            <unmanaged>DWRITE_PANOSE_SYMBOL_KIND_INDUSTRY_SPECIFIC</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_SYMBOL_KIND_INDUSTRY_SPECIFIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseToolKind">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseToolKind"/></strong> enumeration contains values that specify the kind of tool that is used to create character forms.</p>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.Any">
            <summary>
            <dd> <p>Any kind of tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.NoFit">
            <summary>
            <dd> <p>No fit for the kind of tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.FlatNib">
            <summary>
            <dd> <p>Flat NIB tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_FLAT_NIB</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_FLAT_NIB</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.PressurePoint">
            <summary>
            <dd> <p>Pressure point tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_PRESSURE_POINT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_PRESSURE_POINT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.Engraved">
            <summary>
            <dd> <p>Engraved tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_ENGRAVED</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_ENGRAVED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.Ball">
            <summary>
            <dd> <p>Ball tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_BALL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_BALL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.Brush">
            <summary>
            <dd> <p>Brush tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_BRUSH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_BRUSH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.Rough">
            <summary>
            <dd> <p>Rough tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_ROUGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_ROUGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.FeltPenBrushTip">
            <summary>
            <dd> <p>Felt-pen-brush-tip tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_FELT_PEN_BRUSH_TIP</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_FELT_PEN_BRUSH_TIP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseToolKind.WildBrush">
            <summary>
            <dd> <p>Wild-brush tool.</p> </dd>
            </summary>
            <doc-id>hh997738</doc-id>
            <unmanaged>DWRITE_PANOSE_TOOL_KIND_WILD_BRUSH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_TOOL_KIND_WILD_BRUSH</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseWeight">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseWeight"/></strong> enumeration contains values that specify the weight of characters.</p>
            </summary>
            <remarks>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseWeight"/></strong> values roughly correspond to the <strong><see cref = "T:SharpDX.DirectWrite.FontWeight"/></strong> values by using (panose_weight - 2) * 100 = font_weight.</p>
            </remarks>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Any">
            <summary>
            <dd> <p>Any weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.NoFit">
            <summary>
            <dd> <p>No fit weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.VeryLight">
            <summary>
            <dd> <p>Very light weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_VERY_LIGHT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_VERY_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Light">
            <summary>
            <dd> <p>Light weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_LIGHT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_LIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Thin">
            <summary>
            <dd> <p>Thin weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_THIN</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_THIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Book">
            <summary>
            <dd> <p>Book weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_BOOK</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_BOOK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Medium">
            <summary>
            <dd> <p>Medium weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_MEDIUM</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Demi">
            <summary>
            <dd> <p>Demi weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_DEMI</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_DEMI</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Bold">
            <summary>
            <dd> <p>Bold weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_BOLD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_BOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Heavy">
            <summary>
            <dd> <p>Heavy weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_HEAVY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_HEAVY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Black">
            <summary>
            <dd> <p>Black weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_BLACK</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_BLACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.ExtraBlack">
            <summary>
            <dd> <p>Extra black weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_EXTRA_BLACK</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_EXTRA_BLACK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseWeight.Nord">
            <summary>
            <dd> <p>Extra black weight.</p> </dd>
            </summary>
            <doc-id>hh995031</doc-id>
            <unmanaged>DWRITE_PANOSE_WEIGHT_NORD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_WEIGHT_NORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseXascent">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseXascent"/></strong> enumeration contains values that specify the relative size of the lowercase letters.</p>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.Any">
            <summary>
            <dd> <p>Any xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.NoFit">
            <summary>
            <dd> <p>No fit for xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.VeryLow">
            <summary>
            <dd> <p>Very low xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_VERY_LOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_VERY_LOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.Low">
            <summary>
            <dd> <p>Low xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_LOW</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_LOW</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.Medium">
            <summary>
            <dd> <p>Medium xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_MEDIUM</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_MEDIUM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.High">
            <summary>
            <dd> <p>High xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_HIGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_HIGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXascent.VeryHigh">
            <summary>
            <dd> <p>Very high xascent.</p> </dd>
            </summary>
            <doc-id>hh997739</doc-id>
            <unmanaged>DWRITE_PANOSE_XASCENT_VERY_HIGH</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XASCENT_VERY_HIGH</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseXheight">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.PanoseXheight"/></strong> enumeration contains values that specify info about the relative size of lowercase letters and the treatment of diacritic marks (xheight).</p>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.Any">
            <summary>
            <dd> <p>Any xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_ANY</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_ANY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.NoFit">
            <summary>
            <dd> <p>No fit xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_NO_FIT</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_NO_FIT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.ConstantSmall">
            <summary>
            <dd> <p>Constant small xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_CONSTANT_SMALL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_CONSTANT_SMALL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.ConstantStandard">
            <summary>
            <dd> <p>Constant standard xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_CONSTANT_STANDARD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_CONSTANT_STANDARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.ConstantLarge">
            <summary>
            <dd> <p>Constant large xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_CONSTANT_LARGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_CONSTANT_LARGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.DuckingSmall">
            <summary>
            <dd> <p>Ducking small xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_DUCKING_SMALL</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_DUCKING_SMALL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.DuckingStandard">
            <summary>
            <dd> <p>Ducking standard xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_DUCKING_STANDARD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_DUCKING_STANDARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.DuckingLarge">
            <summary>
            <dd> <p>Ducking large xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_DUCKING_LARGE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_DUCKING_LARGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.ConstantStd">
            <summary>
            <dd> <p>Constant standard xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_CONSTANT_STD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_CONSTANT_STD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseXheight.DuckingStd">
            <summary>
            <dd> <p>Ducking standard xheight.</p> </dd>
            </summary>
            <doc-id>hh997740</doc-id>
            <unmanaged>DWRITE_PANOSE_XHEIGHT_DUCKING_STD</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_XHEIGHT_DUCKING_STD</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ParagraphAlignment">
            <summary>
            <p> Specifies the alignment of paragraph text along the flow direction axis, relative to the top and bottom of the flow's layout box. </p>
            </summary>
            <doc-id>dd368112</doc-id>
            <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT</unmanaged>
            <unmanaged-short>DWRITE_PARAGRAPH_ALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ParagraphAlignment.Near">
            <summary>
            <dd> <p>The top of the text flow is aligned to the top edge of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368112</doc-id>
            <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT_NEAR</unmanaged>
            <unmanaged-short>DWRITE_PARAGRAPH_ALIGNMENT_NEAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ParagraphAlignment.Far">
            <summary>
            <dd> <p>The bottom of the text flow is aligned to the bottom edge of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368112</doc-id>
            <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT_FAR</unmanaged>
            <unmanaged-short>DWRITE_PARAGRAPH_ALIGNMENT_FAR</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ParagraphAlignment.Center">
            <summary>
            <dd> <p>The center of the flow is aligned to the center of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368112</doc-id>
            <unmanaged>DWRITE_PARAGRAPH_ALIGNMENT_CENTER</unmanaged>
            <unmanaged-short>DWRITE_PARAGRAPH_ALIGNMENT_CENTER</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PixelGeometry">
            <summary>
            <p> Represents the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text.
            </p>
            </summary>
            <doc-id>dd368114</doc-id>
            <unmanaged>DWRITE_PIXEL_GEOMETRY</unmanaged>
            <unmanaged-short>DWRITE_PIXEL_GEOMETRY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PixelGeometry.Flat">
            <summary>
            <dd> <p>The red, green, and blue color components of each pixel are assumed to occupy the same point.</p> </dd>
            </summary>
            <doc-id>dd368114</doc-id>
            <unmanaged>DWRITE_PIXEL_GEOMETRY_FLAT</unmanaged>
            <unmanaged-short>DWRITE_PIXEL_GEOMETRY_FLAT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PixelGeometry.Rgb">
            <summary>
            <dd> <p>Each pixel is composed of three vertical stripes, with red on the left, green in the center, and  blue on the right. This is the most common pixel geometry for LCD monitors.	   </p> </dd>
            </summary>
            <doc-id>dd368114</doc-id>
            <unmanaged>DWRITE_PIXEL_GEOMETRY_RGB</unmanaged>
            <unmanaged-short>DWRITE_PIXEL_GEOMETRY_RGB</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PixelGeometry.Bgr">
            <summary>
            <dd> <p>Each pixel is composed of three vertical stripes, with blue on the left, green in the center, and  red on the right.</p> </dd>
            </summary>
            <doc-id>dd368114</doc-id>
            <unmanaged>DWRITE_PIXEL_GEOMETRY_BGR</unmanaged>
            <unmanaged-short>DWRITE_PIXEL_GEOMETRY_BGR</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ReadingDirection">
            <summary>
            <p> Specifies the direction in which reading progresses. </p><strong>Note</strong>??<strong>DWRITE_READING_DIRECTION_TOP_TO_BOTTOM</strong> and <strong>DWRITE_READING_DIRECTION_BOTTOM_TO_TOP</strong> are available in Windows?8.1 and later, only.?
            </summary>
            <doc-id>dd368116</doc-id>
            <unmanaged>DWRITE_READING_DIRECTION</unmanaged>
            <unmanaged-short>DWRITE_READING_DIRECTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ReadingDirection.LeftToRight">
            <summary>
            <dd> <p>Indicates that reading progresses from left to right.</p> </dd>
            </summary>
            <doc-id>dd368116</doc-id>
            <unmanaged>DWRITE_READING_DIRECTION_LEFT_TO_RIGHT</unmanaged>
            <unmanaged-short>DWRITE_READING_DIRECTION_LEFT_TO_RIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ReadingDirection.RightToLeft">
            <summary>
            <dd> <p>Indicates that reading progresses from right to left.</p> </dd>
            </summary>
            <doc-id>dd368116</doc-id>
            <unmanaged>DWRITE_READING_DIRECTION_RIGHT_TO_LEFT</unmanaged>
            <unmanaged-short>DWRITE_READING_DIRECTION_RIGHT_TO_LEFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ReadingDirection.TopToBottom">
            <summary>
            <dd> <strong>Note</strong>??Windows?8.1 and later only. ? <p>Indicates that reading progresses from top to bottom.</p> </dd>
            </summary>
            <doc-id>dd368116</doc-id>
            <unmanaged>DWRITE_READING_DIRECTION_TOP_TO_BOTTOM</unmanaged>
            <unmanaged-short>DWRITE_READING_DIRECTION_TOP_TO_BOTTOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ReadingDirection.BottomToTop">
            <summary>
            <dd> <strong>Note</strong>??Windows?8.1 and later only. ? <p> Indicates that reading progresses from bottom to top.</p> </dd>
            </summary>
            <doc-id>dd368116</doc-id>
            <unmanaged>DWRITE_READING_DIRECTION_BOTTOM_TO_TOP</unmanaged>
            <unmanaged-short>DWRITE_READING_DIRECTION_BOTTOM_TO_TOP</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.RenderingMode">
            <summary>
            <p> Represents a method of rendering glyphs. </p><strong>Note</strong>?? This topic is about <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode"/></strong> in Windows?8 and later.  For info on the previous version see <strong>this topic</strong>.?
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.Aliased">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_ALIASED</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_ALIASED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.GdiClassic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_GDI_CLASSIC</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_GDI_CLASSIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.GdiNatural">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_GDI_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_GDI_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.Natural">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.NaturalSymmetric">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.Outline">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_OUTLINE</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_OUTLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.CleartypeGdiClassic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.CleartypeGdiNatural">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.CleartypeNatural">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode.CleartypeNaturalSymmetric">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.RenderingMode1">
            <summary>
            <p> Represents a method of rendering glyphs. </p><strong>Note</strong>?? This topic is about <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode"/></strong> in Windows?8 and later.  For info on the previous version see <strong>this topic</strong>.?
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.Aliased">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_ALIASED</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_ALIASED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.GdiClassic">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_GDI_CLASSIC</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_GDI_CLASSIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.GdiNatural">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_GDI_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_GDI_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.Natural">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_NATURAL</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_NATURAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.NaturalSymmetric">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.Outline">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_OUTLINE</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_OUTLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.RenderingMode1.NaturalSymmetricDownsampled">
            <summary>
            No documentation.
            </summary>
            <doc-id>dd368118</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC_DOWNSAMPLED</unmanaged>
            <unmanaged-short>DWRITE_RENDERING_MODE1_NATURAL_SYMMETRIC_DOWNSAMPLED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ScriptShapes">
            <summary>
            <p>Indicates additional shaping requirements for text.</p>
            </summary>
            <doc-id>dd368121</doc-id>
            <unmanaged>DWRITE_SCRIPT_SHAPES</unmanaged>
            <unmanaged-short>DWRITE_SCRIPT_SHAPES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptShapes.Default">
            <summary>
            <dd> <p>Indicates that there is no additional shaping requirements for text. Text is shaped with the writing system default behavior.</p> </dd>
            </summary>
            <doc-id>dd368121</doc-id>
            <unmanaged>DWRITE_SCRIPT_SHAPES_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_SCRIPT_SHAPES_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptShapes.NoVisual">
            <summary>
            <dd> <p>Indicates that text should leave no visible control or format control characters.</p> </dd>
            </summary>
            <doc-id>dd368121</doc-id>
            <unmanaged>DWRITE_SCRIPT_SHAPES_NO_VISUAL</unmanaged>
            <unmanaged-short>DWRITE_SCRIPT_SHAPES_NO_VISUAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAlignment">
            <summary>
            <p>Specifies the alignment of paragraph text along the reading direction axis, relative to the leading and trailing edge of the layout box.</p>
            </summary>
            <doc-id>dd368131</doc-id>
            <unmanaged>DWRITE_TEXT_ALIGNMENT</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextAlignment.Leading">
            <summary>
            <dd> <p>The leading edge of the paragraph text is aligned to the leading edge of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368131</doc-id>
            <unmanaged>DWRITE_TEXT_ALIGNMENT_LEADING</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ALIGNMENT_LEADING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextAlignment.Trailing">
            <summary>
            <dd> <p>The trailing edge of the paragraph text is aligned to the  trailing edge of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368131</doc-id>
            <unmanaged>DWRITE_TEXT_ALIGNMENT_TRAILING</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ALIGNMENT_TRAILING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextAlignment.Center">
            <summary>
            <dd> <p>The center of the paragraph text is aligned to the center of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368131</doc-id>
            <unmanaged>DWRITE_TEXT_ALIGNMENT_CENTER</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ALIGNMENT_CENTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextAlignment.Justified">
            <summary>
            <dd> <p>Align text to the leading side, and also justify text to fill the lines.</p> </dd>
            </summary>
            <doc-id>dd368131</doc-id>
            <unmanaged>DWRITE_TEXT_ALIGNMENT_JUSTIFIED</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ALIGNMENT_JUSTIFIED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TextAntialiasMode">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.TextAntialiasMode"/></strong> enumeration contains values that specify the type of antialiasing to use for text when the rendering mode calls for antialiasing.</p>
            </summary>
            <doc-id>jj127237</doc-id>
            <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ANTIALIAS_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextAntialiasMode.Cleartype">
            <summary>
            <dd> <p>ClearType antialiasing computes coverage independently for the red, green, and blue color elements of each pixel. This allows for more detail than conventional antialiasing. However, because there is no one alpha value for each pixel, ClearType is not suitable for rendering text onto a transparent intermediate bitmap.</p> </dd>
            </summary>
            <doc-id>jj127237</doc-id>
            <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextAntialiasMode.Grayscale">
            <summary>
            <dd> <p>Grayscale antialiasing computes one coverage value for each pixel. Because the alpha value of each pixel is well-defined, text can be rendered onto a transparent bitmap, which can then be composited with other content.</p> <strong>Note</strong>??Grayscale rendering with <strong><see cref = "T:SharpDX.DirectWrite.BitmapRenderTarget1"/></strong> uses premultiplied alpha. ? </dd>
            </summary>
            <doc-id>jj127237</doc-id>
            <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE</unmanaged>
            <unmanaged-short>DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TextureType">
            <summary>
            <p>Identifies a type of alpha texture.</p>
            </summary>
            <remarks>
            <p>An alpha texture is a bitmap of alpha values, each representing opacity of a pixel or subpixel.</p>
            </remarks>
            <doc-id>dd368129</doc-id>
            <unmanaged>DWRITE_TEXTURE_TYPE</unmanaged>
            <unmanaged-short>DWRITE_TEXTURE_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextureType.Aliased1x1">
            <summary>
            <dd> <p>Specifies an alpha texture for aliased text rendering (that is,  each pixel is either fully opaque or fully transparent), with one byte per pixel.</p> </dd>
            </summary>
            <doc-id>dd368129</doc-id>
            <unmanaged>DWRITE_TEXTURE_ALIASED_1x1</unmanaged>
            <unmanaged-short>DWRITE_TEXTURE_ALIASED_1x1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextureType.Cleartype3x1">
            <summary>
            <dd> <p>Specifies an alpha texture for ClearType text rendering, with three bytes per pixel in the horizontal dimension and one byte per pixel in the vertical dimension.</p> </dd>
            </summary>
            <doc-id>dd368129</doc-id>
            <unmanaged>DWRITE_TEXTURE_CLEARTYPE_3x1</unmanaged>
            <unmanaged-short>DWRITE_TEXTURE_CLEARTYPE_3x1</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TrimmingGranularity">
            <summary>
            <p>Specifies  the text granularity used to trim text overflowing the layout box.</p>
            </summary>
            <doc-id>dd368141</doc-id>
            <unmanaged>DWRITE_TRIMMING_GRANULARITY</unmanaged>
            <unmanaged-short>DWRITE_TRIMMING_GRANULARITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TrimmingGranularity.None">
            <summary>
            <dd> <p>No trimming occurs. Text flows beyond the layout width.</p> </dd>
            </summary>
            <doc-id>dd368141</doc-id>
            <unmanaged>DWRITE_TRIMMING_GRANULARITY_NONE</unmanaged>
            <unmanaged-short>DWRITE_TRIMMING_GRANULARITY_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TrimmingGranularity.Character">
            <summary>
            <dd> <p>Trimming occurs at a character cluster boundary.</p> </dd>
            </summary>
            <doc-id>dd368141</doc-id>
            <unmanaged>DWRITE_TRIMMING_GRANULARITY_CHARACTER</unmanaged>
            <unmanaged-short>DWRITE_TRIMMING_GRANULARITY_CHARACTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TrimmingGranularity.Word">
            <summary>
            <dd> <p>Trimming occurs at a word boundary.</p> </dd>
            </summary>
            <doc-id>dd368141</doc-id>
            <unmanaged>DWRITE_TRIMMING_GRANULARITY_WORD</unmanaged>
            <unmanaged-short>DWRITE_TRIMMING_GRANULARITY_WORD</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.VerticalGlyphOrientation">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.VerticalGlyphOrientation"/></strong> enumeration contains values that specify the desired kind of glyph orientation for the text.</p>
            </summary>
            <remarks>
            <p>The client specifies a <strong><see cref = "T:SharpDX.DirectWrite.VerticalGlyphOrientation"/></strong>-typed value to the analyzer as the desired orientation.</p><strong>Note</strong>??This is the client preference, and the constraints of the script determine the final presentation.?
            </remarks>
            <doc-id>jj126266</doc-id>
            <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION</unmanaged>
            <unmanaged-short>DWRITE_VERTICAL_GLYPH_ORIENTATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.VerticalGlyphOrientation.Default">
            <summary>
            <dd> <p>The default glyph orientation. In vertical layout, naturally horizontal scripts (Latin, Thai, Arabic, Devanagari) rotate 90 degrees clockwise, while ideographic scripts (Chinese, Japanese, Korean) remain upright, 0 degrees.</p> </dd>
            </summary>
            <doc-id>jj126266</doc-id>
            <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION_DEFAULT</unmanaged>
            <unmanaged-short>DWRITE_VERTICAL_GLYPH_ORIENTATION_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.VerticalGlyphOrientation.Stacked">
            <summary>
            <dd> <p>Stacked glyph orientation. Ideographic scripts and scripts that permit stacking (Latin, Hebrew) are stacked in vertical reading layout. Connected scripts (Arabic, Syriac, 'Phags-pa, Ogham), which would otherwise look broken if glyphs were kept at 0 degrees, remain connected and rotate.</p> </dd>
            </summary>
            <doc-id>jj126266</doc-id>
            <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION_STACKED</unmanaged>
            <unmanaged-short>DWRITE_VERTICAL_GLYPH_ORIENTATION_STACKED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.WordWrapping">
            <summary>
            <p> Specifies the word wrapping to be used in a particular multiline paragraph.  </p><strong>Note</strong>??<strong>DWRITE_WORD_WRAPPING_EMERGENCY_BREAK</strong>, <strong>DWRITE_WORD_WRAPPING_WHOLE _WORD</strong>, and <strong>DWRITE_WORD_WRAPPING_CHARACTER</strong> are available in Windows?8.1 and later, only.?
            </summary>
            <doc-id>dd368146</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING</unmanaged>
            <unmanaged-short>DWRITE_WORD_WRAPPING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.WordWrapping.Wrap">
            <summary>
            <dd> <p>Indicates that words are broken across lines to avoid text overflowing the layout box.</p> </dd>
            </summary>
            <doc-id>dd368146</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING_WRAP</unmanaged>
            <unmanaged-short>DWRITE_WORD_WRAPPING_WRAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.WordWrapping.NoWrap">
            <summary>
            <dd> <p>Indicates that words are kept within the same line even when it overflows the layout box. This option is often used with scrolling to reveal overflow text.</p> </dd>
            </summary>
            <doc-id>dd368146</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING_NO_WRAP</unmanaged>
            <unmanaged-short>DWRITE_WORD_WRAPPING_NO_WRAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.WordWrapping.EmergencyBreak">
            <summary>
            <dd> <strong>Note</strong>??Windows?8.1 and later only. ? <p>Words are broken across lines to avoid text overflowing the layout box. Emergency wrapping occurs if the word is larger than the maximum width.
            </p> </dd>
            </summary>
            <doc-id>dd368146</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING_EMERGENCY_BREAK</unmanaged>
            <unmanaged-short>DWRITE_WORD_WRAPPING_EMERGENCY_BREAK</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.WordWrapping.WholeWord">
            <summary>
            <dd> <strong>Note</strong>??Windows?8.1 and later only. ? <p> When emergency wrapping, only wrap whole words, never breaking words when the layout width is too small for even a single word.
            </p> </dd>
            </summary>
            <doc-id>dd368146</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING_WHOLE_WORD</unmanaged>
            <unmanaged-short>DWRITE_WORD_WRAPPING_WHOLE_WORD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.WordWrapping.Character">
            <summary>
            <dd> <strong>Note</strong>??Windows?8.1 and later only. ? <p>Wrap between any valid character clusters.</p> </dd>
            </summary>
            <doc-id>dd368146</doc-id>
            <unmanaged>DWRITE_WORD_WRAPPING_CHARACTER</unmanaged>
            <unmanaged-short>DWRITE_WORD_WRAPPING_CHARACTER</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.DWrite">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:SharpDX.DirectWrite.DWrite.CreateFactory(SharpDX.DirectWrite.FactoryType,System.Guid,SharpDX.ComObject)">
            <summary>
            <p>Creates a DirectWrite factory object that is used for subsequent creation of individual DirectWrite objects.</p>
            </summary>
            <param name = "factoryType"><dd>  <p>A value that specifies whether the factory object will be shared or isolated.</p> </dd></param>
            <param name = "iid"><dd>  <p>A <see cref = "T:System.Guid"/> value that identifies the DirectWrite factory interface, such as __uuidof(<strong><see cref = "T:SharpDX.DirectWrite.Factory"/></strong>).</p> </dd></param>
            <param name = "factory"><dd>  <p>An address of a reference to the newly created DirectWrite factory object.</p> </dd></param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function creates a DirectWrite factory object that is used for subsequent creation of individual DirectWrite objects. DirectWrite factory contains internal state data such as font loader registration and cached font data. In most cases it is recommended you use the shared factory object, because it allows multiple components that use DirectWrite to share internal DirectWrite state data, and thereby reduce memory usage. However, there are cases when it is desirable to reduce the impact of a component, such as a plug-in from an untrusted source, on the rest of the process, by sandboxing and isolating it from the rest of the process components. In such cases, it is recommended you use an isolated factory for the sandboxed component.</p><p>The following example shows how to create a shared DirectWrite factory.</p><pre> if (SUCCEEDED(hr))
            { hr = DWriteCreateFactory( DWRITE_FACTORY_TYPE_SHARED, __uuidof(<see cref = "T:SharpDX.DirectWrite.Factory"/>), reinterpret_cast&lt;<see cref = "T:SharpDX.IUnknown"/>**&gt;(&amp;pDWriteFactory_) );
            } </pre>
            </remarks>
            <doc-id>dd368040</doc-id>
            <unmanaged>HRESULT DWriteCreateFactory([In] DWRITE_FACTORY_TYPE factoryType,[In] const GUID&amp; iid,[Out, Fast] IUnknown** factory)</unmanaged>
            <unmanaged-short>DWriteCreateFactory</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.AsyncResult.WaitHandle">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetWaitHandle</unmanaged>
            <unmanaged-short>GetWaitHandle</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.AsyncResult.Result">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetResult</unmanaged>
            <unmanaged-short>GetResult</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.AsyncResult.GetWaitHandle">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>void* IDWriteAsyncResult::GetWaitHandle()</unmanaged>
            <unmanaged-short>IDWriteAsyncResult::GetWaitHandle</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.AsyncResult.GetResult">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteAsyncResult::GetResult()</unmanaged>
            <unmanaged-short>IDWriteAsyncResult::GetResult</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.BitmapRenderTarget1.TextAntialiasMode">
            <summary>
            <p>Gets or sets the current text antialiasing mode of the bitmap render target.</p>
            </summary>
            <doc-id>hh780399</doc-id>
            <unmanaged>GetTextAntialiasMode / SetTextAntialiasMode</unmanaged>
            <unmanaged-short>GetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget1.GetTextAntialiasMode">
            <summary>
            <p>Gets the current text antialiasing mode of the bitmap render target.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.TextAntialiasMode"/></strong>-typed value that specifies the antialiasing mode.</p></returns>
            <doc-id>hh780399</doc-id>
            <unmanaged>DWRITE_TEXT_ANTIALIAS_MODE IDWriteBitmapRenderTarget1::GetTextAntialiasMode()</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget1::GetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.BitmapRenderTarget1.SetTextAntialiasMode(SharpDX.DirectWrite.TextAntialiasMode)">
            <summary>
            <p>Sets the current text antialiasing mode of the bitmap render target.</p>
            </summary>
            <param name = "antialiasMode"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.TextAntialiasMode"/></strong>-typed value that specifies the antialiasing mode.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> if successful, or E_INVALIDARG if the argument is not valid.</p></returns>
            <remarks>
            <p>The antialiasing mode of a newly-created bitmap render target defaults to  <strong>DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE</strong>. An app can change the antialiasing mode by calling <strong>SetTextAntialiasMode</strong>. For example, an app might specify <strong>DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE</strong> for grayscale antialiasing when it renders text onto a transparent bitmap.</p>
            </remarks>
            <doc-id>hh780400</doc-id>
            <unmanaged>HRESULT IDWriteBitmapRenderTarget1::SetTextAntialiasMode([In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode)</unmanaged>
            <unmanaged-short>IDWriteBitmapRenderTarget1::SetTextAntialiasMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Factory3.SystemFontSet">
            <summary>
            <p>Retrieves the list of system fonts.</p>
            </summary>
            <doc-id>dn890764</doc-id>
            <unmanaged>GetSystemFontSet</unmanaged>
            <unmanaged-short>GetSystemFontSet</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Factory3.FontDownloadQueue">
            <summary>
            <p>Gets the font download queue associated with this factory object.</p>
            </summary>
            <doc-id>dn890762</doc-id>
            <unmanaged>GetFontDownloadQueue</unmanaged>
            <unmanaged-short>GetFontDownloadQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.CreateGlyphRunAnalysis(SharpDX.DirectWrite.GlyphRun,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.DirectWrite.RenderingMode1,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.GridFitMode,SharpDX.DirectWrite.TextAntialiasMode,System.Single,System.Single,SharpDX.DirectWrite.GlyphRunAnalysis@)">
            <summary>
            <p> Creates a glyph-run-analysis object that encapsulates info that DirectWrite uses to render a glyph run. </p>
            </summary>
            <param name = "glyphRun">No documentation.</param>
            <param name = "transform">No documentation.</param>
            <param name = "renderingMode">No documentation.</param>
            <param name = "measuringMode">No documentation.</param>
            <param name = "gridFitMode">No documentation.</param>
            <param name = "antialiasMode">No documentation.</param>
            <param name = "baselineOriginX">No documentation.</param>
            <param name = "baselineOriginY">No documentation.</param>
            <param name = "glyphRunAnalysis">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890760</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::CreateGlyphRunAnalysis([In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_MATRIX* transform,[In] DWRITE_RENDERING_MODE1 renderingMode,[In] DWRITE_MEASURING_MODE measuringMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[In] DWRITE_TEXT_ANTIALIAS_MODE antialiasMode,[In] float baselineOriginX,[In] float baselineOriginY,[Out] IDWriteGlyphRunAnalysis** glyphRunAnalysis)</unmanaged>
            <unmanaged-short>IDWriteFactory3::CreateGlyphRunAnalysis</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.CreateCustomRenderingParams(System.Single,System.Single,System.Single,System.Single,SharpDX.DirectWrite.PixelGeometry,SharpDX.DirectWrite.RenderingMode1,SharpDX.DirectWrite.GridFitMode,SharpDX.DirectWrite.RenderingParams3@)">
            <summary>
            <p>Creates a rendering parameters object with the specified properties.</p>
            </summary>
            <param name = "gamma"><dd>  <p>The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</p> </dd></param>
            <param name = "enhancedContrast"><dd>  <p> The amount of contrast enhancement, zero or greater. </p> </dd></param>
            <param name = "grayscaleEnhancedContrast"><dd>  <p>The amount of contrast enhancement to use for grayscale antialiasing, zero or greater.</p> </dd></param>
            <param name = "clearTypeLevel"><dd>  <p>The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</p> </dd></param>
            <param name = "pixelGeometry"><dd>  <p> A <strong><see cref = "T:SharpDX.DirectWrite.PixelGeometry"/></strong>-typed value that specifies the internal structure of a device pixel (that is, the physical arrangement of red, green, and blue color components) that is assumed for purposes of rendering text. </p> </dd></param>
            <param name = "renderingMode"><dd>  <p> A <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode1"/></strong>-typed value that specifies the method (for example, ClearType natural quality) for rendering glyphs. In most cases, specify <strong>DWRITE_RENDERING_MODE1_DEFAULT</strong> to automatically use an appropriate mode. </p> </dd></param>
            <param name = "gridFitMode"><dd>  <p> A <strong><see cref = "T:SharpDX.DirectWrite.GridFitMode"/></strong>-typed value that specifies how to grid-fit glyph outlines. In most cases, specify <strong>DWRITE_GRID_FIT_DEFAULT</strong> to automatically choose an appropriate mode. </p> </dd></param>
            <param name = "renderingParams"><dd>  <p> A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.RenderingParams3"/></strong> interface for the newly created rendering parameters object, or <strong><c>null</c></strong> in case of failure. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890754</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::CreateCustomRenderingParams([In] float gamma,[In] float enhancedContrast,[In] float grayscaleEnhancedContrast,[In] float clearTypeLevel,[In] DWRITE_PIXEL_GEOMETRY pixelGeometry,[In] DWRITE_RENDERING_MODE1 renderingMode,[In] DWRITE_GRID_FIT_MODE gridFitMode,[Out] IDWriteRenderingParams3** renderingParams)</unmanaged>
            <unmanaged-short>IDWriteFactory3::CreateCustomRenderingParams</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.CreateFontFaceReference(SharpDX.DirectWrite.FontFile,System.Int32,SharpDX.DirectWrite.FontSimulations,SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Creates a reference to a font given a full path. </p>
            </summary>
            <param name = "fontFile"><dd>  <p>Absolute file path. Subsequent operations on the constructed object may fail       if the user provided filePath doesn't correspond to a valid file on the disk.</p> </dd></param>
            <param name = "faceIndex"><dd>  <p>The zero based index of a font face in cases when the font files contain a collection of font faces.       If the font files contain a single face, this value should be zero.</p> </dd></param>
            <param name = "fontSimulations"><dd>  <p>Font face simulation flags for algorithmic emboldening and italicization.</p> </dd></param>
            <param name = "fontFaceReference"><dd>  <p>Contains newly created font face reference object, or nullptr in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890756</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::CreateFontFaceReference([In] IDWriteFontFile* fontFile,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontSimulations,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFactory3::CreateFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.CreateFontFaceReference(System.String,System.Nullable{System.Int64},System.Int32,SharpDX.DirectWrite.FontSimulations,SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Creates a reference to a font given a full path. </p>
            </summary>
            <param name = "filePath"><dd>  <p>Absolute file path. Subsequent operations on the constructed object may fail       if the user provided filePath doesn't correspond to a valid file on the disk.</p> </dd></param>
            <param name = "lastWriteTime"><dd>  <p>Last modified time of the input file path. If the parameter is omitted,       the function will access the font file to obtain its last write time, so the clients are encouraged to specify this value       to avoid extra disk access. Subsequent operations on the constructed object may fail       if the user provided lastWriteTime doesn't match the file on the disk.</p> </dd></param>
            <param name = "faceIndex"><dd>  <p>The zero based index of a font face in cases when the font files contain a collection of font faces.       If the font files contain a single face, this value should be zero.</p> </dd></param>
            <param name = "fontSimulations"><dd>  <p>Font face simulation flags for algorithmic emboldening and italicization.</p> </dd></param>
            <param name = "fontFaceReference"><dd>  <p>Contains newly created font face reference object, or nullptr in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890756</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::CreateFontFaceReference([In] const wchar_t* filePath,[In, Optional] const FILETIME* lastWriteTime,[In] unsigned int faceIndex,[In] DWRITE_FONT_SIMULATIONS fontSimulations,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFactory3::CreateFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.GetSystemFontSet(SharpDX.DirectWrite.FontSet@)">
            <summary>
            <p>Retrieves the list of system fonts.</p>
            </summary>
            <param name = "fontSet"><dd>  <p>Holds the newly created font set object, or <c>null</c> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890764</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::GetSystemFontSet([Out] IDWriteFontSet** fontSet)</unmanaged>
            <unmanaged-short>IDWriteFactory3::GetSystemFontSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.CreateFontSetBuilder(SharpDX.DirectWrite.FontSetBuilder@)">
            <summary>
            <p>Creates an empty font set builder to add font face references      and create a custom font set. </p>
            </summary>
            <param name = "fontSetBuilder"><dd>  <p>Holds the newly created font set builder object, or <c>null</c> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890759</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::CreateFontSetBuilder([Out] IDWriteFontSetBuilder** fontSetBuilder)</unmanaged>
            <unmanaged-short>IDWriteFactory3::CreateFontSetBuilder</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.CreateFontCollectionFromFontSet(SharpDX.DirectWrite.FontSet,SharpDX.DirectWrite.FontCollection1@)">
            <summary>
            <p>Create a weight/width/slope tree from a set of fonts.</p>
            </summary>
            <param name = "fontSet"><dd>  <p>A set of fonts to use to build the collection.</p> </dd></param>
            <param name = "fontCollection"><dd>  <p>Holds the newly created font collection object, or <c>null</c> in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890755</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::CreateFontCollectionFromFontSet([In] IDWriteFontSet* fontSet,[Out] IDWriteFontCollection1** fontCollection)</unmanaged>
            <unmanaged-short>IDWriteFactory3::CreateFontCollectionFromFontSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.GetSystemFontCollection(SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.FontCollection1@,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Retrieves a weight/width/slope tree of system fonts.</p>
            </summary>
            <param name = "includeDownloadableFonts"><dd>  <p>If this parameter is TRUE, the function performs an immediate check for changes        to the set of system fonts. If this parameter is <see cref = "F:SharpDX.Result.False"/>, the function will still detect changes if the font       cache service is running, but there may be some latency. For example, an application might specify TRUE if       it has just installed a font and wants to be sure the font collection contains that font.</p> </dd></param>
            <param name = "fontCollection"><dd>  <p>Holds the newly created font collection object, or <c>null</c> in case of failure.</p> </dd></param>
            <param name = "checkForUpdates"><dd>  <p>If this parameter is TRUE, the function performs an immediate check for changes        to the set of system fonts. If this parameter is <see cref = "F:SharpDX.Result.False"/>, the function will still detect changes if the font       cache service is running, but there may be some latency. For example, an application might specify TRUE if       it has just installed a font and wants to be sure the font collection contains that font.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890761</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::GetSystemFontCollection([In] BOOL includeDownloadableFonts,[Out] IDWriteFontCollection1** fontCollection,[In] BOOL checkForUpdates)</unmanaged>
            <unmanaged-short>IDWriteFactory3::GetSystemFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory3.GetFontDownloadQueue(SharpDX.DirectWrite.FontDownloadQueue@)">
            <summary>
            <p>Gets the font download queue associated with this factory object.</p>
            </summary>
            <param name = "fontDownloadQueue"><dd>  <p>Receives a reference to the font download queue interface.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890762</doc-id>
            <unmanaged>HRESULT IDWriteFactory3::GetFontDownloadQueue([Out] IDWriteFontDownloadQueue** fontDownloadQueue)</unmanaged>
            <unmanaged-short>IDWriteFactory3::GetFontDownloadQueue</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory4.TranslateColorGlyphRun(SharpDX.Mathematics.Interop.RawVector2,SharpDX.DirectWrite.GlyphRun,SharpDX.DirectWrite.GlyphRunDescription,SharpDX.Direct2D1.GlyphImageFormatS,SharpDX.Direct2D1.MeasuringMode,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},System.Int32,SharpDX.DirectWrite.ColorGlyphRunEnumerator1@)">
            <summary>
            <p>Translates a glyph run to a sequence of color glyph runs, which can be rendered to produce a color representation of the original "base" run.</p>
            </summary>
            <param name = "baselineOrigin"><dd>  <p>Horizontal and vertical origin of the base glyph run in pre-transform coordinates.</p> </dd></param>
            <param name = "glyphRun"><dd>  <p>Pointer to the original "base" glyph run.</p> </dd></param>
            <param name = "glyphRunDescription"><dd>  <p>Optional glyph run description.</p> </dd></param>
            <param name = "desiredGlyphImageFormats"><dd>  <p>Which data formats the runs should be split into.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>Measuring mode, needed to compute the origins of each glyph.</p> </dd></param>
            <param name = "worldAndDpiTransform"><dd>  <p>Matrix converting from the client's coordinate space to device coordinates (pixels), i.e., the world transform multiplied by any DPI scaling.</p> </dd></param>
            <param name = "colorPaletteIndex"><dd>  <p>Zero-based index of the color palette to use. Valid indices are less than the number of palettes in the font, as returned by <strong>IDWriteFontFace2::GetColorPaletteCount</strong>.</p> </dd></param>
            <param name = "colorLayers"><dd>  <p>If the function succeeds, receives a reference to an enumerator object that can be used to obtain the color glyph runs. If the base run has no color glyphs, then the output reference is <c>null</c> and the method returns DWRITE_E_NOCOLOR.</p> </dd></param>
            <returns><p>Returns DWRITE_E_NOCOLOR if the font has no color information, the glyph run does not contain any color glyphs, or the specified color palette index is out of range. In this case, the client should render the original glyph  run. Otherwise, returns a standard <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p>Calling <strong>IDWriteFactory2::TranslateColorGlyphRun</strong> is equivalent  to calling <strong>IDWriteFactory4::TranslateColorGlyph</strong> run with the following formats specified: DWRITE_GLYPH_IMAGE_FORMATS_TRUETYPE|DWRITE_GLYPH_IMAGE_FORMATS_CFF|DWRITE_GLYPH_IMAGE_FORMATS_COLR.</p>
            </remarks>
            <doc-id>mt761992</doc-id>
            <unmanaged>HRESULT IDWriteFactory4::TranslateColorGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] DWRITE_GLYPH_IMAGE_FORMATS desiredGlyphImageFormats,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] const DWRITE_MATRIX* worldAndDpiTransform,[In] unsigned int colorPaletteIndex,[Out] IDWriteColorGlyphRunEnumerator1** colorLayers)</unmanaged>
            <unmanaged-short>IDWriteFactory4::TranslateColorGlyphRun</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory4.ComputeGlyphOrigins(SharpDX.DirectWrite.GlyphRun,SharpDX.Mathematics.Interop.RawVector2,SharpDX.Mathematics.Interop.RawVector2[])">
            <summary>
            <p>Converts glyph run placements to glyph origins.</p>
            </summary>
            <param name = "glyphRun"><dd>  <p>Structure containing the properties of the glyph run.</p> </dd></param>
            <param name = "baselineOrigin"><dd>  <p>The position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
            <param name = "glyphOrigins"><dd>  <p>On return contains the glyph origins for the glyphrun.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <see cref = "F:SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p>The transform and DPI have no effect on the origin scaling. They are solely used to compute glyph advances when not supplied and align glyphs in pixel aligned measuring modes.</p>
            </remarks>
            <doc-id>mt725316</doc-id>
            <unmanaged>HRESULT IDWriteFactory4::ComputeGlyphOrigins([In] const DWRITE_GLYPH_RUN* glyphRun,[In] D2D_POINT_2F baselineOrigin,[Out, Buffer] D2D_POINT_2F* glyphOrigins)</unmanaged>
            <unmanaged-short>IDWriteFactory4::ComputeGlyphOrigins</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory4.ComputeGlyphOrigins(SharpDX.DirectWrite.GlyphRun,SharpDX.Direct2D1.MeasuringMode,SharpDX.Mathematics.Interop.RawVector2,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawVector2[])">
            <summary>
            <p>Converts glyph run placements to glyph origins.</p>
            </summary>
            <param name = "glyphRun"><dd>  <p>Structure containing the properties of the glyph run.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>The measuring method for glyphs in the run, used with the other properties to determine the rendering mode.</p> </dd></param>
            <param name = "baselineOrigin"><dd>  <p>The position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</p> </dd></param>
            <param name = "worldAndDpiTransform"><dd>  <p>World transform multiplied by any DPI scaling.  This is needed to compute glyph positions if the run contains color glyphs and the measuring mode is not <strong>DWRITE_MEASURING_MODE_NATURAL</strong>.  If this parameter is <c>null</c>, and identity transform is assumed. </p> </dd></param>
            <param name = "glyphOrigins"><dd>  <p>On return contains the glyph origins for the glyphrun.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <see cref = "F:SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p>The transform and DPI have no effect on the origin scaling. They are solely used to compute glyph advances when not supplied and align glyphs in pixel aligned measuring modes.</p>
            </remarks>
            <doc-id>mt725316</doc-id>
            <unmanaged>HRESULT IDWriteFactory4::ComputeGlyphOrigins([In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[In] D2D_POINT_2F baselineOrigin,[In, Optional] const DWRITE_MATRIX* worldAndDpiTransform,[Out, Buffer] D2D_POINT_2F* glyphOrigins)</unmanaged>
            <unmanaged-short>IDWriteFactory4::ComputeGlyphOrigins</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory5.CreateFontSetBuilder(SharpDX.DirectWrite.FontSetBuilder1@)">
            <summary>
            No documentation.
            </summary>
            <param name = "fontSetBuilder">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteFactory5::CreateFontSetBuilder([Out] IDWriteFontSetBuilder1** fontSetBuilder)</unmanaged>
            <unmanaged-short>IDWriteFactory5::CreateFontSetBuilder</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory5.CreateInMemoryFontFileLoader(SharpDX.DirectWrite.InMemoryFontFileLoader@)">
            <summary>
            <p> </p><p>This topic describes various ways in which you can use custom fonts in your app.</p><p> </p><ul> <li>Introduction?</li> <li>Summary</li> <li>Key</li> <li>Fonts</li> <li>Font</li> <li>Common<ul> <li>Creating</li> <li>Creating</li> <li>Creating</li> <li>Creating</li> </ul> </li> <li>Advanced<ul> <li>Combining</li> <li>Using</li> <li>Using</li> <li>Supporting</li> </ul> </li> </ul>
            </summary>
            <param name = "newLoader">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt492448</doc-id>
            <unmanaged>HRESULT IDWriteFactory5::CreateInMemoryFontFileLoader([Out] IDWriteInMemoryFontFileLoader** newLoader)</unmanaged>
            <unmanaged-short>IDWriteFactory5::CreateInMemoryFontFileLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory5.CreateHttpFontFileLoader(System.String,System.String,SharpDX.DirectWrite.RemoteFontFileLoader@)">
            <summary>
            No documentation.
            </summary>
            <param name = "referrerUrl">No documentation.</param>
            <param name = "extraHeaders">No documentation.</param>
            <param name = "newLoader">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteFactory5::CreateHttpFontFileLoader([In, Optional] const wchar_t* referrerUrl,[In, Optional] const wchar_t* extraHeaders,[Out] IDWriteRemoteFontFileLoader** newLoader)</unmanaged>
            <unmanaged-short>IDWriteFactory5::CreateHttpFontFileLoader</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory5.AnalyzeContainerType(System.IntPtr,System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "fileData">No documentation.</param>
            <param name = "fileDataSize">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>DWRITE_CONTAINER_TYPE IDWriteFactory5::AnalyzeContainerType([In, Buffer] const void* fileData,[In] unsigned int fileDataSize)</unmanaged>
            <unmanaged-short>IDWriteFactory5::AnalyzeContainerType</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Factory5.UnpackFontFile(SharpDX.DirectWrite.ContainerType,System.IntPtr,System.Int32,SharpDX.DirectWrite.FontFileStream@)">
            <summary>
            <p> </p><p>This topic describes various ways in which you can use custom fonts in your app.</p><p> </p><ul> <li>Introduction?</li> <li>Summary</li> <li>Key</li> <li>Fonts</li> <li>Font</li> <li>Common<ul> <li>Creating</li> <li>Creating</li> <li>Creating</li> <li>Creating</li> </ul> </li> <li>Advanced<ul> <li>Combining</li> <li>Using</li> <li>Using</li> <li>Supporting</li> </ul> </li> </ul>
            </summary>
            <param name = "containerType">No documentation.</param>
            <param name = "fileData">No documentation.</param>
            <param name = "fileDataSize">No documentation.</param>
            <param name = "unpackedFontStream">No documentation.</param>
            <returns>No documentation.</returns>
            <doc-id>mt492448</doc-id>
            <unmanaged>HRESULT IDWriteFactory5::UnpackFontFile([In] DWRITE_CONTAINER_TYPE containerType,[In, Buffer] const void* fileData,[In] unsigned int fileDataSize,[Out] IDWriteFontFileStream** unpackedFontStream)</unmanaged>
            <unmanaged-short>IDWriteFactory5::UnpackFontFile</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.FontFamily">
            <summary>
            <p> Gets the font family to which the specified font belongs. </p>
            </summary>
            <doc-id>dd371143</doc-id>
            <unmanaged>GetFontFamily</unmanaged>
            <unmanaged-short>GetFontFamily</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.Weight">
            <summary>
            <p> Gets the weight, or stroke thickness, of the specified font. </p>
            </summary>
            <doc-id>dd371162</doc-id>
            <unmanaged>GetWeight</unmanaged>
            <unmanaged-short>GetWeight</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.Stretch">
            <summary>
            <p> Gets the stretch, or width, of the specified font. </p>
            </summary>
            <doc-id>dd371156</doc-id>
            <unmanaged>GetStretch</unmanaged>
            <unmanaged-short>GetStretch</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.Style">
            <summary>
            <p> Gets the style, or slope, of the specified font. </p>
            </summary>
            <doc-id>dd371159</doc-id>
            <unmanaged>GetStyle</unmanaged>
            <unmanaged-short>GetStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.IsSymbolFont">
            <summary>
            <p> Determines whether the font is a symbol font. </p>
            </summary>
            <doc-id>dd371168</doc-id>
            <unmanaged>IsSymbolFont</unmanaged>
            <unmanaged-short>IsSymbolFont</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.FaceNames">
            <summary>
            <p> Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. </p>
            </summary>
            <doc-id>dd371140</doc-id>
            <unmanaged>GetFaceNames</unmanaged>
            <unmanaged-short>GetFaceNames</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.Simulations">
            <summary>
            <p> Gets a value that indicates what simulations are applied to the specified font. </p>
            </summary>
            <doc-id>dd371153</doc-id>
            <unmanaged>GetSimulations</unmanaged>
            <unmanaged-short>GetSimulations</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font.Metrics">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <doc-id>dd371149</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetFontFamily(SharpDX.DirectWrite.FontFamily@)">
            <summary>
            <p> Gets the font family to which the specified font belongs. </p>
            </summary>
            <param name = "fontFamily"><dd>  <p>When this method returns, contains an address of a reference to the font family object to which the specified font belongs.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371143</doc-id>
            <unmanaged>HRESULT IDWriteFont::GetFontFamily([Out] IDWriteFontFamily** fontFamily)</unmanaged>
            <unmanaged-short>IDWriteFont::GetFontFamily</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetWeight">
            <summary>
            <p> Gets the weight, or stroke thickness, of the specified font. </p>
            </summary>
            <returns><p>A value that indicates the weight for the specified font.</p></returns>
            <doc-id>dd371162</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT IDWriteFont::GetWeight()</unmanaged>
            <unmanaged-short>IDWriteFont::GetWeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetStretch">
            <summary>
            <p> Gets the stretch, or width, of the specified font. </p>
            </summary>
            <returns><p>A value that indicates the type of stretch, or width, applied to the specified font.</p></returns>
            <doc-id>dd371156</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH IDWriteFont::GetStretch()</unmanaged>
            <unmanaged-short>IDWriteFont::GetStretch</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetStyle">
            <summary>
            <p> Gets the style, or slope, of the specified font. </p>
            </summary>
            <returns><p>A value that indicates the type of style, or slope, of the specified font.</p></returns>
            <doc-id>dd371159</doc-id>
            <unmanaged>DWRITE_FONT_STYLE IDWriteFont::GetStyle()</unmanaged>
            <unmanaged-short>IDWriteFont::GetStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.IsSymbolFont_">
            <summary>
            <p> Determines whether the font is a symbol font. </p>
            </summary>
            <returns><p><strong>TRUE</strong> if the font is a symbol font; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <doc-id>dd371168</doc-id>
            <unmanaged>BOOL IDWriteFont::IsSymbolFont()</unmanaged>
            <unmanaged-short>IDWriteFont::IsSymbolFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetFaceNames(SharpDX.DirectWrite.LocalizedStrings@)">
            <summary>
            <p> Gets a localized strings collection containing the face names for the font (such as Regular or Bold), indexed by locale name. </p>
            </summary>
            <param name = "names"><dd>  <p>When this method returns, contains an address to a  reference to the newly created localized strings object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371140</doc-id>
            <unmanaged>HRESULT IDWriteFont::GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
            <unmanaged-short>IDWriteFont::GetFaceNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetInformationalStrings(SharpDX.DirectWrite.InformationalStringId,SharpDX.DirectWrite.LocalizedStrings@)">
            <summary>
            <p> Gets a localized strings collection containing the specified informational strings, indexed by locale name. </p>
            </summary>
            <param name = "informationalStringID"><dd>  <p>A value that identifies the  informational string to get. For example, <strong>DWRITE_INFORMATIONAL_STRING_DESCRIPTION</strong> specifies a string that contains a description of the font. </p> </dd></param>
            <param name = "informationalStrings"><dd>  <p>When this method returns, contains an address of a reference to the newly created localized strings object.</p> </dd></param>
            <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the font contains the specified string ID; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <remarks>
            <p> If the font does not contain the string specified by <em>informationalStringID</em>, the return value is <strong><see cref = "F:SharpDX.Result.Ok"/></strong> but  <em>informationalStrings</em> receives a <strong><c>null</c></strong> reference and <em>exists</em> receives the value <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p>
            </remarks>
            <doc-id>dd371147</doc-id>
            <unmanaged>HRESULT IDWriteFont::GetInformationalStrings([In] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,[Out, Optional] IDWriteLocalizedStrings** informationalStrings,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFont::GetInformationalStrings</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetSimulations">
            <summary>
            <p> Gets a value that indicates what simulations are applied to the specified font. </p>
            </summary>
            <returns><p> A value that indicates one or more of the  types of simulations (none, bold, or oblique)  applied to the specified font.</p></returns>
            <doc-id>dd371153</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFont::GetSimulations()</unmanaged>
            <unmanaged-short>IDWriteFont::GetSimulations</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.GetMetrics(SharpDX.DirectWrite.FontMetrics@)">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <param name = "fontMetrics"><dd>  <p>When this method returns, contains a structure that has font metrics for the current font face. The metrics returned by this function are in font design units.</p> </dd></param>
            <doc-id>dd371149</doc-id>
            <unmanaged>void IDWriteFont::GetMetrics([Out] DWRITE_FONT_METRICS* fontMetrics)</unmanaged>
            <unmanaged-short>IDWriteFont::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.HasCharacter(System.Int32)">
            <summary>
            <p> Determines whether the font supports a specified character. </p>
            </summary>
            <param name = "unicodeValue"><dd>  <p>A Unicode (UCS-4) character value for the method to inspect.</p> </dd></param>
            <returns><dd>  <p>When this method returns, <strong>TRUE</strong> if the font supports the specified character; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <doc-id>dd371165</doc-id>
            <unmanaged>HRESULT IDWriteFont::HasCharacter([In] unsigned int unicodeValue,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFont::HasCharacter</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font.CreateFontFace(SharpDX.DirectWrite.FontFace)">
            <summary>
            <p> Creates a font face object for the font. </p>
            </summary>
            <param name = "fontFace"><dd>  <p>When this method returns, contains an address of a reference to the newly created font face object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371137</doc-id>
            <unmanaged>HRESULT IDWriteFont::CreateFontFace([Out, Fast] IDWriteFontFace** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFont::CreateFontFace</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font1.Metrics">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <doc-id>hh780405</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font1.Panose">
            <summary>
            <p>Gets the PANOSE values from the font and is used for font selection and matching.</p>
            </summary>
            <remarks>
            <p>If the font has no PANOSE values, they are set to 'any' (0) and DirectWrite doesn't simulate those values.</p>
            </remarks>
            <doc-id>hh780406</doc-id>
            <unmanaged>GetPanose</unmanaged>
            <unmanaged-short>GetPanose</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font1.IsMonospacedFont">
            <summary>
            <p>Determines if the font is monospaced, that is, the characters are the same fixed-pitch width (non-proportional).</p>
            </summary>
            <doc-id>hh780408</doc-id>
            <unmanaged>IsMonospacedFont</unmanaged>
            <unmanaged-short>IsMonospacedFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font1.GetMetrics(SharpDX.DirectWrite.FontMetrics1@)">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <param name = "fontMetrics"><dd>  <p> A filled  <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics1"/></strong> structure that has font metrics for the current font face. The metrics returned by this method are in font design units.</p> </dd></param>
            <doc-id>hh780405</doc-id>
            <unmanaged>void IDWriteFont1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
            <unmanaged-short>IDWriteFont1::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font1.GetPanose(SharpDX.DirectWrite.Panose@)">
            <summary>
            <p>Gets the PANOSE values from the font and is used for font selection and matching.</p>
            </summary>
            <param name = "anoseRef"><dd>  <p>A reference to the <strong><see cref = "T:SharpDX.DirectWrite.Panose"/></strong> structure to fill in.</p> </dd></param>
            <remarks>
            <p>If the font has no PANOSE values, they are set to 'any' (0) and DirectWrite doesn't simulate those values.</p>
            </remarks>
            <doc-id>hh780406</doc-id>
            <unmanaged>void IDWriteFont1::GetPanose([Out] DWRITE_PANOSE* panose)</unmanaged>
            <unmanaged-short>IDWriteFont1::GetPanose</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font1.GetUnicodeRanges(System.Int32,SharpDX.DirectWrite.UnicodeRange[],System.Int32@)">
            <summary>
            <p>Retrieves the list of character ranges supported by a font.</p>
            </summary>
            <param name = "maxRangeCount"><dd>  <p>The maximum number of character ranges passed in from the client.</p> </dd></param>
            <param name = "unicodeRanges"><dd>  <p>An array of <strong><see cref = "T:SharpDX.DirectWrite.UnicodeRange"/></strong> structures that are filled with the character ranges.</p> </dd></param>
            <param name = "actualRangeCount"><dd>  <p>A reference to the actual number of character ranges, regardless of the maximum count.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The method executed successfully.</p> </td></tr> <tr><td> <dl> <dt>E_NOT_SUFFICIENT_BUFFER</dt> </dl> </td><td> <p>The buffer is too small.  The <em>actualRangeCount</em> was more than the <em>maxRangeCount</em>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The list of character ranges supported by a font, is useful for scenarios like character picking, glyph display, and efficient font selection lookup. GetUnicodeRanges is similar to GDI's GetFontUnicodeRanges, except that it returns the full Unicode range, not just 16-bit UCS-2.</p><p>These ranges are from the cmap, not the OS/2::ulCodePageRange1.</p><p>If this method is unavailable, you can use the <strong>IDWriteFontFace::GetGlyphIndices</strong> method to check for missing glyphs.  The method returns the 0 index for glyphs that aren't present in the font.</p><p> The <strong>IDWriteFont::HasCharacter</strong> method is often simpler in cases where you need to check a single character or a series of single characters in succession, such as in font fallback.</p>
            </remarks>
            <doc-id>hh780407</doc-id>
            <unmanaged>HRESULT IDWriteFont1::GetUnicodeRanges([In] unsigned int maxRangeCount,[Out, Buffer, Optional] DWRITE_UNICODE_RANGE* unicodeRanges,[Out] unsigned int* actualRangeCount)</unmanaged>
            <unmanaged-short>IDWriteFont1::GetUnicodeRanges</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font1.IsMonospacedFont_">
            <summary>
            <p>Determines if the font is monospaced, that is, the characters are the same fixed-pitch width (non-proportional).</p>
            </summary>
            <returns><p>Returns true if the font is monospaced, else it returns false.</p></returns>
            <doc-id>hh780408</doc-id>
            <unmanaged>BOOL IDWriteFont1::IsMonospacedFont()</unmanaged>
            <unmanaged-short>IDWriteFont1::IsMonospacedFont</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font2.IsColorFont">
            <summary>
            <p>Enables determining if a color rendering path is potentially necessary.</p>
            </summary>
            <doc-id>dn280453</doc-id>
            <unmanaged>IsColorFont</unmanaged>
            <unmanaged-short>IsColorFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font2.IsColorFont_">
            <summary>
            <p>Enables determining if a color rendering path is potentially necessary.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if the font has color information (COLR and CPAL tables); otherwise <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <doc-id>dn280453</doc-id>
            <unmanaged>BOOL IDWriteFont2::IsColorFont()</unmanaged>
            <unmanaged-short>IDWriteFont2::IsColorFont</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font3.FontFaceReference">
            <summary>
            <p>Gets a font face reference that identifies this font.</p>
            </summary>
            <doc-id>dn890771</doc-id>
            <unmanaged>GetFontFaceReference</unmanaged>
            <unmanaged-short>GetFontFaceReference</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Font3.Locality">
            <summary>
            <p>Gets the current locality of the font.</p>
            </summary>
            <remarks>
            <p>For fully local files, the result will always  be DWRITE_LOCALITY_LOCAL. A downloadable file may be any of the states, and this function may change between calls.</p>
            </remarks>
            <doc-id>mt725319</doc-id>
            <unmanaged>GetLocality</unmanaged>
            <unmanaged-short>GetLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font3.CreateFontFace(SharpDX.DirectWrite.FontFace3@)">
            <summary>
            <p>Creates a font face object for the font.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.FontFace3"/></strong> interface for the newly created font face object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p><p>This method returns <strong>DWRITE_E_REMOTEFONT</strong> if it could not construct a remote font.</p></returns>
            <doc-id>dn890767</doc-id>
            <unmanaged>HRESULT IDWriteFont3::CreateFontFace([Out] IDWriteFontFace3** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFont3::CreateFontFace</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font3.Equals(SharpDX.DirectWrite.Font)">
            <summary>
            <p>Compares two instances of font references for equality.</p>
            </summary>
            <param name = "font"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> interface for the other font instance to compare to this font instance.</p> </dd></param>
            <returns><p>Returns whether the two instances of font references are equal. Returns <strong>TRUE</strong> if the two instances are equal; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p></returns>
            <doc-id>dn890769</doc-id>
            <unmanaged>BOOL IDWriteFont3::Equals([In] IDWriteFont* font)</unmanaged>
            <unmanaged-short>IDWriteFont3::Equals</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font3.GetFontFaceReference(SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Gets a font face reference that identifies this font.</p>
            </summary>
            <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn890771</doc-id>
            <unmanaged>HRESULT IDWriteFont3::GetFontFaceReference([Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFont3::GetFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font3.HasCharacter(System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "unicodeValue">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>BOOL IDWriteFont3::HasCharacter([In] unsigned int unicodeValue)</unmanaged>
            <unmanaged-short>IDWriteFont3::HasCharacter</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.Font3.GetLocality">
            <summary>
            <p>Gets the current locality of the font.</p>
            </summary>
            <returns><p>Returns the current locality of the font.</p></returns>
            <remarks>
            <p>For fully local files, the result will always  be DWRITE_LOCALITY_LOCAL. A downloadable file may be any of the states, and this function may change between calls.</p>
            </remarks>
            <doc-id>mt725319</doc-id>
            <unmanaged>DWRITE_LOCALITY IDWriteFont3::GetLocality()</unmanaged>
            <unmanaged-short>IDWriteFont3::GetLocality</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontCollection1.FontSet">
            <summary>
            <p>Gets the underlying font set used by this collection.</p>
            </summary>
            <doc-id>dn933225</doc-id>
            <unmanaged>GetFontSet</unmanaged>
            <unmanaged-short>GetFontSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection1.GetFontSet(SharpDX.DirectWrite.FontSet@)">
            <summary>
            <p>Gets the underlying font set used by this collection.</p>
            </summary>
            <param name = "fontSet"><dd>  <p>Returns the font set used by the collection.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933225</doc-id>
            <unmanaged>HRESULT IDWriteFontCollection1::GetFontSet([Out] IDWriteFontSet** fontSet)</unmanaged>
            <unmanaged-short>IDWriteFontCollection1::GetFontSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontCollection1.GetFontFamily(System.Int32,SharpDX.DirectWrite.FontFamily1@)">
            <summary>
            No documentation.
            </summary>
            <param name = "index">No documentation.</param>
            <param name = "fontFamily">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteFontCollection1::GetFontFamily([In] unsigned int index,[Out] IDWriteFontFamily1** fontFamily)</unmanaged>
            <unmanaged-short>IDWriteFontCollection1::GetFontFamily</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadListener.DownloadCompleted(SharpDX.DirectWrite.FontDownloadQueue,SharpDX.IUnknown,SharpDX.Result)">
            <summary>
            <p>The DownloadCompleted method is called back on an arbitrary thread when a     download operation ends. </p>
            </summary>
            <param name = "downloadQueue"><dd>  <p>Pointer to the download queue interface on which      the BeginDownload method was called.</p> </dd></param>
            <param name = "context"><dd>  <p>Optional context object that was passed to BeginDownload.     AddRef is called on the context object by BeginDownload and Release is called   after the DownloadCompleted method returns.</p> </dd></param>
            <param name = "downloadResult"><dd>  <p>Result of the download operation.</p> </dd></param>
            <doc-id>dn890776</doc-id>
            <unmanaged>void IDWriteFontDownloadListener::DownloadCompleted([In] IDWriteFontDownloadQueue* downloadQueue,[In, Optional] IUnknown* context,[In] HRESULT downloadResult)</unmanaged>
            <unmanaged-short>IDWriteFontDownloadListener::DownloadCompleted</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontDownloadQueue.IsEmpty">
            <summary>
            <p>Determines whether the download queue is empty. Note that the queue does not     include requests that are already being downloaded. Calling <strong>BeginDownload</strong> clears the queue.</p>
            </summary>
            <doc-id>dn894558</doc-id>
            <unmanaged>IsEmpty</unmanaged>
            <unmanaged-short>IsEmpty</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontDownloadQueue.GenerationCount">
            <summary>
            <p>Gets the current generation number of the download queue, which is incremented    every time after a download completes, whether failed or successful. This cookie   value can be compared against cached data to determine if it is stale.</p>
            </summary>
            <doc-id>dn894557</doc-id>
            <unmanaged>GetGenerationCount</unmanaged>
            <unmanaged-short>GetGenerationCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadQueue.AddListener(SharpDX.DirectWrite.FontDownloadListener,System.Int32@)">
            <summary>
            <p>Registers a client-defined listener object that receives download notifications.   All registered listener's DownloadCompleted will be called after <strong>BeginDownload</strong> completes. </p>
            </summary>
            <param name = "listener">No documentation.</param>
            <param name = "token">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>An <strong><see cref = "T:SharpDX.DirectWrite.FontDownloadListener"/></strong> can also be passed to <strong>BeginDownload</strong> using the context parameter, rather than globally registered to the queue.</p>
            </remarks>
            <doc-id>dn890779</doc-id>
            <unmanaged>HRESULT IDWriteFontDownloadQueue::AddListener([In] IDWriteFontDownloadListener* listener,[Out] unsigned int* token)</unmanaged>
            <unmanaged-short>IDWriteFontDownloadQueue::AddListener</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadQueue.RemoveListener(System.Int32)">
            <summary>
            <p>Unregisters a notification handler that was previously registered using <strong>AddListener</strong>.</p>
            </summary>
            <param name = "token">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894559</doc-id>
            <unmanaged>HRESULT IDWriteFontDownloadQueue::RemoveListener([In] unsigned int token)</unmanaged>
            <unmanaged-short>IDWriteFontDownloadQueue::RemoveListener</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadQueue.IsEmpty_">
            <summary>
            <p>Determines whether the download queue is empty. Note that the queue does not     include requests that are already being downloaded. Calling <strong>BeginDownload</strong> clears the queue.</p>
            </summary>
            <returns><p>TRUE if the queue is empty, <see cref = "F:SharpDX.Result.False"/> if there are requests pending for <strong>BeginDownload</strong>.</p></returns>
            <doc-id>dn894558</doc-id>
            <unmanaged>BOOL IDWriteFontDownloadQueue::IsEmpty()</unmanaged>
            <unmanaged-short>IDWriteFontDownloadQueue::IsEmpty</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadQueue.BeginDownload(SharpDX.IUnknown)">
            <summary>
            <p>Begins an asynchronous download operation. The download operation executes    in the background until it completes or is cancelled by a <strong>CancelDownload</strong> call.</p>
            </summary>
            <param name = "context">No documentation.</param>
            <returns><p> Returns <see cref = "F:SharpDX.Result.Ok"/> if a download was successfully begun, S_FALSE if the queue was  empty, or a standard <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p>BeginDownload removes all download requests from the queue, transferring them    to a background download operation. If any previous downloads are still ongoing      when BeginDownload is called again, the new download does not complete until      the previous downloads have finished. If the queue is empty and no active    downloads are pending, the <strong>DownloadCompleted</strong> callback is called immediately with     DWRITE_DOWNLOAD_RESULT_NONE.</p>
            </remarks>
            <doc-id>dn894554</doc-id>
            <unmanaged>HRESULT IDWriteFontDownloadQueue::BeginDownload([In, Optional] IUnknown* context)</unmanaged>
            <unmanaged-short>IDWriteFontDownloadQueue::BeginDownload</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadQueue.CancelDownload">
            <summary>
            <p> Removes all download requests from the queue and cancels any active download     operations.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894556</doc-id>
            <unmanaged>HRESULT IDWriteFontDownloadQueue::CancelDownload()</unmanaged>
            <unmanaged-short>IDWriteFontDownloadQueue::CancelDownload</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontDownloadQueue.GetGenerationCount">
            <summary>
            <p>Gets the current generation number of the download queue, which is incremented    every time after a download completes, whether failed or successful. This cookie   value can be compared against cached data to determine if it is stale.</p>
            </summary>
            <returns><p>The current generation number of the download queue.</p></returns>
            <doc-id>dn894557</doc-id>
            <unmanaged>unsigned longlong IDWriteFontDownloadQueue::GetGenerationCount()</unmanaged>
            <unmanaged-short>IDWriteFontDownloadQueue::GetGenerationCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace1.Metrics">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <doc-id>hh780415</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace1.CaretMetrics">
            <summary>
            <p>Gets caret metrics for the font in design units.</p>
            </summary>
            <remarks>
            <p>Caret metrics are used by text editors for drawing the correct caret placement and slant.</p>
            </remarks>
            <doc-id>hh780410</doc-id>
            <unmanaged>GetCaretMetrics</unmanaged>
            <unmanaged-short>GetCaretMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace1.IsMonospacedFont">
            <summary>
            <p>Determines whether the font of a text range is monospaced, that is, the font characters are the same fixed-pitch width.</p>
            </summary>
            <doc-id>hh780421</doc-id>
            <unmanaged>IsMonospacedFont</unmanaged>
            <unmanaged-short>IsMonospacedFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetMetrics(SharpDX.DirectWrite.FontMetrics1@)">
            <summary>
            <p> Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a font face and are used by applications for layout calculations. </p>
            </summary>
            <param name = "fontMetrics"><dd>  <p>A filled <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics1"/></strong> structure that holds metrics for the current font face element. The metrics returned by this method are in font design units.</p> </dd></param>
            <doc-id>hh780415</doc-id>
            <unmanaged>void IDWriteFontFace1::GetMetrics([Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetGdiCompatibleMetrics(System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.DirectWrite.FontMetrics1@)">
            <summary>
            <p>Obtains design units and common metrics for the font face. These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.</p>
            </summary>
            <param name = "emSize"><dd>  <p>The logical size of the font in DIP units.</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>The number of physical pixels per DIP.</p> </dd></param>
            <param name = "transform"><dd>  <p>An optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and <em>pixelsPerDip</em>.</p> </dd></param>
            <param name = "fontMetrics"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics1"/></strong> structure to fill in. The metrics returned by this function are in font design units.</p> </dd></param>
            <returns><p>Standard <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <doc-id>hh780413</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetGdiCompatibleMetrics([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[Out] DWRITE_FONT_METRICS1* fontMetrics)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetGdiCompatibleMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetCaretMetrics(SharpDX.DirectWrite.CaretMetrics@)">
            <summary>
            <p>Gets caret metrics for the font in design units.</p>
            </summary>
            <param name = "caretMetrics"><dd>  <p>A reference to the <strong><see cref = "T:SharpDX.DirectWrite.CaretMetrics"/></strong> structure that is filled.</p> </dd></param>
            <remarks>
            <p>Caret metrics are used by text editors for drawing the correct caret placement and slant.</p>
            </remarks>
            <doc-id>hh780410</doc-id>
            <unmanaged>void IDWriteFontFace1::GetCaretMetrics([Out] DWRITE_CARET_METRICS* caretMetrics)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetCaretMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetUnicodeRanges(System.Int32,SharpDX.DirectWrite.UnicodeRange[],System.Int32@)">
            <summary>
            <p>Retrieves a list of character ranges supported by a font.</p>
            </summary>
            <param name = "maxRangeCount"><dd>  <p>Maximum number of character ranges passed in from the client.</p> </dd></param>
            <param name = "unicodeRanges"><dd>  <p>An array of <strong><see cref = "T:SharpDX.DirectWrite.UnicodeRange"/></strong> structures that are filled with the character ranges.</p> </dd></param>
            <param name = "actualRangeCount"><dd>  <p>A reference to the actual number of character ranges, regardless of the maximum count.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The method executed successfully.</p> </td></tr> <tr><td> <dl> <dt>E_NOT_SUFFICIENT_BUFFER</dt> </dl> </td><td> <p>The buffer is too small.  The <em>actualRangeCount</em> was more than the <em>maxRangeCount</em>.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>A  list of character ranges supported by the font is useful for scenarios like character picking, glyph display, and efficient font selection lookup. This is similar to GDI's <strong>GetFontUnicodeRanges</strong>, except that it returns the full Unicode range, not just 16-bit UCS-2.</p><p>These ranges are from the cmap, not the OS/2::ulCodePageRange1.</p><p>If this method is unavailable, you can use the <strong>IDWriteFontFace::GetGlyphIndices</strong> method to check for missing glyphs.  The method returns the 0 index for glyphs that aren't present in the font.</p><p> The <strong>IDWriteFont::HasCharacter</strong> method is often simpler in cases where you need to check a single character or a series of single characters in succession, such as in font fallback.</p>
            </remarks>
            <doc-id>hh780417</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetUnicodeRanges([In] unsigned int maxRangeCount,[Out, Buffer, Optional] DWRITE_UNICODE_RANGE* unicodeRanges,[Out] unsigned int* actualRangeCount)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetUnicodeRanges</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.IsMonospacedFont_">
            <summary>
            <p>Determines whether the font of a text range is monospaced, that is, the font characters are the same fixed-pitch width.</p>
            </summary>
            <returns><p>Returns TRUE if the font is monospaced, otherwise it returns <see cref = "F:SharpDX.Result.False"/>.</p></returns>
            <doc-id>hh780421</doc-id>
            <unmanaged>BOOL IDWriteFontFace1::IsMonospacedFont()</unmanaged>
            <unmanaged-short>IDWriteFontFace1::IsMonospacedFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetDesignGlyphAdvances(System.Int32,System.Int16[],System.Int32[],SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Retrieves the advances in design units for a sequences of glyphs.</p>
            </summary>
            <param name = "glyphCount"><dd>  <p>The number of glyphs to retrieve advances for.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>An array of glyph id's to retrieve advances for.</p> </dd></param>
            <param name = "glyphAdvances"><dd>  <p>The returned advances in font design units for each glyph.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Retrieve the glyph's vertical advance height rather than horizontal advance widths.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This is equivalent to calling GetGlyphMetrics and using only the advance width and height.</p>
            </remarks>
            <doc-id>hh780411</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetDesignGlyphAdvances([In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvances,[In] BOOL isSideways)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetDesignGlyphAdvances</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetGdiCompatibleGlyphAdvances(System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,System.Int32,System.Int16[],System.Int32[])">
            <summary>
            <p>Returns the pixel-aligned advances for a sequences of glyphs.</p>
            </summary>
            <param name = "emSize"><dd>  <p>Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
            <param name = "pixelsPerDip"><dd>  <p>Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
            <param name = "transform"><dd>  <p>Optional transform applied to the glyphs and their positions. This transform is applied after the scaling specified by the font size and pixelsPerDip.</p> </dd></param>
            <param name = "useGdiNatural"><dd>  <p>When <see cref = "F:SharpDX.Result.False"/>, the metrics are the same as GDI aliased text (DWRITE_MEASURING_MODE_GDI_CLASSIC). When TRUE, the metrics are the same as those measured by GDI using a font using CLEARTYPE_NATURAL_QUALITY (DWRITE_MEASURING_MODE_GDI_NATURAL).</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Retrieve the glyph's vertical advances rather than horizontal advances.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>Total glyphs to retrieve adjustments for.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>An array of glyph id's to retrieve advances.</p> </dd></param>
            <param name = "glyphAdvances"><dd>  <p>The returned advances in font design units for each glyph.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This is equivalent to calling <strong>GetGdiCompatibleGlyphMetrics</strong> and using only the advance width and height. </p><p>Like <strong>GetGdiCompatibleGlyphMetrics</strong>, these are in design units, meaning they must be scaled down by DWRITE_FONT_METRICS::designUnitsPerEm.</p>
            </remarks>
            <doc-id>hh780412</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetGdiCompatibleGlyphAdvances([In] float emSize,[In] float pixelsPerDip,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL useGdiNatural,[In] BOOL isSideways,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvances)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetGdiCompatibleGlyphAdvances</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetKerningPairAdjustments(System.Int32,System.Int16[],System.Int32[])">
            <summary>
            <p>Retrieves the kerning pair adjustments from the font's kern table.</p>
            </summary>
            <param name = "glyphCount"><dd>  <p>Number of glyphs to retrieve adjustments for.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>An array of glyph id's to retrieve adjustments for.</p> </dd></param>
            <param name = "glyphAdvanceAdjustments"><dd>  <p>The advances, returned in font design units, for each glyph. The last glyph adjustment is zero.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>GetKerningPairAdjustments</strong> isn't a direct replacement for GDI's character based <strong>GetKerningPairs</strong>, but it serves the same role, without the client needing to cache them locally. <strong>GetKerningPairAdjustments</strong> also uses glyph id's directly rather than UCS-2 characters (how the kern table actually stores them), which avoids glyph collapse and ambiguity, such as the dash and hyphen, or space and non-breaking space. </p><p>Newer fonts may have only GPOS kerning instead of the legacy pair-table kerning. Such fonts, like Gabriola, will only return 0's for adjustments. <strong>GetKerningPairAdjustments</strong> doesn't virtualize and flatten these GPOS entries into kerning pairs.</p><p>You can realize a performance benefit by calling <strong>IDWriteFontFace1::HasKerningPairs</strong> to determine whether you need to call  <strong>GetKerningPairAdjustments</strong>. If you previously called <strong>IDWriteFontFace1::HasKerningPairs</strong> and it returned <see cref = "F:SharpDX.Result.False"/>, you can avoid calling <strong>GetKerningPairAdjustments</strong> because the font has no kerning pair-table entries. That is, in this situation, a call to <strong>GetKerningPairAdjustments</strong> would be a no-op.</p>
            </remarks>
            <doc-id>hh780414</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetKerningPairAdjustments([In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] int* glyphAdvanceAdjustments)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetKerningPairAdjustments</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.HasKerningPairs">
            <summary>
            <p>Determines whether the font supports pair-kerning.</p>
            </summary>
            <returns><p>Returns TRUE if the font supports kerning pairs, otherwise <see cref = "F:SharpDX.Result.False"/>.</p></returns>
            <remarks>
            <p>If the font doesn't support pair table kerning, you don't need to call <strong>IDWriteFontFace1::GetKerningPairAdjustments</strong> because it would retrieve all zeroes.</p>
            </remarks>
            <doc-id>hh780419</doc-id>
            <unmanaged>BOOL IDWriteFontFace1::HasKerningPairs()</unmanaged>
            <unmanaged-short>IDWriteFontFace1::HasKerningPairs</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetRecommendedRenderingMode(System.Single,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.OutlineThreshold,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.RenderingMode@)">
            <summary>
            <p> Determines the recommended rendering mode for the font, using the specified size and rendering parameters. </p>
            </summary>
            <param name = "fontEmSize"><dd>  <p>The logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</p> </dd></param>
            <param name = "dpiX"><dd>  <p>The number of physical pixels per DIP in a horizontal position. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>The number of physical pixels per DIP in a vertical position. For example, if the DPI of the rendering surface is 96, this  value is 1.0f. If the DPI is 120, this value is 120.0f/96.</p> </dd></param>
            <param name = "transform"><dd>  <p>Specifies the world transform.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Whether the glyphs in the run are sideways or not.</p> </dd></param>
            <param name = "outlineThreshold"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>The measuring method that will be used for glyphs in the font. Renderer implementations may choose different rendering modes for different measuring methods, for example: </p> <ul> <li>DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for <strong>DWRITE_MEASURING_MODE_NATURAL</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for <strong>DWRITE_MEASURING_MODE_GDI_CLASSIC</strong> </li> <li> DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for <strong>DWRITE_MEASURING_MODE_GDI_NATURAL</strong> </li> </ul> </dd></param>
            <param name = "renderingMode"><dd>  <p>When this method returns, contains a value that indicates the recommended rendering mode to use.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method should be used to determine the actual rendering mode in cases where the rendering  mode of the rendering params object is DWRITE_RENDERING_MODE_DEFAULT.</p>
            </remarks>
            <doc-id>hh780416</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[Out] DWRITE_RENDERING_MODE* renderingMode)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetRecommendedRenderingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.GetVerticalGlyphVariants(System.Int32,System.Int16[],System.Int16[])">
            <summary>
            <p>Retrieves the vertical forms of the nominal glyphs retrieved from GetGlyphIndices.</p>
            </summary>
            <param name = "glyphCount"><dd>  <p>The number of glyphs to retrieve.</p> </dd></param>
            <param name = "nominalGlyphIndices"><dd>  <p>Original glyph indices from cmap.</p> </dd></param>
            <param name = "verticalGlyphIndices"><dd>  <p>The vertical form of glyph indices.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The retrieval uses the font's 'vert' table. This is used in CJK vertical layout so the correct characters are shown.</p><p>Call <strong>GetGlyphIndices</strong> to get the nominal glyph indices, followed by calling this to remap the to the substituted forms, when the run is sideways, and the font has vertical glyph variants. See <strong>HasVerticalGlyphVariants</strong> for more info.
            </p>
            </remarks>
            <doc-id>hh780418</doc-id>
            <unmanaged>HRESULT IDWriteFontFace1::GetVerticalGlyphVariants([In] unsigned int glyphCount,[In, Buffer] const unsigned short* nominalGlyphIndices,[Out, Buffer] unsigned short* verticalGlyphIndices)</unmanaged>
            <unmanaged-short>IDWriteFontFace1::GetVerticalGlyphVariants</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace1.HasVerticalGlyphVariants">
            <summary>
            <p>Determines whether the font has any vertical glyph variants.</p>
            </summary>
            <returns><p>Returns TRUE if the font contains vertical glyph variants, otherwise <see cref = "F:SharpDX.Result.False"/>.</p></returns>
            <remarks>
            <p>For OpenType fonts, <strong>HasVerticalGlyphVariants</strong> returns TRUE if the font contains a "vert" feature. </p><p> <strong>IDWriteFontFace1::GetVerticalGlyphVariants</strong> retrieves the vertical forms of the nominal glyphs that are retrieved from <strong>IDWriteFontFace::GetGlyphIndices</strong>. </p>
            </remarks>
            <doc-id>hh780420</doc-id>
            <unmanaged>BOOL IDWriteFontFace1::HasVerticalGlyphVariants()</unmanaged>
            <unmanaged-short>IDWriteFontFace1::HasVerticalGlyphVariants</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace2.IsColorFont">
            <summary>
            <p>Allows you to determine if a color rendering path is potentially necessary.</p>
            </summary>
            <doc-id>dn280457</doc-id>
            <unmanaged>IsColorFont</unmanaged>
            <unmanaged-short>IsColorFont</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace2.ColorPaletteCount">
            <summary>
            <p>Gets the number of color palettes defined by the font. </p>
            </summary>
            <doc-id>dn312080</doc-id>
            <unmanaged>GetColorPaletteCount</unmanaged>
            <unmanaged-short>GetColorPaletteCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace2.PaletteEntryCount">
            <summary>
            <p>Get the number of entries in each color palette.</p>
            </summary>
            <doc-id>dn312082</doc-id>
            <unmanaged>GetPaletteEntryCount</unmanaged>
            <unmanaged-short>GetPaletteEntryCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace2.IsColorFont_">
            <summary>
            <p>Allows you to determine if a color rendering path is potentially necessary.</p>
            </summary>
            <returns><p>Returns <strong>TRUE</strong> if a color rendering path is potentially necessary.</p></returns>
            <doc-id>dn280457</doc-id>
            <unmanaged>BOOL IDWriteFontFace2::IsColorFont()</unmanaged>
            <unmanaged-short>IDWriteFontFace2::IsColorFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace2.GetColorPaletteCount">
            <summary>
            <p>Gets the number of color palettes defined by the font. </p>
            </summary>
            <returns><p>The return value is zero if the font has no color information. Color fonts are required to define at least one palette, with palette index zero reserved as the default palette.</p></returns>
            <doc-id>dn312080</doc-id>
            <unmanaged>unsigned int IDWriteFontFace2::GetColorPaletteCount()</unmanaged>
            <unmanaged-short>IDWriteFontFace2::GetColorPaletteCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace2.GetPaletteEntryCount">
            <summary>
            <p>Get the number of entries in each color palette.</p>
            </summary>
            <returns><p>The number of entries in each color palette. All color palettes in a font have the same number of palette entries. The return value is  zero if the font has no color information.</p></returns>
            <doc-id>dn312082</doc-id>
            <unmanaged>unsigned int IDWriteFontFace2::GetPaletteEntryCount()</unmanaged>
            <unmanaged-short>IDWriteFontFace2::GetPaletteEntryCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace2.GetPaletteEntries(System.Int32,System.Int32,System.Int32,SharpDX.Mathematics.Interop.RawColor4[])">
            <summary>
            <p>Gets color values from the font's color palette.</p>
            </summary>
            <param name = "colorPaletteIndex"><dd> <p>Zero-based index of the color palette. If the font does not have a palette with the specified index, the method returns <strong>DWRITE_E_NOCOLOR</strong>.</p> </dd></param>
            <param name = "firstEntryIndex"><dd> <p>Zero-based index of the first palette entry to read.</p> </dd></param>
            <param name = "entryCount"><dd> <p>Number of palette entries to read.</p> </dd></param>
            <param name = "aletteEntriesRef"><dd> <p>Array that receives the color values.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt>E_INVALIDARG</dt> </dl> </td><td> <p>The sum of <em>firstEntryIndex</em> and <em>entryCount</em> is greater than the actual number of palette entries that's returned by the <strong>GetPaletteEntryCount</strong> method.</p> </td></tr> <tr><td> <dl> <dt>DWRITE_E_NOCOLOR</dt> </dl> </td><td> <p>The font doesn't have a palette with the specified palette index.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn312081</doc-id>
            <unmanaged>HRESULT IDWriteFontFace2::GetPaletteEntries([In] unsigned int colorPaletteIndex,[In] unsigned int firstEntryIndex,[In] unsigned int entryCount,[Out, Buffer] D3DCOLORVALUE* paletteEntries)</unmanaged>
            <unmanaged-short>IDWriteFontFace2::GetPaletteEntries</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace2.GetRecommendedRenderingMode(System.Single,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.OutlineThreshold,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.RenderingParams,SharpDX.DirectWrite.RenderingMode@,SharpDX.DirectWrite.GridFitMode@)">
            <summary>
            <p>Determines the recommended text rendering and grid-fit mode to be used based on the font, size, world transform, and measuring mode.</p>
            </summary>
            <param name = "fontEmSize"><dd>  <p>Logical font size in DIPs.</p> </dd></param>
            <param name = "dpiX"><dd>  <p>Number of pixels per logical inch in the horizontal direction.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>Number of pixels per logical inch in the vertical direction.</p> </dd></param>
            <param name = "transform"><dd>  <p>A <strong><see cref = "T:SharpDX.Mathematics.Interop.RawMatrix3x2"/></strong> structure that describes the world transform.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Specifies whether the font is sideways. <strong>TRUE</strong> if the font is sideways; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <param name = "outlineThreshold"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>A <strong><see cref = "T:SharpDX.Direct2D1.MeasuringMode"/></strong>-typed value that specifies  the method used to measure during text layout. For proper glyph spacing, this method returns a rendering mode that is compatible with the specified measuring mode.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.RenderingParams"/></strong> interface for the rendering parameters object. This parameter is necessary in case the rendering parameters object overrides the rendering mode.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode"/></strong>-typed value for the recommended rendering mode.</p> </dd></param>
            <param name = "gridFitMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.DirectWrite.GridFitMode"/></strong>-typed value for the recommended grid-fit mode.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894560</doc-id>
            <unmanaged>HRESULT IDWriteFontFace2::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE* renderingMode,[Out] DWRITE_GRID_FIT_MODE* gridFitMode)</unmanaged>
            <unmanaged-short>IDWriteFontFace2::GetRecommendedRenderingMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.FontFaceReference">
            <summary>
            <p>Gets a font face reference that identifies this font.</p>
            </summary>
            <doc-id>dn894566</doc-id>
            <unmanaged>GetFontFaceReference</unmanaged>
            <unmanaged-short>GetFontFaceReference</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.Panose">
            <summary>
            <p>Gets the PANOSE values from the font, used for font selection and matching.</p>
            </summary>
            <remarks>
            <p>This method doesn't simulate these values, such as substituting a weight or proportion inferred on other values. If the font doesn't specify them, they are all set to 'any' (0).</p>
            </remarks>
            <doc-id>dn894568</doc-id>
            <unmanaged>GetPanose</unmanaged>
            <unmanaged-short>GetPanose</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.Weight">
            <summary>
            <p>Gets the weight of this font.</p>
            </summary>
            <doc-id>dn894572</doc-id>
            <unmanaged>GetWeight</unmanaged>
            <unmanaged-short>GetWeight</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.Stretch">
            <summary>
            <p>Gets the stretch (also known as width) of this font.</p>
            </summary>
            <doc-id>dn894570</doc-id>
            <unmanaged>GetStretch</unmanaged>
            <unmanaged-short>GetStretch</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.Style">
            <summary>
            <p>Gets the style (also known as slope) of this font.</p>
            </summary>
            <doc-id>dn894571</doc-id>
            <unmanaged>GetStyle</unmanaged>
            <unmanaged-short>GetStyle</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.FamilyNames">
            <summary>
            <p>Creates a localized strings object that contains the family names for the font family, indexed by locale name.</p>
            </summary>
            <doc-id>dn894565</doc-id>
            <unmanaged>GetFamilyNames</unmanaged>
            <unmanaged-short>GetFamilyNames</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFace3.FaceNames">
            <summary>
            <p>Creates a localized strings object that contains the face names for the font (for example, Regular or Bold), indexed by locale name.</p>
            </summary>
            <doc-id>dn894564</doc-id>
            <unmanaged>GetFaceNames</unmanaged>
            <unmanaged-short>GetFaceNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetFontFaceReference(SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Gets a font face reference that identifies this font.</p>
            </summary>
            <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894566</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::GetFontFaceReference([Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetPanose(SharpDX.DirectWrite.Panose@)">
            <summary>
            <p>Gets the PANOSE values from the font, used for font selection and matching.</p>
            </summary>
            <param name = "anoseRef"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.Panose"/></strong> structure that receives the PANOSE values from the font.</p> </dd></param>
            <remarks>
            <p>This method doesn't simulate these values, such as substituting a weight or proportion inferred on other values. If the font doesn't specify them, they are all set to 'any' (0).</p>
            </remarks>
            <doc-id>dn894568</doc-id>
            <unmanaged>void IDWriteFontFace3::GetPanose([Out] DWRITE_PANOSE* panose)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetPanose</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetWeight">
            <summary>
            <p>Gets the weight of this font.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.FontWeight"/></strong>-typed value that specifies the density of a typeface, in terms of the lightness or heaviness of the strokes. </p></returns>
            <doc-id>dn894572</doc-id>
            <unmanaged>DWRITE_FONT_WEIGHT IDWriteFontFace3::GetWeight()</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetWeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetStretch">
            <summary>
            <p>Gets the stretch (also known as width) of this font.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.FontStretch"/></strong>-typed value that specifies the degree to which a font has been stretched compared to a font's normal aspect ratio. </p></returns>
            <doc-id>dn894570</doc-id>
            <unmanaged>DWRITE_FONT_STRETCH IDWriteFontFace3::GetStretch()</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetStretch</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetStyle">
            <summary>
            <p>Gets the style (also known as slope) of this font.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.FontStyle"/></strong>-typed value that specifies the style of the font. </p></returns>
            <doc-id>dn894571</doc-id>
            <unmanaged>DWRITE_FONT_STYLE IDWriteFontFace3::GetStyle()</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetStyle</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetFamilyNames(SharpDX.DirectWrite.LocalizedStrings@)">
            <summary>
            <p>Creates a localized strings object that contains the family names for the font family, indexed by locale name.</p>
            </summary>
            <param name = "names"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.LocalizedStrings"/></strong> interface for the newly created localized strings object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894565</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetFamilyNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetFaceNames(SharpDX.DirectWrite.LocalizedStrings@)">
            <summary>
            <p>Creates a localized strings object that contains the face names for the font (for example, Regular or Bold), indexed by locale name.</p>
            </summary>
            <param name = "names"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.LocalizedStrings"/></strong> interface for the newly created localized strings object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894564</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::GetFaceNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetFaceNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetInformationalStrings(SharpDX.DirectWrite.InformationalStringId,SharpDX.DirectWrite.LocalizedStrings@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets a localized strings collection that contains the specified informational strings, indexed by locale name.</p>
            </summary>
            <param name = "informationalStringID"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.InformationalStringId"/></strong>-typed value that identifies the strings to get.</p> </dd></param>
            <param name = "informationalStrings"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.LocalizedStrings"/></strong> interface for the newly created localized strings object.</p> </dd></param>
            <param name = "exists"><dd>  <p>A reference to a variable that receives whether the font contains the specified string ID. <strong>TRUE</strong> if the font contains the specified string ID; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If the font doesn't contain the specified string, the return value is <see cref = "F:SharpDX.Result.Ok"/>, but <em>informationalStrings</em> receives a <strong><c>null</c></strong> reference and <em>exists</em> receives the value <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p></returns>
            <doc-id>dn894567</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::GetInformationalStrings([In] DWRITE_INFORMATIONAL_STRING_ID informationalStringID,[Out, Optional] IDWriteLocalizedStrings** informationalStrings,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetInformationalStrings</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.HasCharacter(System.Int32)">
            <summary>
            <p>Determines whether the font supports the specified character.</p>
            </summary>
            <param name = "unicodeValue"><dd>  <p>A Unicode (UCS-4) character value.</p> </dd></param>
            <returns><p>Returns whether the font supports the specified character. Returns <strong>TRUE</strong> if the font has the specified character; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p></returns>
            <doc-id>dn894573</doc-id>
            <unmanaged>BOOL IDWriteFontFace3::HasCharacter([In] unsigned int unicodeValue)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::HasCharacter</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.GetRecommendedRenderingMode(System.Single,System.Single,System.Single,System.Nullable{SharpDX.Mathematics.Interop.RawMatrix3x2},SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.OutlineThreshold,SharpDX.Direct2D1.MeasuringMode,SharpDX.DirectWrite.RenderingParams,SharpDX.DirectWrite.RenderingMode1@,SharpDX.DirectWrite.GridFitMode@)">
            <summary>
            <p>Determines the recommended text rendering and grid-fit mode to be used based on the font, size, world transform, and measuring mode.</p>
            </summary>
            <param name = "fontEmSize"><dd>  <p>Logical font size in DIPs.</p> </dd></param>
            <param name = "dpiX"><dd>  <p>Number of pixels per logical inch in the horizontal direction.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>Number of pixels per logical inch in the vertical direction.</p> </dd></param>
            <param name = "transform"><dd>  <p>A <strong><see cref = "T:SharpDX.Mathematics.Interop.RawMatrix3x2"/></strong> structure that describes the world transform.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Specifies whether the font is sideways. <strong>TRUE</strong> if the font is sideways; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>. </p> </dd></param>
            <param name = "outlineThreshold"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.OutlineThreshold"/></strong>-typed value that specifies the quality of the graphics system's outline rendering, affects the size threshold above which outline rendering is used.</p> </dd></param>
            <param name = "measuringMode"><dd>  <p>A <strong><see cref = "T:SharpDX.Direct2D1.MeasuringMode"/></strong>-typed value that specifies  the method used to measure during text layout. For proper glyph spacing, this method returns a rendering mode that is compatible with the specified measuring mode.</p> </dd></param>
            <param name = "renderingParams"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.RenderingParams"/></strong> interface for the rendering parameters object. This parameter is necessary in case the rendering parameters object overrides the rendering mode.</p> </dd></param>
            <param name = "renderingMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode1"/></strong>-typed value for the recommended rendering mode.</p> </dd></param>
            <param name = "gridFitMode"><dd>  <p>A reference to a variable that receives a <strong><see cref = "T:SharpDX.DirectWrite.GridFitMode"/></strong>-typed value for the recommended grid-fit mode.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894569</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::GetRecommendedRenderingMode([In] float fontEmSize,[In] float dpiX,[In] float dpiY,[In, Optional] const DWRITE_MATRIX* transform,[In] BOOL isSideways,[In] DWRITE_OUTLINE_THRESHOLD outlineThreshold,[In] DWRITE_MEASURING_MODE measuringMode,[In, Optional] IDWriteRenderingParams* renderingParams,[Out] DWRITE_RENDERING_MODE1* renderingMode,[Out] DWRITE_GRID_FIT_MODE* gridFitMode)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::GetRecommendedRenderingMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.IsCharacterLocal(System.Int32)">
            <summary>
            <p>Determines whether the character is locally downloaded from the font.</p>
            </summary>
            <param name = "unicodeValue"><dd>  <p>A Unicode (UCS-4) character value.</p> </dd></param>
            <returns><p>Returns <strong>TRUE</strong> if the font has the specified character locally available,     <strong><see cref = "F:SharpDX.Result.False"/></strong> if not or if the font does not support that character. </p></returns>
            <doc-id>dn894574</doc-id>
            <unmanaged>BOOL IDWriteFontFace3::IsCharacterLocal([In] unsigned int unicodeValue)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::IsCharacterLocal</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.IsGlyphLocal(System.Int16)">
            <summary>
            <p>Determines whether the glyph is locally downloaded from the font.</p>
            </summary>
            <param name = "glyphId"><dd>  <p>Glyph identifier.</p> </dd></param>
            <returns><p>Returns TRUE if the font has the specified glyph locally available.</p></returns>
            <doc-id>dn894575</doc-id>
            <unmanaged>BOOL IDWriteFontFace3::IsGlyphLocal([In] unsigned short glyphId)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::IsGlyphLocal</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.AreCharactersLocal(System.String,System.Int32,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Determines whether the specified characters are local.</p>
            </summary>
            <param name = "characters"><dd>  <p>Array of characters.</p> </dd></param>
            <param name = "characterCount"><dd>  <p>The number of elements in the character array.</p> </dd></param>
            <param name = "enqueueIfNotLocal"><dd>  <p>Specifies whether to enqueue a download request     if any of the specified characters are not local.</p> </dd></param>
            <param name = "isLocal"><dd>  <p>Receives TRUE if all of the specified characters are local,     <see cref = "F:SharpDX.Result.False"/> if any of the specified characters are remote.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894562</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::AreCharactersLocal([In, Buffer] const wchar_t* characters,[In] unsigned int characterCount,[In] BOOL enqueueIfNotLocal,[Out] BOOL* isLocal)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::AreCharactersLocal</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace3.AreGlyphsLocal(System.Int16[],System.Int32,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Determines whether the specified glyphs are local.</p>
            </summary>
            <param name = "glyphIndices"><dd>  <p>Array of glyph indices.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>The number of elements in the glyph index array.</p> </dd></param>
            <param name = "enqueueIfNotLocal"><dd>  <p>Specifies whether to enqueue a download request     if any of the specified glyphs are not local.</p> </dd></param>
            <param name = "isLocal"><dd>  <p>Receives TRUE if all of the specified glyphs are local,     <see cref = "F:SharpDX.Result.False"/> if any of the specified glyphs are remote.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894563</doc-id>
            <unmanaged>HRESULT IDWriteFontFace3::AreGlyphsLocal([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount,[In] BOOL enqueueIfNotLocal,[Out] BOOL* isLocal)</unmanaged>
            <unmanaged-short>IDWriteFontFace3::AreGlyphsLocal</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace4.GetGlyphImageFormats(System.Int16,System.Int32,System.Int32,SharpDX.Direct2D1.GlyphImageFormatS@)">
            <summary>
            <p>Gets the available image formats of a specific glyph and ppem. </p>
            </summary>
            <param name = "glyphId"><dd>  <p>The ID of the glyph.</p> </dd></param>
            <param name = "pixelsPerEmFirst"><dd>  </dd></param>
            <param name = "pixelsPerEmLast"><dd>  </dd></param>
            <param name = "glyphImageFormats"><dd>  <p>Specifies which formats are supported in the font.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <see cref = "F:SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p>Glyphs often have at least TrueType or CFF outlines, but they may also have SVG outlines, or they may have only bitmaps with no TrueType/CFF outlines. Some image formats, notably the PNG/JPEG ones, are size specific and will return no match when there isn't an entry in that size range.</p><p>Glyph ids beyond the glyph count return DWRITE_GLYPH_IMAGE_FORMATS_NONE.</p>
            </remarks>
            <doc-id>mt725323</doc-id>
            <unmanaged>HRESULT IDWriteFontFace4::GetGlyphImageFormats([In] unsigned short glyphId,[In] unsigned int pixelsPerEmFirst,[In] unsigned int pixelsPerEmLast,[Out] DWRITE_GLYPH_IMAGE_FORMATS* glyphImageFormats)</unmanaged>
            <unmanaged-short>IDWriteFontFace4::GetGlyphImageFormats</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace4.GetGlyphImageFormats">
            <summary>
            <p>Gets the available image formats of a specific glyph and ppem. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <see cref = "F:SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p>Glyphs often have at least TrueType or CFF outlines, but they may also have SVG outlines, or they may have only bitmaps with no TrueType/CFF outlines. Some image formats, notably the PNG/JPEG ones, are size specific and will return no match when there isn't an entry in that size range.</p><p>Glyph ids beyond the glyph count return DWRITE_GLYPH_IMAGE_FORMATS_NONE.</p>
            </remarks>
            <doc-id>mt725323</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_FORMATS IDWriteFontFace4::GetGlyphImageFormats()</unmanaged>
            <unmanaged-short>IDWriteFontFace4::GetGlyphImageFormats</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace4.GetGlyphImageData(System.Int16,System.Int32,SharpDX.Direct2D1.GlyphImageFormatS,SharpDX.DirectWrite.GlyphImageData@,System.IntPtr@)">
            <summary>
            <p>Gets a reference to the glyph data based on the desired image format.</p>
            </summary>
            <param name = "glyphId"><dd>  <p>The ID of the glyph to retrieve image data for.</p> </dd></param>
            <param name = "pixelsPerEm"><dd>  <p>Requested pixels per em.</p> </dd></param>
            <param name = "glyphImageFormat"><dd>  <p>Specifies which formats are supported in the font.</p> </dd></param>
            <param name = "glyphData"><dd>  <p>On return contains data for a glyph.</p> </dd></param>
            <param name = "glyphDataContext"><dd>  </dd></param>
            <returns><p>If this method succeeds, it returns <see cref = "F:SharpDX.Result.Ok"/>. Otherwise, it returns an <see cref = "T:SharpDX.Result"/> error code.</p></returns>
            <remarks>
            <p> The glyphDataContext must be released via <strong>ReleaseGlyphImageData</strong> when done if the data is not empty, similar to <strong>IDWriteFontFileStream::ReadFileFragment</strong> and <strong>IDWriteFontFileStream::ReleaseFileFragment</strong>. The data reference is valid so long as the <strong><see cref = "T:SharpDX.DirectWrite.FontFace"/></strong> exists and <strong>ReleaseGlyphImageData</strong> has not been called. </p><p> The <strong>DWRITE_GLYPH_IMAGE_DATA::uniqueDataId</strong> is valuable for caching purposes so that if the same resource is returned more than once, an existing resource can be quickly retrieved rather than needing to reparse or decompress the data. </p><p> The function only returns SVG or raster data - requesting TrueType/CFF/COLR data returns DWRITE_E_INVALIDARG. Those must be drawn via DrawGlyphRun or queried using GetGlyphOutline instead. Exactly one format may be requested or else the function returns DWRITE_E_INVALIDARG. If the glyph does not have that format, the call is not an error, but the function returns empty data.  </p>
            </remarks>
            <doc-id>mt725321</doc-id>
            <unmanaged>HRESULT IDWriteFontFace4::GetGlyphImageData([In] unsigned short glyphId,[In] unsigned int pixelsPerEm,[In] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,[Out] DWRITE_GLYPH_IMAGE_DATA* glyphData,[Out, Optional] void** glyphDataContext)</unmanaged>
            <unmanaged-short>IDWriteFontFace4::GetGlyphImageData</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFace4.ReleaseGlyphImageData(System.IntPtr)">
            <summary>
            <p>Releases the table data obtained from ReadGlyphData.</p>
            </summary>
            <param name = "glyphDataContext"><dd>  <p>Opaque context from ReadGlyphData.</p> </dd></param>
            <doc-id>mt725325</doc-id>
            <unmanaged>void IDWriteFontFace4::ReleaseGlyphImageData([In] void* glyphDataContext)</unmanaged>
            <unmanaged-short>IDWriteFontFace4::ReleaseGlyphImageData</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.FontFaceIndex">
            <summary>
            <p>Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face,   the return value is zero. </p>
            </summary>
            <doc-id>dn894585</doc-id>
            <unmanaged>GetFontFaceIndex</unmanaged>
            <unmanaged-short>GetFontFaceIndex</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.Simulations">
            <summary>
            <p>Obtains the algorithmic style simulation flags of a font face.</p>
            </summary>
            <doc-id>dn894589</doc-id>
            <unmanaged>GetSimulations</unmanaged>
            <unmanaged-short>GetSimulations</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.FontFile">
            <summary>
            <p>Obtains the font file representing a font face.</p>
            </summary>
            <doc-id>dn894586</doc-id>
            <unmanaged>GetFontFile</unmanaged>
            <unmanaged-short>GetFontFile</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.LocalFileSize">
            <summary>
            <p>Get the local size of the font face in bytes, which will always be    less than or equal to GetFullSize. If the locality is remote, this      value is zero. If full, this value will equal GetFileSize.</p>
            </summary>
            <doc-id>dn894587</doc-id>
            <unmanaged>GetLocalFileSize</unmanaged>
            <unmanaged-short>GetLocalFileSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.FileSize">
            <summary>
            <p>Get the total size of the font face in bytes.  </p>
            </summary>
            <doc-id>dn894583</doc-id>
            <unmanaged>GetFileSize</unmanaged>
            <unmanaged-short>GetFileSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.FileTime">
            <summary>
            <p>Get the last modified date.</p>
            </summary>
            <doc-id>dn894584</doc-id>
            <unmanaged>GetFileTime</unmanaged>
            <unmanaged-short>GetFileTime</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFaceReference.Locality">
            <summary>
            <p>Get the locality of this font face reference.</p>
            </summary>
            <remarks>
            <p>You can always successfully   create a font face from a fully local font. Attempting to create a font      face on a remote or partially local font may fail with DWRITE_E_REMOTEFONT.     This function may change between calls depending on background downloads     and whether cached data expires.</p>
            </remarks>
            <doc-id>dn894588</doc-id>
            <unmanaged>GetLocality</unmanaged>
            <unmanaged-short>GetLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.CreateFontFace(SharpDX.DirectWrite.FontFace3@)">
            <summary>
            <p>Creates a font face from the reference for use with layout, shaping, or rendering.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>Newly created font face object, or nullptr in the case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function can fail with DWRITE_E_REMOTEFONT if the font is not local.</p>
            </remarks>
            <doc-id>dn894577</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::CreateFontFace([Out] IDWriteFontFace3** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::CreateFontFace</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.CreateFontFaceWithSimulations(SharpDX.DirectWrite.FontSimulations,SharpDX.DirectWrite.FontFace3@)">
            <summary>
            <p>Creates a font face with alternate font simulations, for example, to explicitly simulate a bold font face out of a regular variant.</p>
            </summary>
            <param name = "fontFaceSimulationFlags"><dd>  <p>Font face simulation flags for algorithmic emboldening and italicization.</p> </dd></param>
            <param name = "fontFace"><dd>  <p>Newly created font face object, or nullptr in the case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function can fail with DWRITE_E_REMOTEFONT if the font is not local.</p>
            </remarks>
            <doc-id>dn894578</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::CreateFontFaceWithSimulations([In] DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,[Out] IDWriteFontFace3** fontFace)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::CreateFontFaceWithSimulations</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.Equals(SharpDX.DirectWrite.FontFaceReference)">
            <summary>
            No documentation.
            </summary>
            <param name = "fontFaceReference">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>BOOL IDWriteFontFaceReference::Equals([In] IDWriteFontFaceReference* fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::Equals</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetFontFaceIndex">
            <summary>
            <p>Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face,   the return value is zero. </p>
            </summary>
            <returns><p> the zero-based index of the font face in its font file or files. If the font files contain a single face,   the return value is zero.</p></returns>
            <doc-id>dn894585</doc-id>
            <unmanaged>unsigned int IDWriteFontFaceReference::GetFontFaceIndex()</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetFontFaceIndex</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetSimulations">
            <summary>
            <p>Obtains the algorithmic style simulation flags of a font face.</p>
            </summary>
            <returns><p>Returns the algorithmic style simulation flags of a font face.</p></returns>
            <doc-id>dn894589</doc-id>
            <unmanaged>DWRITE_FONT_SIMULATIONS IDWriteFontFaceReference::GetSimulations()</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetSimulations</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetFontFile(SharpDX.DirectWrite.FontFile@)">
            <summary>
            <p>Obtains the font file representing a font face.</p>
            </summary>
            <param name = "fontFile"><dd>  </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894586</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::GetFontFile([Out] IDWriteFontFile** fontFile)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetFontFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetLocalFileSize">
            <summary>
            <p>Get the local size of the font face in bytes, which will always be    less than or equal to GetFullSize. If the locality is remote, this      value is zero. If full, this value will equal GetFileSize.</p>
            </summary>
            <returns><p>the local size of the font face in bytes, which will always be    less than or equal to GetFullSize. If the locality is remote, this      value is zero. If full, this value will equal <strong>GetFileSize</strong>.</p></returns>
            <doc-id>dn894587</doc-id>
            <unmanaged>unsigned longlong IDWriteFontFaceReference::GetLocalFileSize()</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetLocalFileSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetFileSize">
            <summary>
            <p>Get the total size of the font face in bytes.  </p>
            </summary>
            <returns><p>Returns the total size of the font face in bytes. If the locality is remote, this value is unknown and will be zero.</p></returns>
            <doc-id>dn894583</doc-id>
            <unmanaged>unsigned longlong IDWriteFontFaceReference::GetFileSize()</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetFileSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetFileTime(System.Int64@)">
            <summary>
            <p>Get the last modified date.</p>
            </summary>
            <param name = "lastWriteTime"><dd>  <p>Returns the last modified date. The time may be zero if the font file loader does not expose file time.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894584</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::GetFileTime([Out] FILETIME* lastWriteTime)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetFileTime</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.GetLocality">
            <summary>
            <p>Get the locality of this font face reference.</p>
            </summary>
            <returns><p>Returns the locality of this font face reference.</p></returns>
            <remarks>
            <p>You can always successfully   create a font face from a fully local font. Attempting to create a font      face on a remote or partially local font may fail with DWRITE_E_REMOTEFONT.     This function may change between calls depending on background downloads     and whether cached data expires.</p>
            </remarks>
            <doc-id>dn894588</doc-id>
            <unmanaged>DWRITE_LOCALITY IDWriteFontFaceReference::GetLocality()</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::GetLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.EnqueueFontDownloadRequest">
            <summary>
            <p>Adds a request to the font download queue (<strong><see cref = "T:SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894581</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueFontDownloadRequest()</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::EnqueueFontDownloadRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.EnqueueCharacterDownloadRequest(System.String,System.Int32)">
            <summary>
            <p>Adds a request to the font download queue (<strong><see cref = "T:SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
            </summary>
            <param name = "characters">No documentation.</param>
            <param name = "characterCount">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Downloading a character involves downloading every glyph it depends on directly or indirectly, via font tables (cmap, GSUB, COLR, glyf).</p>
            </remarks>
            <doc-id>dn894579</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueCharacterDownloadRequest([In, Buffer] const wchar_t* characters,[In] unsigned int characterCount)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::EnqueueCharacterDownloadRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.EnqueueGlyphDownloadRequest(System.Int16[],System.Int32)">
            <summary>
            <p>Adds a request to the font download queue (<strong><see cref = "T:SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
            </summary>
            <param name = "glyphIndices">No documentation.</param>
            <param name = "glyphCount">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Downloading a glyph involves downloading any other glyphs it depends on from the font tables (GSUB, COLR, glyf).</p>
            </remarks>
            <doc-id>dn894582</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueGlyphDownloadRequest([In, Buffer] const unsigned short* glyphIndices,[In] unsigned int glyphCount)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::EnqueueGlyphDownloadRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFaceReference.EnqueueFileFragmentDownloadRequest(System.Int64,System.Int64)">
            <summary>
            <p>Adds a request to the font download queue (<strong><see cref = "T:SharpDX.DirectWrite.FontDownloadQueue"/></strong>).</p>
            </summary>
            <param name = "fileOffset">No documentation.</param>
            <param name = "fragmentSize">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894580</doc-id>
            <unmanaged>HRESULT IDWriteFontFaceReference::EnqueueFileFragmentDownloadRequest([In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize)</unmanaged>
            <unmanaged-short>IDWriteFontFaceReference::EnqueueFileFragmentDownloadRequest</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFallback.MapCharacters(SharpDX.DirectWrite.TextAnalysisSource,System.Int32,System.Int32,SharpDX.DirectWrite.FontCollection,System.String,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.FontStretch,System.Int32@,SharpDX.DirectWrite.Font@,System.Single@)">
            <summary>
            <p>Determines an appropriate font to use to render the beginning range of text.</p>
            </summary>
            <param name = "analysisSource"><dd>  <p>The text source implementation holds the text and locale.</p> </dd></param>
            <param name = "textPosition"><dd>  <p>Starting position to analyze.</p> </dd></param>
            <param name = "textLength"><dd>  <p>Length of the text to analyze.</p> </dd></param>
            <param name = "baseFontCollection"><dd>  <p>Default font collection to use.</p> </dd></param>
            <param name = "baseFamilyName"><dd>  <p>Family name of the base font. If you pass null, no matching     will be done against the family.</p> </dd></param>
            <param name = "baseWeight"><dd>  <p>The desired weight.</p> </dd></param>
            <param name = "baseStyle"><dd>  <p>The desired style.</p> </dd></param>
            <param name = "baseStretch"><dd>  <p>The desired stretch.</p> </dd></param>
            <param name = "mappedLength"><dd>  <p>Length of text mapped to the mapped font. This will always be less than     or equal to the text length and greater than zero (if the text length is non-zero) so     the caller advances at least one character.</p> </dd></param>
            <param name = "mappedFont"><dd>  <p>The font that should be used to render the first <em>mappedLength</em> characters of the text. If it returns <c>null</c>, that means that no font can render the     text, and <em>mappedLength</em> is the number of characters to skip (rendered with a missing glyph).</p> </dd></param>
            <param name = "scale"><dd>  <p>Scale factor to multiply the em size of the returned font by.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280480</doc-id>
            <unmanaged>HRESULT IDWriteFontFallback::MapCharacters([In] IDWriteTextAnalysisSource* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In, Optional] IDWriteFontCollection* baseFontCollection,[In, Optional] const wchar_t* baseFamilyName,[In] DWRITE_FONT_WEIGHT baseWeight,[In] DWRITE_FONT_STYLE baseStyle,[In] DWRITE_FONT_STRETCH baseStretch,[Out] unsigned int* mappedLength,[Out, Optional] IDWriteFont** mappedFont,[Out] float* scale)</unmanaged>
            <unmanaged-short>IDWriteFontFallback::MapCharacters</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFallbackBuilder.AddMapping(SharpDX.DirectWrite.UnicodeRange[],System.Int32,System.String,System.Int32,SharpDX.DirectWrite.FontCollection,System.String,System.String,System.Single)">
            <summary>
            <p>Appends a single mapping to the list. Call this once for each additional mapping.</p>
            </summary>
            <param name = "ranges"><dd>  <p>Unicode ranges that apply to this mapping.</p> </dd></param>
            <param name = "rangesCount"><dd>  <p>Number of Unicode ranges.</p> </dd></param>
            <param name = "targetFamilyNames"><dd>  <p>List of target family name strings.</p> </dd></param>
            <param name = "targetFamilyNamesCount"><dd>  <p>Number of target family names.</p> </dd></param>
            <param name = "fontCollection"><dd>  <p>Optional explicit font collection for this mapping.</p> </dd></param>
            <param name = "localeName"><dd>  <p>Locale of the context.</p> </dd></param>
            <param name = "baseFamilyName"><dd>  <p>Base family name to match against, if applicable.</p> </dd></param>
            <param name = "scale"><dd>  <p>Scale factor to multiply the result target font by.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280477</doc-id>
            <unmanaged>HRESULT IDWriteFontFallbackBuilder::AddMapping([In, Buffer] const DWRITE_UNICODE_RANGE* ranges,[In] unsigned int rangesCount,[In, Buffer] const wchar_t** targetFamilyNames,[In] unsigned int targetFamilyNamesCount,[In, Optional] IDWriteFontCollection* fontCollection,[In, Optional] const wchar_t* localeName,[In, Optional] const wchar_t* baseFamilyName,[In] float scale)</unmanaged>
            <unmanaged-short>IDWriteFontFallbackBuilder::AddMapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFallbackBuilder.AddMappings(SharpDX.DirectWrite.FontFallback)">
            <summary>
            <p>Add all the mappings from an existing font fallback object.</p>
            </summary>
            <param name = "fontFallback"><dd>  <p>An existing font fallback object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280478</doc-id>
            <unmanaged>HRESULT IDWriteFontFallbackBuilder::AddMappings([In] IDWriteFontFallback* fontFallback)</unmanaged>
            <unmanaged-short>IDWriteFontFallbackBuilder::AddMappings</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFallbackBuilder.CreateFontFallback(SharpDX.DirectWrite.FontFallback@)">
            <summary>
            <p>Creates the finalized fallback object from the mappings added.</p>
            </summary>
            <param name = "fontFallback"><dd> <p>Contains an address of a reference to the created fallback list.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280479</doc-id>
            <unmanaged>HRESULT IDWriteFontFallbackBuilder::CreateFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
            <unmanaged-short>IDWriteFontFallbackBuilder::CreateFontFallback</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontFamily.FamilyNames">
            <summary>
            <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>
            </summary>
            <remarks>
            <p> The following code example shows how to get the font family name from a <strong><see cref = "T:SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref = "T:SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.
            if (SUCCEEDED(hr))
            { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);
            } UINT32 index = 0;
            <see cref = "T:SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))
            { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp; &amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }
            } // If the specified locale doesn't exist, select the first on the list.
            if (!exists) index = 0; UINT32 length = 0; // Get the string length.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
            } // Allocate a string big enough to hold the name.
            wchar_t* name = new (std::nothrow) wchar_t[length+1];
            if (name == <c>null</c>)
            { hr = E_OUTOFMEMORY;
            } // Get the family name.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetString(index, name, length+1);
            }
            </pre>
            </remarks>
            <doc-id>dd371047</doc-id>
            <unmanaged>GetFamilyNames</unmanaged>
            <unmanaged-short>GetFamilyNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFamily.GetFamilyNames(SharpDX.DirectWrite.LocalizedStrings@)">
            <summary>
            <p> Creates a localized strings object that contains the family names for the font family, indexed by locale name. </p>
            </summary>
            <param name = "names"><dd>  <p>The address of a reference to the newly created <strong><see cref = "T:SharpDX.DirectWrite.LocalizedStrings"/></strong> object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The following code example shows how to get the font family name from a <strong><see cref = "T:SharpDX.DirectWrite.FontFamily"/></strong> object.</p><pre><see cref = "T:SharpDX.DirectWrite.LocalizedStrings"/>* pFamilyNames = <c>null</c>; // Get a list of localized strings for the family name.
            if (SUCCEEDED(hr))
            { hr = pFontFamily-&gt;GetFamilyNames(&amp;pFamilyNames);
            } UINT32 index = 0;
            <see cref = "T:SharpDX.Mathematics.Interop.RawBool"/> exists = false; wchar_t localeName[LOCALE_NAME_MAX_LENGTH]; if (SUCCEEDED(hr))
            { // Get the default locale for this user. int defaultLocaleSuccess = GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH); // If the default locale is returned, find that locale name, otherwise use "en-us". if (defaultLocaleSuccess) { hr = pFamilyNames-&gt;FindLocaleName(localeName, &amp;index, &amp;exists); } if (SUCCEEDED(hr) &amp; &amp; !exists) // if the above find did not find a match, retry with US English { hr = pFamilyNames-&gt;FindLocaleName(L"en-us", &amp;index, &amp;exists); }
            } // If the specified locale doesn't exist, select the first on the list.
            if (!exists) index = 0; UINT32 length = 0; // Get the string length.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetStringLength(index, &amp;length);
            } // Allocate a string big enough to hold the name.
            wchar_t* name = new (std::nothrow) wchar_t[length+1];
            if (name == <c>null</c>)
            { hr = E_OUTOFMEMORY;
            } // Get the family name.
            if (SUCCEEDED(hr))
            { hr = pFamilyNames-&gt;GetString(index, name, length+1);
            }
            </pre>
            </remarks>
            <doc-id>dd371047</doc-id>
            <unmanaged>HRESULT IDWriteFontFamily::GetFamilyNames([Out] IDWriteLocalizedStrings** names)</unmanaged>
            <unmanaged-short>IDWriteFontFamily::GetFamilyNames</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFamily.GetFirstMatchingFont(SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStretch,SharpDX.DirectWrite.FontStyle)">
            <summary>
            <p> Gets the font that best matches the specified properties. </p>
            </summary>
            <param name = "weight"><dd>  <p>A value that is used to match a requested font weight.</p> </dd></param>
            <param name = "stretch"><dd>  <p>A value that is used to match a requested font stretch.</p> </dd></param>
            <param name = "style"><dd>  <p>A value that is used to match a requested font style.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> object.</p> </dd></returns>
            <doc-id>dd371051</doc-id>
            <unmanaged>HRESULT IDWriteFontFamily::GetFirstMatchingFont([In] DWRITE_FONT_WEIGHT weight,[In] DWRITE_FONT_STRETCH stretch,[In] DWRITE_FONT_STYLE style,[Out] IDWriteFont** matchingFont)</unmanaged>
            <unmanaged-short>IDWriteFontFamily::GetFirstMatchingFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFamily.GetMatchingFonts(SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStretch,SharpDX.DirectWrite.FontStyle)">
            <summary>
            <p> Gets a list of fonts in the font family ranked in order of how well they match the specified properties. </p>
            </summary>
            <param name = "weight"><dd>  <p>A value that is used to match a requested font weight.</p> </dd></param>
            <param name = "stretch"><dd>  <p>A value that is used to match a requested font stretch.</p> </dd></param>
            <param name = "style"><dd>  <p>A value that is used to match a requested font style.</p> </dd></param>
            <returns><dd>  <p>An address of a reference to the newly created <strong><see cref = "T:SharpDX.DirectWrite.FontList"/></strong> object.</p> </dd></returns>
            <doc-id>dd371056</doc-id>
            <unmanaged>HRESULT IDWriteFontFamily::GetMatchingFonts([In] DWRITE_FONT_WEIGHT weight,[In] DWRITE_FONT_STRETCH stretch,[In] DWRITE_FONT_STYLE style,[Out] IDWriteFontList** matchingFonts)</unmanaged>
            <unmanaged-short>IDWriteFontFamily::GetMatchingFonts</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFamily1.GetFontLocality(System.Int32)">
            <summary>
            <p>Gets the current location of a font given its zero-based index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.Locality"/></strong>-typed value that specifies the location of the specified font.</p></returns>
            <remarks>
            <p>For fully local files, the result will always be <strong>DWRITE_LOCALITY_LOCAL</strong>. For streamed files, the result depends on how much of the file has been downloaded. <strong>GetFont</strong> fails if the locality is <strong>DWRITE_LOCALITY_REMOTE</strong> and potentially fails if <strong>DWRITE_LOCALITY_PARTIAL</strong>. </p>
            </remarks>
            <doc-id>dn894593</doc-id>
            <unmanaged>DWRITE_LOCALITY IDWriteFontFamily1::GetFontLocality([In] unsigned int listIndex)</unmanaged>
            <unmanaged-short>IDWriteFontFamily1::GetFontLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFamily1.GetFont(System.Int32,SharpDX.DirectWrite.Font3@)">
            <summary>
            <p>Gets a font given its zero-based index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <param name = "font"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.Font3"/></strong> interface for the newly created font object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894591</doc-id>
            <unmanaged>HRESULT IDWriteFontFamily1::GetFont([In] unsigned int listIndex,[Out] IDWriteFont3** font)</unmanaged>
            <unmanaged-short>IDWriteFontFamily1::GetFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontFamily1.GetFontFaceReference(System.Int32,SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Gets a font face reference given its zero-based index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn894592</doc-id>
            <unmanaged>HRESULT IDWriteFontFamily1::GetFontFaceReference([In] unsigned int listIndex,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFontFamily1::GetFontFaceReference</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontList.FontCollection">
            <summary>
            <p> Gets the font collection that contains the fonts in the font list.</p>
            </summary>
            <doc-id>dd371129</doc-id>
            <unmanaged>GetFontCollection</unmanaged>
            <unmanaged-short>GetFontCollection</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontList.FontCount">
            <summary>
            <p> Gets the number of fonts in the font list. </p>
            </summary>
            <doc-id>dd371133</doc-id>
            <unmanaged>GetFontCount</unmanaged>
            <unmanaged-short>GetFontCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontList.GetFontCollection(SharpDX.DirectWrite.FontCollection@)">
            <summary>
            <p> Gets the font collection that contains the fonts in the font list.</p>
            </summary>
            <param name = "fontCollection"><dd>  <p>When this method returns, contains the address of a reference to the current <strong><see cref = "T:SharpDX.DirectWrite.FontCollection"/></strong> object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dd371129</doc-id>
            <unmanaged>HRESULT IDWriteFontList::GetFontCollection([Out] IDWriteFontCollection** fontCollection)</unmanaged>
            <unmanaged-short>IDWriteFontList::GetFontCollection</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontList.GetFontCount">
            <summary>
            <p> Gets the number of fonts in the font list. </p>
            </summary>
            <returns><p>The number of fonts in the font list.</p></returns>
            <doc-id>dd371133</doc-id>
            <unmanaged>unsigned int IDWriteFontList::GetFontCount()</unmanaged>
            <unmanaged-short>IDWriteFontList::GetFontCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontList.GetFont(System.Int32)">
            <summary>
            <p> Gets a font given its zero-based index. </p>
            </summary>
            <param name = "index"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <returns><dd>  <p>When this method returns, contains the address of a reference to the newly created <strong><see cref = "T:SharpDX.DirectWrite.Font"/></strong> object.</p> </dd></returns>
            <doc-id>dd371125</doc-id>
            <unmanaged>HRESULT IDWriteFontList::GetFont([In] unsigned int index,[Out] IDWriteFont** font)</unmanaged>
            <unmanaged-short>IDWriteFontList::GetFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontList1.GetFontLocality(System.Int32)">
            <summary>
            <p>Gets the current location of a font given its zero-based index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.Locality"/></strong>-typed value that specifies the location of the specified font.</p></returns>
            <remarks>
            <p>For fully local files, the result will always be <strong>DWRITE_LOCALITY_LOCAL</strong>. For streamed files, the result depends on how much of the file has been downloaded. <strong>GetFont</strong> fails if the locality is <strong>DWRITE_LOCALITY_REMOTE</strong> and potentially fails if <strong>DWRITE_LOCALITY_PARTIAL</strong>. </p>
            </remarks>
            <doc-id>dn900386</doc-id>
            <unmanaged>DWRITE_LOCALITY IDWriteFontList1::GetFontLocality([In] unsigned int listIndex)</unmanaged>
            <unmanaged-short>IDWriteFontList1::GetFontLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontList1.GetFont(System.Int32,SharpDX.DirectWrite.Font3@)">
            <summary>
            <p>Gets a font given its zero-based index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <param name = "font"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.Font3"/></strong> interface for the newly created font object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. </p><p>This method returns <strong>DWRITE_E_REMOTEFONT</strong> if it could not construct a remote font.</p></returns>
            <doc-id>dn894595</doc-id>
            <unmanaged>HRESULT IDWriteFontList1::GetFont([In] unsigned int listIndex,[Out] IDWriteFont3** font)</unmanaged>
            <unmanaged-short>IDWriteFontList1::GetFont</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontList1.GetFontFaceReference(System.Int32,SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Gets a font face reference given its zero-based index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font in the font list.</p> </dd></param>
            <param name = "fontFaceReference"><dd>  <p>A reference to a memory block that receives a reference to a <strong><see cref = "T:SharpDX.DirectWrite.FontFaceReference"/></strong> interface for the newly created font face reference object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900385</doc-id>
            <unmanaged>HRESULT IDWriteFontList1::GetFontFaceReference([In] unsigned int listIndex,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFontList1::GetFontFaceReference</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.FontSet.FontCount">
            <summary>
            <p>Get the number of total fonts in the set.</p>
            </summary>
            <doc-id>dn933243</doc-id>
            <unmanaged>GetFontCount</unmanaged>
            <unmanaged-short>GetFontCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetFontCount">
            <summary>
            <p>Get the number of total fonts in the set.</p>
            </summary>
            <returns><p>Returns the number of total fonts in the set.</p></returns>
            <doc-id>dn933243</doc-id>
            <unmanaged>unsigned int IDWriteFontSet::GetFontCount()</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetFontCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetFontFaceReference(System.Int32,SharpDX.DirectWrite.FontFaceReference@)">
            <summary>
            <p>Gets a reference to the font at the specified index, which may be local or remote.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the font.</p> </dd></param>
            <param name = "fontFaceReference"><dd>  <p>Receives a reference the font face reference object, or nullptr on failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933244</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetFontFaceReference([In] unsigned int listIndex,[Out] IDWriteFontFaceReference** fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.FindFontFaceReference(SharpDX.DirectWrite.FontFaceReference,System.Int32@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets the index of the matching font face reference in the font set, with the same file, face index, and simulations.</p>
            </summary>
            <param name = "fontFaceReference"><dd>  <p>Font face object that specifies the physical font.</p> </dd></param>
            <param name = "listIndex"><dd>  <p>Receives the zero-based index of the matching font if the font was found, or UINT_MAX otherwise.</p> </dd></param>
            <param name = "exists"><dd>  <p>Receives TRUE if the font exists or <see cref = "F:SharpDX.Result.False"/> otherwise.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn958414</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::FindFontFaceReference([In] IDWriteFontFaceReference* fontFaceReference,[Out] unsigned int* listIndex,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFontSet::FindFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.FindFontFace(SharpDX.DirectWrite.FontFace,System.Int32@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Gets the index of the matching font face reference in the font set, with the same file, face index, and simulations.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>Font face object that specifies the physical font.</p> </dd></param>
            <param name = "listIndex"><dd>  <p>Receives the zero-based index of the matching font if the font was found, or UINT_MAX otherwise.</p> </dd></param>
            <param name = "exists"><dd>  <p>Receives TRUE if the font exists or <see cref = "F:SharpDX.Result.False"/> otherwise.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933242</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::FindFontFace([In] IDWriteFontFace* fontFace,[Out] unsigned int* listIndex,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteFontSet::FindFontFace</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetPropertyValues(SharpDX.DirectWrite.FontPropertyId,SharpDX.DirectWrite.StringList@)">
            <summary>
            <p>Returns all unique property values in the set, which can be used for purposes such as displaying a family list or tag cloud. Values are returned in priority order according to the language list, such that if a font contains more than one localized name, the preferred one will be returned.</p>
            </summary>
            <param name = "propertyID"><dd>  <p>Font property of interest.</p> </dd></param>
            <param name = "values"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933250</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetPropertyValues([In] DWRITE_FONT_PROPERTY_ID propertyID,[Out] IDWriteStringList** values)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetPropertyValues</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetPropertyValues(SharpDX.DirectWrite.FontPropertyId,System.String,SharpDX.DirectWrite.StringList@)">
            <summary>
            <p>Returns all unique property values in the set, which can be used for purposes such as displaying a family list or tag cloud. Values are returned in priority order according to the language list, such that if a font contains more than one localized name, the preferred one will be returned.</p>
            </summary>
            <param name = "propertyID"><dd>  <p>Font property of interest.</p> </dd></param>
            <param name = "referredLocaleNamesRef"><dd>  <p>List of semicolon delimited language names in preferred order. When a particular string like font family has more than one localized name, the first match is returned. For example, suppose the font set includes the Meiryo family, which has both Japanese and English family names. The returned list of distinct family names would include either the Japanese name (if "ja-jp" was specified as a preferred locale) or the English name (in all other cases). </p> </dd></param>
            <param name = "values"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933250</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetPropertyValues([In] DWRITE_FONT_PROPERTY_ID propertyID,[In] const wchar_t* preferredLocaleNames,[Out] IDWriteStringList** values)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetPropertyValues</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetPropertyValues(System.Int32,SharpDX.DirectWrite.FontPropertyId,SharpDX.Mathematics.Interop.RawBool@,SharpDX.DirectWrite.LocalizedStrings@)">
            <summary>
            <p>Returns all unique property values in the set, which can be used for purposes such as displaying a family list or tag cloud. Values are returned in priority order according to the language list, such that if a font contains more than one localized name, the preferred one will be returned.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Font property of interest.</p> </dd></param>
            <param name = "propertyId"><dd>  <p>List of semicolon delimited language names in preferred order. When a particular string like font family has more than one localized name, the first match is returned. For example, suppose the font set includes the Meiryo family, which has both Japanese and English family names. The returned list of distinct family names would include either the Japanese name (if "ja-jp" was specified as a preferred locale) or the English name (in all other cases). </p> </dd></param>
            <param name = "exists"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
            <param name = "values"><dd>  <p>Receives a reference to the newly created strings list.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933250</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetPropertyValues([In] unsigned int listIndex,[In] DWRITE_FONT_PROPERTY_ID propertyId,[Out] BOOL* exists,[Out, Optional] IDWriteLocalizedStrings** values)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetPropertyValues</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetPropertyOccurrenceCount(SharpDX.DirectWrite.FontProperty@,System.Int32@)">
            <summary>
            <p>Returns how many times a given property value occurs in the set.</p>
            </summary>
            <param name = "ropertyRef"><dd>  <p>Font property of interest.</p> </dd></param>
            <param name = "ropertyOccurrenceCountRef"><dd>  <p>Receives how many times the property occurs.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933248</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetPropertyOccurrenceCount([In] const DWRITE_FONT_PROPERTY* property,[Out] unsigned int* propertyOccurrenceCount)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetPropertyOccurrenceCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetMatchingFonts(System.String,SharpDX.DirectWrite.FontWeight,SharpDX.DirectWrite.FontStretch,SharpDX.DirectWrite.FontStyle,SharpDX.DirectWrite.FontSet@)">
            <summary>
            <p>Returns a subset of fonts filtered by the given properties.</p>
            </summary>
            <param name = "familyName"><dd>  <p>List of properties to filter using.</p> </dd></param>
            <param name = "fontWeight"><dd>  <p>The number of properties to filter.</p> </dd></param>
            <param name = "fontStretch"><dd>  <p>The subset of fonts that match the properties, or nullptr on failure.</p> </dd></param>
            <param name = "fontStyle">No documentation.</param>
            <param name = "filteredSet"><dd>  <p>The subset of fonts that match the properties, or nullptr on failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If no fonts matched the filter, the subset will be empty (GetFontCount returns 0), but the function does not return an error. The subset will always be equal to or less than the original set. If you only want to filter out remote fonts, you may pass null in properties and zero in propertyCount. </p>
            </remarks>
            <doc-id>dn933245</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetMatchingFonts([In] const wchar_t* familyName,[In] DWRITE_FONT_WEIGHT fontWeight,[In] DWRITE_FONT_STRETCH fontStretch,[In] DWRITE_FONT_STYLE fontStyle,[Out] IDWriteFontSet** filteredSet)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetMatchingFonts</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSet.GetMatchingFonts(SharpDX.DirectWrite.FontProperty[],System.Int32,SharpDX.DirectWrite.FontSet@)">
            <summary>
            <p>Returns a subset of fonts filtered by the given properties.</p>
            </summary>
            <param name = "ropertiesRef"><dd>  <p>List of properties to filter using.</p> </dd></param>
            <param name = "propertyCount"><dd>  <p>The number of properties to filter.</p> </dd></param>
            <param name = "filteredSet"><dd>  <p>The subset of fonts that match the properties, or nullptr on failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If no fonts matched the filter, the subset will be empty (GetFontCount returns 0), but the function does not return an error. The subset will always be equal to or less than the original set. If you only want to filter out remote fonts, you may pass null in properties and zero in propertyCount. </p>
            </remarks>
            <doc-id>dn933245</doc-id>
            <unmanaged>HRESULT IDWriteFontSet::GetMatchingFonts([In, Buffer] const DWRITE_FONT_PROPERTY* properties,[In] unsigned int propertyCount,[Out] IDWriteFontSet** filteredSet)</unmanaged>
            <unmanaged-short>IDWriteFontSet::GetMatchingFonts</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSetBuilder.AddFontFaceReference(SharpDX.DirectWrite.FontFaceReference,SharpDX.DirectWrite.FontProperty[],System.Int32)">
            <summary>
            <p>Adds a reference to a font to the set being built. The caller supplies enough information to search on, avoiding the need to open the potentially non-local font. Any properties not supplied by the caller will be missing, and those properties will not be available as filters in GetMatchingFonts. GetPropertyValues for missing properties will return an empty string list. The properties passed should generally be consistent with the actual font contents, but they need not be. You could, for example, alias a font using a different name or unique identifier, or you could set custom tags not present in the actual font.</p>
            </summary>
            <param name = "fontFaceReference"><dd>  <p>Reference to the font.</p> </dd></param>
            <param name = "ropertiesRef"><dd>  <p>List of properties to associate with the reference.</p> </dd></param>
            <param name = "propertyCount"><dd>  <p>The number of properties defined.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933238</doc-id>
            <unmanaged>HRESULT IDWriteFontSetBuilder::AddFontFaceReference([In] IDWriteFontFaceReference* fontFaceReference,[In, Buffer] const DWRITE_FONT_PROPERTY* properties,[In] unsigned int propertyCount)</unmanaged>
            <unmanaged-short>IDWriteFontSetBuilder::AddFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSetBuilder.AddFontFaceReference(SharpDX.DirectWrite.FontFaceReference)">
            <summary>
            <p>Adds a reference to a font to the set being built. The caller supplies enough information to search on, avoiding the need to open the potentially non-local font. Any properties not supplied by the caller will be missing, and those properties will not be available as filters in GetMatchingFonts. GetPropertyValues for missing properties will return an empty string list. The properties passed should generally be consistent with the actual font contents, but they need not be. You could, for example, alias a font using a different name or unique identifier, or you could set custom tags not present in the actual font.</p>
            </summary>
            <param name = "fontFaceReference"><dd>  <p>Reference to the font.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933238</doc-id>
            <unmanaged>HRESULT IDWriteFontSetBuilder::AddFontFaceReference([In] IDWriteFontFaceReference* fontFaceReference)</unmanaged>
            <unmanaged-short>IDWriteFontSetBuilder::AddFontFaceReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSetBuilder.AddFontSet(SharpDX.DirectWrite.FontSet)">
            <summary>
            <p>Appends an existing font set to the one being built, allowing one to aggregate two sets or to essentially extend an existing one.</p>
            </summary>
            <param name = "fontSet"><dd>  <p>Font set to append font face references from.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn933240</doc-id>
            <unmanaged>HRESULT IDWriteFontSetBuilder::AddFontSet([In] IDWriteFontSet* fontSet)</unmanaged>
            <unmanaged-short>IDWriteFontSetBuilder::AddFontSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSetBuilder.CreateFontSet(SharpDX.DirectWrite.FontSet@)">
            <summary>
            <p>Creates a font set from all the font face references added so far with AddFontFaceReference.</p>
            </summary>
            <param name = "fontSet"><dd>  <p>Contains the newly created font set object, or nullptr in case of failure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Creating a font set takes less time if the references were added with metadata rather than needing to extract the metadata from the font file.</p>
            </remarks>
            <doc-id>dn933241</doc-id>
            <unmanaged>HRESULT IDWriteFontSetBuilder::CreateFontSet([Out] IDWriteFontSet** fontSet)</unmanaged>
            <unmanaged-short>IDWriteFontSetBuilder::CreateFontSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.FontSetBuilder1.AddFontFile(SharpDX.DirectWrite.FontFile)">
            <summary>
            No documentation.
            </summary>
            <param name = "fontFile">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteFontSetBuilder1::AddFontFile([In] IDWriteFontFile* fontFile)</unmanaged>
            <unmanaged-short>IDWriteFontSetBuilder1::AddFontFile</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop1.CreateFontFromLOGFONT(System.IntPtr,SharpDX.DirectWrite.FontCollection)">
            <summary>
            <p>Creates a font object that matches the properties specified by the <see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/> structure.</p>
            </summary>
            <param name = "logFont"><dd>  <p>Structure containing a GDI-compatible font description.</p> </dd></param>
            <param name = "fontCollection"><dd>  <p>The font collection to search. If <c>null</c>, the local system font collection is used.</p> </dd></param>
            <returns><dd>  <p>Receives a newly created font object if successful, or <c>null</c> in case of error.</p> </dd></returns>
            <doc-id>dn958416</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop1::CreateFontFromLOGFONT([In] const void* logFont,[In, Optional] IDWriteFontCollection* fontCollection,[Out] IDWriteFont** font)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop1::CreateFontFromLOGFONT</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop1.GetFontSignature(SharpDX.DirectWrite.FontFace)">
            <summary>
            <p>Reads the font signature from the given font face.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>Font face to read font signature from.</p> </dd></param>
            <returns><dd>  <p>Font signature from the OS/2 table, ulUnicodeRange and ulCodePageRange.</p> </dd></returns>
            <doc-id>dn958418</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop1::GetFontSignature([In] IDWriteFontFace* fontFace,[Out] FONTSIGNATURE* fontSignature)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop1::GetFontSignature</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop1.GetFontSignature(SharpDX.DirectWrite.Font)">
            <summary>
            <p>Reads the font signature from the given font face.</p>
            </summary>
            <param name = "font"><dd>  <p>Font face to read font signature from.</p> </dd></param>
            <returns><dd>  <p>Font signature from the OS/2 table, ulUnicodeRange and ulCodePageRange.</p> </dd></returns>
            <doc-id>dn958418</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop1::GetFontSignature([In] IDWriteFont* font,[Out] FONTSIGNATURE* fontSignature)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop1::GetFontSignature</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.GdiInterop1.GetMatchingFontsByLOGFONT(System.IntPtr,SharpDX.DirectWrite.FontSet,SharpDX.DirectWrite.FontSet@)">
            <summary>
            <p>Gets a list of matching fonts based on the specified <see cref = "T:SharpDX.DirectWrite.GdiInterop.LogFont"/> values. Only fonts of that family name will be returned.</p>
            </summary>
            <param name = "logFont"><dd>  <p>Structure containing a GDI-compatible font description.</p> </dd></param>
            <param name = "fontSet"><dd>  <p>The font set to search.</p> </dd></param>
            <param name = "filteredSet"><dd>  <p>&gt;Receives the filtered font set if successful.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn958420</doc-id>
            <unmanaged>HRESULT IDWriteGdiInterop1::GetMatchingFontsByLOGFONT([In] const void* logFont,[In] IDWriteFontSet* fontSet,[Out] IDWriteFontSet** filteredSet)</unmanaged>
            <unmanaged-short>IDWriteGdiInterop1::GetMatchingFontsByLOGFONT</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.InMemoryFontFileLoader.FileCount">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetFileCount</unmanaged>
            <unmanaged-short>GetFileCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.InMemoryFontFileLoader.CreateInMemoryFontFileReference(SharpDX.DirectWrite.Factory,System.IntPtr,System.Int32,SharpDX.IUnknown,SharpDX.DirectWrite.FontFile@)">
            <summary>
            No documentation.
            </summary>
            <param name = "factory">No documentation.</param>
            <param name = "fontData">No documentation.</param>
            <param name = "fontDataSize">No documentation.</param>
            <param name = "ownerObject">No documentation.</param>
            <param name = "fontFile">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference([In] IDWriteFactory* factory,[In, Buffer] const void* fontData,[In] unsigned int fontDataSize,[In, Optional] IUnknown* ownerObject,[Out] IDWriteFontFile** fontFile)</unmanaged>
            <unmanaged-short>IDWriteInMemoryFontFileLoader::CreateInMemoryFontFileReference</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.InMemoryFontFileLoader.GetFileCount">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>unsigned int IDWriteInMemoryFontFileLoader::GetFileCount()</unmanaged>
            <unmanaged-short>IDWriteInMemoryFontFileLoader::GetFileCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileLoader.CreateRemoteStreamFromKey(System.IntPtr,System.Int32,SharpDX.DirectWrite.RemoteFontFileStream@)">
            <summary>
            No documentation.
            </summary>
            <param name = "fontFileReferenceKey">No documentation.</param>
            <param name = "fontFileReferenceKeySize">No documentation.</param>
            <param name = "fontFileStream">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteRemoteFontFileLoader::CreateRemoteStreamFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] IDWriteRemoteFontFileStream** fontFileStream)</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileLoader::CreateRemoteStreamFromKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileLoader.GetLocalityFromKey(System.IntPtr,System.Int32,SharpDX.DirectWrite.Locality@)">
            <summary>
            No documentation.
            </summary>
            <param name = "fontFileReferenceKey">No documentation.</param>
            <param name = "fontFileReferenceKeySize">No documentation.</param>
            <param name = "locality">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteRemoteFontFileLoader::GetLocalityFromKey([In, Buffer] const void* fontFileReferenceKey,[In] unsigned int fontFileReferenceKeySize,[Out] DWRITE_LOCALITY* locality)</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileLoader::GetLocalityFromKey</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileLoader.CreateFontFileReferenceFromUrl(SharpDX.DirectWrite.Factory,System.String,System.String,SharpDX.DirectWrite.FontFile@)">
            <summary>
            No documentation.
            </summary>
            <param name = "factory">No documentation.</param>
            <param name = "baseUrl">No documentation.</param>
            <param name = "fontFileUrl">No documentation.</param>
            <param name = "fontFile">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteRemoteFontFileLoader::CreateFontFileReferenceFromUrl([In] IDWriteFactory* factory,[In, Optional] const wchar_t* baseUrl,[In] const wchar_t* fontFileUrl,[Out] IDWriteFontFile** fontFile)</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileLoader::CreateFontFileReferenceFromUrl</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RemoteFontFileStream.LocalFileSize">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetLocalFileSize</unmanaged>
            <unmanaged-short>GetLocalFileSize</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RemoteFontFileStream.Locality">
            <summary>
            No documentation.
            </summary>
            <unmanaged>GetLocality</unmanaged>
            <unmanaged-short>GetLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileStream.GetLocalFileSize(System.Int64@)">
            <summary>
            No documentation.
            </summary>
            <param name = "localFileSize">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteRemoteFontFileStream::GetLocalFileSize([Out] unsigned longlong* localFileSize)</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileStream::GetLocalFileSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileStream.GetFileFragmentLocality(System.Int64,System.Int64,SharpDX.Mathematics.Interop.RawBool@,System.Int64)">
            <summary>
            No documentation.
            </summary>
            <param name = "fileOffset">No documentation.</param>
            <param name = "fragmentSize">No documentation.</param>
            <param name = "isLocal">No documentation.</param>
            <param name = "artialSizeRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteRemoteFontFileStream::GetFileFragmentLocality([In] unsigned longlong fileOffset,[In] unsigned longlong fragmentSize,[Out] BOOL* isLocal,[In] unsigned longlong* partialSize)</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileStream::GetFileFragmentLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileStream.GetLocality">
            <summary>
            No documentation.
            </summary>
            <returns>No documentation.</returns>
            <unmanaged>DWRITE_LOCALITY IDWriteRemoteFontFileStream::GetLocality()</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileStream::GetLocality</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RemoteFontFileStream.BeginDownload(System.Guid,SharpDX.DirectWrite.FileFragment[],System.Int32)">
            <summary>
            No documentation.
            </summary>
            <param name = "downloadOperationID">No documentation.</param>
            <param name = "fileFragments">No documentation.</param>
            <param name = "fragmentCount">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IDWriteRemoteFontFileStream::BeginDownload([In] const GUID* downloadOperationID,[In, Buffer] const DWRITE_FILE_FRAGMENT* fileFragments,[In] unsigned int fragmentCount,[Out, Optional] IDWriteAsyncResult** asyncResult)</unmanaged>
            <unmanaged-short>IDWriteRemoteFontFileStream::BeginDownload</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams1.GrayscaleEnhancedContrast">
            <summary>
            <p>Gets the amount of contrast enhancement to use for grayscale antialiasing.</p>
            </summary>
            <doc-id>hh780423</doc-id>
            <unmanaged>GetGrayscaleEnhancedContrast</unmanaged>
            <unmanaged-short>GetGrayscaleEnhancedContrast</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams1.GetGrayscaleEnhancedContrast">
            <summary>
            <p>Gets the amount of contrast enhancement to use for grayscale antialiasing.</p>
            </summary>
            <returns><p>The contrast enhancement value. Valid values are greater than or equal to zero.</p></returns>
            <doc-id>hh780423</doc-id>
            <unmanaged>float IDWriteRenderingParams1::GetGrayscaleEnhancedContrast()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams1::GetGrayscaleEnhancedContrast</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams2.GridFitMode">
            <summary>
            <p>Gets the grid fitting mode.</p>
            </summary>
            <doc-id>dn900388</doc-id>
            <unmanaged>GetGridFitMode</unmanaged>
            <unmanaged-short>GetGridFitMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams2.GetGridFitMode">
            <summary>
            <p>Gets the grid fitting mode.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.GridFitMode"/></strong>-typed value for the grid fitting mode.</p></returns>
            <doc-id>dn900388</doc-id>
            <unmanaged>DWRITE_GRID_FIT_MODE IDWriteRenderingParams2::GetGridFitMode()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams2::GetGridFitMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.RenderingParams3.RenderingMode1">
            <summary>
            <p>Gets the rendering mode.</p>
            </summary>
            <doc-id>dn900390</doc-id>
            <unmanaged>GetRenderingMode1</unmanaged>
            <unmanaged-short>GetRenderingMode1</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.RenderingParams3.GetRenderingMode1">
            <summary>
            <p>Gets the rendering mode.</p>
            </summary>
            <returns><p>Returns a <strong><see cref = "T:SharpDX.DirectWrite.RenderingMode1"/></strong>-typed value for the rendering mode.</p></returns>
            <doc-id>dn900390</doc-id>
            <unmanaged>DWRITE_RENDERING_MODE1 IDWriteRenderingParams3::GetRenderingMode1()</unmanaged>
            <unmanaged-short>IDWriteRenderingParams3::GetRenderingMode1</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.StringList.Count">
            <summary>
            <p>Gets the number of strings in the string list.</p>
            </summary>
            <doc-id>dn958422</doc-id>
            <unmanaged>GetCount</unmanaged>
            <unmanaged-short>GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.StringList.GetCount">
            <summary>
            <p>Gets the number of strings in the string list.</p>
            </summary>
            <returns><p>Returns the number of strings in the string list.</p></returns>
            <doc-id>dn958422</doc-id>
            <unmanaged>unsigned int IDWriteStringList::GetCount()</unmanaged>
            <unmanaged-short>IDWriteStringList::GetCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.StringList.GetLocaleNameLength(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the length in characters (not including the null terminator) of the locale name with the specified index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the locale name.</p> </dd></param>
            <param name = "length"><dd>  <p>Receives the length in characters, not including the null terminator.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn958424</doc-id>
            <unmanaged>HRESULT IDWriteStringList::GetLocaleNameLength([In] unsigned int listIndex,[Out] unsigned int* length)</unmanaged>
            <unmanaged-short>IDWriteStringList::GetLocaleNameLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.StringList.GetLocaleName(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <p>Copies the locale name with the specified index to the specified array.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the locale name.</p> </dd></param>
            <param name = "localeName"><dd>  <p>Character array that receives the locale name.</p> </dd></param>
            <param name = "size"><dd>  <p>Size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn958423</doc-id>
            <unmanaged>HRESULT IDWriteStringList::GetLocaleName([In] unsigned int listIndex,[Out, Buffer] wchar_t* localeName,[In] unsigned int size)</unmanaged>
            <unmanaged-short>IDWriteStringList::GetLocaleName</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.StringList.GetStringLength(System.Int32,System.Int32@)">
            <summary>
            <p>Gets the length in characters (not including the null terminator) of the string with the specified index.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the string.</p> </dd></param>
            <param name = "length"><dd>  <p>Receives the length in characters of the string, not including the null terminator.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn958426</doc-id>
            <unmanaged>HRESULT IDWriteStringList::GetStringLength([In] unsigned int listIndex,[Out] unsigned int* length)</unmanaged>
            <unmanaged-short>IDWriteStringList::GetStringLength</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.StringList.GetString(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <p>Copies the string with the specified index to the specified array.</p>
            </summary>
            <param name = "listIndex"><dd>  <p>Zero-based index of the string.</p> </dd></param>
            <param name = "stringBuffer"><dd>  <p>Character array that receives the string.</p> </dd></param>
            <param name = "stringBufferSize"><dd>  <p>Size of the array in characters. The size must include space for the terminating null character.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn958425</doc-id>
            <unmanaged>HRESULT IDWriteStringList::GetString([In] unsigned int listIndex,[Out, Buffer] wchar_t* stringBuffer,[In] unsigned int stringBufferSize)</unmanaged>
            <unmanaged-short>IDWriteStringList::GetString</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.ApplyCharacterSpacing(System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Int16[],System.Single[],SharpDX.DirectWrite.GlyphOffset[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            <p>Applies spacing between characters, properly adjusting glyph clusters and diacritics.</p>
            </summary>
            <param name = "leadingSpacing"><dd> <p>The spacing before each character, in reading order.</p> </dd></param>
            <param name = "trailingSpacing"><dd> <p>The spacing after each character, in reading order.</p> </dd></param>
            <param name = "minimumAdvanceWidth"><dd> <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>
            <param name = "textLength"><dd> <p>The length of the clustermap and original text.</p> </dd></param>
            <param name = "glyphCount"><dd> <p>The number of glyphs.</p> </dd></param>
            <param name = "clusterMap"><dd> <p>Mapping from character ranges to glyph ranges.</p> </dd></param>
            <param name = "glyphAdvances"><dd> <p>The advance width of each glyph.</p> </dd></param>
            <param name = "glyphOffsets"><dd> <p>The offset of the origin of each glyph.</p> </dd></param>
            <param name = "glyphProperties"><dd> <p>Properties of each glyph, from GetGlyphs.</p> </dd></param>
            <param name = "modifiedGlyphAdvances"><dd> <p>The new advance width of each glyph.</p> </dd></param>
            <param name = "modifiedGlyphOffsets"><dd> <p>The new offset of the origin of each glyph.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The input and output advances/offsets are allowed to alias the same array.</p>
            </remarks>
            <doc-id>hh780430</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::ApplyCharacterSpacing([In] float leadingSpacing,[In] float trailingSpacing,[In] float minimumAdvanceWidth,[In] unsigned int textLength,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] const float* glyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* glyphOffsets,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[Out, Buffer] float* modifiedGlyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::ApplyCharacterSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.GetBaseline(SharpDX.DirectWrite.FontFace,SharpDX.DirectWrite.Baseline,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.ScriptAnalysis,System.String,System.Int32@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves the given baseline from the font.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>The font face to read.</p> </dd></param>
            <param name = "baseline"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.Baseline"/></strong>-typed value that specifies the baseline of interest.</p> </dd></param>
            <param name = "isVertical"><dd>  <p>Whether the baseline is vertical or horizontal.</p> </dd></param>
            <param name = "isSimulationAllowed"><dd>  <p>Simulate the baseline if it is missing in the font.</p> </dd></param>
            <param name = "scriptAnalysis"><dd>  <p>Script analysis result from AnalyzeScript.</p> <strong>Note</strong>??You can pass an empty script analysis structure, like this <code><see cref = "T:SharpDX.DirectWrite.ScriptAnalysis"/> scriptAnalysis = {};</code>, and this method will return the default baseline. ? </dd></param>
            <param name = "localeName"><dd>  <p>The language of the run.</p> </dd></param>
            <param name = "baselineCoordinate"><dd>  <p>The baseline coordinate value in design units.</p> </dd></param>
            <param name = "exists"><dd>  <p>Whether the returned baseline exists in the font.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the baseline does not exist in the font, it is not considered an error, but the function will return exists = false. You may then use heuristics to calculate the missing base, or, if the flag simulationAllowed is true, the function will compute a reasonable approximation for you.</p>
            </remarks>
            <doc-id>hh780431</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::GetBaseline([In] IDWriteFontFace* fontFace,[In] DWRITE_BASELINE baseline,[In] BOOL isVertical,[In] BOOL isSimulationAllowed,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[Out] int* baselineCoordinate,[Out] BOOL* exists)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::GetBaseline</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.AnalyzeVerticalGlyphOrientation(SharpDX.DirectWrite.TextAnalysisSource1,System.Int32,System.Int32,SharpDX.DirectWrite.TextAnalysisSink1)">
            <summary>
            <p>Analyzes a text range for script orientation, reading text and attributes from the source and reporting results to the sink callback <strong>SetGlyphOrientation</strong>.</p>
            </summary>
            <param name = "analysisSource">No documentation.</param>
            <param name = "textPosition">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "analysisSink">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh780429</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation([In] IDWriteTextAnalysisSource1* analysisSource,[In] unsigned int textPosition,[In] unsigned int textLength,[In] IDWriteTextAnalysisSink1* analysisSink)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::AnalyzeVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.GetGlyphOrientationTransform(SharpDX.DirectWrite.GlyphOrientationAngle,SharpDX.Mathematics.Interop.RawBool,SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Returns 2x3 transform matrix for the respective angle to draw the glyph run.</p>
            </summary>
            <param name = "glyphOrientationAngle"><dd>  <p>A <strong><see cref = "T:SharpDX.DirectWrite.GlyphOrientationAngle"/></strong>-typed value that specifies the angle that was reported into <strong>IDWriteTextAnalysisSink1::SetGlyphOrientation</strong>.</p> </dd></param>
            <param name = "isSideways"><dd>  <p>Whether the run's glyphs are sideways or not.</p> </dd></param>
            <param name = "transform"><dd>  <p>Returned transform.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The translation component of the transform returned is zero.</p>
            </remarks>
            <doc-id>hh780432</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::GetGlyphOrientationTransform([In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] BOOL isSideways,[Out] DWRITE_MATRIX* transform)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::GetGlyphOrientationTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.GetScriptProperties(SharpDX.DirectWrite.ScriptAnalysis,SharpDX.DirectWrite.ScriptProperties@)">
            <summary>
            <p>Retrieves the properties for a given script.</p>
            </summary>
            <param name = "scriptAnalysis"><dd>  <p>The script for a run of text returned from <strong>IDWriteTextAnalyzer::AnalyzeScript</strong>.</p> </dd></param>
            <param name = "scriptProperties"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.ScriptProperties"/></strong> structure that describes info for the script.</p> </dd></param>
            <returns><p>Returns properties for the given script. If the script is invalid, it returns generic properties for the unknown script and E_INVALIDARG.</p></returns>
            <doc-id>hh780435</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::GetScriptProperties([In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[Out] DWRITE_SCRIPT_PROPERTIES* scriptProperties)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::GetScriptProperties</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.GetTextComplexity(System.String,System.Int32,SharpDX.DirectWrite.FontFace,SharpDX.Mathematics.Interop.RawBool@,System.Int32,System.Int16[])">
            <summary>
            <p>Determines the complexity of text, and whether you need to call <strong>IDWriteTextAnalyzer::GetGlyphs</strong> for full script shaping. </p>
            </summary>
            <param name = "textString">No documentation.</param>
            <param name = "textLength">No documentation.</param>
            <param name = "fontFace">No documentation.</param>
            <param name = "isTextSimple">No documentation.</param>
            <param name = "textLengthRead">No documentation.</param>
            <param name = "glyphIndices">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Text is not simple if the characters are part of a script that has complex shaping requirements, require bidi analysis, combine with other characters, reside in the supplementary planes, or have glyphs that participate in standard OpenType features. The length returned will not split combining marks from their base characters.</p>
            </remarks>
            <doc-id>hh780436</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::GetTextComplexity([In, Buffer] const wchar_t* textString,[In] unsigned int textLength,[In] IDWriteFontFace* fontFace,[Out] BOOL* isTextSimple,[In] unsigned int* textLengthRead,[Out, Buffer, Optional] unsigned short* glyphIndices)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::GetTextComplexity</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.GetJustificationOpportunities(SharpDX.DirectWrite.FontFace,System.Single,SharpDX.DirectWrite.ScriptAnalysis,System.Int32,System.Int32,System.String,System.Int16[],SharpDX.DirectWrite.ShapingGlyphProperties[],SharpDX.DirectWrite.JustificationOpportunity[])">
            <summary>
            <p>Retrieves justification opportunity information for each of the glyphs given the text and shaping glyph properties.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>Font face that was used for shaping. This is mainly important for returning correct results of the kashida width. </p> <p>May be <c>null</c>. </p> </dd></param>
            <param name = "fontEmSize"><dd>  <p>Font em size used for the glyph run.</p> </dd></param>
            <param name = "scriptAnalysis"><dd>  <p>Script of the text from the itemizer.</p> </dd></param>
            <param name = "textLength"><dd>  <p>Length of the text.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>Number of glyphs.</p> </dd></param>
            <param name = "textString"><dd>  <p>Characters used to produce the glyphs.</p> </dd></param>
            <param name = "clusterMap"><dd>  <p>Clustermap produced from shaping.</p> </dd></param>
            <param name = "glyphProperties"><dd>  <p>Glyph properties produced from shaping.</p> </dd></param>
            <param name = "justificationOpportunities"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure that receives info for the allowed justification expansion/compression for each glyph.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function is called per-run, after shaping is done via the <strong>IDWriteTextAnalyzer::GetGlyphs</strong> method. </p><strong>Note</strong>??this function only supports natural metrics (<strong>DWRITE_MEASURING_MODE_NATURAL</strong>).?
            </remarks>
            <doc-id>hh780433</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::GetJustificationOpportunities([In, Optional] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In] unsigned int textLength,[In] unsigned int glyphCount,[In, Buffer] const wchar_t* textString,[In, Buffer] const unsigned short* clusterMap,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[Out, Buffer] DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::GetJustificationOpportunities</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.JustifyGlyphAdvances(System.Single,System.Int32,SharpDX.DirectWrite.JustificationOpportunity[],System.Single[],SharpDX.DirectWrite.GlyphOffset[],System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            <p>Justifies an array of glyph advances to fit the line width.</p>
            </summary>
            <param name = "lineWidth"><dd>  <p>The line width.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>The glyph count.</p> </dd></param>
            <param name = "justificationOpportunities"><dd>  <p>A reference to a <strong><see cref = "T:SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure that contains info for the allowed justification expansion/compression for each glyph. Get this info from <strong>IDWriteTextAnalyzer1::GetJustificationOpportunities</strong>. </p> </dd></param>
            <param name = "glyphAdvances"><dd>  <p>An array of glyph advances.</p> </dd></param>
            <param name = "glyphOffsets"><dd>  <p>An array of glyph offsets.</p> </dd></param>
            <param name = "justifiedGlyphAdvances"><dd>  <p>The returned array of justified glyph advances.</p> </dd></param>
            <param name = "justifiedGlyphOffsets"><dd>  <p>The returned array of justified glyph offsets.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You call  <strong>JustifyGlyphAdvances</strong> after you call <strong>IDWriteTextAnalyzer1::GetJustificationOpportunities</strong> to collect all the opportunities, and <strong>JustifyGlyphAdvances</strong> spans across the entire line. The input and output arrays are allowed to alias each other, permitting in-place update.</p>
            </remarks>
            <doc-id>hh780437</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::JustifyGlyphAdvances([In] float lineWidth,[In] unsigned int glyphCount,[In, Buffer] const DWRITE_JUSTIFICATION_OPPORTUNITY* justificationOpportunities,[In, Buffer] const float* glyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* glyphOffsets,[Out, Buffer] float* justifiedGlyphAdvances,[Out, Buffer, Optional] DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::JustifyGlyphAdvances</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer1.GetJustifiedGlyphs(SharpDX.DirectWrite.FontFace,System.Single,SharpDX.DirectWrite.ScriptAnalysis,System.Int32,System.Int32,System.Int32,System.Int16[],System.Int16[],System.Single[],System.Single[],SharpDX.DirectWrite.GlyphOffset[],SharpDX.DirectWrite.ShapingGlyphProperties[],System.Int32,System.Int16[],System.Int16[],System.Single[],SharpDX.DirectWrite.GlyphOffset[])">
            <summary>
            <p>Fills in new glyphs for complex scripts where justification increased the advances of glyphs, such as Arabic with kashida.</p>
            </summary>
            <param name = "fontFace"><dd>  <p>Font face used for shaping.</p> <p>May be <c>null</c>.</p> </dd></param>
            <param name = "fontEmSize"><dd>  <p>Font em size used for the glyph run.</p> </dd></param>
            <param name = "scriptAnalysis"><dd>  <p>Script of the text from the itemizer.</p> </dd></param>
            <param name = "textLength"><dd>  <p>Length of the text.</p> </dd></param>
            <param name = "glyphCount"><dd>  <p>Number of glyphs.</p> </dd></param>
            <param name = "maxGlyphCount"><dd>  <p>Maximum number of output glyphs allocated by caller.</p> </dd></param>
            <param name = "clusterMap"><dd>  <p>Clustermap produced from shaping.</p> </dd></param>
            <param name = "glyphIndices"><dd>  <p>Original glyphs produced from shaping.</p> </dd></param>
            <param name = "glyphAdvances"><dd>  <p>Original glyph advances produced from shaping.</p> </dd></param>
            <param name = "justifiedGlyphAdvances"><dd>  <p>Justified glyph advances from <strong>IDWriteTextAnalyzer1::JustifyGlyphAdvances</strong>. </p> </dd></param>
            <param name = "justifiedGlyphOffsets"><dd>  <p>Justified glyph offsets from <strong>IDWriteTextAnalyzer1::JustifyGlyphAdvances</strong>. </p> </dd></param>
            <param name = "glyphProperties"><dd>  <p>Properties of each glyph, from <strong>IDWriteTextAnalyzer::GetGlyphs</strong>. </p> </dd></param>
            <param name = "actualGlyphCount"><dd>  <p>The new glyph count written to the modified arrays, or the needed glyph count if the size is not large enough.</p> </dd></param>
            <param name = "modifiedClusterMap"><dd>  <p>Updated clustermap.</p> </dd></param>
            <param name = "modifiedGlyphIndices"><dd>  <p>Updated glyphs with new glyphs inserted where needed.</p> </dd></param>
            <param name = "modifiedGlyphAdvances"><dd>  <p>Updated glyph advances.</p> </dd></param>
            <param name = "modifiedGlyphOffsets"><dd>  <p>Updated glyph offsets.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You call <strong>GetJustifiedGlyphs</strong> after the line has been justified, and it is per-run. </p><p>You should call <strong>GetJustifiedGlyphs</strong> if <strong>IDWriteTextAnalyzer1::GetScriptProperties</strong> returns a non-null <strong><see cref = "T:SharpDX.DirectWrite.ScriptProperties"/>.justificationCharacter</strong> for that script.</p><p> Use  <strong>GetJustifiedGlyphs</strong> mainly for cursive scripts like Arabic. If <em>maxGlyphCount</em> is not large enough, <strong>GetJustifiedGlyphs</strong> returns the error E_NOT_SUFFICIENT_BUFFER and fills the variable  to which <em>actualGlyphCount</em> points with the needed glyph count.</p>
            </remarks>
            <doc-id>hh780434</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer1::GetJustifiedGlyphs([In, Optional] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In] unsigned int textLength,[In] unsigned int glyphCount,[In] unsigned int maxGlyphCount,[In, Buffer, Optional] const unsigned short* clusterMap,[In, Buffer] const unsigned short* glyphIndices,[In, Buffer] const float* glyphAdvances,[In, Buffer] const float* justifiedGlyphAdvances,[In, Buffer] const DWRITE_GLYPH_OFFSET* justifiedGlyphOffsets,[In, Buffer] const DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProperties,[In] unsigned int* actualGlyphCount,[Out, Buffer, Optional] unsigned short* modifiedClusterMap,[Out, Buffer] unsigned short* modifiedGlyphIndices,[Out, Buffer] float* modifiedGlyphAdvances,[Out, Buffer] DWRITE_GLYPH_OFFSET* modifiedGlyphOffsets)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer1::GetJustifiedGlyphs</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer2.GetGlyphOrientationTransform(SharpDX.DirectWrite.GlyphOrientationAngle,SharpDX.Mathematics.Interop.RawBool,System.Single,System.Single,SharpDX.Mathematics.Interop.RawMatrix3x2@)">
            <summary>
            <p>Returns 2x3 transform matrix for the respective angle to draw the glyph run.</p><p>Extends <strong>IDWriteTextAnalyzer1::GetGlyphOrientationTransform</strong> to pass valid values for the baseline origin rather than zeroes.</p>
            </summary>
            <param name = "glyphOrientationAngle">No documentation.</param>
            <param name = "isSideways">No documentation.</param>
            <param name = "originX">No documentation.</param>
            <param name = "originY">No documentation.</param>
            <param name = "transform">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280484</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer2::GetGlyphOrientationTransform([In] DWRITE_GLYPH_ORIENTATION_ANGLE glyphOrientationAngle,[In] BOOL isSideways,[In] float originX,[In] float originY,[Out] DWRITE_MATRIX* transform)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer2::GetGlyphOrientationTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer2.GetTypographicFeatures(SharpDX.DirectWrite.FontFace,SharpDX.DirectWrite.ScriptAnalysis,System.String,System.Int32,System.Int32@,SharpDX.DirectWrite.FontFeatureTag[])">
            <summary>
            <p>Returns a complete list of OpenType features available for a script or font. If a feature is partially supported, then this method indicates that it is supported. </p>
            </summary>
            <param name = "fontFace"><dd>  <p>The font face to get features from.</p> </dd></param>
            <param name = "scriptAnalysis"><dd>  <p>The script analysis for the script or font to check.</p> </dd></param>
            <param name = "localeName"><dd>  <p>The locale name to check.</p> </dd></param>
            <param name = "maxTagCount"><dd>  <p>The maximum number of tags to return.</p> </dd></param>
            <param name = "actualTagCount"><dd>  <p>The actual number of tags returned.</p> </dd></param>
            <param name = "tags"><dd>  <p>An array of OpenType font feature tags.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280456</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer2::GetTypographicFeatures([In] IDWriteFontFace* fontFace,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[In] unsigned int maxTagCount,[Out] unsigned int* actualTagCount,[Out, Buffer] DWRITE_FONT_FEATURE_TAG* tags)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer2::GetTypographicFeatures</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextAnalyzer2.CheckTypographicFeature(SharpDX.DirectWrite.FontFace,SharpDX.DirectWrite.ScriptAnalysis,System.String,SharpDX.DirectWrite.FontFeatureTag,System.Int32,System.Int16[],System.Byte[])">
            <summary>
            <p>Checks if a typographic feature is available for a glyph or a set of glyphs.</p>
            </summary>
            <param name = "fontFace"><dd> <p>The font face to read glyph information from.</p> </dd></param>
            <param name = "scriptAnalysis"><dd> <p>The script analysis for the script or font to check.</p> </dd></param>
            <param name = "localeName"><dd> <p>The locale name to check.</p> </dd></param>
            <param name = "featureTag"><dd> <p>The font feature tag to check.</p> </dd></param>
            <param name = "glyphCount"><dd> <p>The number of glyphs to check.</p> </dd></param>
            <param name = "glyphIndices"><dd> <p>An array of glyph indices to check.</p> </dd></param>
            <param name = "featureApplies"><dd> <p>An array of integers that indicate whether or not the font feature applies to each glyph specified.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280455</doc-id>
            <unmanaged>HRESULT IDWriteTextAnalyzer2::CheckTypographicFeature([In] IDWriteFontFace* fontFace,[In] DWRITE_SCRIPT_ANALYSIS scriptAnalysis,[In, Optional] const wchar_t* localeName,[In] DWRITE_FONT_FEATURE_TAG featureTag,[In] unsigned int glyphCount,[In, Buffer] const unsigned short* glyphIndices,[Out, Buffer] unsigned char* featureApplies)</unmanaged>
            <unmanaged-short>IDWriteTextAnalyzer2::CheckTypographicFeature</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat1.VerticalGlyphOrientation">
            <summary>
            <p>Get or sets the preferred orientation of glyphs when using a vertical reading direction.</p>
            </summary>
            <doc-id>dn894598</doc-id>
            <unmanaged>GetVerticalGlyphOrientation / SetVerticalGlyphOrientation</unmanaged>
            <unmanaged-short>GetVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat1.LastLineWrapping">
            <summary>
            <p>Gets or sets the wrapping mode of the last line.</p>
            </summary>
            <doc-id>dn894596</doc-id>
            <unmanaged>GetLastLineWrapping / SetLastLineWrapping</unmanaged>
            <unmanaged-short>GetLastLineWrapping</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat1.OpticalAlignment">
            <summary>
            <p>Gets or sets the optical margin alignment for the text format.</p>
            </summary>
            <doc-id>dn894597</doc-id>
            <unmanaged>GetOpticalAlignment / SetOpticalAlignment</unmanaged>
            <unmanaged-short>GetOpticalAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat1.FontFallback">
            <summary>
            <p>Gets or sets the current fallback. If none was ever set since creating the layout, it will be nullptr.</p>
            </summary>
            <doc-id>dn280486</doc-id>
            <unmanaged>GetFontFallback / SetFontFallback</unmanaged>
            <unmanaged-short>GetFontFallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.SetVerticalGlyphOrientation(SharpDX.DirectWrite.VerticalGlyphOrientation)">
            <summary>
            <p>Sets the orientation of a text format.</p>
            </summary>
            <param name = "glyphOrientation"><dd>  <p>The orientation to apply to the text format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280489</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat1::SetVerticalGlyphOrientation([In] DWRITE_VERTICAL_GLYPH_ORIENTATION glyphOrientation)</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::SetVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.GetVerticalGlyphOrientation">
            <summary>
            <p>Get the preferred orientation of glyphs when using a vertical reading direction.</p>
            </summary>
            <returns><p>The preferred orientation of glyphs when using a vertical reading direction.</p></returns>
            <doc-id>dn894598</doc-id>
            <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION IDWriteTextFormat1::GetVerticalGlyphOrientation()</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::GetVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.SetLastLineWrapping(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Sets the wrapping mode of the last line.</p>
            </summary>
            <param name = "isLastLineWrappingEnabled"><dd>  <p>If set to <see cref = "F:SharpDX.Result.False"/>, the last line is not wrapped. If set to TRUE, the last line is wrapped.</p> <p>The last line is wrapped by default.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280490</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat1::SetLastLineWrapping([In] BOOL isLastLineWrappingEnabled)</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::SetLastLineWrapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.GetLastLineWrapping">
            <summary>
            <p>Gets the wrapping mode of the last line.</p>
            </summary>
            <returns><p>Returns <see cref = "F:SharpDX.Result.False"/> if the last line is not wrapped; TRUE if the last line is wrapped.</p></returns>
            <doc-id>dn894596</doc-id>
            <unmanaged>BOOL IDWriteTextFormat1::GetLastLineWrapping()</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::GetLastLineWrapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.SetOpticalAlignment(SharpDX.DirectWrite.OptimizationIcalAlignment)">
            <summary>
            <p>Sets the optical margin alignment for the text format.</p><p> By default, glyphs are aligned to the margin by the default origin and side-bearings of the glyph. If you specify <strong>DWRITE_OPTICAL_ALIGNMENT_USING_SIDE_BEARINGS</strong>, then the alignment Suses the side bearings to offset the glyph from the aligned edge to ensure the ink of the glyphs are aligned. </p>
            </summary>
            <param name = "opticalAlignment"><dd> <p>The optical alignment to set.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280488</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat1::SetOpticalAlignment([In] DWRITE_OPTICAL_ALIGNMENT opticalAlignment)</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::SetOpticalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.GetOpticalAlignment">
            <summary>
            <p>Gets the optical margin alignment for the text format.</p>
            </summary>
            <returns><p>The optical alignment.</p></returns>
            <doc-id>dn894597</doc-id>
            <unmanaged>DWRITE_OPTICAL_ALIGNMENT IDWriteTextFormat1::GetOpticalAlignment()</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::GetOpticalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.SetFontFallback(SharpDX.DirectWrite.FontFallback)">
            <summary>
            <p> Applies the custom font fallback onto the layout. If none is set, it uses the default system fallback list. </p>
            </summary>
            <param name = "fontFallback"><dd>  <p>The font fallback to apply to the layout.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280487</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat1::SetFontFallback([In] IDWriteFontFallback* fontFallback)</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::SetFontFallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat1.GetFontFallback(SharpDX.DirectWrite.FontFallback@)">
            <summary>
            <p>Gets the current fallback. If none was ever set since creating the layout, it will be nullptr.</p>
            </summary>
            <param name = "fontFallback"><dd>  <p>Contains an address of a reference to the the current font fallback object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280486</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat1::GetFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
            <unmanaged-short>IDWriteTextFormat1::GetFontFallback</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextFormat2.LineSpacing">
            <summary>
            <p>Gets or sets the line spacing adjustment set for a multiline text paragraph. </p>
            </summary>
            <doc-id>mt574122</doc-id>
            <unmanaged>GetLineSpacing / SetLineSpacing</unmanaged>
            <unmanaged-short>GetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat2.SetLineSpacing(SharpDX.DirectWrite.LineSpacing@)">
            <summary>
            <p>Set line spacing.</p>
            </summary>
            <param name = "lineSpacingOptions"><dd>  <p>How to manage space between lines.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt574123</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat2::SetLineSpacing([In] const DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
            <unmanaged-short>IDWriteTextFormat2::SetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextFormat2.GetLineSpacing(SharpDX.DirectWrite.LineSpacing@)">
            <summary>
            <p>Gets the line spacing adjustment set for a multiline text paragraph. </p>
            </summary>
            <param name = "lineSpacingOptions"><dd>  <p>A structure describing how the space between lines is managed for the paragraph.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt574122</doc-id>
            <unmanaged>HRESULT IDWriteTextFormat2::GetLineSpacing([Out] DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
            <unmanaged-short>IDWriteTextFormat2::GetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout1.SetPairKerning(SharpDX.Mathematics.Interop.RawBool,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p>Enables or disables pair-kerning on a given text range.</p>
            </summary>
            <param name = "isPairKerningEnabled"><dd>  <p>The flag that indicates whether text is pair-kerned.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The text range to which the change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh780442</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout1::SetPairKerning([In] BOOL isPairKerningEnabled,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout1::SetPairKerning</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout1.GetPairKerning(System.Int32,SharpDX.Mathematics.Interop.RawBool@,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p>Gets whether or not pair-kerning is enabled at given position.</p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
            <param name = "isPairKerningEnabled"><dd>  <p>The flag that indicates whether text is pair-kerned.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The position range of the current format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh780440</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout1::GetPairKerning([In] unsigned int currentPosition,[Out] BOOL* isPairKerningEnabled,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout1::GetPairKerning</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout1.SetCharacterSpacing(System.Single,System.Single,System.Single,SharpDX.DirectWrite.TextRange)">
            <summary>
            <p>Sets the spacing between characters.</p>
            </summary>
            <param name = "leadingSpacing"><dd>  <p>The spacing before each character, in reading order.</p> </dd></param>
            <param name = "trailingSpacing"><dd>  <p>The spacing after each character, in reading order.</p> </dd></param>
            <param name = "minimumAdvanceWidth"><dd>  <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>
            <param name = "textRange"><dd>  <p>Text range to which this change applies.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh780441</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout1::SetCharacterSpacing([In] float leadingSpacing,[In] float trailingSpacing,[In] float minimumAdvanceWidth,[In] DWRITE_TEXT_RANGE textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout1::SetCharacterSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout1.GetCharacterSpacing(System.Int32,System.Single@,System.Single@,System.Single@,SharpDX.DirectWrite.TextRange@)">
            <summary>
            <p>Gets the spacing between characters.</p>
            </summary>
            <param name = "currentPosition"><dd>  <p>The current text position.</p> </dd></param>
            <param name = "leadingSpacing"><dd>  <p>The spacing before each character, in reading order.</p> </dd></param>
            <param name = "trailingSpacing"><dd>  <p>The spacing after each character, in reading order.</p> </dd></param>
            <param name = "minimumAdvanceWidth"><dd>  <p>The minimum advance of each character, to prevent characters from becoming too thin or zero-width. This must be zero or greater.</p> </dd></param>
            <param name = "textRange"><dd>  <p>The position range of the current format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh780439</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout1::GetCharacterSpacing([In] unsigned int currentPosition,[Out] float* leadingSpacing,[Out] float* trailingSpacing,[Out] float* minimumAdvanceWidth,[Out, Optional] DWRITE_TEXT_RANGE* textRange)</unmanaged>
            <unmanaged-short>IDWriteTextLayout1::GetCharacterSpacing</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout2.Metrics">
            <summary>
            <p> Retrieves overall metrics for the formatted string. </p>
            </summary>
            <doc-id>dn280492</doc-id>
            <unmanaged>GetMetrics</unmanaged>
            <unmanaged-short>GetMetrics</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout2.VerticalGlyphOrientation">
            <summary>
            <p>Get or sets the preferred orientation of glyphs when using a vertical reading direction.</p>
            </summary>
            <doc-id>dn482048</doc-id>
            <unmanaged>GetVerticalGlyphOrientation / SetVerticalGlyphOrientation</unmanaged>
            <unmanaged-short>GetVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout2.LastLineWrapping">
            <summary>
            <p>Get or sets whether or not the last word on the last line is wrapped.</p>
            </summary>
            <doc-id>dn482046</doc-id>
            <unmanaged>GetLastLineWrapping / SetLastLineWrapping</unmanaged>
            <unmanaged-short>GetLastLineWrapping</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout2.OpticalAlignment">
            <summary>
            <p>Get or sets how the glyphs align to the edges the margin.  </p>
            </summary>
            <doc-id>dn482047</doc-id>
            <unmanaged>GetOpticalAlignment / SetOpticalAlignment</unmanaged>
            <unmanaged-short>GetOpticalAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout2.FontFallback">
            <summary>
            <p>Get or sets the current font fallback object.  </p>
            </summary>
            <doc-id>dn482045</doc-id>
            <unmanaged>GetFontFallback / SetFontFallback</unmanaged>
            <unmanaged-short>GetFontFallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.GetMetrics(SharpDX.DirectWrite.TextMetrics1@)">
            <summary>
            <p> Retrieves overall metrics for the formatted string. </p>
            </summary>
            <param name = "textMetrics"><dd>  <p>When this method returns, contains the measured distances of text and associated content after being formatted.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280492</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout2::GetMetrics([Out] DWRITE_TEXT_METRICS1* textMetrics)</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::GetMetrics</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.SetVerticalGlyphOrientation(SharpDX.DirectWrite.VerticalGlyphOrientation)">
            <summary>
            <p>Set the preferred orientation of glyphs when using a vertical reading direction.</p>
            </summary>
            <param name = "glyphOrientation"><dd> <p>Preferred glyph orientation.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn482052</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout2::SetVerticalGlyphOrientation([In] DWRITE_VERTICAL_GLYPH_ORIENTATION glyphOrientation)</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::SetVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.GetVerticalGlyphOrientation">
            <summary>
            <p>Get the preferred orientation of glyphs when using a vertical reading direction.</p>
            </summary>
            <returns>No documentation.</returns>
            <doc-id>dn482048</doc-id>
            <unmanaged>DWRITE_VERTICAL_GLYPH_ORIENTATION IDWriteTextLayout2::GetVerticalGlyphOrientation()</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::GetVerticalGlyphOrientation</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.SetLastLineWrapping(SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Set whether or not the last word on the last line is wrapped. </p>
            </summary>
            <param name = "isLastLineWrappingEnabled"><dd> <p>Line wrapping option.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn482050</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout2::SetLastLineWrapping([In] BOOL isLastLineWrappingEnabled)</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::SetLastLineWrapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.GetLastLineWrapping">
            <summary>
            <p>Get whether or not the last word on the last line is wrapped.</p>
            </summary>
            <returns>No documentation.</returns>
            <doc-id>dn482046</doc-id>
            <unmanaged>BOOL IDWriteTextLayout2::GetLastLineWrapping()</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::GetLastLineWrapping</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.SetOpticalAlignment(SharpDX.DirectWrite.OptimizationIcalAlignment)">
            <summary>
            <p>Set how the glyphs align to the edges the margin.  Default behavior is to align glyphs using their default glyphs metrics, which include side bearings. </p>
            </summary>
            <param name = "opticalAlignment"><dd> <p>Optical alignment option.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn482051</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout2::SetOpticalAlignment([In] DWRITE_OPTICAL_ALIGNMENT opticalAlignment)</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::SetOpticalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.GetOpticalAlignment">
            <summary>
            <p>Get how the glyphs align to the edges the margin.  </p>
            </summary>
            <returns>No documentation.</returns>
            <doc-id>dn482047</doc-id>
            <unmanaged>DWRITE_OPTICAL_ALIGNMENT IDWriteTextLayout2::GetOpticalAlignment()</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::GetOpticalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.SetFontFallback(SharpDX.DirectWrite.FontFallback)">
            <summary>
            <p>Apply a custom font fallback onto layout. If none is specified, the layout uses the system fallback list. </p>
            </summary>
            <param name = "fontFallback"><dd> <p> Custom font fallback created from <strong>IDWriteFontFallbackBuilder::CreateFontFallback</strong> or <strong>IDWriteFactory2::GetSystemFontFallback</strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn482049</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout2::SetFontFallback([In] IDWriteFontFallback* fontFallback)</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::SetFontFallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout2.GetFontFallback(SharpDX.DirectWrite.FontFallback@)">
            <summary>
            <p>Get the current font fallback object.  </p>
            </summary>
            <param name = "fontFallback"><dd> <p>The current font fallback object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn482045</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout2::GetFontFallback([Out] IDWriteFontFallback** fontFallback)</unmanaged>
            <unmanaged-short>IDWriteTextLayout2::GetFontFallback</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.TextLayout3.LineSpacing">
            <summary>
            <p>Gets or sets line spacing information.</p>
            </summary>
            <doc-id>dn900407</doc-id>
            <unmanaged>GetLineSpacing / SetLineSpacing</unmanaged>
            <unmanaged-short>GetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout3.InvalidateLayout">
            <summary>
            <p>Invalidates the layout, forcing layout to remeasure before calling the    metrics or drawing functions. This is useful if the locality of a font     changes, and layout should be redrawn, or if the size of a client     implemented <see cref = "T:SharpDX.DirectWrite.InlineObject"/> changes. </p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900408</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout3::InvalidateLayout()</unmanaged>
            <unmanaged-short>IDWriteTextLayout3::InvalidateLayout</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout3.SetLineSpacing(SharpDX.DirectWrite.LineSpacing@)">
            <summary>
            <p>Set line spacing.</p>
            </summary>
            <param name = "lineSpacingOptions"><dd> <p>How to manage space between lines.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900409</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout3::SetLineSpacing([In] const DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
            <unmanaged-short>IDWriteTextLayout3::SetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout3.GetLineSpacing(SharpDX.DirectWrite.LineSpacing@)">
            <summary>
            <p>Gets line spacing information.</p>
            </summary>
            <param name = "lineSpacingOptions"><dd> <p>How to manage space between lines.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn900407</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout3::GetLineSpacing([Out] DWRITE_LINE_SPACING* lineSpacingOptions)</unmanaged>
            <unmanaged-short>IDWriteTextLayout3::GetLineSpacing</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectWrite.TextLayout3.GetLineMetrics(SharpDX.DirectWrite.LineMetrics1[],System.Int32,System.Int32@)">
            <summary>
            <p>Retrieves properties of each line.</p>
            </summary>
            <param name = "lineMetrics"><dd> <p>The array to fill with line information.</p> </dd></param>
            <param name = "maxLineCount"><dd> <p>The maximum size of the lineMetrics array.</p> </dd></param>
            <param name = "actualLineCount"><dd> <p>The actual size of the lineMetrics     array that is needed.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER,    which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),   is returned and actualLineCount is set to the number of lines    needed.</p>
            </remarks>
            <doc-id>dn900406</doc-id>
            <unmanaged>HRESULT IDWriteTextLayout3::GetLineMetrics([Out, Buffer, Optional] DWRITE_LINE_METRICS1* lineMetrics,[In] unsigned int maxLineCount,[Out] unsigned int* actualLineCount)</unmanaged>
            <unmanaged-short>IDWriteTextLayout3::GetLineMetrics</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.CaretMetrics">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.CaretMetrics"/></strong> structure specifies the metrics for caret placement in a font.</p>
            </summary>
            <doc-id>jj126258</doc-id>
            <unmanaged>DWRITE_CARET_METRICS</unmanaged>
            <unmanaged-short>DWRITE_CARET_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.CaretMetrics.SlopeRise">
            <summary>
            <dd> <p>Vertical rise of the caret in font design units. Rise / Run yields the caret angle. Rise = 1 for perfectly upright fonts (non-italic).</p> </dd>
            </summary>
            <doc-id>jj126258</doc-id>
            <unmanaged>slopeRise</unmanaged>
            <unmanaged-short>slopeRise</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.CaretMetrics.SlopeRun">
            <summary>
            <dd> <p>Horizontal run of the caret in font design units. Rise / Run yields the caret angle. Run = 0 for perfectly upright fonts (non-italic).</p> </dd>
            </summary>
            <doc-id>jj126258</doc-id>
            <unmanaged>slopeRun</unmanaged>
            <unmanaged-short>slopeRun</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.CaretMetrics.Offset">
            <summary>
            <dd> <p>Horizontal offset of the caret, in font design units, along the baseline for good appearance. Offset = 0 for perfectly upright fonts (non-italic).</p> </dd>
            </summary>
            <doc-id>jj126258</doc-id>
            <unmanaged>offset</unmanaged>
            <unmanaged-short>offset</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ClusterMetrics">
            <summary>
            <p>Contains information about a glyph cluster.</p>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>DWRITE_CLUSTER_METRICS</unmanaged>
            <unmanaged-short>DWRITE_CLUSTER_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ClusterMetrics.Width">
            <summary>
            <dd> <p>The total advance width of all glyphs in the cluster.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ClusterMetrics.Length">
            <summary>
            <dd> <p>The number of text positions in the cluster.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>length</unmanaged>
            <unmanaged-short>length</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ClusterMetrics.CanWrapLineAfter">
            <summary>
            <dd> <p>Indicates whether a line can be broken right after the cluster.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>canWrapLineAfter</unmanaged>
            <unmanaged-short>canWrapLineAfter</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ClusterMetrics.IsWhitespace">
            <summary>
            <dd> <p>Indicates whether the cluster corresponds to a whitespace character.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>isWhitespace</unmanaged>
            <unmanaged-short>isWhitespace</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ClusterMetrics.IsNewline">
            <summary>
            <dd> <p>Indicates whether the cluster corresponds to a newline character.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>isNewline</unmanaged>
            <unmanaged-short>isNewline</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ClusterMetrics.IsSoftHyphen">
            <summary>
            <dd> <p>Indicates whether the cluster corresponds to a soft hyphen character.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>isSoftHyphen</unmanaged>
            <unmanaged-short>isSoftHyphen</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ClusterMetrics.IsRightToLeft">
            <summary>
            <dd> <p>Indicates whether the cluster is read from right to left.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>isRightToLeft</unmanaged>
            <unmanaged-short>isRightToLeft</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ClusterMetrics.Padding">
            <summary>
            <dd> <p>Reserved for future use.</p> </dd>
            </summary>
            <doc-id>dd368054</doc-id>
            <unmanaged>padding</unmanaged>
            <unmanaged-short>padding</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ColorGlyphRun">
            <summary>
            <p>Contains the information needed by renderers to draw glyph runs with glyph color information.  All coordinates are in device independent pixels (DIPs).</p>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>DWRITE_COLOR_GLYPH_RUN</unmanaged>
            <unmanaged-short>DWRITE_COLOR_GLYPH_RUN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun.GlyphRun">
            <summary>
            <dd> <p>Glyph run to draw for this layer.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>glyphRun</unmanaged>
            <unmanaged-short>glyphRun</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun.GlyphRunDescription">
            <summary>
            <dd> <p>Pointer to the glyph run description for this layer. This may be <strong><c>null</c></strong>. For example, when the original glyph run is split into multiple layers, one layer might have a description and the others have none.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>glyphRunDescription</unmanaged>
            <unmanaged-short>glyphRunDescription</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun.BaselineOriginX">
            <summary>
            <dd> <p>X coordinate of the baseline origin for the layer.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>baselineOriginX</unmanaged>
            <unmanaged-short>baselineOriginX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun.BaselineOriginY">
            <summary>
            <dd> <p>Y coordinate of the baseline origin for the layer.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>baselineOriginY</unmanaged>
            <unmanaged-short>baselineOriginY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun.RunColor">
            <summary>
            <dd> <p>Color value of the run; if all members are zero, the run should be drawn using the current brush.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>runColor</unmanaged>
            <unmanaged-short>runColor</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun.PaletteIndex">
            <summary>
            <dd> <p>Zero-based index into the font?s color palette; if this is <strong>0xFFFF</strong>, the run should be drawn using the current brush.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>paletteIndex</unmanaged>
            <unmanaged-short>paletteIndex</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ColorGlyphRun1">
            <summary>
            <p>Represents a color glyph run. The IDWriteFactory4::TranslateColorGlyphRun method returns an ordered collection of color glyph runs of varying types depending on what the font supports.</p>
            </summary>
            <doc-id>mt725306</doc-id>
            <unmanaged>DWRITE_COLOR_GLYPH_RUN1</unmanaged>
            <unmanaged-short>DWRITE_COLOR_GLYPH_RUN1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.GlyphRun">
            <summary>
            <dd> <p>Glyph run to draw for this layer.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>glyphRun</unmanaged>
            <unmanaged-short>glyphRun</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.GlyphRunDescription">
            <summary>
            <dd> <p>Pointer to the glyph run description for this layer. This may be <strong><c>null</c></strong>. For example, when the original glyph run is split into multiple layers, one layer might have a description and the others have none.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>glyphRunDescription</unmanaged>
            <unmanaged-short>glyphRunDescription</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.BaselineOriginX">
            <summary>
            <dd> <p>X coordinate of the baseline origin for the layer.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>baselineOriginX</unmanaged>
            <unmanaged-short>baselineOriginX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.BaselineOriginY">
            <summary>
            <dd> <p>Y coordinate of the baseline origin for the layer.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>baselineOriginY</unmanaged>
            <unmanaged-short>baselineOriginY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.RunColor">
            <summary>
            <dd> <p>Color value of the run; if all members are zero, the run should be drawn using the current brush.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>runColor</unmanaged>
            <unmanaged-short>runColor</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.PaletteIndex">
            <summary>
            <dd> <p>Zero-based index into the font?s color palette; if this is <strong>0xFFFF</strong>, the run should be drawn using the current brush.</p> </dd>
            </summary>
            <doc-id>dn280407</doc-id>
            <unmanaged>paletteIndex</unmanaged>
            <unmanaged-short>paletteIndex</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.GlyphImageFormat">
            <summary>
            <dd> <p>Type of glyph image format for this color run. Exactly one type will be set since TranslateColorGlyphRun has already broken down the run into separate parts.</p> </dd>
            </summary>
            <doc-id>mt725306</doc-id>
            <unmanaged>glyphImageFormat</unmanaged>
            <unmanaged-short>glyphImageFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ColorGlyphRun1.MeasuringMode">
            <summary>
            <dd> <p>Measuring mode to use for this glyph run.</p> </dd>
            </summary>
            <doc-id>mt725306</doc-id>
            <unmanaged>measuringMode</unmanaged>
            <unmanaged-short>measuringMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FileFragment">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DWRITE_FILE_FRAGMENT</unmanaged>
            <unmanaged-short>DWRITE_FILE_FRAGMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FileFragment.FileOffset">
            <summary>
            No documentation.
            </summary>
            <unmanaged>fileOffset</unmanaged>
            <unmanaged-short>fileOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FileFragment.FragmentSize">
            <summary>
            No documentation.
            </summary>
            <unmanaged>fragmentSize</unmanaged>
            <unmanaged-short>fragmentSize</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontMetrics">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics"/></strong> structure specifies the metrics that are applicable to all glyphs within the font face.</p>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>DWRITE_FONT_METRICS</unmanaged>
            <unmanaged-short>DWRITE_FONT_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.DesignUnitsPerEm">
            <summary>
            <dd> <p>The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>designUnitsPerEm</unmanaged>
            <unmanaged-short>designUnitsPerEm</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.Ascent">
            <summary>
            <dd> <p>The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>ascent</unmanaged>
            <unmanaged-short>ascent</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.Descent">
            <summary>
            <dd> <p>The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>descent</unmanaged>
            <unmanaged-short>descent</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.LineGap">
            <summary>
            <dd> <p>The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of <strong>ascent</strong>, <strong>descent</strong>, and <strong>lineGap</strong>. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>lineGap</unmanaged>
            <unmanaged-short>lineGap</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.CapHeight">
            <summary>
            <dd> <p>The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>capHeight</unmanaged>
            <unmanaged-short>capHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.XHeight">
            <summary>
            <dd> <p>The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>xHeight</unmanaged>
            <unmanaged-short>xHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.UnderlinePosition">
            <summary>
            <dd> <p>The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>underlinePosition</unmanaged>
            <unmanaged-short>underlinePosition</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.UnderlineThickness">
            <summary>
            <dd> <p>The suggested underline thickness value of the font face in font design units.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>underlineThickness</unmanaged>
            <unmanaged-short>underlineThickness</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.StrikethroughPosition">
            <summary>
            <dd> <p>The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>strikethroughPosition</unmanaged>
            <unmanaged-short>strikethroughPosition</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics.StrikethroughThickness">
            <summary>
            <dd> <p>The suggested strikethrough thickness value of the font face in font design units.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>strikethroughThickness</unmanaged>
            <unmanaged-short>strikethroughThickness</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontMetrics1">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics1"/></strong> structure specifies the metrics that are applicable to all glyphs within the font face.</p>
            </summary>
            <remarks>
            <p><strong><see cref = "T:SharpDX.DirectWrite.FontMetrics1"/></strong> inherits from <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics"/></strong>:</p><code> struct <see cref = "T:SharpDX.DirectWrite.FontMetrics1"/> : public <see cref = "T:SharpDX.DirectWrite.FontMetrics"/>
            {
            ...
            };</code>
            </remarks>
            <doc-id>jj126259</doc-id>
            <unmanaged>DWRITE_FONT_METRICS1</unmanaged>
            <unmanaged-short>DWRITE_FONT_METRICS1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.DesignUnitsPerEm">
            <summary>
            <dd> <p>The number of font design units per em unit. Font files use their own coordinate system of font design units. A font design unit is the smallest measurable unit in the em square, an imaginary square that is used to size and align glyphs. The concept of em square is used as a reference scale factor when defining font size and device transformation semantics. The size of one em square is also commonly used to compute the paragraph identation value.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>designUnitsPerEm</unmanaged>
            <unmanaged-short>designUnitsPerEm</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.Ascent">
            <summary>
            <dd> <p>The ascent value of the font face in font design units. Ascent is the distance from the top of font character alignment box to the English baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>ascent</unmanaged>
            <unmanaged-short>ascent</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.Descent">
            <summary>
            <dd> <p>The descent value of the font face in font design units. Descent is the distance from the bottom of font character alignment box to the English baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>descent</unmanaged>
            <unmanaged-short>descent</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.LineGap">
            <summary>
            <dd> <p>The line gap in font design units. Recommended additional white space to add between lines to improve legibility. The recommended line spacing (baseline-to-baseline distance) is  the sum of <strong>ascent</strong>, <strong>descent</strong>, and <strong>lineGap</strong>. The line gap is usually positive or zero but can be negative, in which case the recommended line spacing is less than the height of the character alignment box.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>lineGap</unmanaged>
            <unmanaged-short>lineGap</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.CapHeight">
            <summary>
            <dd> <p>The cap height value of the font face in font design units. Cap height is the distance from the English baseline to the top of a typical English capital. Capital "H" is often used as a reference character for the purpose of calculating the cap height value.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>capHeight</unmanaged>
            <unmanaged-short>capHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.XHeight">
            <summary>
            <dd> <p>The x-height value of the font face in font design units. x-height is the distance from the English baseline to the top of lowercase letter "x", or a similar lowercase character.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>xHeight</unmanaged>
            <unmanaged-short>xHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.UnderlinePosition">
            <summary>
            <dd> <p>The underline position value of the font face in font design units. Underline position is the position of underline relative to the English baseline. The value is usually made negative in order to place the underline below the baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>underlinePosition</unmanaged>
            <unmanaged-short>underlinePosition</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.UnderlineThickness">
            <summary>
            <dd> <p>The suggested underline thickness value of the font face in font design units.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>underlineThickness</unmanaged>
            <unmanaged-short>underlineThickness</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.StrikethroughPosition">
            <summary>
            <dd> <p>The strikethrough position value of the font face in font design units. Strikethrough position is the position of strikethrough relative to the English baseline. The value is usually made positive in order to place the strikethrough above the baseline.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>strikethroughPosition</unmanaged>
            <unmanaged-short>strikethroughPosition</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.StrikethroughThickness">
            <summary>
            <dd> <p>The suggested strikethrough thickness value of the font face in font design units.</p> </dd>
            </summary>
            <doc-id>dd368074</doc-id>
            <unmanaged>strikethroughThickness</unmanaged>
            <unmanaged-short>strikethroughThickness</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.GlyphBoxLeft">
            <summary>
            <dd> <p>Left edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>glyphBoxLeft</unmanaged>
            <unmanaged-short>glyphBoxLeft</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.GlyphBoxTop">
            <summary>
            <dd> <p>Top edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>glyphBoxTop</unmanaged>
            <unmanaged-short>glyphBoxTop</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.GlyphBoxRight">
            <summary>
            <dd> <p>Right edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>glyphBoxRight</unmanaged>
            <unmanaged-short>glyphBoxRight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.GlyphBoxBottom">
            <summary>
            <dd> <p>Bottom edge of accumulated bounding blackbox of all glyphs in the font.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>glyphBoxBottom</unmanaged>
            <unmanaged-short>glyphBoxBottom</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SubscriptPositionX">
            <summary>
            <dd> <p>Horizontal position of the subscript relative to the baseline origin. This is typically negative (to the left) in italic and oblique fonts, and zero in regular fonts.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>subscriptPositionX</unmanaged>
            <unmanaged-short>subscriptPositionX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SubscriptPositionY">
            <summary>
            <dd> <p>Vertical position of the subscript relative to the baseline. This is typically negative.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>subscriptPositionY</unmanaged>
            <unmanaged-short>subscriptPositionY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SubscriptSizeX">
            <summary>
            <dd> <p>Horizontal size of the subscript em box in design units, used to scale the simulated subscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client uses its own policy.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>subscriptSizeX</unmanaged>
            <unmanaged-short>subscriptSizeX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SubscriptSizeY">
            <summary>
            <dd> <p>Vertical size of the subscript em box in design units, used to scale the simulated subscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client uses its own policy.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>subscriptSizeY</unmanaged>
            <unmanaged-short>subscriptSizeY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SuperscriptPositionX">
            <summary>
            <dd> <p>Horizontal position of the superscript relative to the baseline origin. This is typically positive (to the right) in italic and oblique fonts, and zero in regular fonts.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>superscriptPositionX</unmanaged>
            <unmanaged-short>superscriptPositionX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SuperscriptPositionY">
            <summary>
            <dd> <p>Vertical position of the superscript relative to the baseline. This is typically positive.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>superscriptPositionY</unmanaged>
            <unmanaged-short>superscriptPositionY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SuperscriptSizeX">
            <summary>
            <dd> <p>Horizontal size of the superscript em box in design units, used to scale the simulated superscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client should use its own policy.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>superscriptSizeX</unmanaged>
            <unmanaged-short>superscriptSizeX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.SuperscriptSizeY">
            <summary>
            <dd> <p>Vertical size of the superscript em box in design units, used to scale the simulated superscript relative to the full em box size. This is the numerator of the scaling ratio where denominator is the design units per em. If this member is zero, the font does not specify a scale factor, and the client should use its own policy.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>superscriptSizeY</unmanaged>
            <unmanaged-short>superscriptSizeY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontMetrics1.HasTypographicMetrics">
            <summary>
            <dd> <p>A Boolean value that indicates that the ascent, descent, and lineGap are based on newer 'typographic' values in the font, rather than legacy values.</p> </dd>
            </summary>
            <doc-id>jj126259</doc-id>
            <unmanaged>hasTypographicMetrics</unmanaged>
            <unmanaged-short>hasTypographicMetrics</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.FontProperty">
            <summary>
            <p>Font property used for filtering font sets and building a font set with explicit properties.</p>
            </summary>
            <doc-id>dn933212</doc-id>
            <unmanaged>DWRITE_FONT_PROPERTY</unmanaged>
            <unmanaged-short>DWRITE_FONT_PROPERTY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontProperty.PropertyId">
            <summary>
            <dd> <p>Specifies the requested font property, such as DWRITE_FONT_PROPERTY_ID_FAMILY_NAME.</p> </dd>
            </summary>
            <doc-id>dn933212</doc-id>
            <unmanaged>propertyId</unmanaged>
            <unmanaged-short>propertyId</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontProperty.PropertyValue">
            <summary>
            <dd> <p>Specifies the value, such as "Segoe UI".</p> </dd>
            </summary>
            <doc-id>dn933212</doc-id>
            <unmanaged>propertyValue</unmanaged>
            <unmanaged-short>propertyValue</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.FontProperty.LocaleName">
            <summary>
            <dd> <p>Specifies the locale to use, such as "en-US". Simply leave this empty when used with the font set filtering functions, as they will find a match regardless of language. For passing to AddFontFaceReference, the localeName specifies the language of the property value.</p> </dd>
            </summary>
            <doc-id>dn933212</doc-id>
            <unmanaged>localeName</unmanaged>
            <unmanaged-short>localeName</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphImageData">
            <summary>
            <p>Data for a single glyph from GetGlyphImageData.</p>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>DWRITE_GLYPH_IMAGE_DATA</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_IMAGE_DATA</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.ImageData">
            <summary>
            <dd> <p>Pointer to the glyph data.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>imageData</unmanaged>
            <unmanaged-short>imageData</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.ImageDataSize">
            <summary>
            <dd> <p>Size of glyph data in bytes.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>imageDataSize</unmanaged>
            <unmanaged-short>imageDataSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.UniqueDataId">
            <summary>
            <dd> <p>Unique identifier for the glyph data. Clients may use this to cache a parsed/decompressed version and tell whether a repeated call to the same font returns the same data.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>uniqueDataId</unmanaged>
            <unmanaged-short>uniqueDataId</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.PixelsPerEm">
            <summary>
            <dd> <p>Pixels per em of the returned data. For non-scalable raster data (PNG/TIFF/JPG), this can be larger or smaller than requested from GetGlyphImageData when there isn't an exact match. For scaling intermediate sizes, use: desired pixels per em * font em size / actual pixels per em.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>pixelsPerEm</unmanaged>
            <unmanaged-short>pixelsPerEm</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.PixelSize">
            <summary>
            <dd> <p>Size of image when the format is pixel data.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>pixelSize</unmanaged>
            <unmanaged-short>pixelSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.HorizontalLeftOrigin">
            <summary>
            <dd> <p>Left origin along the horizontal Roman baseline.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>horizontalLeftOrigin</unmanaged>
            <unmanaged-short>horizontalLeftOrigin</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.HorizontalRightOrigin">
            <summary>
            <dd> <p>Right origin along the horizontal Roman baseline.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>horizontalRightOrigin</unmanaged>
            <unmanaged-short>horizontalRightOrigin</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.VerticalTopOrigin">
            <summary>
            <dd> <p>Top origin along the vertical central baseline.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>verticalTopOrigin</unmanaged>
            <unmanaged-short>verticalTopOrigin</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphImageData.VerticalBottomOrigin">
            <summary>
            <dd> <p>Bottom origin along vertical central baseline.</p> </dd>
            </summary>
            <doc-id>mt725307</doc-id>
            <unmanaged>verticalBottomOrigin</unmanaged>
            <unmanaged-short>verticalBottomOrigin</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphMetrics">
            <summary>
            <p>Specifies the metrics of an individual glyph. The units depend on how the metrics are obtained.</p>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>DWRITE_GLYPH_METRICS</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.LeftSideBearing">
            <summary>
            <dd> <p>Specifies the X offset from the glyph origin to the left edge of the black box. The glyph origin is the current horizontal writing position. A negative value means the black box extends to the left of the origin (often true for lowercase italic 'f').</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>leftSideBearing</unmanaged>
            <unmanaged-short>leftSideBearing</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.AdvanceWidth">
            <summary>
            <dd> <p>Specifies the X offset from the origin of the current glyph to the origin of the next glyph when writing horizontally.</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>advanceWidth</unmanaged>
            <unmanaged-short>advanceWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.RightSideBearing">
            <summary>
            <dd> <p>Specifies the X offset from the right edge of the black box to the origin of the next glyph when writing horizontally. The value is negative when the right edge of the black box overhangs the layout box.</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>rightSideBearing</unmanaged>
            <unmanaged-short>rightSideBearing</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.TopSideBearing">
            <summary>
            <dd> <p>Specifies the vertical offset from the vertical origin to the top of the black box. Thus, a positive value adds whitespace whereas a negative value means the glyph overhangs the top of the layout box.</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>topSideBearing</unmanaged>
            <unmanaged-short>topSideBearing</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.AdvanceHeight">
            <summary>
            <dd> <p>Specifies the Y offset from the vertical origin of the current glyph to the vertical origin of the next glyph when writing vertically. Note that the term "origin" by itself denotes the horizontal origin. The vertical origin is different. Its Y coordinate is specified by <strong>verticalOriginY</strong> value, and its X coordinate is half the <strong>advanceWidth</strong> to the right of the horizontal origin.</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>advanceHeight</unmanaged>
            <unmanaged-short>advanceHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.BottomSideBearing">
            <summary>
            <dd> <p>Specifies the vertical distance from the bottom edge of the black box to the advance height. This is positive when the bottom edge of the black box is within the layout box, or negative when the bottom edge of black box overhangs the layout box.</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>bottomSideBearing</unmanaged>
            <unmanaged-short>bottomSideBearing</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphMetrics.VerticalOriginY">
            <summary>
            <dd> <p>Specifies the Y coordinate of a glyph's vertical origin, in the font's design coordinate system. The y coordinate of a glyph's vertical origin is the sum of the glyph's top side bearing and the top (that is, yMax) of the glyph's bounding box.</p> </dd>
            </summary>
            <doc-id>dd368084</doc-id>
            <unmanaged>verticalOriginY</unmanaged>
            <unmanaged-short>verticalOriginY</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.GlyphOffset">
            <summary>
            <p>The optional adjustment to a glyph's position.</p>
            </summary>
            <remarks>
            <p>An glyph offset changes the position of a glyph without affecting the pen position. Offsets are in logical, pre-transform units.</p>
            </remarks>
            <doc-id>dd368086</doc-id>
            <unmanaged>DWRITE_GLYPH_OFFSET</unmanaged>
            <unmanaged-short>DWRITE_GLYPH_OFFSET</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphOffset.AdvanceOffset">
            <summary>
            <dd> <p>The offset in the advance direction of the run. A positive advance offset moves the glyph to the right (in pre-transform coordinates) if the run is left-to-right or to the left if the run is right-to-left.</p> </dd>
            </summary>
            <doc-id>dd368086</doc-id>
            <unmanaged>advanceOffset</unmanaged>
            <unmanaged-short>advanceOffset</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.GlyphOffset.AscenderOffset">
            <summary>
            <dd> <p>The offset in the ascent direction, that is, the direction ascenders point. A positive ascender offset moves the glyph up (in pre-transform coordinates).  A negative ascender offset moves the glyph down.</p> </dd>
            </summary>
            <doc-id>dd368086</doc-id>
            <unmanaged>ascenderOffset</unmanaged>
            <unmanaged-short>ascenderOffset</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.HitTestMetrics">
            <summary>
            <p>Describes the region obtained by a hit test.</p>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>DWRITE_HIT_TEST_METRICS</unmanaged>
            <unmanaged-short>DWRITE_HIT_TEST_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.TextPosition">
            <summary>
            <dd> <p>The first text position within the hit region. </p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>textPosition</unmanaged>
            <unmanaged-short>textPosition</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.Length">
            <summary>
            <dd> <p>The number of text positions within the hit region. </p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>length</unmanaged>
            <unmanaged-short>length</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.Left">
            <summary>
            <dd> <p>The x-coordinate of the upper-left corner of the hit region.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>left</unmanaged>
            <unmanaged-short>left</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.Top">
            <summary>
            <dd> <p>The y-coordinate of the upper-left corner of the hit region.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>top</unmanaged>
            <unmanaged-short>top</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.Width">
            <summary>
            <dd> <p>The width of the hit region.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.Height">
            <summary>
            <dd> <p>The height of the hit region.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.BidiLevel">
            <summary>
            <dd> <p>The <strong>BIDI level</strong> of the text positions within the hit region.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>bidiLevel</unmanaged>
            <unmanaged-short>bidiLevel</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.IsText">
            <summary>
            <dd> <p>true if the hit region contains text; otherwise, false.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>isText</unmanaged>
            <unmanaged-short>isText</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.HitTestMetrics.IsTrimmed">
            <summary>
            <dd> <p>true if the text range is trimmed; otherwise, false.</p> </dd>
            </summary>
            <doc-id>dd368092</doc-id>
            <unmanaged>isTrimmed</unmanaged>
            <unmanaged-short>isTrimmed</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.InlineObjectMetrics">
            <summary>
            <p>Contains properties describing the geometric measurement of an
            application-defined inline object.</p>
            </summary>
            <doc-id>dd368096</doc-id>
            <unmanaged>DWRITE_INLINE_OBJECT_METRICS</unmanaged>
            <unmanaged-short>DWRITE_INLINE_OBJECT_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InlineObjectMetrics.Width">
            <summary>
            <dd> <p>The width of the inline object.</p> </dd>
            </summary>
            <doc-id>dd368096</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InlineObjectMetrics.Height">
            <summary>
            <dd> <p>The height of the inline object.</p> </dd>
            </summary>
            <doc-id>dd368096</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InlineObjectMetrics.Baseline">
            <summary>
            <dd> <p>The distance from the top of the object to the point where it is lined up with the adjacent text.  If the baseline is at the bottom, then <strong>baseline</strong> simply equals <strong>height</strong>.</p> </dd>
            </summary>
            <doc-id>dd368096</doc-id>
            <unmanaged>baseline</unmanaged>
            <unmanaged-short>baseline</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.InlineObjectMetrics.SupportsSideways">
            <summary>
            <dd> <p>A Boolean flag that indicates whether the object is to be placed upright or alongside the text baseline for vertical text.</p> </dd>
            </summary>
            <doc-id>dd368096</doc-id>
            <unmanaged>supportsSideways</unmanaged>
            <unmanaged-short>supportsSideways</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.JustificationOpportunity">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.JustificationOpportunity"/></strong> structure specifies justification info per glyph.</p>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>DWRITE_JUSTIFICATION_OPPORTUNITY</unmanaged>
            <unmanaged-short>DWRITE_JUSTIFICATION_OPPORTUNITY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.JustificationOpportunity.ExpansionMinimum">
            <summary>
            <dd> <p>Minimum amount of expansion to apply to the side of the glyph. This might vary from zero to infinity, typically being zero except for kashida.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>expansionMinimum</unmanaged>
            <unmanaged-short>expansionMinimum</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.JustificationOpportunity.ExpansionMaximum">
            <summary>
            <dd> <p>Maximum amount of expansion to apply to the side of the glyph. This might vary from zero to infinity, being zero for fixed-size characters and connected scripts, and non-zero for discrete scripts, and non-zero for cursive scripts at expansion points.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>expansionMaximum</unmanaged>
            <unmanaged-short>expansionMaximum</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.JustificationOpportunity.CompressionMaximum">
            <summary>
            <dd> <p>Maximum amount of compression to apply to the side of the glyph. This might vary from zero up to the glyph cluster size.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>compressionMaximum</unmanaged>
            <unmanaged-short>compressionMaximum</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.ExpansionPriority">
            <summary>
            <dd> <p>Priority of this expansion point. Larger priorities are applied later, while priority zero does nothing.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>expansionPriority</unmanaged>
            <unmanaged-short>expansionPriority</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.CompressionPriority">
            <summary>
            <dd> <p>Priority of this compression point. Larger priorities are applied later, while priority zero does nothing.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>compressionPriority</unmanaged>
            <unmanaged-short>compressionPriority</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.AllowResidualExpansion">
            <summary>
            <dd> <p>Allow this expansion point to use up any remaining slack space even after all expansion priorities have been used up.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>allowResidualExpansion</unmanaged>
            <unmanaged-short>allowResidualExpansion</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.AllowResidualCompression">
            <summary>
            <dd> <p>Allow this compression point to use up any remaining space even after all compression priorities have been used up.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>allowResidualCompression</unmanaged>
            <unmanaged-short>allowResidualCompression</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.ApplyToLeadingEdge">
            <summary>
            <dd> <p>Apply expansion and compression to the leading edge of the glyph. This bit is <strong><see cref = "F:SharpDX.Result.False"/></strong> (0) for connected scripts, fixed-size characters, and diacritics. It is generally <strong><see cref = "F:SharpDX.Result.False"/></strong> within a multi-glyph cluster, unless the script allows expansion of glyphs within a cluster, like Thai.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>applyToLeadingEdge</unmanaged>
            <unmanaged-short>applyToLeadingEdge</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.ApplyToTrailingEdge">
            <summary>
            <dd> <p>Apply expansion and compression to the trailing edge of the glyph. This bit is <strong><see cref = "F:SharpDX.Result.False"/></strong> (0) for connected scripts, fixed-size characters, and diacritics. It is generally <strong><see cref = "F:SharpDX.Result.False"/></strong> within a multi-glyph cluster, unless the script allows expansion of glyphs within a cluster, like Thai.</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>applyToTrailingEdge</unmanaged>
            <unmanaged-short>applyToTrailingEdge</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.JustificationOpportunity.Reserved">
            <summary>
            <dd> <p>Reserved</p> </dd>
            </summary>
            <doc-id>jj126261</doc-id>
            <unmanaged>reserved</unmanaged>
            <unmanaged-short>reserved</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.LineMetrics">
            <summary>
            <p>Contains information about a formatted line of text.</p>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>DWRITE_LINE_METRICS</unmanaged>
            <unmanaged-short>DWRITE_LINE_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics.Length">
            <summary>
            <dd> <p>The number of text positions in the text line.  This includes any trailing whitespace and newline characters.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>length</unmanaged>
            <unmanaged-short>length</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics.TrailingWhitespaceLength">
            <summary>
            <dd> <p>The number of whitespace positions at the end of the text line.  Newline sequences are considered whitespace.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>trailingWhitespaceLength</unmanaged>
            <unmanaged-short>trailingWhitespaceLength</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics.NewlineLength">
            <summary>
            <dd> <p>The number of characters in the newline sequence at the end of the text line.  If the count is zero, then the text line was either wrapped or it is the end of the text.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>newlineLength</unmanaged>
            <unmanaged-short>newlineLength</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics.Height">
            <summary>
            <dd> <p>The height of the text line.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics.Baseline">
            <summary>
            <dd> <p>The distance from the top of the text line to its baseline.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>baseline</unmanaged>
            <unmanaged-short>baseline</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics.IsTrimmed">
            <summary>
            <dd> <p>The line is trimmed.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>isTrimmed</unmanaged>
            <unmanaged-short>isTrimmed</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.LineMetrics1">
            <summary>
            <p>Contains information about a formatted line of text.</p>
            </summary>
            <doc-id>dn933215</doc-id>
            <unmanaged>DWRITE_LINE_METRICS1</unmanaged>
            <unmanaged-short>DWRITE_LINE_METRICS1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.Length">
            <summary>
            <dd> <p>The number of text positions in the text line.  This includes any trailing whitespace and newline characters.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>length</unmanaged>
            <unmanaged-short>length</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.TrailingWhitespaceLength">
            <summary>
            <dd> <p>The number of whitespace positions at the end of the text line.  Newline sequences are considered whitespace.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>trailingWhitespaceLength</unmanaged>
            <unmanaged-short>trailingWhitespaceLength</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.NewlineLength">
            <summary>
            <dd> <p>The number of characters in the newline sequence at the end of the text line.  If the count is zero, then the text line was either wrapped or it is the end of the text.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>newlineLength</unmanaged>
            <unmanaged-short>newlineLength</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.Height">
            <summary>
            <dd> <p>The height of the text line.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.Baseline">
            <summary>
            <dd> <p>The distance from the top of the text line to its baseline.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>baseline</unmanaged>
            <unmanaged-short>baseline</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.IsTrimmed">
            <summary>
            <dd> <p>The line is trimmed.</p> </dd>
            </summary>
            <doc-id>dd368099</doc-id>
            <unmanaged>isTrimmed</unmanaged>
            <unmanaged-short>isTrimmed</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.LeadingBefore">
            <summary>
            <dd> <p>White space before the content of the line. This is included in the line height and baseline distances. If the line is formatted horizontally either with a uniform line spacing or with proportional line spacing, this value represents the extra space above the content.</p> </dd>
            </summary>
            <doc-id>dn933215</doc-id>
            <unmanaged>leadingBefore</unmanaged>
            <unmanaged-short>leadingBefore</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineMetrics1.LeadingAfter">
            <summary>
            <dd> <p>White space after the content of the line. This is included in the height of the line. If the line is formatted horizontally either with a uniform line spacing or with proportional line spacing, this value represents the extra space below the content.</p> </dd>
            </summary>
            <doc-id>dn933215</doc-id>
            <unmanaged>leadingAfter</unmanaged>
            <unmanaged-short>leadingAfter</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.LineSpacing">
            <summary>
            <p></p>
            </summary>
            <doc-id>dn933216</doc-id>
            <unmanaged>DWRITE_LINE_SPACING</unmanaged>
            <unmanaged-short>DWRITE_LINE_SPACING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacing.Method">
            <summary>
            <dd> <p>Method used to determine line spacing.</p> </dd>
            </summary>
            <doc-id>dn933216</doc-id>
            <unmanaged>method</unmanaged>
            <unmanaged-short>method</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacing.Height">
            <summary>
            <dd> <p>Spacing between lines. The interpretation of this parameter depends upon the line spacing method, as follows: </p> <ul> <li>Line spacing: ignored</li> <li>uniform line spacing: explicit distance in DIPs between lines</li> <li>proportional line spacing: a scaling factor to be applied to the computed line height;  for each line, the height of the line is computed as for default line spacing, and the scaling factor is applied to that value.</li> </ul> </dd>
            </summary>
            <doc-id>dn933216</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacing.Baseline">
            <summary>
            <dd> <p>Distance from top of line to baseline.  The interpretation of this parameter depends upon the line spacing method, as follows: </p> <ul> <li>default line spacing: ignored</li> <li>uniform line spacing: explicit distance in DIPs from the top of the line to the baseline</li> <li>proportional line spacing: a scaling factor applied to the computed baseline; for each line,  the baseline distance is computed as for default line spacing, and the scaling factor is applied to that value.</li> </ul> </dd>
            </summary>
            <doc-id>dn933216</doc-id>
            <unmanaged>baseline</unmanaged>
            <unmanaged-short>baseline</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacing.LeadingBefore">
            <summary>
            <dd> <p>Proportion of the entire leading distributed before the line. The allowed value is between 0 and 1.0. The remaining leading is distributed after the line. It is ignored for the default and uniform line spacing methods. The leading that is available to distribute before or after the line depends on the values of the height and baseline parameters.</p> </dd>
            </summary>
            <doc-id>dn933216</doc-id>
            <unmanaged>leadingBefore</unmanaged>
            <unmanaged-short>leadingBefore</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.LineSpacing.FontLineGapUsage">
            <summary>
            <dd> <p>Specify whether <strong><see cref = "T:SharpDX.DirectWrite.FontMetrics"/></strong>::lineGap value should be part of the line metrics.</p> </dd>
            </summary>
            <doc-id>dn933216</doc-id>
            <unmanaged>fontLineGapUsage</unmanaged>
            <unmanaged-short>fontLineGapUsage</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.OverhangMetrics">
            <summary>
            <p>Indicates how much any visible DIPs (device independent pixels) overshoot each side of the layout or inline objects.</p><p>Positive overhangs indicate that the visible area extends outside the layout box or inline object, while negative values mean there is whitespace inside. The returned values are unaffected by rendering transforms or pixel snapping.  Additionally, they may not exactly match the final target's pixel bounds after applying grid fitting and hinting.</p>
            </summary>
            <doc-id>dd368109</doc-id>
            <unmanaged>DWRITE_OVERHANG_METRICS</unmanaged>
            <unmanaged-short>DWRITE_OVERHANG_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OverhangMetrics.Left">
            <summary>
            <dd> <p>The distance from the left-most visible DIP to its  left-alignment edge.</p> </dd>
            </summary>
            <doc-id>dd368109</doc-id>
            <unmanaged>left</unmanaged>
            <unmanaged-short>left</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OverhangMetrics.Top">
            <summary>
            <dd> <p>The distance from the top-most visible DIP to its  top alignment edge.</p> </dd>
            </summary>
            <doc-id>dd368109</doc-id>
            <unmanaged>top</unmanaged>
            <unmanaged-short>top</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OverhangMetrics.Right">
            <summary>
            <dd> <p>The distance from the right-most visible DIP to its  right-alignment edge.</p> </dd>
            </summary>
            <doc-id>dd368109</doc-id>
            <unmanaged>right</unmanaged>
            <unmanaged-short>right</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.OverhangMetrics.Bottom">
            <summary>
            <dd> <p>The distance from the bottom-most visible DIP to its lower-alignment edge.</p> </dd>
            </summary>
            <doc-id>dd368109</doc-id>
            <unmanaged>bottom</unmanaged>
            <unmanaged-short>bottom</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Panose">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.Panose"/></strong> union describes typeface classification values that you use with <strong>IDWriteFont1::GetPanose</strong> to select and match the font.</p>
            </summary>
            <remarks>
            <strong>Note</strong>??The <strong>familyKind</strong> member (index 0) is the only stable entry in the 10-byte array because all the entries that follow can change dynamically depending on the context of the first member.?
            </remarks>
            <doc-id>hh995027</doc-id>
            <unmanaged>DWRITE_PANOSE</unmanaged>
            <unmanaged-short>DWRITE_PANOSE</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.Panose.Values">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh995027</doc-id>
            <unmanaged>values</unmanaged>
            <unmanaged-short>values</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Panose.FamilyKind">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh995027</doc-id>
            <unmanaged>familyKind</unmanaged>
            <unmanaged-short>familyKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Panose.Text">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh995027</doc-id>
            <unmanaged>text</unmanaged>
            <unmanaged-short>text</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Panose.Script">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh995027</doc-id>
            <unmanaged>script</unmanaged>
            <unmanaged-short>script</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Panose.Decorative">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh995027</doc-id>
            <unmanaged>decorative</unmanaged>
            <unmanaged-short>decorative</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Panose.Symbol">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh995027</doc-id>
            <unmanaged>symbol</unmanaged>
            <unmanaged-short>symbol</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseDecorative">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DWRITE_PANOSE_INNER_2</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_INNER_2</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.FamilyKind">
            <summary>
            No documentation.
            </summary>
            <unmanaged>familyKind</unmanaged>
            <unmanaged-short>familyKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.DecorativeClass">
            <summary>
            No documentation.
            </summary>
            <unmanaged>decorativeClass</unmanaged>
            <unmanaged-short>decorativeClass</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.Weight">
            <summary>
            No documentation.
            </summary>
            <unmanaged>weight</unmanaged>
            <unmanaged-short>weight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.Aspect">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspect</unmanaged>
            <unmanaged-short>aspect</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.Contrast">
            <summary>
            No documentation.
            </summary>
            <unmanaged>contrast</unmanaged>
            <unmanaged-short>contrast</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.SerifVariant">
            <summary>
            No documentation.
            </summary>
            <unmanaged>serifVariant</unmanaged>
            <unmanaged-short>serifVariant</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.Fill">
            <summary>
            No documentation.
            </summary>
            <unmanaged>fill</unmanaged>
            <unmanaged-short>fill</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.Lining">
            <summary>
            No documentation.
            </summary>
            <unmanaged>lining</unmanaged>
            <unmanaged-short>lining</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.DecorativeTopology">
            <summary>
            No documentation.
            </summary>
            <unmanaged>decorativeTopology</unmanaged>
            <unmanaged-short>decorativeTopology</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseDecorative.CharacterRange">
            <summary>
            No documentation.
            </summary>
            <unmanaged>characterRange</unmanaged>
            <unmanaged-short>characterRange</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseScript">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DWRITE_PANOSE_INNER_1</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_INNER_1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.FamilyKind">
            <summary>
            No documentation.
            </summary>
            <unmanaged>familyKind</unmanaged>
            <unmanaged-short>familyKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.ToolKind">
            <summary>
            No documentation.
            </summary>
            <unmanaged>toolKind</unmanaged>
            <unmanaged-short>toolKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.Weight">
            <summary>
            No documentation.
            </summary>
            <unmanaged>weight</unmanaged>
            <unmanaged-short>weight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.Spacing">
            <summary>
            No documentation.
            </summary>
            <unmanaged>spacing</unmanaged>
            <unmanaged-short>spacing</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.AspectRatio">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatio</unmanaged>
            <unmanaged-short>aspectRatio</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.Contrast">
            <summary>
            No documentation.
            </summary>
            <unmanaged>contrast</unmanaged>
            <unmanaged-short>contrast</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.ScriptTopology">
            <summary>
            No documentation.
            </summary>
            <unmanaged>scriptTopology</unmanaged>
            <unmanaged-short>scriptTopology</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.ScriptForm">
            <summary>
            No documentation.
            </summary>
            <unmanaged>scriptForm</unmanaged>
            <unmanaged-short>scriptForm</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.Finials">
            <summary>
            No documentation.
            </summary>
            <unmanaged>finials</unmanaged>
            <unmanaged-short>finials</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseScript.XAscent">
            <summary>
            No documentation.
            </summary>
            <unmanaged>xAscent</unmanaged>
            <unmanaged-short>xAscent</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseSymbol">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DWRITE_PANOSE_INNER_3</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_INNER_3</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.FamilyKind">
            <summary>
            No documentation.
            </summary>
            <unmanaged>familyKind</unmanaged>
            <unmanaged-short>familyKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.SymbolKind">
            <summary>
            No documentation.
            </summary>
            <unmanaged>symbolKind</unmanaged>
            <unmanaged-short>symbolKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.Weight">
            <summary>
            No documentation.
            </summary>
            <unmanaged>weight</unmanaged>
            <unmanaged-short>weight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.Spacing">
            <summary>
            No documentation.
            </summary>
            <unmanaged>spacing</unmanaged>
            <unmanaged-short>spacing</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.AspectRatioAndContrast">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatioAndContrast</unmanaged>
            <unmanaged-short>aspectRatioAndContrast</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.AspectRatio94">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatio94</unmanaged>
            <unmanaged-short>aspectRatio94</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.AspectRatio119">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatio119</unmanaged>
            <unmanaged-short>aspectRatio119</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.AspectRatio157">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatio157</unmanaged>
            <unmanaged-short>aspectRatio157</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.AspectRatio163">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatio163</unmanaged>
            <unmanaged-short>aspectRatio163</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseSymbol.AspectRatio211">
            <summary>
            No documentation.
            </summary>
            <unmanaged>aspectRatio211</unmanaged>
            <unmanaged-short>aspectRatio211</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.PanoseText">
            <summary>
            No documentation.
            </summary>
            <unmanaged>DWRITE_PANOSE_INNER_0</unmanaged>
            <unmanaged-short>DWRITE_PANOSE_INNER_0</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.FamilyKind">
            <summary>
            No documentation.
            </summary>
            <unmanaged>familyKind</unmanaged>
            <unmanaged-short>familyKind</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.SerifStyle">
            <summary>
            No documentation.
            </summary>
            <unmanaged>serifStyle</unmanaged>
            <unmanaged-short>serifStyle</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.Weight">
            <summary>
            No documentation.
            </summary>
            <unmanaged>weight</unmanaged>
            <unmanaged-short>weight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.Proportion">
            <summary>
            No documentation.
            </summary>
            <unmanaged>proportion</unmanaged>
            <unmanaged-short>proportion</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.Contrast">
            <summary>
            No documentation.
            </summary>
            <unmanaged>contrast</unmanaged>
            <unmanaged-short>contrast</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.StrokeVariation">
            <summary>
            No documentation.
            </summary>
            <unmanaged>strokeVariation</unmanaged>
            <unmanaged-short>strokeVariation</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.ArmStyle">
            <summary>
            No documentation.
            </summary>
            <unmanaged>armStyle</unmanaged>
            <unmanaged-short>armStyle</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.Letterform">
            <summary>
            No documentation.
            </summary>
            <unmanaged>letterform</unmanaged>
            <unmanaged-short>letterform</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.Midline">
            <summary>
            No documentation.
            </summary>
            <unmanaged>midline</unmanaged>
            <unmanaged-short>midline</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.PanoseText.XHeight">
            <summary>
            No documentation.
            </summary>
            <unmanaged>xHeight</unmanaged>
            <unmanaged-short>xHeight</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ScriptAnalysis">
            <summary>
            <p>Stores the association of text and its writing system script, as well as some display attributes.</p>
            </summary>
            <doc-id>dd368120</doc-id>
            <unmanaged>DWRITE_SCRIPT_ANALYSIS</unmanaged>
            <unmanaged-short>DWRITE_SCRIPT_ANALYSIS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptAnalysis.Script">
            <summary>
            <dd> <p>The zero-based index representation of writing system script.</p> </dd>
            </summary>
            <doc-id>dd368120</doc-id>
            <unmanaged>script</unmanaged>
            <unmanaged-short>script</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptAnalysis.Shapes">
            <summary>
            <dd> <p>A value that indicates additional shaping requirement of text.</p> </dd>
            </summary>
            <doc-id>dd368120</doc-id>
            <unmanaged>shapes</unmanaged>
            <unmanaged-short>shapes</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ScriptProperties">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.ScriptProperties"/></strong> structure specifies script properties for caret navigation and justification.</p>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>DWRITE_SCRIPT_PROPERTIES</unmanaged>
            <unmanaged-short>DWRITE_SCRIPT_PROPERTIES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptProperties.IsoScriptCode">
            <summary>
            <dd> <p>The standardized four character code for the given script. </p> <strong>Note</strong>??These only include the general Unicode scripts, not any additional ISO 15924 scripts for bibliographic distinction. ? </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isoScriptCode</unmanaged>
            <unmanaged-short>isoScriptCode</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptProperties.IsoScriptNumber">
            <summary>
            <dd> <p>The standardized numeric code, ranging 0-999.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isoScriptNumber</unmanaged>
            <unmanaged-short>isoScriptNumber</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptProperties.ClusterLookahead">
            <summary>
            <dd> <p>Number of characters to estimate look-ahead for complex scripts. Latin and all Kana are generally 1. Indic scripts are up to 15, and most others are 8.</p> <strong>Note</strong>??Combining marks and variation selectors can produce clusters that are longer than these look-aheads, so this estimate is considered typical language use. Diacritics must be tested explicitly separately. ? </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>clusterLookahead</unmanaged>
            <unmanaged-short>clusterLookahead</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.ScriptProperties.JustificationCharacter">
            <summary>
            <dd> <p>Appropriate character to elongate the given script for justification. For example:</p> <ul> <li>Arabic    - U+0640 Tatweel</li> <li>Ogham     - U+1680 Ogham Space Mark</li> </ul> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>justificationCharacter</unmanaged>
            <unmanaged-short>justificationCharacter</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.RestrictCaretToClusters">
            <summary>
            <dd> <p>Restrict the caret to whole clusters, like Thai and Devanagari. Scripts such as Arabic by default allow navigation between clusters. Others like Thai always navigate across whole clusters.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>restrictCaretToClusters</unmanaged>
            <unmanaged-short>restrictCaretToClusters</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.UsesWordDividers">
            <summary>
            <dd> <p>The language uses dividers between words, such as spaces between Latin or the Ethiopic wordspace. Examples include Latin, Greek, Devanagari, and Ethiopic. Chinese, Korean, and Thai are excluded.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>usesWordDividers</unmanaged>
            <unmanaged-short>usesWordDividers</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.IsDiscreteWriting">
            <summary>
            <dd> <p>The characters are discrete units from each other. This includes both block scripts and clustered scripts. Examples include Latin, Greek, Cyrillic, Hebrew, Chinese, and Thai.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isDiscreteWriting</unmanaged>
            <unmanaged-short>isDiscreteWriting</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.IsBlockWriting">
            <summary>
            <dd> <p>The language is a block script, expanding between characters. Examples include Chinese, Japanese, Korean, and Bopomofo.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isBlockWriting</unmanaged>
            <unmanaged-short>isBlockWriting</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.IsDistributedWithinCluster">
            <summary>
            <dd> <p>The language is justified within glyph clusters, not just between glyph clusters, such as the character sequence of Thai Lu and Sara Am (U+E026, U+E033), which form a single cluster but still expand between them. Examples include Thai, Lao, and Khmer.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isDistributedWithinCluster</unmanaged>
            <unmanaged-short>isDistributedWithinCluster</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.IsConnectedWriting">
            <summary>
            <dd> <p>The script's clusters are connected to each other (such as the baseline-linked Devanagari), and no separation is added between characters.</p> <strong>Note</strong>??Cursively linked scripts like Arabic are also connected (but not all connected scripts are cursive).  ? <p>Examples include Devanagari, Arabic, Syriac, Bengala, Gurmukhi, and Ogham. Latin, Chinese, and Thaana are excluded.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isConnectedWriting</unmanaged>
            <unmanaged-short>isConnectedWriting</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.IsCursiveWriting">
            <summary>
            <dd> <p>The script is naturally cursive (Arabic and Syriac), meaning it uses other justification methods like kashida extension rather than inter-character spacing.</p> <strong>Note</strong>?? Although other scripts like Latin and Japanese might actually support handwritten cursive forms, they are not considered cursive scripts. ? <p>Examples include Arabic, Syriac, and Mongolian. Thaana, Devanagari, Latin, and Chinese are excluded.</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>isCursiveWriting</unmanaged>
            <unmanaged-short>isCursiveWriting</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ScriptProperties.Reserved">
            <summary>
            <dd> <p>Reserved</p> </dd>
            </summary>
            <doc-id>jj126264</doc-id>
            <unmanaged>reserved</unmanaged>
            <unmanaged-short>reserved</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.ShapingTextProperties">
            <summary>
            <p>Shaping output properties for an output glyph.</p>
            </summary>
            <doc-id>dd368125</doc-id>
            <unmanaged>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged>
            <unmanaged-short>DWRITE_SHAPING_TEXT_PROPERTIES</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingTextProperties.IsShapedAlone">
            <summary>
            <dd> <p>Indicates that the glyph is shaped alone.</p> </dd>
            </summary>
            <doc-id>dd368125</doc-id>
            <unmanaged>isShapedAlone</unmanaged>
            <unmanaged-short>isShapedAlone</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectWrite.ShapingTextProperties.Reserved">
            <summary>
            <dd> <p>Reserved for future use.</p> </dd>
            </summary>
            <doc-id>dd368125</doc-id>
            <unmanaged>reserved</unmanaged>
            <unmanaged-short>reserved</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Strikethrough">
            <summary>
            <p>Contains information regarding the size and placement of strikethroughs. All coordinates are in device independent pixels (DIPs).</p>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>DWRITE_STRIKETHROUGH</unmanaged>
            <unmanaged-short>DWRITE_STRIKETHROUGH</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.Width">
            <summary>
            <dd> <p>A value that indicates the width of the strikethrough, measured parallel to the baseline.</p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.Thickness">
            <summary>
            <dd> <p>A value that indicates the thickness of the strikethrough, measured perpendicular to the baseline.</p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>thickness</unmanaged>
            <unmanaged-short>thickness</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.Offset">
            <summary>
            <dd> <p>A value that indicates the offset of the strikethrough from the baseline.  A positive offset represents a position below the baseline and  a negative offset is above.  Typically, the offset will be negative.</p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>offset</unmanaged>
            <unmanaged-short>offset</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.ReadingDirection">
            <summary>
            <dd> <p>Reading direction of the text associated with the strikethrough.  This value is used to interpret whether the width value runs horizontally  or vertically.</p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>readingDirection</unmanaged>
            <unmanaged-short>readingDirection</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.FlowDirection">
            <summary>
            <dd> <p>Flow direction of the text associated with the strikethrough.  This value is used to interpret whether the thickness value advances top to  bottom, left to right, or right to left.</p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>flowDirection</unmanaged>
            <unmanaged-short>flowDirection</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.LocaleName">
            <summary>
            <dd> <p>An array of characters containing the locale of the  text that is the strikethrough is being drawn over. </p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>localeName</unmanaged>
            <unmanaged-short>localeName</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Strikethrough.MeasuringMode">
            <summary>
            <dd> <p>The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.</p> </dd>
            </summary>
            <doc-id>dd368126</doc-id>
            <unmanaged>measuringMode</unmanaged>
            <unmanaged-short>measuringMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TextMetrics">
            <summary>
            <p>Contains the metrics associated with text after layout.  All coordinates are in device independent pixels (DIPs).</p>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>DWRITE_TEXT_METRICS</unmanaged>
            <unmanaged-short>DWRITE_TEXT_METRICS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.Left">
            <summary>
            <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>left</unmanaged>
            <unmanaged-short>left</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.Top">
            <summary>
            <dd> <p>A value that indicates the top-most point of formatted text relative to the layout box, while excluding any glyph overhang.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>top</unmanaged>
            <unmanaged-short>top</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.Width">
            <summary>
            <dd> <p>A value that indicates the width of the formatted text, while ignoring trailing whitespace  at the end of each line.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.WidthIncludingTrailingWhitespace">
            <summary>
            <dd> <p>The width of the formatted text, taking into account the  trailing whitespace at the end of each line.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>widthIncludingTrailingWhitespace</unmanaged>
            <unmanaged-short>widthIncludingTrailingWhitespace</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.Height">
            <summary>
            <dd> <p>The height of the formatted text. The height of an empty string  is set to the same value as that of the default font.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.LayoutWidth">
            <summary>
            <dd> <p>The initial width given to the layout. It can be either larger or smaller than the  text content width, depending on whether the text  was wrapped.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>layoutWidth</unmanaged>
            <unmanaged-short>layoutWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.LayoutHeight">
            <summary>
            <dd> <p>Initial height given to the layout. Depending on the length of the text, it may be larger or smaller than the text content height.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>layoutHeight</unmanaged>
            <unmanaged-short>layoutHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.MaxBidiReorderingDepth">
            <summary>
            <dd> <p>The maximum reordering count of any line of text, used  to calculate the most number of hit-testing boxes needed.  If the layout has no bidirectional text, or no text at all,  the minimum level is 1.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>maxBidiReorderingDepth</unmanaged>
            <unmanaged-short>maxBidiReorderingDepth</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics.LineCount">
            <summary>
            <dd> <p>Total number of lines.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>lineCount</unmanaged>
            <unmanaged-short>lineCount</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TextMetrics1">
            <summary>
            <p>Contains the metrics associated with text after layout.  All coordinates are in device independent pixels (DIPs).</p>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>DWRITE_TEXT_METRICS1</unmanaged>
            <unmanaged-short>DWRITE_TEXT_METRICS1</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.Left">
            <summary>
            <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>left</unmanaged>
            <unmanaged-short>left</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.Top">
            <summary>
            <dd> <p>A value that indicates the top-most point of formatted text relative to the layout box, while excluding any glyph overhang.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>top</unmanaged>
            <unmanaged-short>top</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.Width">
            <summary>
            <dd> <p>A value that indicates the width of the formatted text, while ignoring trailing whitespace  at the end of each line.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.WidthIncludingTrailingWhitespace">
            <summary>
            <dd> <p>The width of the formatted text, taking into account the  trailing whitespace at the end of each line.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>widthIncludingTrailingWhitespace</unmanaged>
            <unmanaged-short>widthIncludingTrailingWhitespace</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.Height">
            <summary>
            <dd> <p>The height of the formatted text. The height of an empty string  is set to the same value as that of the default font.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>height</unmanaged>
            <unmanaged-short>height</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.LayoutWidth">
            <summary>
            <dd> <p>The initial width given to the layout. It can be either larger or smaller than the  text content width, depending on whether the text  was wrapped.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>layoutWidth</unmanaged>
            <unmanaged-short>layoutWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.LayoutHeight">
            <summary>
            <dd> <p>Initial height given to the layout. Depending on the length of the text, it may be larger or smaller than the text content height.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>layoutHeight</unmanaged>
            <unmanaged-short>layoutHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.MaxBidiReorderingDepth">
            <summary>
            <dd> <p>The maximum reordering count of any line of text, used  to calculate the most number of hit-testing boxes needed.  If the layout has no bidirectional text, or no text at all,  the minimum level is 1.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>maxBidiReorderingDepth</unmanaged>
            <unmanaged-short>maxBidiReorderingDepth</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.LineCount">
            <summary>
            <dd> <p>Total number of lines.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>lineCount</unmanaged>
            <unmanaged-short>lineCount</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TextMetrics1.HeightIncludingTrailingWhitespace">
            <summary>
            <dd> <p>A value that indicates the left-most point of formatted text relative to the layout box,  while excluding any glyph overhang.</p> </dd>
            </summary>
            <doc-id>dd368135</doc-id>
            <unmanaged>heightIncludingTrailingWhitespace</unmanaged>
            <unmanaged-short>heightIncludingTrailingWhitespace</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Trimming">
            <summary>
            <p>Specifies the trimming option for text overflowing the layout box. </p>
            </summary>
            <doc-id>dd368139</doc-id>
            <unmanaged>DWRITE_TRIMMING</unmanaged>
            <unmanaged-short>DWRITE_TRIMMING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Trimming.Granularity">
            <summary>
            <dd> <p>A value that specifies  the text granularity used to trim text overflowing the layout box.</p> </dd>
            </summary>
            <doc-id>dd368139</doc-id>
            <unmanaged>granularity</unmanaged>
            <unmanaged-short>granularity</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Trimming.Delimiter">
            <summary>
            <dd> <p>A character code used as the delimiter that signals the beginning of the portion of text to be preserved.  Text starting from the Nth occurence of the delimiter (where N equals delimiterCount) counting backwards from the end of the text block will be preserved. For example, given the text is a path like c:\A\B\C\D\file.txt and delimiter equal to '\' and delimiterCount equal to 1, the file.txt portion of the text would be preserved.   Specifying a delimiterCount of 2 would preserve D\file.txt. </p> </dd>
            </summary>
            <doc-id>dd368139</doc-id>
            <unmanaged>delimiter</unmanaged>
            <unmanaged-short>delimiter</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Trimming.DelimiterCount">
            <summary>
            <dd> <p>The delimiter count, counting from the end of the text, to preserve text from.</p> </dd>
            </summary>
            <doc-id>dd368139</doc-id>
            <unmanaged>delimiterCount</unmanaged>
            <unmanaged-short>delimiterCount</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.TypographicFeatures">
            <summary>
            <p>Contains a set of typographic features to be applied during text shaping.</p>
            </summary>
            <doc-id>dd368143</doc-id>
            <unmanaged>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged>
            <unmanaged-short>DWRITE_TYPOGRAPHIC_FEATURES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TypographicFeatures.Features">
            <summary>
            <dd> <p>A reference to a structure that specifies properties used to identify and execute typographic features in the font.</p> </dd>
            </summary>
            <doc-id>dd368143</doc-id>
            <unmanaged>features</unmanaged>
            <unmanaged-short>features</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.TypographicFeatures.FeatureCount">
            <summary>
            <dd> <p>A value that indicates the number of features being applied to a font face.</p> </dd>
            </summary>
            <doc-id>dd368143</doc-id>
            <unmanaged>featureCount</unmanaged>
            <unmanaged-short>featureCount</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.Underline">
            <summary>
            <p>Contains information about the width, thickness, offset, run height, reading direction, and flow direction of an underline. </p>
            </summary>
            <remarks>
            <p>All coordinates are in device independent pixels (DIPs).</p>
            </remarks>
            <doc-id>dd368145</doc-id>
            <unmanaged>DWRITE_UNDERLINE</unmanaged>
            <unmanaged-short>DWRITE_UNDERLINE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.Width">
            <summary>
            <dd> <p>A value that indicates the width of the underline, measured parallel to the baseline.</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>width</unmanaged>
            <unmanaged-short>width</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.Thickness">
            <summary>
            <dd> <p>A value that indicates the thickness of the underline, measured perpendicular to the baseline.</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>thickness</unmanaged>
            <unmanaged-short>thickness</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.Offset">
            <summary>
            <dd> <p>A value that indicates the offset of the underline from the baseline. A positive offset represents a position below the baseline (away from the text) and a negative offset is above (toward the text).</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>offset</unmanaged>
            <unmanaged-short>offset</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.RunHeight">
            <summary>
            <dd> <p>A value that indicates the height of the tallest run where the underline is applied.</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>runHeight</unmanaged>
            <unmanaged-short>runHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.ReadingDirection">
            <summary>
            <dd> <p>A value that indicates the reading direction of the text associated with the underline. This value is used to interpret whether the width value runs horizontally or vertically.</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>readingDirection</unmanaged>
            <unmanaged-short>readingDirection</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.FlowDirection">
            <summary>
            <dd> <p>A value that indicates the flow direction of the text associated with the underline. This value is used to interpret whether the thickness value advances top to bottom, left to right, or right to left.</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>flowDirection</unmanaged>
            <unmanaged-short>flowDirection</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.LocaleName">
            <summary>
            <dd> <p>An array of characters which contains the locale of the text that the underline is being drawn under.  For example, in vertical text, the underline belongs on the left for Chinese but on the right for Japanese. </p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>localeName</unmanaged>
            <unmanaged-short>localeName</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.Underline.MeasuringMode">
            <summary>
            <dd> <p>The measuring mode can be useful to the renderer to determine how underlines are rendered, such as rounding the thickness to a whole pixel in GDI-compatible modes.</p> </dd>
            </summary>
            <doc-id>dd368145</doc-id>
            <unmanaged>measuringMode</unmanaged>
            <unmanaged-short>measuringMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectWrite.UnicodeRange">
            <summary>
            <p>The <strong><see cref = "T:SharpDX.DirectWrite.UnicodeRange"/></strong> structure specifies the range of Unicode code points.</p>
            </summary>
            <doc-id>jj126265</doc-id>
            <unmanaged>DWRITE_UNICODE_RANGE</unmanaged>
            <unmanaged-short>DWRITE_UNICODE_RANGE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.UnicodeRange.First">
            <summary>
            <dd> <p>The first code point in the Unicode range.</p> </dd>
            </summary>
            <doc-id>jj126265</doc-id>
            <unmanaged>first</unmanaged>
            <unmanaged-short>first</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectWrite.UnicodeRange.Last">
            <summary>
            <dd> <p>The last code point in the Unicode range.</p> </dd>
            </summary>
            <doc-id>jj126265</doc-id>
            <unmanaged>last</unmanaged>
            <unmanaged-short>last</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Bitmap.#ctor(SharpDX.WIC.ImagingFactory,System.Int32,System.Int32,System.Guid,SharpDX.WIC.BitmapCreateCacheOption)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.Bitmap"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="pixelFormat">The pixel format. <see cref="T:SharpDX.WIC.PixelFormat"/> for a list of valid formats. </param>
            <param name="option">The option.</param>
            <msdn-id>ee690282</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmap([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
            <unmanaged-short>IWICImagingFactory::CreateBitmap</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Bitmap.#ctor(SharpDX.WIC.ImagingFactory,System.Int32,System.Int32,System.Guid,SharpDX.DataRectangle,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.Bitmap"/> class from a memory location using <see cref="T:SharpDX.DataRectangle"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="pixelFormat">The pixel format.</param>
            <param name="dataRectangle">The data rectangle.</param>
            <param name="totalSizeInBytes">Size of the buffer in <see cref="!:dataRectangle"/>. If == 0, calculate the size automatically based on the height and row pitch.</param>
            <msdn-id>ee690291</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromMemory([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Bitmap.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.BitmapSource,SharpDX.WIC.BitmapCreateCacheOption)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.Bitmap"/> class from a <see cref="T:SharpDX.WIC.BitmapSource"/>
            </summary>
            <param name="factory">The factory.</param>
            <param name="bitmapSource">The bitmap source ref.</param>
            <param name="option">The option.</param>
            <msdn-id>ee690293</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromSource</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Bitmap.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.BitmapSource,SharpDX.Mathematics.Interop.RawBox)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.Bitmap"/> class from a <see cref="T:SharpDX.WIC.BitmapSource"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="bitmapSource">The bitmap source.</param>
            <param name="rectangle">The rectangle.</param>
            <msdn-id>ee690294</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSourceRect([In, Optional] IWICBitmapSource* pIBitmapSource,[In] unsigned int x,[In] unsigned int y,[In] unsigned int width,[In] unsigned int height,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromSourceRect</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Bitmap.New``1(SharpDX.WIC.ImagingFactory,System.Int32,System.Int32,System.Guid,``0[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.Bitmap"/> class from an array of pixel data.
            </summary>
            <param name="factory">The factory.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="pixelFormat">The pixel format.</param>
            <param name="pixelDatas">The pixel data.</param>
            <param name="stride">Stride of a row of pixels (number of bytes per row). By default the stride is == 0, and calculated by taking the sizeof(T) * width.</param>
            <msdn-id>ee690291</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromMemory([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>	
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Bitmap.Lock(SharpDX.WIC.BitmapLockFlags)">
            <summary>	
            <p>Provides access to a rectangular area of the bitmap.</p>	
            </summary>	
            <param name="flags"><dd>  <p>The access mode you wish to obtain for the lock. This is a bitwise combination of <strong><see cref="T:SharpDX.WIC.BitmapLockFlags"/></strong> for read, write, or read and write access.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="F:SharpDX.WIC.BitmapLockFlags.Read"/></strong></dt> </dl> </td><td> <p>The read access lock.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="F:SharpDX.WIC.BitmapLockFlags.Write"/></strong></dt> </dl> </td><td> <p>The write access lock.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <returns><dd>  <p>A reference that receives the locked memory location.</p> </dd></returns>	
            <remarks>	
            <p>Locks are exclusive for writing but can be shared for reading. You cannot call <strong>CopyPixels</strong> while the <strong><see cref="T:SharpDX.WIC.Bitmap"/></strong> is locked for writing. Doing so will return an error, since locks are exclusive.</p>	
            </remarks>	
            <msdn-id>ee690187</msdn-id>	
            <unmanaged>HRESULT IWICBitmap::Lock([In, Optional] const WICRect* prcLock,[In] WICBitmapLockFlags flags,[Out] IWICBitmapLock** ppILock)</unmanaged>	
            <unmanaged-short>IWICBitmap::Lock</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Bitmap.Lock(SharpDX.Mathematics.Interop.RawBox,SharpDX.WIC.BitmapLockFlags)">
            <summary>	
            <p>Provides access to a rectangular area of the bitmap.</p>	
            </summary>	
            <param name="rcLockRef"><dd>  <p>The rectangle to be accessed.</p> </dd></param>	
            <param name="flags"><dd>  <p>The access mode you wish to obtain for the lock. This is a bitwise combination of <strong><see cref="T:SharpDX.WIC.BitmapLockFlags"/></strong> for read, write, or read and write access.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong><see cref="F:SharpDX.WIC.BitmapLockFlags.Read"/></strong></dt> </dl> </td><td> <p>The read access lock.</p> </td></tr> <tr><td><dl> <dt><strong><see cref="F:SharpDX.WIC.BitmapLockFlags.Write"/></strong></dt> </dl> </td><td> <p>The write access lock.</p> </td></tr> </table> <p>?</p> </dd></param>	
            <returns><dd>  <p>A reference that receives the locked memory location.</p> </dd></returns>	
            <remarks>	
            <p>Locks are exclusive for writing but can be shared for reading. You cannot call <strong>CopyPixels</strong> while the <strong><see cref="T:SharpDX.WIC.Bitmap"/></strong> is locked for writing. Doing so will return an error, since locks are exclusive.</p>	
            </remarks>	
            <msdn-id>ee690187</msdn-id>	
            <unmanaged>HRESULT IWICBitmap::Lock([In, Optional] const WICRect* prcLock,[In] WICBitmapLockFlags flags,[Out] IWICBitmapLock** ppILock)</unmanaged>	
            <unmanaged-short>IWICBitmap::Lock</unmanaged-short>	
        </member>
        <member name="P:SharpDX.WIC.Bitmap.Palette">
            <summary>
            <p>Provides access for palette modifications.</p>
            </summary>
            <doc-id>ee690189</doc-id>
            <unmanaged>SetPalette</unmanaged>
            <unmanaged-short>SetPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Bitmap.Lock(System.IntPtr,SharpDX.WIC.BitmapLockFlags)">
            <summary>
            <p>Provides access to a rectangular area of the bitmap.</p>
            </summary>
            <param name = "rcLockRef"><dd>  <p>The rectangle to be accessed.</p> </dd></param>
            <param name = "flags"><dd>  <p>The access mode you wish to obtain for the lock. This is a bitwise combination of <strong><see cref = "T:SharpDX.WIC.BitmapLockFlags"/></strong> for read, write, or read and write access.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>WICBitmapLockRead</strong></dt> </dl> </td><td> <p>The read access lock.</p> </td></tr> <tr><td><dl> <dt><strong>WICBitmapLockWrite</strong></dt> </dl> </td><td> <p>The write access lock.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><dd>  <p>A reference that receives the locked memory location.</p> </dd></returns>
            <remarks>
            <p>Locks are exclusive for writing but can be shared for reading. You cannot call <strong>CopyPixels</strong> while the <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> is locked for writing. Doing so will return an error, since locks are exclusive.</p>
            </remarks>
            <doc-id>ee690187</doc-id>
            <unmanaged>HRESULT IWICBitmap::Lock([In] const WICRect* prcLock,[In] DWORD flags,[Out] IWICBitmapLock** ppILock)</unmanaged>
            <unmanaged-short>IWICBitmap::Lock</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Bitmap.SetPalette(SharpDX.WIC.Palette)">
            <summary>
            <p>Provides access for palette modifications.</p>
            </summary>
            <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690189</doc-id>
            <unmanaged>HRESULT IWICBitmap::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
            <unmanaged-short>IWICBitmap::SetPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Bitmap.SetResolution(System.Double,System.Double)">
            <summary>
            <p>Changes the physical resolution of the image.</p>
            </summary>
            <param name = "dpiX"><dd>  <p>The horizontal resolution.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>The vertical resolution.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method has no effect on the actual pixels or samples stored in the bitmap.  Instead the interpretation of the sampling rate is modified.  This means that a 96 DPI image which is 96 pixels wide is one inch.  If the physical resolution is modified to 48 DPI, then the bitmap is considered to be 2 inches wide but has the same number of pixels.   If the resolution is less than <strong>REAL_EPSILON</strong> (1.192092896e-07F) the error code <strong><see cref = "!:InvalidParameter"/></strong> is returned.</p>
            </remarks>
            <doc-id>ee690191</doc-id>
            <unmanaged>HRESULT IWICBitmap::SetResolution([In] double dpiX,[In] double dpiY)</unmanaged>
            <unmanaged-short>IWICBitmap::SetResolution</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapClipper.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapClipper"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.BitmapClipper.Initialize(SharpDX.WIC.BitmapSource,SharpDX.Mathematics.Interop.RawBox)">
            <summary>	
            <p>Initializes the bitmap clipper with the provided parameters.</p>	
            </summary>	
            <param name="sourceRef"><dd>  <p>he input bitmap source.</p> </dd></param>	
            <param name="rectangleRef"><dd>  <p>The rectangle of the bitmap source to clip.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <msdn-id>ee719677</msdn-id>	
            <unmanaged>HRESULT IWICBitmapClipper::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const WICRect* prc)</unmanaged>	
            <unmanaged-short>IWICBitmapClipper::Initialize</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapClipper.Initialize(SharpDX.WIC.BitmapSource,System.IntPtr)">
            <summary>
            <p>Initializes the bitmap clipper with the provided parameters.</p>
            </summary>
            <param name = "sourceRef"><dd>  <p>he input bitmap source.</p> </dd></param>
            <param name = "rectangleRef"><dd>  <p>The rectangle of the bitmap source to clip.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719677</doc-id>
            <unmanaged>HRESULT IWICBitmapClipper::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const WICRect* prc)</unmanaged>
            <unmanaged-short>IWICBitmapClipper::Initialize</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.PixelFormats">
            <summary>
            Gets the pixel formats the codec supports.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.ColorManagementVersion">
            <summary>
            Gets the color management version number the codec supports.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.DeviceManufacturer">
            <summary>
            Gets the name of the device manufacture associated with the codec.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.DeviceModels">
            <summary>
            Gets a comma delimited list of device models associated with the codec.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.MimeTypes">
            <summary>
            Gets a comma delimited sequence of mime types associated with the codec.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.FileExtensions">
            <summary>
            Gets a comma delimited list of the file name extensions associated with the codec.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.ContainerFormat">
            <summary>
            <p>Proxy function for the <strong>GetContainerFormat</strong> method.</p>
            </summary>
            <doc-id>ee719689</doc-id>
            <unmanaged>GetContainerFormat</unmanaged>
            <unmanaged-short>GetContainerFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.IsAnimationSupported">
            <summary>
            <p>Proxy function for the <strong>DoesSupportAnimation</strong> method.</p>
            </summary>
            <doc-id>ee719681</doc-id>
            <unmanaged>DoesSupportAnimation</unmanaged>
            <unmanaged-short>DoesSupportAnimation</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.IsChromakeySupported">
            <summary>
            <p>Retrieves a value indicating whether the codec supports chromakeys.</p>
            </summary>
            <doc-id>ee719682</doc-id>
            <unmanaged>DoesSupportChromakey</unmanaged>
            <unmanaged-short>DoesSupportChromakey</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.IsLosslessSupported">
            <summary>
            <p>Retrieves a value indicating whether the codec supports lossless formats.</p>
            </summary>
            <doc-id>ee719683</doc-id>
            <unmanaged>DoesSupportLossless</unmanaged>
            <unmanaged-short>DoesSupportLossless</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapCodecInfo.IsMultiframeSupported">
            <summary>
            <p>Retrieves a value indicating whether the codec supports multi frame images.</p>
            </summary>
            <doc-id>ee719685</doc-id>
            <unmanaged>DoesSupportMultiframe</unmanaged>
            <unmanaged-short>DoesSupportMultiframe</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetContainerFormat(System.Guid@)">
            <summary>
            <p>Proxy function for the <strong>GetContainerFormat</strong> method.</p>
            </summary>
            <param name = "guidContainerFormatRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719689</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetContainerFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetPixelFormats(System.Int32,System.Guid[],System.Int32@)">
            <summary>
            <p>Retrieves the pixel formats the codec supports.</p>
            </summary>
            <param name = "formats"><dd>  <p>The size of the <em>pguidPixelFormats</em> array. Use <code>0</code> on first call to determine the needed array size.</p> </dd></param>
            <param name = "guidPixelFormatsRef"><dd>  <p>Receives the supported pixel formats. Use <code><c>null</c></code> on first call to determine needed array size.</p> </dd></param>
            <param name = "actualRef"><dd>  <p>The array size needed to retrieve all supported pixel formats.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The usage pattern for this method is a two call process. The first call retrieves the array size needed to retrieve all the supported pixel formats by calling it with <em>cFormats</em> set to <code>0</code> and <em>pguidPixelFormats</em> set to <code><c>null</c></code>. This call sets <em>pcActual</em> to the array size needed. Once the needed array size is determined, a second <strong>GetPixelFormats</strong> call with <em>pguidPixelFormats</em> set to an array of the appropriate size will retrieve the pixel formats. </p>
            </remarks>
            <doc-id>ee690082</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetPixelFormats([In] unsigned int cFormats,[In, Buffer] GUID* pguidPixelFormats,[Out] unsigned int* pcActual)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetPixelFormats</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetColorManagementVersion(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the color manangement version number the codec supports.</p>
            </summary>
            <param name = "cchColorManagementVersion"><dd>  <p>The size of the version buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "colorManagementVersion"><dd>  <p>Receives the color management version number. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve the full color management version number.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchColorManagementVersion</em> set to <code>0</code> and <em>wzColorManagementVersion</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetColorManagementVersion</strong> call with <em>cchColorManagementVersion</em> set to the buffer size and <em>wzColorManagementVersion</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
            </remarks>
            <doc-id>ee719687</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetColorManagementVersion([In] unsigned int cchColorManagementVersion,[In] wchar_t* wzColorManagementVersion,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetColorManagementVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetDeviceManufacturer(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the name of the device manufacture associated with the codec.</p>
            </summary>
            <param name = "cchDeviceManufacturer"><dd>  <p>The size of the device manufacture's name. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "deviceManufacturer"><dd>  <p>Receives the device manufacture's name. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve the device manufacture's name.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchDeviceManufacturer</em> set to <code>0</code> and <em>wzDeviceManufacturer</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetDeviceManufacturer</strong> call with <em>cchDeviceManufacturer</em> set to the buffer size and <em>wzDeviceManufacturer</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
            </remarks>
            <doc-id>ee719690</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetDeviceManufacturer([In] unsigned int cchDeviceManufacturer,[In] wchar_t* wzDeviceManufacturer,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetDeviceManufacturer</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetDeviceModels(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves a comma delimited list of device models associated with the codec.</p>
            </summary>
            <param name = "cchDeviceModels"><dd>  <p>The size of the device models buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "deviceModels"><dd>  <p>Receives a comma delimited list of device model names associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all of the device model names.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchDeviceModels</em> set to <code>0</code> and <em>wzDeviceModels</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetDeviceModels</strong> call with <em>cchDeviceModels</em> set to the buffer size and <em>wzDeviceModels</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
            </remarks>
            <doc-id>ee719692</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetDeviceModels([In] unsigned int cchDeviceModels,[In] wchar_t* wzDeviceModels,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetDeviceModels</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetMimeTypes(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetMimeTypes</strong> method.</p>
            </summary>
            <param name = "cchMimeTypes">No documentation.</param>
            <param name = "mimeTypes">No documentation.</param>
            <param name = "cchActualRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719697</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetMimeTypes([In] unsigned int cchMimeTypes,[In] wchar_t* wzMimeTypes,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetMimeTypes</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.GetFileExtensions(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves a comma delimited list of the file name extensions associated with the codec.</p>
            </summary>
            <param name = "cchFileExtensions"><dd>  <p>The size of the file name extension buffer. Use <code>0</code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "fileExtensions"><dd>  <p>Receives a comma delimited list  of file name extensions associated with the codec. Use <code><c>null</c></code> on first call to determine needed buffer size.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>The actual buffer size needed to retrieve all file name extensions associated with the codec. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The default extension for an image encoder is the first item in the list of returned extensions.</p><p> The usage pattern for this method is a two call process. The first call retrieves the buffer size needed to retrieve the full color management version number by calling it with <em>cchFileExtensions</em> set to <code>0</code> and <em>wzFileExtensions</em> set to <code><c>null</c></code>. This call sets <em>pcchActual</em> to the buffer size needed. Once the needed buffer size is determined, a second <strong>GetFileExtensions</strong> call with <em>cchFileExtensions</em> set to the buffer size and <em>wzFileExtensions</em> set to a buffer of the appropriate size will retrieve the pixel formats. </p>
            </remarks>
            <doc-id>ee719694</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::GetFileExtensions([In] unsigned int cchFileExtensions,[In] wchar_t* wzFileExtensions,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::GetFileExtensions</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.IsAnimationSupported_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Proxy function for the <strong>DoesSupportAnimation</strong> method.</p>
            </summary>
            <param name = "fSupportAnimationRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719681</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportAnimation([Out] BOOL* pfSupportAnimation)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::DoesSupportAnimation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.IsChromakeySupported_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves a value indicating whether the codec supports chromakeys.</p>
            </summary>
            <param name = "fSupportChromakeyRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports chromakeys; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719682</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportChromakey([Out] BOOL* pfSupportChromakey)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::DoesSupportChromakey</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.IsLosslessSupported_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves a value indicating whether the codec supports lossless formats.</p>
            </summary>
            <param name = "fSupportLosslessRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports lossless formats; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719683</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportLossless([Out] BOOL* pfSupportLossless)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::DoesSupportLossless</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.IsMultiframeSupported_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves a value indicating whether the codec supports multi frame images.</p>
            </summary>
            <param name = "fSupportMultiframeRef"><dd>  <p>Receives <strong>TRUE</strong> if the codec supports multi frame images; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719685</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::DoesSupportMultiframe([Out] BOOL* pfSupportMultiframe)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::DoesSupportMultiframe</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecInfo.MatchesMimeType(System.String)">
            <summary>
            <p>Retrieves a value indicating whether the given mime type matches the mime type of the codec.</p>
            </summary>
            <param name = "mimeType"><dd>  <p>The mime type to compare.</p> </dd></param>
            <returns><dd>  <p>Receives <strong>TRUE</strong> if the mime types match; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <remarks>
            <strong>Note</strong>??The Windows provided codecs do not implement this method and return E_NOTIMPL.?
            </remarks>
            <doc-id>ee690083</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecInfo::MatchesMimeType([In] const wchar_t* wzMimeType,[Out] BOOL* pfMatches)</unmanaged>
            <unmanaged-short>IWICBitmapCodecInfo::MatchesMimeType</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.BitmapDecoderInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a <see cref="T:SharpDX.WIC.BitmapDecoderInfo"/>.
            </summary>
            <param name="bitmapDecoderInfo">The bitmap decoder info.</param>
            <unmanaged>HRESULT IWICBitmapDecoderInfo::CreateInstance([Out, Fast] IWICBitmapDecoder** ppIBitmapDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a guid. <see cref="T:SharpDX.WIC.BitmapDecoderGuids"/> for a list of default supported decoder.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.Win32.IStream,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a <see cref="T:SharpDX.Win32.IStream"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="streamRef">The stream ref.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a <see cref="T:SharpDX.Win32.IStream"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="streamRef">The stream ref.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.Win32.IStream,System.Guid,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a <see cref="T:SharpDX.Win32.IStream"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="streamRef">The stream ref.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream,System.Guid,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a <see cref="T:SharpDX.Win32.IStream"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="streamRef">The stream ref.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.String,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a file in read mode.
            </summary>
            <param name="factory">The factory.</param>
            <param name="filename">The filename.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFilename([In] const wchar_t* wzFilename,[In, Optional] const GUID* pguidVendor,[In] unsigned int dwDesiredAccess,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.String,SharpDX.IO.NativeFileAccess,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a file.
            </summary>
            <param name="factory">The factory.</param>
            <param name="filename">The filename.</param>
            <param name="desiredAccess">The desired access.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFilename([In] const wchar_t* wzFilename,[In, Optional] const GUID* pguidVendor,[In] unsigned int dwDesiredAccess,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.String,System.Nullable{System.Guid},SharpDX.IO.NativeFileAccess,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a file.
            </summary>
            <param name="factory">The factory.</param>
            <param name="filename">The filename.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="desiredAccess">The desired access.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFilename([In] const wchar_t* wzFilename,[In, Optional] const GUID* pguidVendor,[In] unsigned int dwDesiredAccess,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.IO.NativeFileStream,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a file stream.
            </summary>
            <param name="factory">The factory.</param>
            <param name="fileStream">The filename.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFileHandle([In] unsigned int hFile,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.IO.NativeFileStream,System.Guid,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapDecoder"/> class from a file stream.
            </summary>
            <param name="factory">The factory.</param>
            <param name="fileStream">The filename.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="metadataOptions">The metadata options.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFileHandle([In] unsigned int hFile,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.Initialize(SharpDX.Win32.IStream,SharpDX.WIC.DecodeOptions)">
            <summary>
            Initializes the decoder with the provided stream.
            </summary>
            <param name="stream">The stream to use for initialization.</param>
            <param name="cacheOptions">The cache options.</param>
            <returns>If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>. Otherwise, it throws an exception.</returns>
            <unmanaged>HRESULT IWICBitmapDecoder::Initialize([In, Optional] IStream* pIStream,[In] WICDecodeOptions cacheOptions)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.TryGetColorContexts(SharpDX.WIC.ImagingFactory,SharpDX.WIC.ColorContext[]@)">
            <summary>
            Get the <see cref="T:SharpDX.WIC.ColorContext"/> of the image (if any)
            </summary>
            <param name="imagingFactory">The factory for creating new color contexts</param>
            <param name="colorContexts">The color context array, or null</param>
            <remarks>
            When the image format does not support color contexts,
            <see cref="F:SharpDX.WIC.ResultCode.UnsupportedOperation"/> is returned.
            </remarks>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[Out, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.TryGetColorContexts(SharpDX.WIC.ImagingFactory)">
            <summary>
            Get the <see cref="T:SharpDX.WIC.ColorContext"/> of the image (if any)
            </summary>
            <returns>
            null if the decoder does not support color contexts;
            otherwise an array of zero or more ColorContext objects
            </returns>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[Out, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] </unmanaged>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoder.ContainerFormat">
            <summary>
            <p>Retrieves the image's container format.</p>
            </summary>
            <doc-id>ee690095</doc-id>
            <unmanaged>GetContainerFormat</unmanaged>
            <unmanaged-short>GetContainerFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoder.DecoderInfo">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.WIC.BitmapDecoderInfo"/></strong> for the image.</p>
            </summary>
            <doc-id>ee690096</doc-id>
            <unmanaged>GetDecoderInfo</unmanaged>
            <unmanaged-short>GetDecoderInfo</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoder.MetadataQueryReader">
            <summary>
            <p>Proxy function for the <strong>GetMetadataQueryReader</strong> method.</p>
            </summary>
            <doc-id>ee690103</doc-id>
            <unmanaged>GetMetadataQueryReader</unmanaged>
            <unmanaged-short>GetMetadataQueryReader</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoder.Preview">
            <summary>
            <p>Retrieves a preview image, if supported.</p>
            </summary>
            <remarks>
            <p>Not all formats support previews. Only the native Microsoft?Windows Digital Photo (WDP) codec support previews.</p>
            </remarks>
            <doc-id>ee690104</doc-id>
            <unmanaged>GetPreview</unmanaged>
            <unmanaged-short>GetPreview</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoder.Thumbnail">
            <summary>
            <p>Proxy function for the <strong>GetThumbnail</strong> method.</p>
            </summary>
            <doc-id>ee690107</doc-id>
            <unmanaged>GetThumbnail</unmanaged>
            <unmanaged-short>GetThumbnail</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoder.FrameCount">
            <summary>
            <p>Retrieves the total number of frames in the image.</p>
            </summary>
            <doc-id>ee690099</doc-id>
            <unmanaged>GetFrameCount</unmanaged>
            <unmanaged-short>GetFrameCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.QueryCapability(SharpDX.Win32.IStream)">
            <summary>
            <p>Retrieves the capabilities of the decoder based on the specified stream.</p>
            </summary>
            <param name = "streamRef"><dd>  <p>The stream to retrieve the decoder capabilities from.</p> </dd></param>
            <returns><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapDecoderCapabilities"/></strong> of the decoder.</p> </dd></returns>
            <remarks>
            <p>Custom decoder implementations should save the current position of the specified <see cref = "T:SharpDX.Win32.IStream"/>, read whatever information is necessary in order to determine which capabilities it can provide for the supplied stream, and restore the stream position.</p>
            </remarks>
            <doc-id>ee690109</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::QueryCapability([In, Optional] IStream* pIStream,[Out] DWORD* pdwCapability)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::QueryCapability</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.Initialize_(SharpDX.Win32.IStream,SharpDX.WIC.DecodeOptions)">
            <summary>
            <p>Initializes the decoder with the provided stream.</p>
            </summary>
            <param name = "streamRef"><dd>  <p>The stream to use for initialization.</p> <p>The stream contains the encoded pixels which are decoded each time the <strong>CopyPixels</strong> method on the <strong><see cref = "T:SharpDX.WIC.BitmapFrameDecode"/></strong> interface (see <strong>GetFrame</strong>) is invoked.</p> </dd></param>
            <param name = "cacheOptions"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.DecodeOptions"/></strong> to use for initialization.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690108</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::Initialize([In, Optional] IStream* pIStream,[In] WICDecodeOptions cacheOptions)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetContainerFormat(System.Guid@)">
            <summary>
            <p>Retrieves the image's container format.</p>
            </summary>
            <param name = "guidContainerFormatRef"><dd>  <p>A reference that receives the image's container format <see cref = "T:System.Guid"/>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690095</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetContainerFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetDecoderInfo(SharpDX.WIC.BitmapDecoderInfo@)">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.WIC.BitmapDecoderInfo"/></strong> for the image.</p>
            </summary>
            <param name = "decoderInfoOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690096</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetDecoderInfo([Out] IWICBitmapDecoderInfo** ppIDecoderInfo)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetDecoderInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.CopyPalette(SharpDX.WIC.Palette)">
            <summary>
            <p>Proxy function for the <strong>CopyPalette</strong> method.</p>
            </summary>
            <param name = "paletteRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690092</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::CopyPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::CopyPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetMetadataQueryReader(SharpDX.WIC.MetadataQueryReader@)">
            <summary>
            <p>Proxy function for the <strong>GetMetadataQueryReader</strong> method.</p>
            </summary>
            <param name = "metadataQueryReaderOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690103</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetMetadataQueryReader</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetPreview(SharpDX.WIC.BitmapSource@)">
            <summary>
            <p>Retrieves a preview image, if supported.</p>
            </summary>
            <param name = "bitmapSourceOut"><dd>  <p>Receives a reference to the preview bitmap if supported.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Not all formats support previews. Only the native Microsoft?Windows Digital Photo (WDP) codec support previews.</p>
            </remarks>
            <doc-id>ee690104</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetPreview([Out] IWICBitmapSource** ppIBitmapSource)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetPreview</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetColorContexts(System.Int32,SharpDX.WIC.ColorContext[],System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetColorContexts</strong> method.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextsOut">No documentation.</param>
            <param name = "actualCountRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690094</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetThumbnail(SharpDX.WIC.BitmapSource@)">
            <summary>
            <p>Proxy function for the <strong>GetThumbnail</strong> method.</p>
            </summary>
            <param name = "thumbnailOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690107</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetThumbnail</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetFrameCount(System.Int32@)">
            <summary>
            <p>Retrieves the total number of frames in the image.</p>
            </summary>
            <param name = "countRef"><dd>  <p>A reference that receives the total number of frames in the image.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690099</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetFrameCount([Out] unsigned int* pCount)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetFrameCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetFrame(System.Int32)">
            <summary>
            <p>Retrieves the specified frame of the image.</p>
            </summary>
            <param name = "index"><dd>  <p>The particular frame to retrieve.</p> </dd></param>
            <returns><dd>  <p>A reference that receives a reference to the <strong><see cref = "T:SharpDX.WIC.BitmapFrameDecode"/></strong>.</p> </dd></returns>
            <doc-id>ee690098</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetFrame([In] unsigned int index,[Out] IWICBitmapFrameDecode** ppIBitmapFrame)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetFrame</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetColorContexts(System.Int32,SharpDX.ComArray{SharpDX.WIC.ColorContext},System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetColorContexts</strong> method.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextsOut">No documentation.</param>
            <param name = "actualCountRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690094</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoder.GetColorContexts(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            <p>Proxy function for the <strong>GetColorContexts</strong> method.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextsOut">No documentation.</param>
            <param name = "actualCountRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690094</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
            <unmanaged-short>IWICBitmapDecoder::GetColorContexts</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapDecoderInfo.Patterns">
            <summary>
            Gets the file pattern signatures supported by the decoder.
            </summary>
            <unmanaged>HRESULT IWICBitmapDecoderInfo::GetPatterns([In] unsigned int cbSizePatterns,[Out, Buffer, Optional] WICBitmapPattern* pPatterns,[Out] unsigned int* pcPatterns,[Out] unsigned int* pcbPatternsActual)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoderInfo.GetPatterns(System.Int32,SharpDX.WIC.BitmapPattern[],System.Int32@,System.Int32@)">
            <summary>
            <p>Retrieves the file pattern signatures supported by the decoder.</p>
            </summary>
            <param name = "sizePatterns"><dd>  <p>The array size of the <em>pPatterns</em> array.</p> </dd></param>
            <param name = "patternsRef"><dd>  <p>Receives a list of <strong><see cref = "T:SharpDX.WIC.BitmapPattern"/></strong> objects supported by the decoder.</p> </dd></param>
            <param name = "atternCountRef"><dd>  <p>Receives the number of patterns the decoder supports.</p> </dd></param>
            <param name = "patternsActualRef"><dd>  <p>Receives the actual buffer size needed to retrieve all pattern signatures supported by the decoder. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> To retrieve all pattern signatures, this method should first be called with <em>pPatterns</em> set to <code><c>null</c></code> to retrieve the actual buffer size needed through <em>pcbPatternsActual</em>. Once the needed buffer size is known, allocate a buffer of the needed size and call <strong>GetPatterns</strong> again with the allocated buffer. </p>
            </remarks>
            <doc-id>ee690089</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoderInfo::GetPatterns([In] unsigned int cbSizePatterns,[Out, Buffer, Optional] WICBitmapPattern* pPatterns,[Out] unsigned int* pcPatterns,[Out] unsigned int* pcbPatternsActual)</unmanaged>
            <unmanaged-short>IWICBitmapDecoderInfo::GetPatterns</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoderInfo.MatchesPattern(SharpDX.Win32.IStream)">
            <summary>
            <p>Retrieves a value that indicates whether the codec recognizes the pattern within a specified stream.</p>
            </summary>
            <param name = "streamRef"><dd>  <p>The stream to pattern match within.</p> </dd></param>
            <returns><dd>  <p>A reference that receives <strong>TRUE</strong> if the patterns match; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></returns>
            <doc-id>ee690090</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoderInfo::MatchesPattern([In, Optional] IStream* pIStream,[Out] BOOL* pfMatches)</unmanaged>
            <unmanaged-short>IWICBitmapDecoderInfo::MatchesPattern</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapDecoderInfo.CreateInstance(SharpDX.WIC.BitmapDecoder)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong> instance.</p>
            </summary>
            <param name = "bitmapDecoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690088</doc-id>
            <unmanaged>HRESULT IWICBitmapDecoderInfo::CreateInstance([Out, Fast] IWICBitmapDecoder** ppIBitmapDecoder)</unmanaged>
            <unmanaged-short>IWICBitmapDecoderInfo::CreateInstance</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID. List from <see cref="T:SharpDX.WIC.ContainerFormatGuids"/> </param>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID. List from <see cref="T:SharpDX.WIC.ContainerFormatGuids"/></param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID. List from <see cref="T:SharpDX.WIC.ContainerFormatGuids"/> </param>
            <param name="stream">A stream to use as the output of this bitmap encoder.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID. List from <see cref="T:SharpDX.WIC.ContainerFormatGuids"/> </param>
            <param name="stream">A stream to use as the output of this bitmap encoder.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID. List from <see cref="T:SharpDX.WIC.ContainerFormatGuids"/></param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">A stream to use as the output of this bitmap encoder.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="containerFormatGuid">The container format GUID. List from <see cref="T:SharpDX.WIC.ContainerFormatGuids"/></param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">A stream to use as the output of this bitmap encoder.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out] IWICBitmapEncoder** ppIEncoder)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.Initialize(SharpDX.Win32.IStream)">
            <summary>
            Initializes the encoder with the provided stream.
            </summary>
            <param name="stream">The stream to use for initialization.</param>
            <returns>If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>. Otherwise, it throws an exception.</returns>
            <unmanaged>HRESULT IWICBitmapEncoder::Initialize([In, Optional] IStream* pIStream,[In] WICBitmapEncoderCacheOption cacheOption)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.Initialize(System.IO.Stream)">
            <summary>
            Initializes the encoder with the provided stream.
            </summary>
            <param name="stream">The stream to use for initialization.</param>
            <returns>If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>. Otherwise, it throws an exception.</returns>
            <unmanaged>HRESULT IWICBitmapEncoder::Initialize([In, Optional] IStream* pIStream,[In] WICBitmapEncoderCacheOption cacheOption)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetColorContexts(SharpDX.WIC.ColorContext[])">
            <summary>
            Sets the <see cref="T:SharpDX.WIC.ColorContext"/> objects for the encoder.
            </summary>
            <param name="colorContextOut">The color contexts to set for the encoder.</param>
            <returns>If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>. Otherwise, it throws an exception.</returns>
            <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoder.ContainerFormat">
            <summary>
            <p>Retrieves the encoder's container format.</p>
            </summary>
            <doc-id>ee690118</doc-id>
            <unmanaged>GetContainerFormat</unmanaged>
            <unmanaged-short>GetContainerFormat</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoder.EncoderInfo">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.WIC.BitmapEncoderInfo"/></strong> for the encoder.</p>
            </summary>
            <doc-id>ee690119</doc-id>
            <unmanaged>GetEncoderInfo</unmanaged>
            <unmanaged-short>GetEncoderInfo</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoder.Palette">
            <summary>
            <p>Proxy function for the <strong>SetPalette</strong> method.</p>
            </summary>
            <doc-id>ee690127</doc-id>
            <unmanaged>SetPalette</unmanaged>
            <unmanaged-short>SetPalette</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoder.Thumbnail">
            <summary>
            <p>Sets the global thumbnail for the image.</p>
            </summary>
            <doc-id>ee690129</doc-id>
            <unmanaged>SetThumbnail</unmanaged>
            <unmanaged-short>SetThumbnail</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoder.Preview">
            <summary>
            <p>Sets the global preview for the image.</p>
            </summary>
            <doc-id>ee690128</doc-id>
            <unmanaged>SetPreview</unmanaged>
            <unmanaged-short>SetPreview</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoder.MetadataQueryWriter">
            <summary>
            <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
            </summary>
            <doc-id>ee690122</doc-id>
            <unmanaged>GetMetadataQueryWriter</unmanaged>
            <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.Initialize(SharpDX.Win32.IStream,SharpDX.WIC.BitmapEncoderCacheOption)">
            <summary>
            <p>Initializes the encoder with an <see cref = "T:SharpDX.Win32.IStream"/> which tells the encoder where to encode the bits.</p>
            </summary>
            <param name = "streamRef">No documentation.</param>
            <param name = "cacheOption">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690123</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::Initialize([In, Optional] IStream* pIStream,[In] WICBitmapEncoderCacheOption cacheOption)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.GetContainerFormat(System.Guid@)">
            <summary>
            <p>Retrieves the encoder's container format.</p>
            </summary>
            <param name = "guidContainerFormatRef"><dd>  <p>A reference that receives the encoder's container format <see cref = "T:System.Guid"/>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690118</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::GetContainerFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.GetEncoderInfo(SharpDX.WIC.BitmapEncoderInfo@)">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.WIC.BitmapEncoderInfo"/></strong> for the encoder.</p>
            </summary>
            <param name = "encoderInfoOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690119</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::GetEncoderInfo([Out] IWICBitmapEncoderInfo** ppIEncoderInfo)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::GetEncoderInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetColorContexts(System.Int32,SharpDX.WIC.ColorContext[])">
            <summary>
            <p>Sets the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690125</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetPalette(SharpDX.WIC.Palette)">
            <summary>
            <p>Proxy function for the <strong>SetPalette</strong> method.</p>
            </summary>
            <param name = "paletteRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690127</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::SetPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetThumbnail(SharpDX.WIC.BitmapSource)">
            <summary>
            <p>Sets the global thumbnail for the image.</p>
            </summary>
            <param name = "thumbnailRef"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> to set as the global thumbnail.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref = "!:UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>
            <doc-id>ee690129</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::SetThumbnail</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetPreview(SharpDX.WIC.BitmapSource)">
            <summary>
            <p>Sets the global preview for the image.</p>
            </summary>
            <param name = "previewRef"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> to use as the global preview.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> if successful, or an error value otherwise. </p><p>Returns <see cref = "!:UnsupportedOperation"/> if the feature is not supported by the encoder.</p></returns>
            <doc-id>ee690128</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::SetPreview([In, Optional] IWICBitmapSource* pIPreview)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::SetPreview</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.CreateNewFrame(SharpDX.WIC.BitmapFrameEncode,SharpDX.Win32.PropertyBag)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> instance.</p>
            </summary>
            <param name = "frameEncodeOut">No documentation.</param>
            <param name = "encoderOptionsOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The parameter <em>ppIEncoderOptions</em> can be used to receive an <see cref = "T:SharpDX.Win32.PropertyBag"/> that can then be used to specify encoder options. This is done by passing a reference to a <strong><c>null</c></strong> <see cref = "T:SharpDX.Win32.PropertyBag"/> reference in <em>ppIEncoderOptions</em>. The returned <see cref = "T:SharpDX.Win32.PropertyBag"/> is initialized with all encoder options that are available for the given format, at their default values. To specify non-default encoding behavior, set the needed encoder options on the <see cref = "T:SharpDX.Win32.PropertyBag"/> and pass it to <strong>IWICBitmapFrameEncode::Initialize</strong>.</p><strong>Note</strong>??Do not pass in a reference to an initialized <see cref = "T:SharpDX.Win32.PropertyBag"/>. The reference will be overwritten, and the original <see cref = "T:SharpDX.Win32.PropertyBag"/> will not be freed.?<p>Otherwise, you can pass <strong><c>null</c></strong> in <em>ppIEncoderOptions</em> if you do not intend to specify encoder options.</p><p>See Encoding Overview for an example of how to set encoder options.</p><p>For formats that support encoding multiple frames (for example, TIFF, JPEG-XR), you can work on only one frame at a time. This means that you must call <strong>IWICBitmapFrameEncode::Commit</strong> before you call <strong>CreateNewFrame</strong> again.
            </p>
            </remarks>
            <doc-id>ee690116</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::CreateNewFrame([Out, Fast] IWICBitmapFrameEncode** ppIFrameEncode,[Out, Fast] IPropertyBag2** ppIEncoderOptions)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::CreateNewFrame</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.Commit">
            <summary>
            <p>Commits all changes for the image and closes the stream.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>To finalize an image, both the frame <strong>Commit</strong> and the encoder <strong>Commit</strong> must be called. However, only call the encoder  <strong>Commit</strong> method after all frames have been committed.</p><p>After the encoder has been committed, it can't be re-initialized or reused with another stream. A new encoder interface must be created, for example, with <strong>IWICImagingFactory::CreateEncoder</strong>.
            </p><p>For the encoder <strong>Commit</strong> to succeed, you must at a minimum call  <strong>IWICBitmapEncoder::Initialize</strong> and either <strong>IWICBitmapFrameEncode::WriteSource</strong> or <strong>IWICBitmapFrameEncode::WritePixels</strong>.
            </p><p> <strong>IWICBitmapFrameEncode::WriteSource</strong> specifies all parameters needed to encode the image data. <strong>IWICBitmapFrameEncode::WritePixels</strong> requires that you also call <strong>IWICBitmapFrameEncode::SetSize</strong>, <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, and <strong>IWICBitmapFrameEncode::SetPalette</strong> (if the pixel format is indexed).
            </p>
            </remarks>
            <doc-id>ee690114</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::Commit()</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::Commit</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.GetMetadataQueryWriter(SharpDX.WIC.MetadataQueryWriter@)">
            <summary>
            <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
            </summary>
            <param name = "metadataQueryWriterOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690122</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::GetMetadataQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetColorContexts(System.Int32,SharpDX.ComArray{SharpDX.WIC.ColorContext})">
            <summary>
            <p>Sets the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690125</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoder.SetColorContexts(System.Int32,System.IntPtr)">
            <summary>
            <p>Sets the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> objects for the encoder.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690125</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoder::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICBitmapEncoder::SetColorContexts</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapEncoderOptions">
            <summary>
            BitmapEncoderOptions used for encoding.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoderOptions.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapEncoderOptions"/> class.
            </summary>
            <param name="propertyBagPointer">The property bag pointer.</param>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.ImageQuality">
            <summary>
            Gets or sets the image quality.
            </summary>
            <value>
            The image quality.
            </value>
            <remarks>
            Range value: 0-1.0f
            Applicable Codecs: JPEG, HDPhoto
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.CompressionQuality">
            <summary>
            Gets or sets the compression quality.
            </summary>
            <value>
            The compression quality.
            </value>
            <remarks>
            Range value: 0-1.0f 
            Applicable Codecs: TIFF
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.LossLess">
            <summary>
            Gets or sets a value indicating whether loss less compression is enabled.
            </summary>
            <value>
              <c>true</c> if [loss less]; otherwise, <c>false</c>.
            </value>
            <remarks>
            Range value: true-false
            Applicable Codecs: HDPhoto
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.BitmapTransform">
            <summary>
            Gets or sets the bitmap transform.
            </summary>
            <value>
            The bitmap transform.
            </value>
            <remarks>
            Range value: <see cref="T:SharpDX.WIC.BitmapTransformOptions"/>
            Applicable Codecs: JPEG
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.InterlaceOption">
            <summary>
            Gets or sets a value indicating whether [interlace option].
            </summary>
            <value>
              <c>true</c> if [interlace option]; otherwise, <c>false</c>.
            </value>
            <remarks>
            Range value: true-false
            Applicable Codecs: PNG
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.FilterOption">
            <summary>
            Gets or sets the filter option.
            </summary>
            <value>
            The filter option.
            </value>
            <remarks>
            Range value: <see cref="T:SharpDX.WIC.PngFilterOption"/>
            Applicable Codecs: PNG
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.TiffCompressionMethod">
            <summary>
            Gets or sets the TIFF compression method.
            </summary>
            <value>
            The TIFF compression method.
            </value>
            <remarks>
            Range value: <see cref="T:SharpDX.WIC.TiffCompressionOption"/>
            Applicable Codecs: TIFF
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.Luminance">
            <summary>
            Gets or sets the luminance.
            </summary>
            <value>
            The luminance.
            </value>
            <remarks>
            Range value: 64 Entries (DCT)
            Applicable Codecs: JPEG
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.Chrominance">
            <summary>
            Gets or sets the chrominance.
            </summary>
            <value>
            The chrominance.
            </value>
            <remarks>
            Range value: 64 Entries (DCT)
            Applicable Codecs: JPEG
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.JpegYCrCbSubsampling">
            <summary>
            Gets or sets the JPEG Y Cr Cb subsampling.
            </summary>
            <value>
            The JPEG Y Cr Cb subsampling.
            </value>
            <remarks>
            Range value: <see cref="T:SharpDX.WIC.JpegYCrCbSubsamplingOption"/>
            Applicable Codecs: JPEG
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapEncoderOptions.SuppressApp0">
            <summary>
            Gets or sets a value indicating whether [suppress app0].
            </summary>
            <value>
              <c>true</c> if [suppress app0]; otherwise, <c>false</c>.
            </value>
            <remarks>
            Range value: true-false
            Applicable Codecs: JPEG
            </remarks>
        </member>
        <member name="M:SharpDX.WIC.BitmapFlipRotator.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapFlipRotator"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.BitmapFlipRotator.Initialize(SharpDX.WIC.BitmapSource,SharpDX.WIC.BitmapTransformOptions)">
            <summary>
            <p>Initializes the bitmap flip rotator with the provided parameters.</p>
            </summary>
            <param name = "sourceRef"><dd>  <p>The input bitmap source.</p> </dd></param>
            <param name = "options"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapTransformOptions"/></strong> to flip or rotate the image.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690132</doc-id>
            <unmanaged>HRESULT IWICBitmapFlipRotator::Initialize([In, Optional] IWICBitmapSource* pISource,[In] WICBitmapTransformOptions options)</unmanaged>
            <unmanaged-short>IWICBitmapFlipRotator::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.TryGetColorContexts(SharpDX.WIC.ImagingFactory,SharpDX.WIC.ColorContext[]@)">
            <summary>
            Get the <see cref="T:SharpDX.WIC.ColorContext"/> of the image (if any)
            </summary>
            <param name="imagingFactory">The factory for creating new color contexts</param>
            <param name="colorContexts">The color context array, or null</param>
            <remarks>
            When the image format does not support color contexts,
            <see cref="F:SharpDX.WIC.ResultCode.UnsupportedOperation"/> is returned.
            </remarks>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[Out, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.TryGetColorContexts(SharpDX.WIC.ImagingFactory)">
            <summary>
            Get the <see cref="T:SharpDX.WIC.ColorContext"/> of the image (if any)
            </summary>
            <returns>
            null if the decoder does not support color contexts;
            otherwise an array of zero or more ColorContext objects
            </returns>
            <unmanaged>HRESULT IWICBitmapDecoder::GetColorContexts([In] unsigned int cCount,[Out, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] </unmanaged>
        </member>
        <member name="P:SharpDX.WIC.BitmapFrameDecode.MetadataQueryReader">
            <summary>
            <p>Retrieves a metadata query reader for the frame.</p>
            </summary>
            <remarks>
            <p>For image formats with one frame (JPG, PNG, JPEG-XR), the frame-level query reader of the first frame is used to access all image metadata, and the decoder-level query reader isn?t used. For formats with more than one frame (GIF, TIFF), the frame-level query reader for a given frame is used to access metadata specific to that frame, and in the case of GIF a decoder-level metadata reader will be present. If the decoder doesn?t support metadata (BMP, ICO), this will return <see cref = "!:UnsupportedOperation"/>.
            </p>
            </remarks>
            <doc-id>ee690137</doc-id>
            <unmanaged>GetMetadataQueryReader</unmanaged>
            <unmanaged-short>GetMetadataQueryReader</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapFrameDecode.Thumbnail">
            <summary>
            <p>Retrieves a small preview of the frame, if supported by the codec.</p>
            </summary>
            <remarks>
            <p>Not all formats support thumbnails. Joint Photographic Experts Group (JPEG), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP) support thumbnails.</p>
            </remarks>
            <doc-id>ee690139</doc-id>
            <unmanaged>GetThumbnail</unmanaged>
            <unmanaged-short>GetThumbnail</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.GetMetadataQueryReader(SharpDX.WIC.MetadataQueryReader@)">
            <summary>
            <p>Retrieves a metadata query reader for the frame.</p>
            </summary>
            <param name = "metadataQueryReaderOut"><dd>  <p>When this method returns, contains a reference to the frame's metadata query reader.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For image formats with one frame (JPG, PNG, JPEG-XR), the frame-level query reader of the first frame is used to access all image metadata, and the decoder-level query reader isn?t used. For formats with more than one frame (GIF, TIFF), the frame-level query reader for a given frame is used to access metadata specific to that frame, and in the case of GIF a decoder-level metadata reader will be present. If the decoder doesn?t support metadata (BMP, ICO), this will return <see cref = "!:UnsupportedOperation"/>.
            </p>
            </remarks>
            <doc-id>ee690137</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameDecode::GetMetadataQueryReader([Out] IWICMetadataQueryReader** ppIMetadataQueryReader)</unmanaged>
            <unmanaged-short>IWICBitmapFrameDecode::GetMetadataQueryReader</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.GetColorContexts(System.Int32,SharpDX.WIC.ColorContext[],System.Int32@)">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextsOut">No documentation.</param>
            <param name = "actualCountRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref = "T:SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong>IWICImagingFactory::CreateColorContext</strong>.
            </p>
            </remarks>
            <doc-id>ee690135</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
            <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.GetThumbnail(SharpDX.WIC.BitmapSource@)">
            <summary>
            <p>Retrieves a small preview of the frame, if supported by the codec.</p>
            </summary>
            <param name = "thumbnailOut"><dd>  <p>A reference that receives a reference to the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> of the thumbnail.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Not all formats support thumbnails. Joint Photographic Experts Group (JPEG), Tagged Image File Format (TIFF), and Microsoft?Windows Digital Photo (WDP) support thumbnails.</p>
            </remarks>
            <doc-id>ee690139</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameDecode::GetThumbnail([Out] IWICBitmapSource** ppIThumbnail)</unmanaged>
            <unmanaged-short>IWICBitmapFrameDecode::GetThumbnail</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.GetColorContexts(System.Int32,SharpDX.ComArray{SharpDX.WIC.ColorContext},System.Int32@)">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextsOut">No documentation.</param>
            <param name = "actualCountRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref = "T:SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong>IWICImagingFactory::CreateColorContext</strong>.
            </p>
            </remarks>
            <doc-id>ee690135</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
            <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameDecode.GetColorContexts(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> associated with the image frame.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextsOut">No documentation.</param>
            <param name = "actualCountRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <c>null</c> is passed for <em>ppIColorContexts</em>, and 0 is passed for <em>cCount</em>, this method will return the total number of color contexts in the image in <em>pcActualCount</em>. </p><p>The <em>ppIColorContexts</em> array must be filled with valid data: each <strong><see cref = "T:SharpDX.WIC.ColorContext"/>*</strong> in the array must have been created using <strong>IWICImagingFactory::CreateColorContext</strong>.
            </p>
            </remarks>
            <doc-id>ee690135</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameDecode::GetColorContexts([In] unsigned int cCount,[InOut, Buffer, Optional] IWICColorContext** ppIColorContexts,[Out] unsigned int* pcActualCount)</unmanaged>
            <unmanaged-short>IWICBitmapFrameDecode::GetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.#ctor(SharpDX.WIC.BitmapEncoder)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapFrameEncode"/> class.
            </summary>
            <param name="encoder">The encoder.</param>
            <unmanaged>HRESULT IWICBitmapEncoder::CreateNewFrame([Out] IWICBitmapFrameEncode** ppIFrameEncode,[Out] IPropertyBag2** ppIEncoderOptions)</unmanaged>	
        </member>
        <member name="P:SharpDX.WIC.BitmapFrameEncode.Options">
            <summary>
            Gets the properties to setup before <see cref="M:SharpDX.WIC.BitmapFrameEncode.Initialize"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.Initialize">
            <summary>
            Initializes this instance.
            </summary>
            <unmanaged>HRESULT IWICBitmapFrameEncode::Initialize([In, Optional] IPropertyBag2* pIEncoderOptions)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetColorContexts(SharpDX.WIC.ColorContext[])">
            <summary>
            Sets the <see cref="T:SharpDX.WIC.ColorContext"/> objects for this frame encoder.
            </summary>
            <param name="colorContextOut">The color contexts to set for the encoder.</param>
            <returns>If the method succeeds, it returns <see cref="F:SharpDX.Result.Ok"/>. Otherwise, it throws an exception.</returns>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WritePixels(System.Int32,SharpDX.DataRectangle,System.Int32)">
            <summary>	
            <p>Encodes the frame scanlines.</p>	
            </summary>	
            <param name="lineCount"><dd>  <p>The number of lines to encode.</p> </dd></param>	
            <param name="buffer">A data buffer containing the pixels to copy from.</param>	
            <param name="totalSizeInBytes">Total size in bytes of pixels to write. If == 0, size is calculated with lineCount * rowStride.</param>
            <remarks>	
            <p>Successive <strong>WritePixels</strong> calls are assumed to be sequential scanline access in the output image.</p>	
            </remarks>	
            <msdn-id>ee690158</msdn-id>	
            <unmanaged>HRESULT IWICBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In, Buffer] void* pbPixels)</unmanaged>	
            <unmanaged-short>IWICBitmapFrameEncode::WritePixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WritePixels(System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>	
            <p>Encodes the frame scanlines.</p>	
            </summary>	
            <param name="lineCount"><dd>  <p>The number of lines to encode.</p> </dd></param>	
            <param name="buffer">A data buffer containing the pixels to copy from.</param>
            <param name="rowStride">The stride of one row.</param>
            <param name="totalSizeInBytes">Total size in bytes of pixels to write. If == 0, size is calculated with lineCount * rowStride.</param>
            <remarks>	
            <p>Successive <strong>WritePixels</strong> calls are assumed to be sequential scanline access in the output image.</p>	
            </remarks>	
            <msdn-id>ee690158</msdn-id>	
            <unmanaged>HRESULT IWICBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In, Buffer] void* pbPixels)</unmanaged>	
            <unmanaged-short>IWICBitmapFrameEncode::WritePixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WritePixels``1(System.Int32,System.Int32,``0[])">
            <summary>	
            <p>Encodes the frame scanlines.</p>	
            </summary>	
            <param name="lineCount"><dd>  <p>The number of lines to encode.</p> </dd></param>	
            <param name="stride"><dd>  <p>The <em>stride</em> of the image pixels.</p> </dd></param>	
            <param name="pixelBuffer"><dd>  <p>A reference to the pixel buffer.</p> </dd></param>	
            <remarks>	
            <p>Successive <strong>WritePixels</strong> calls are assumed to be sequential scanline access in the output image.</p>	
            </remarks>	
            <msdn-id>ee690158</msdn-id>	
            <unmanaged>HRESULT IWICBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In, Buffer] void* pbPixels)</unmanaged>	
            <unmanaged-short>IWICBitmapFrameEncode::WritePixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WriteSource(SharpDX.WIC.BitmapSource)">
            <summary>	
            <p>Encodes a bitmap source.</p>	
            </summary>	
            <param name="bitmapSource"><dd>  <p>The bitmap source to encode.</p> </dd></param>	
            <remarks>	
            <p>If <strong>SetSize</strong> is not called prior to calling <strong>WriteSource</strong>, the size given in <em>prc</em> is used if not <strong><c>null</c></strong>. Otherwise, the size of the <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> given in <em>pIBitmapSource</em> is used. </p><p>If <strong>SetPixelFormat</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of the <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> given in <em>pIBitmapSource</em> is used.</p><p>If <strong>SetResolution</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of <em>pIBitmapSource</em> is used.</p><p>If <strong>SetPalette</strong> is not called prior to calling <strong>WriteSource</strong>, the target pixel format is indexed, and the pixel format of <em>pIBitmapSource</em> matches the encoder frame's pixel format, then the <em>pIBitmapSource</em> pixel format is used.</p><p>When encoding a GIF image, if the global palette is set and the frame level palette is not set directly by the user or by a custom independent software vendor (ISV) GIF codec, <strong>WriteSource</strong> will use the global palette to encode the frame even when <em>pIBitmapSource</em> has a frame level palette.</p><p><strong>Windows Vista:</strong>The source rect width must match the width set through SetSize. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through SetSize.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IWICBitmapFrameEncode::WriteSource']/*" />	
            <msdn-id>ee690159</msdn-id>	
            <unmanaged>HRESULT IWICBitmapFrameEncode::WriteSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In, Optional] WICRect* prc)</unmanaged>	
            <unmanaged-short>IWICBitmapFrameEncode::WriteSource</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WriteSource(SharpDX.WIC.BitmapSource,SharpDX.Mathematics.Interop.RawBox)">
            <summary>	
            <p>Encodes a bitmap source.</p>	
            </summary>	
            <param name="bitmapSourceRef"><dd>  <p>The bitmap source to encode.</p> </dd></param>	
            <param name="rectangleRef"><dd>  <p>The size rectangle of the bitmap source.</p> </dd></param>	
            <remarks>	
            <p>If <strong>SetSize</strong> is not called prior to calling <strong>WriteSource</strong>, the size given in <em>prc</em> is used if not <strong><c>null</c></strong>. Otherwise, the size of the <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> given in <em>pIBitmapSource</em> is used. </p><p>If <strong>SetPixelFormat</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of the <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> given in <em>pIBitmapSource</em> is used.</p><p>If <strong>SetResolution</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of <em>pIBitmapSource</em> is used.</p><p>If <strong>SetPalette</strong> is not called prior to calling <strong>WriteSource</strong>, the target pixel format is indexed, and the pixel format of <em>pIBitmapSource</em> matches the encoder frame's pixel format, then the <em>pIBitmapSource</em> pixel format is used.</p><p>When encoding a GIF image, if the global palette is set and the frame level palette is not set directly by the user or by a custom independent software vendor (ISV) GIF codec, <strong>WriteSource</strong> will use the global palette to encode the frame even when <em>pIBitmapSource</em> has a frame level palette.</p><p><strong>Windows Vista:</strong>The source rect width must match the width set through SetSize. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through SetSize.</p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IWICBitmapFrameEncode::WriteSource']/*" />	
            <msdn-id>ee690159</msdn-id>	
            <unmanaged>HRESULT IWICBitmapFrameEncode::WriteSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In, Optional] WICRect* prc)</unmanaged>	
            <unmanaged-short>IWICBitmapFrameEncode::WriteSource</unmanaged-short>	
        </member>
        <member name="P:SharpDX.WIC.BitmapFrameEncode.Palette">
            <summary>
            <p>Sets the <strong><see cref = "T:SharpDX.WIC.Palette"/></strong> for indexed pixel formats.</p>
            </summary>
            <remarks>
            <p>This method doesn't fail if called on a frame whose pixel format is set to a non-indexed pixel format. If the target pixel format is a non-indexed format, the palette will be ignored.</p><p>If you already called <strong>IWICBitmapEncoder::SetPalette</strong> to set a global palette, this method overrides that palette for the current frame.</p><p>The palette must be specified before your first call to <strong>WritePixels</strong>/<strong>WriteSource</strong>. Doing so will cause <strong>WriteSource</strong> to use the specified palette when converting the source image to the encoder pixel format. If no palette is specified, a palette will be generated on the first call to <strong>WriteSource</strong>.
            </p>
            </remarks>
            <doc-id>ee690150</doc-id>
            <unmanaged>SetPalette</unmanaged>
            <unmanaged-short>SetPalette</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapFrameEncode.Thumbnail">
            <summary>
            <p>Proxy function for the <strong>SetThumbnail</strong> method.</p>
            </summary>
            <doc-id>ee690157</doc-id>
            <unmanaged>SetThumbnail</unmanaged>
            <unmanaged-short>SetThumbnail</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapFrameEncode.MetadataQueryWriter">
            <summary>
            <p>Gets the metadata query writer for the encoder frame.</p>
            </summary>
            <remarks>
            <p>If you are setting metadata on the frame, you must do this before you use <strong>IWICBitmapFrameEncode::WritePixels</strong> or <strong>IWICBitmapFrameEncode::WriteSource</strong> to write any image pixels to the frame</p>
            </remarks>
            <doc-id>ee690144</doc-id>
            <unmanaged>GetMetadataQueryWriter</unmanaged>
            <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.Initialize(SharpDX.Win32.PropertyBag)">
            <summary>
            <p>Initializes the frame encoder using the given properties.</p>
            </summary>
            <param name = "encoderOptionsRef"><dd>  <p>The set of properties to use for <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> initialization.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you don't want any encoding options, pass <strong><c>null</c></strong> for <em>pIEncoderOptions</em>. Otherwise, pass the <see cref = "T:SharpDX.Win32.PropertyBag"/> that was provided by <strong>IWICBitmapEncoder::CreateNewFrame</strong> with updated values.
            </p><p>For a complete list of encoding options supported by the Windows-provided codecs, see Native WIC Codecs. </p>
            </remarks>
            <doc-id>ee690146</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::Initialize([In, Optional] IPropertyBag2* pIEncoderOptions)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetSize(System.Int32,System.Int32)">
            <summary>
            <p>Sets the output image dimensions for the frame.</p>
            </summary>
            <param name = "width"><dd>  <p>The width of the output image.</p> </dd></param>
            <param name = "height"><dd>  <p>The height of the output image.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690154</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetSize([In] unsigned int uiWidth,[In] unsigned int uiHeight)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetResolution(System.Double,System.Double)">
            <summary>
            <p>Sets the physical resolution of the output image.</p>
            </summary>
            <param name = "dpiX"><dd>  <p>The horizontal resolution value.</p> </dd></param>
            <param name = "dpiY"><dd>  <p>The vertical resolution value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Windows Imaging Component (WIC) doesn't perform any special processing as a result of DPI resolution values. For example, data returned from <strong>IWICBitmapSource::CopyPixels</strong> isn't scaled by the DPI. The app must handle DPI resolution.
            </p>
            </remarks>
            <doc-id>ee690152</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetResolution([In] double dpiX,[In] double dpiY)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetResolution</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetPixelFormat(System.Guid@)">
            <summary>
            <p>Requests that the encoder use the specified pixel format.</p>
            </summary>
            <param name = "pixelFormatRef"><dd>  <p>On input, the requested pixel format <see cref = "T:System.Guid"/>. On output, the closest pixel format <see cref = "T:System.Guid"/> supported by the encoder; this may be different than the requested format. For a list of pixel format GUIDs, see Native Pixel Formats.</p> </dd></param>
            <returns><p>Possible return values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:WrongState"/></strong></dt> </dl> </td><td> <p>The <strong>IWICBitmapFrameEncode::Initialize</strong> method was not called.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>The encoder might not support the requested pixel format. If not, <strong>SetPixelFormat</strong> returns the closest match in the memory block that <em>pPixelFormat</em> points to. If the returned pixel format doesn't match the requested format, you must use an <strong><see cref = "T:SharpDX.WIC.FormatConverter"/></strong> object to convert the pixel data.</p>
            </remarks>
            <doc-id>ee690151</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetPixelFormat([InOut] GUID* pPixelFormat)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetColorContexts(System.Int32,SharpDX.WIC.ColorContext[])">
            <summary>
            <p>Proxy function for the <strong>SetColorContexts</strong> method.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690149</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetPalette(SharpDX.WIC.Palette)">
            <summary>
            <p>Sets the <strong><see cref = "T:SharpDX.WIC.Palette"/></strong> for indexed pixel formats.</p>
            </summary>
            <param name = "paletteRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method doesn't fail if called on a frame whose pixel format is set to a non-indexed pixel format. If the target pixel format is a non-indexed format, the palette will be ignored.</p><p>If you already called <strong>IWICBitmapEncoder::SetPalette</strong> to set a global palette, this method overrides that palette for the current frame.</p><p>The palette must be specified before your first call to <strong>WritePixels</strong>/<strong>WriteSource</strong>. Doing so will cause <strong>WriteSource</strong> to use the specified palette when converting the source image to the encoder pixel format. If no palette is specified, a palette will be generated on the first call to <strong>WriteSource</strong>.
            </p>
            </remarks>
            <doc-id>ee690150</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetThumbnail(SharpDX.WIC.BitmapSource)">
            <summary>
            <p>Proxy function for the <strong>SetThumbnail</strong> method.</p>
            </summary>
            <param name = "thumbnailRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690157</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetThumbnail([In, Optional] IWICBitmapSource* pIThumbnail)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetThumbnail</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WritePixels(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <p>Copies scan-line data from a caller-supplied buffer to the <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> object.
            </p>
            </summary>
            <param name = "lineCount">No documentation.</param>
            <param name = "stride">No documentation.</param>
            <param name = "bufferSize">No documentation.</param>
            <param name = "pixelsRef">No documentation.</param>
            <returns><p>Possible return values include the following.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>Success.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "!:Codectoomanyscanlines"/></strong></dt> </dl> </td><td> <p>The value of <em>lineCount</em> is larger than the number of scan lines in the image.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p>Successive <strong>WritePixels</strong> calls are assumed to be sequential scan-line access in the output image.</p>
            </remarks>
            <doc-id>ee690158</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In, Buffer] unsigned char* pbPixels)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::WritePixels</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.WriteSource(SharpDX.WIC.BitmapSource,System.IntPtr)">
            <summary>
            <p>Encodes a bitmap source.</p>
            </summary>
            <param name = "bitmapSourceRef"><dd>  <p>The bitmap source to encode.</p> </dd></param>
            <param name = "rectangleRef"><dd>  <p>The size rectangle of the bitmap source.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <strong>SetSize</strong> is not called prior to calling <strong>WriteSource</strong>, the size given in <em>prc</em> is used if not <strong><c>null</c></strong>. Otherwise, the size of the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> given in <em>pIBitmapSource</em> is used. </p><p>If <strong>SetPixelFormat</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> given in <em>pIBitmapSource</em> is used.</p><p>If <strong>SetResolution</strong> is not called prior to calling <strong>WriteSource</strong>, the pixel format of <em>pIBitmapSource</em> is used.</p><p>If <strong>SetPalette</strong> is not called prior to calling <strong>WriteSource</strong>, the target pixel format is indexed, and the pixel format of <em>pIBitmapSource</em> matches the encoder frame's pixel format, then the <em>pIBitmapSource</em> pixel format is used.</p><p>When encoding a GIF image, if the global palette is set and the frame level palette is not set directly by the user or by a custom independent software vendor (ISV) GIF codec, <strong>WriteSource</strong> will use the global palette to encode the frame even when <em>pIBitmapSource</em> has a frame level palette.</p><p>Starting with  Windows?Vista, repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.</p><p>Starting with Windows?8.1, the source rect must be at least the dimensions set through <strong>SetSize</strong>. If the source rect width exceeds the <strong>SetSize</strong> width, extra pixels on the right side are ignored. If the source rect height exceeds the remaining unfilled height, extra scan lines on the bottom are ignored.
            </p>
            </remarks>
            <doc-id>ee690159</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::WriteSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] WICRect* prc)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::WriteSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.Commit">
            <summary>
            <p>Commits the frame to the image.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>After the frame <strong>Commit</strong> has been called, you can't use or reinitialize the <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> object and any objects created from it.
            </p><p>To finalize the image, both the frame <strong>Commit</strong> and the encoder <strong>Commit</strong> must be called. However, only call the encoder  <strong>Commit</strong> method after all frames have been committed.</p>
            </remarks>
            <doc-id>ee690142</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::Commit()</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::Commit</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.GetMetadataQueryWriter(SharpDX.WIC.MetadataQueryWriter@)">
            <summary>
            <p>Gets the metadata query writer for the encoder frame.</p>
            </summary>
            <param name = "metadataQueryWriterOut"><dd>  <p>When this method returns, contains a reference to metadata query writer for the encoder frame.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you are setting metadata on the frame, you must do this before you use <strong>IWICBitmapFrameEncode::WritePixels</strong> or <strong>IWICBitmapFrameEncode::WriteSource</strong> to write any image pixels to the frame</p>
            </remarks>
            <doc-id>ee690144</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::GetMetadataQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetColorContexts(System.Int32,SharpDX.ComArray{SharpDX.WIC.ColorContext})">
            <summary>
            <p>Proxy function for the <strong>SetColorContexts</strong> method.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690149</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapFrameEncode.SetColorContexts(System.Int32,System.IntPtr)">
            <summary>
            <p>Proxy function for the <strong>SetColorContexts</strong> method.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690149</doc-id>
            <unmanaged>HRESULT IWICBitmapFrameEncode::SetColorContexts([In] unsigned int cCount,[In, Buffer] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICBitmapFrameEncode::SetColorContexts</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapLock.Size">
            <summary>
            Gets the size.
            </summary>
            <unmanaged>HRESULT IWICBitmapLock::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>	
        </member>
        <member name="P:SharpDX.WIC.BitmapLock.Data">
            <summary>
            Gets a pointer to the data.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.BitmapLock.Stride">
            <summary>
            <p>Provides access to the stride value for the memory.</p>
            </summary>
            <remarks>
            <p> Note the stride value is specific to the <strong><see cref = "T:SharpDX.WIC.BitmapLock"/></strong>, not the bitmap.  For example, two consecutive locks on the same rectangle of a bitmap may return different references and stride values, depending on internal implementation.  </p>
            </remarks>
            <doc-id>ee690166</doc-id>
            <unmanaged>GetStride</unmanaged>
            <unmanaged-short>GetStride</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapLock.PixelFormat">
            <summary>
            <p>Gets the pixel format of for the locked area of pixels. This can be used to compute the number of bytes-per-pixel in the locked area.</p>
            </summary>
            <doc-id>ee690164</doc-id>
            <unmanaged>GetPixelFormat</unmanaged>
            <unmanaged-short>GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapLock.GetSize(System.Int32@,System.Int32@)">
            <summary>
            <p>Retrieves the width and height, in pixels, of the locked rectangle.</p>
            </summary>
            <param name = "widthRef"><dd>  <p>A reference that receives the width of the locked rectangle.</p> </dd></param>
            <param name = "heightRef"><dd>  <p>A reference that receives the height of the locked rectangle.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690165</doc-id>
            <unmanaged>HRESULT IWICBitmapLock::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>
            <unmanaged-short>IWICBitmapLock::GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapLock.GetStride(System.Int32@)">
            <summary>
            <p>Provides access to the stride value for the memory.</p>
            </summary>
            <param name = "strideRef"><dd>  </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Note the stride value is specific to the <strong><see cref = "T:SharpDX.WIC.BitmapLock"/></strong>, not the bitmap.  For example, two consecutive locks on the same rectangle of a bitmap may return different references and stride values, depending on internal implementation.  </p>
            </remarks>
            <doc-id>ee690166</doc-id>
            <unmanaged>HRESULT IWICBitmapLock::GetStride([Out] unsigned int* pcbStride)</unmanaged>
            <unmanaged-short>IWICBitmapLock::GetStride</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapLock.GetDataPointer(System.Int32@)">
            <summary>
            <p>Gets the reference to the top left pixel in the locked rectangle.</p>
            </summary>
            <param name = "bufferSizeRef"><dd>  <p>A reference that receives the size of the buffer.</p> </dd></param>
            <returns><dd>  <p>A reference that receives a reference to the top left pixel in the locked rectangle.</p> </dd></returns>
            <remarks>
            <p>The reference provided by this method should not be used outside of the lifetime of the lock itself.</p><p><strong>GetDataPointer</strong> is not available in multi-threaded apartment applications.</p>
            </remarks>
            <doc-id>ee690162</doc-id>
            <unmanaged>HRESULT IWICBitmapLock::GetDataPointer([Out] unsigned int* pcbBufferSize,[Out] unsigned char** ppbData)</unmanaged>
            <unmanaged-short>IWICBitmapLock::GetDataPointer</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapLock.GetPixelFormat(System.Guid@)">
            <summary>
            <p>Gets the pixel format of for the locked area of pixels. This can be used to compute the number of bytes-per-pixel in the locked area.</p>
            </summary>
            <param name = "pixelFormatRef"><dd>  <p>A reference that receives the pixel format <see cref = "T:System.Guid"/> of the locked area.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690164</doc-id>
            <unmanaged>HRESULT IWICBitmapLock::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>
            <unmanaged-short>IWICBitmapLock::GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapScaler.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BitmapScaler"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.BitmapScaler.Initialize(SharpDX.WIC.BitmapSource,System.Int32,System.Int32,SharpDX.WIC.BitmapInterpolationMode)">
            <summary>
            <p>Initializes the bitmap scaler with the provided parameters.</p>
            </summary>
            <param name = "sourceRef"><dd>  <p>The input bitmap source.</p> </dd></param>
            <param name = "width"><dd>  <p>The destination width.</p> </dd></param>
            <param name = "height"><dd>  <p>The desination height.</p> </dd></param>
            <param name = "mode"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapInterpolationMode"/></strong> to use when scaling.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> <strong><see cref = "T:SharpDX.WIC.BitmapScaler"/></strong> can't be initialized multiple times. For example, when scaling every frame in a multi-frame image, a new <strong><see cref = "T:SharpDX.WIC.BitmapScaler"/></strong> must be created and initialized for each frame.</p>
            </remarks>
            <doc-id>ee690169</doc-id>
            <unmanaged>HRESULT IWICBitmapScaler::Initialize([In, Optional] IWICBitmapSource* pISource,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] WICBitmapInterpolationMode mode)</unmanaged>
            <unmanaged-short>IWICBitmapScaler::Initialize</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.BitmapSource.Size">
            <summary>	
            <p>Retrieves the pixel width and height of the bitmap.</p>	
            </summary>	
            <unmanaged>HRESULT IWICBitmapSource::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>
            <msdn-id>ee690185</msdn-id>	
            <unmanaged>HRESULT IWICBitmapSource::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>	
            <unmanaged-short>IWICBitmapSource::GetSize</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels(SharpDX.Mathematics.Interop.RawBox,System.Int32,SharpDX.DataPointer)">
            <summary>	
            <p>Instructs the object to produce pixels.</p>	
            </summary>	
            <param name="rectangle"><dd>  <p>The rectangle to copy. A <strong><c>null</c></strong> value specifies the entire bitmap.</p> </dd></param>	
            <param name="stride"><dd>  <p>The stride of the bitmap</p> </dd></param>	
            <param name="dataPointer"><dd>  <p>A reference to the buffer.</p> </dd></param>	
            <remarks>	
            <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 	
            </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap"/></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p>	
            </remarks>	
            <msdn-id>ee690179</msdn-id>	
            <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
            <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels(System.Int32,SharpDX.DataPointer)">
            <summary>	
            <p>Instructs the object to produce pixels.</p>	
            </summary>	
            <param name="stride"><dd>  <p>The stride of the bitmap</p> </dd></param>	
            <param name="dataPointer"><dd>  <p>A reference to the buffer.</p> </dd></param>	
            <remarks>	
            <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 	
            </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap"/></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p>	
            </remarks>	
            <msdn-id>ee690179</msdn-id>	
            <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
            <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels(System.Int32,System.IntPtr,System.Int32)">
            <summary>	
            <p>Instructs the object to produce pixels.</p>	
            </summary>	
            <param name="stride"><dd>  <p>The stride of the bitmap</p> </dd></param>	
            <param name="dataPointer"><dd>  <p>A reference to the buffer.</p> </dd></param>	
            <param name="size">Size of the buffer in bytes.</param>	
            <remarks>	
            <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 	
            </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap"/></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p>	
            </remarks>	
            <msdn-id>ee690179</msdn-id>	
            <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
            <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels``1(SharpDX.Mathematics.Interop.RawBox,``0[])">
            <summary>
            <p>Instructs the object to produce pixels.</p>
            </summary>
            <typeparam name="T">Type of a pixel. This parameter must exactly match a pixel like using <see cref="!:Color"/> for a 32bit RGBA color or <see cref="T:SharpDX.Mathematics.Interop.RawVector4"/> for a 64bits for a RGBA 4 floats color.</typeparam>
            <param name="rectangle"><dd>  <p>The rectangle to copy. A <strong><c>null</c></strong> value specifies the entire bitmap.</p> </dd></param>
            <param name="output">The destination array. The size of the array must be sizeof(pixel) * rectangle.Width * rectangle.Height</param>
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>
            <exception cref="T:System.ArgumentException">output.Length must be equal to Width * Height</exception>
            <msdn-id>ee690179</msdn-id>
              <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
              <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>
            <remarks><p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned.
              </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap" /></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p></remarks>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels``1(``0[])">
            <summary>	
            <p>Instructs the object to produce pixels.</p>	
            </summary>	
            <typeparam name="T">Type of a pixel. This parameter must exactly match a pixel like using <see cref="!:Color"/> for a 32bit RGBA color or <see cref="T:SharpDX.Mathematics.Interop.RawVector4"/> for a 64bits for a RGBA 4 floats color.</typeparam>
            <param name="output">The destination array. The size of the array must be sizeof(pixel) * Width * Height</param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result"/></strong> error code.</p></returns>	
            <remarks>	
            <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 	
            </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap"/></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p>	
            </remarks>	
            <msdn-id>ee690179</msdn-id>	
            <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
            <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels(SharpDX.Mathematics.Interop.RawRectangle,System.Byte[],System.Int32)">
            <summary>
            <p>Instructs the object to produce pixels.</p>
            </summary>
            <param name="output">The destination array. The size of the array must be sizeof(pixel) * Width * Height</param>
            <param name="stride">The stride (number of bytes per row).</param>
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>
            <exception cref="T:System.ArgumentException">output.Length must be equal to Width * Height</exception>
            <msdn-id>ee690179</msdn-id>
              <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
              <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>
            <remarks><p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned.
              </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap" /></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p></remarks>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels(System.Byte[],System.Int32)">
            <summary>
            <p>Instructs the object to produce pixels.</p>
            </summary>
            <param name="output">The destination array. The size of the array must be sizeof(pixel) * Width * Height</param>
            <param name="stride">The stride (number of bytes per row).</param>
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>
            <exception cref="T:System.ArgumentException">output.Length must be equal to Width * Height</exception>
            <msdn-id>ee690179</msdn-id>
              <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
              <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>
            <remarks><p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned.
              </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref="T:SharpDX.WIC.BitmapSource" /></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref="T:SharpDX.WIC.Bitmap" /></strong> first. </p>Codec Developer Remarks<p> The callee must only write to the first (prc-&gt;Width*bitsperpixel+7)/8 bytes of each line of the output buffer (in this case, a line is a consecutive string of <em>cbStride</em> bytes). </p></remarks>
        </member>
        <member name="P:SharpDX.WIC.BitmapSource.PixelFormat">
            <summary>
            <p>Retrieves the pixel format of the bitmap source.. </p>
            </summary>
            <remarks>
            <p> The pixel format returned by this method is not necessarily the pixel format the image is stored as. The codec may perform a format conversion from the storage pixel format to an output pixel format. </p>
            </remarks>
            <doc-id>ee690181</doc-id>
            <unmanaged>GetPixelFormat</unmanaged>
            <unmanaged-short>GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.GetSize(System.Int32@,System.Int32@)">
            <summary>
            <p>Retrieves the pixel width and height of the bitmap.</p>
            </summary>
            <param name = "widthRef"><dd>  <p>A reference that receives the pixel width of the bitmap.</p> </dd></param>
            <param name = "heightRef"><dd>  <p>A reference that receives the pixel height of the bitmap</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690185</doc-id>
            <unmanaged>HRESULT IWICBitmapSource::GetSize([Out] unsigned int* puiWidth,[Out] unsigned int* puiHeight)</unmanaged>
            <unmanaged-short>IWICBitmapSource::GetSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.GetPixelFormat(System.Guid@)">
            <summary>
            <p>Retrieves the pixel format of the bitmap source.. </p>
            </summary>
            <param name = "pixelFormatRef"><dd>  <p>Receives the pixel format <see cref = "T:System.Guid"/> the bitmap is stored in. For a list of available pixel formats, see the Native Pixel Formats topic.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The pixel format returned by this method is not necessarily the pixel format the image is stored as. The codec may perform a format conversion from the storage pixel format to an output pixel format. </p>
            </remarks>
            <doc-id>ee690181</doc-id>
            <unmanaged>HRESULT IWICBitmapSource::GetPixelFormat([Out] GUID* pPixelFormat)</unmanaged>
            <unmanaged-short>IWICBitmapSource::GetPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.GetResolution(System.Double@,System.Double@)">
            <summary>
            <p>Retrieves the sampling rate between pixels and physical world measurements.</p>
            </summary>
            <param name = "dpiXRef"><dd>  <p>A reference that receives the x-axis dpi resolution.</p> </dd></param>
            <param name = "dpiYRef"><dd>  <p>A reference that receives the y-axis dpi resolution.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Some formats, such as GIF and ICO, do not have full DPI support. For GIF, this method calculates the DPI values from the aspect ratio, using a base DPI of (96.0, 96.0). The ICO format does not support DPI at all, and the method always returns (96.0,96.0) for ICO images. </p><p> Additionally, WIC itself does not transform images based on the DPI values in an image. It is up to the caller to transform an image based on the resolution returned. </p>
            </remarks>
            <doc-id>ee690183</doc-id>
            <unmanaged>HRESULT IWICBitmapSource::GetResolution([Out] double* pDpiX,[Out] double* pDpiY)</unmanaged>
            <unmanaged-short>IWICBitmapSource::GetResolution</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPalette(SharpDX.WIC.Palette)">
            <summary>
            <p>Retrieves the color table for indexed pixel formats.</p>
            </summary>
            <param name = "paletteRef"><dd>  <p>An <strong><see cref = "T:SharpDX.WIC.Palette"/></strong>. A palette can be created using the <strong>CreatePalette</strong> method.</p> </dd></param>
            <returns><p>Returns one of the following values.</p><table> <tr><th>Return code</th><th>Description</th></tr> <tr><td> <dl> <dt><strong><see cref = "!:Paletteunavailable"/></strong></dt> </dl> </td><td> <p>The palette was unavailable.</p> </td></tr> <tr><td> <dl> <dt><strong><see cref = "F:SharpDX.Result.Ok"/></strong></dt> </dl> </td><td> <p>The palette was successfully copied.</p> </td></tr> </table><p>?</p></returns>
            <remarks>
            <p> If the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> is an <strong><see cref = "T:SharpDX.WIC.BitmapFrameDecode"/></strong>, the function may return the image's global palette if a frame-level palette is not available. The global palette may also be retrieved using the <strong>CopyPalette</strong> method. </p>
            </remarks>
            <doc-id>ee690177</doc-id>
            <unmanaged>HRESULT IWICBitmapSource::CopyPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
            <unmanaged-short>IWICBitmapSource::CopyPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSource.CopyPixels(System.IntPtr,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <p>Instructs the object to produce pixels.</p>
            </summary>
            <param name = "rectangleRef"><dd>  <p>The rectangle to copy. A <strong><c>null</c></strong> value specifies the entire bitmap.</p> </dd></param>
            <param name = "stride"><dd>  <p>The stride of the bitmap</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The size of the buffer.</p> </dd></param>
            <param name = "bufferRef"><dd>  <p>A reference to the buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>CopyPixels</strong> is one of the two main image processing routines (the other being <strong>Lock</strong>) triggering the actual processing.  It instructs the object to produce pixels according to its algorithm - this may involve decoding a portion of a JPEG stored on disk, copying a block of memory, or even analytically computing a complex gradient.  The algorithm is completely dependent on the object implementing the interface. </p><p> The caller can restrict the operation to a rectangle of interest (ROI) using the prc parameter.  The ROI sub-rectangle must be fully contained in the bounds of the bitmap.  Specifying a <strong><c>null</c></strong> ROI implies that the whole bitmap should be returned. 
            </p><p> The caller controls the memory management and must provide an output buffer (<em>pbBuffer</em>) for the results of the copy along with the buffer's bounds (<em>cbBufferSize</em>).  The cbStride parameter defines the count of bytes between two vertically adjacent pixels in the output buffer.  The caller must ensure that there is sufficient buffer to complete the call based on the width, height and pixel format of the bitmap and the sub-rectangle provided to the copy method. </p><p> If the caller needs to perform numerous copies of an expensive <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> such as a JPEG, it is recommended to create an in-memory <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> first. </p>
            </remarks>
            <doc-id>ee690179</doc-id>
            <unmanaged>HRESULT IWICBitmapSource::CopyPixels([In] const WICRect* prc,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer)</unmanaged>
            <unmanaged-short>IWICBitmapSource::CopyPixels</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.CopyPixels(System.Int32,System.Int32,System.Int32,SharpDX.DataStream)">
            <summary>
            Copies pixel data using the supplied input parameters.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="stride">The stride.</param>
            <param name="output">The output.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.CopyPixels(System.Int32,System.Int32,SharpDX.WIC.BitmapTransformOptions,System.Int32,SharpDX.DataStream)">
            <summary>
            Copies pixel data using the supplied input parameters.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="dstTransform">The DST transform.</param>
            <param name="stride">The stride.</param>
            <param name="output">The output.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.CopyPixels(System.Int32,System.Int32,System.Guid,SharpDX.WIC.BitmapTransformOptions,System.Int32,SharpDX.DataStream)">
            <summary>
            Copies pixel data using the supplied input parameters.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="guidDstFormat">The GUID DST format.</param>
            <param name="dstTransform">The DST transform.</param>
            <param name="stride">The stride.</param>
            <param name="output">The output.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.CopyPixels(SharpDX.Mathematics.Interop.RawBox,System.Int32,System.Int32,System.Guid,SharpDX.WIC.BitmapTransformOptions,System.Int32,SharpDX.DataStream)">
            <summary>
            Copies pixel data using the supplied input parameters.
            </summary>
            <param name="rectangle">The rectangle.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="guidDstFormat">The GUID DST format.</param>
            <param name="dstTransform">The DST transform.</param>
            <param name="stride">The stride.</param>
            <param name="output">The output.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.GetClosestSize(SharpDX.Size2@)">
            <summary>
            Returns the closest dimensions the implementation can natively scale to given the desired dimensions.
            </summary>
            <param name="size">The size.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestSize([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.CopyPixels(System.IntPtr,System.Int32,System.Int32,System.Nullable{System.Guid},SharpDX.WIC.BitmapTransformOptions,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <p>Copies pixel data using the supplied input parameters.</p>
            </summary>
            <param name = "rectangleRef"><dd>  <p>The rectangle of pixels to copy.</p> </dd></param>
            <param name = "width"><dd>  <p>The width to scale the source bitmap. This parameter must equal the value obtainable through <strong>IWICBitmapSourceTransform::GetClosestSize</strong>.</p> </dd></param>
            <param name = "height"><dd>  <p>The height to scale the source bitmap. This parameter must equal the value obtainable through <strong>IWICBitmapSourceTransform::GetClosestSize</strong>.</p> </dd></param>
            <param name = "guidDstFormatRef"><dd>  <p> The <see cref = "T:System.Guid"/> of desired pixel format in which the pixels should be returned.  </p> <p>This <see cref = "T:System.Guid"/> must be a format obtained through an <strong>GetClosestPixelFormat</strong> call.</p> </dd></param>
            <param name = "dstTransform"><dd>  <p> The desired rotation or flip to perform prior to the pixel copy. </p> <p>The transform must be an operation supported by an <strong>DoesSupportTransform</strong> call.</p> <p>If a <em>dstTransform</em> is specified, <em>nStride</em> is the <em>transformed stride</em> and is based on the <em>pguidDstFormat</em> pixel format, not the original source's pixel format.</p> </dd></param>
            <param name = "nStride"><dd>  <p>The stride of the destination buffer.</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The size of the destination buffer.</p> </dd></param>
            <param name = "bufferRef"><dd>  <p>The output buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690173</doc-id>
            <unmanaged>HRESULT IWICBitmapSourceTransform::CopyPixels([In] const WICRect* prc,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In, Optional] GUID* pguidDstFormat,[In] WICBitmapTransformOptions dstTransform,[In] unsigned int nStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer)</unmanaged>
            <unmanaged-short>IWICBitmapSourceTransform::CopyPixels</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.GetClosestSize(System.Int32@,System.Int32@)">
            <summary>
            <p>Returns the closest dimensions the implementation can natively scale to given the desired dimensions.</p>
            </summary>
            <param name = "widthRef"><dd>  <p>The desired width. A reference that receives the closest supported width.</p> </dd></param>
            <param name = "heightRef"><dd>  <p>The desired height. A reference that receives the closest supported height.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Windows provided codecs provide the following support for native scaling:
            </p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <see cref = "T:SharpDX.WIC.BitmapSourceTransform"/>.</li> <li>PNG: No scaling support.</li> <li>JPEG: Native down-scaling by a factor of 8, 4, or 2.</li> <li>JPEG-XR:  Native scaling of the original image by powers of 2.
            </li> </ul>
            </remarks>
            <doc-id>ee690176</doc-id>
            <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestSize([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight)</unmanaged>
            <unmanaged-short>IWICBitmapSourceTransform::GetClosestSize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.GetClosestPixelFormat(System.Guid@)">
            <summary>
            <p>Retrieves the closest pixel format to which the implementation of <strong><see cref = "T:SharpDX.WIC.BitmapSourceTransform"/></strong> can natively copy pixels, given a desired format.</p>
            </summary>
            <param name = "guidDstFormatRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Windows provided codecs provide the following support:</p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <strong><see cref = "T:SharpDX.WIC.BitmapSourceTransform"/></strong>.</li> <li>JPEG, PNG, JPEG-XR: Trivial support (always returns the same value as <strong>IWICBitmapFrameDecode::GetPixelFormat</strong>).</li> </ul>
            </remarks>
            <doc-id>ee690175</doc-id>
            <unmanaged>HRESULT IWICBitmapSourceTransform::GetClosestPixelFormat([InOut] GUID* pguidDstFormat)</unmanaged>
            <unmanaged-short>IWICBitmapSourceTransform::GetClosestPixelFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapSourceTransform.IsSupportingTransform(SharpDX.WIC.BitmapTransformOptions,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Determines whether a specific transform option is supported natively by the implementation of the <strong><see cref = "T:SharpDX.WIC.BitmapSourceTransform"/></strong> interface.</p>
            </summary>
            <param name = "dstTransform">No documentation.</param>
            <param name = "fIsSupportedRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Windows provided codecs provide the following level of support:</p><ul> <li>BMP, ICO, GIF, TIFF: No implementation of <see cref = "T:SharpDX.WIC.BitmapSourceTransform"/>.</li> <li>JPEG, PNG: Trivial support (WICBitmapTransformRotate0 only).</li> <li>JPEG-XR: Support for all transformation/rotations.
            </li> </ul>
            </remarks>
            <doc-id>ee690174</doc-id>
            <unmanaged>HRESULT IWICBitmapSourceTransform::DoesSupportTransform([In] WICBitmapTransformOptions dstTransform,[Out] BOOL* pfIsSupported)</unmanaged>
            <unmanaged-short>IWICBitmapSourceTransform::DoesSupportTransform</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BmpBitmapDecoder">
            <summary>
            Bmp bitmap encoder using <see cref="T:SharpDX.WIC.BitmapDecoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Bmp"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapDecoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapDecoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="T:SharpDX.WIC.BmpBitmapEncoder">
            <summary>
            Bmp bitmap encoder using <see cref="T:SharpDX.WIC.BitmapEncoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Bmp"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapEncoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapEncoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.BmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.BmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.ColorContext"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateColorContext([Out, Fast] IWICColorContext** ppIWICColorContext)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.ColorContext.InitializeFromMemory(SharpDX.DataPointer)">
            <summary>
            Initializes from memory.
            </summary>
            <param name="dataPointer">The data pointer.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICColorContext::InitializeFromMemory([In] const void* pbBuffer,[In] unsigned int cbBufferSize)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.ColorContext.Profile">
            <summary>
            Gets the color context profile.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.ColorContext.TypeInfo">
            <summary>
            <p>Retrieves the color context type.</p>
            </summary>
            <doc-id>ee690196</doc-id>
            <unmanaged>GetType</unmanaged>
            <unmanaged-short>GetType</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.ColorContext.ExifColorSpace">
            <summary>
            <p>Retrieves the Exchangeable Image File (EXIF) color space color context.</p>
            </summary>
            <remarks>
            <p>This method should only be used when <strong>IWICColorContext::GetType</strong> indicates <strong>WICColorContextExifColorSpace</strong>.
            </p>
            </remarks>
            <doc-id>ee690194</doc-id>
            <unmanaged>GetExifColorSpace</unmanaged>
            <unmanaged-short>GetExifColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.InitializeFromFilename(System.String)">
            <summary>
            <p>Initializes the color context from the given file.</p>
            </summary>
            <param name = "filename"><dd>  <p>The name of the file.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Once a color context has been initialized, it can't be re-initialized.
            </p>
            </remarks>
            <doc-id>ee690198</doc-id>
            <unmanaged>HRESULT IWICColorContext::InitializeFromFilename([In] const wchar_t* wzFilename)</unmanaged>
            <unmanaged-short>IWICColorContext::InitializeFromFilename</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.InitializeFromMemory(System.IntPtr,System.Int32)">
            <summary>
            <p>Initializes the color context from a memory block.</p>
            </summary>
            <param name = "bufferRef"><dd>  <p>The buffer used to initialize the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong>.</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The size of the <em>pbBuffer</em> buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Once a color context has been initialized, it can't be re-initialized.
            </p>
            </remarks>
            <doc-id>ee690199</doc-id>
            <unmanaged>HRESULT IWICColorContext::InitializeFromMemory([In] const unsigned char* pbBuffer,[In] unsigned int cbBufferSize)</unmanaged>
            <unmanaged-short>IWICColorContext::InitializeFromMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.InitializeFromExifColorSpace(System.Int32)">
            <summary>
            <p>Initializes the color context using an Exchangeable Image File (EXIF) color space.</p>
            </summary>
            <param name = "value"><dd>  <p>The value of the EXIF color space.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>1</dt> </dl> </td><td> <p>A sRGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>2</dt> </dl> </td><td> <p>An Adobe RGB color space.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Once a color context has been initialized, it can't be re-initialized.
            </p>
            </remarks>
            <doc-id>ee690197</doc-id>
            <unmanaged>HRESULT IWICColorContext::InitializeFromExifColorSpace([In] unsigned int value)</unmanaged>
            <unmanaged-short>IWICColorContext::InitializeFromExifColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.GetTypeInfo(SharpDX.WIC.ColorContextType@)">
            <summary>
            <p>Retrieves the color context type.</p>
            </summary>
            <param name = "typeRef"><dd>  <p>A reference that receives the <strong><see cref = "T:SharpDX.WIC.ColorContextType"/></strong> of the color context.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690196</doc-id>
            <unmanaged>HRESULT IWICColorContext::GetType([Out] WICColorContextType* pType)</unmanaged>
            <unmanaged-short>IWICColorContext::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.GetProfileBytes(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the color context profile.</p>
            </summary>
            <param name = "buffer"><dd>  <p>The size of the <em>pbBuffer</em> buffer.</p> </dd></param>
            <param name = "bufferRef"><dd>  <p>A reference that receives the color context profile.</p> </dd></param>
            <param name = "actualRef"><dd>  <p>A reference that receives the actual buffer size needed to retrieve the entire color context profile.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Only use this method if the context type is <strong>WICColorContextProfile</strong>.
            </p><p>Calling this method with <em>pbBuffer</em> set to <strong><c>null</c></strong> will cause it to return the required buffer size in <em>pcbActual</em>.
            </p>
            </remarks>
            <doc-id>ee690195</doc-id>
            <unmanaged>HRESULT IWICColorContext::GetProfileBytes([In] unsigned int cbBuffer,[In] unsigned char* pbBuffer,[Out] unsigned int* pcbActual)</unmanaged>
            <unmanaged-short>IWICColorContext::GetProfileBytes</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorContext.GetExifColorSpace(System.Int32@)">
            <summary>
            <p>Retrieves the Exchangeable Image File (EXIF) color space color context.</p>
            </summary>
            <param name = "valueRef"><dd>  <p>A reference that receives the EXIF color space color context.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>1</dt> </dl> </td><td> <p>A sRGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>2</dt> </dl> </td><td> <p>An Adobe RGB color space.</p> </td></tr> <tr><td><dl> <dt><strong></strong></dt> <dt>3 through 65534</dt> </dl> </td><td> <p>Unused.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method should only be used when <strong>IWICColorContext::GetType</strong> indicates <strong>WICColorContextExifColorSpace</strong>.
            </p>
            </remarks>
            <doc-id>ee690194</doc-id>
            <unmanaged>HRESULT IWICColorContext::GetExifColorSpace([Out] unsigned int* pValue)</unmanaged>
            <unmanaged-short>IWICColorContext::GetExifColorSpace</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ColorTransform.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.ColorTransform"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateColorTransformer([Out, Fast] IWICColorTransform** ppIWICColorTransform)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.ColorTransform.Initialize(SharpDX.WIC.BitmapSource,SharpDX.WIC.ColorContext,SharpDX.WIC.ColorContext,System.Guid)">
            <summary>
            <p>Initializes an <strong><see cref = "T:SharpDX.WIC.ColorTransform"/></strong> with a <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> and transforms it from one <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> to another. </p>
            </summary>
            <param name = "bitmapSourceRef">No documentation.</param>
            <param name = "contextSourceRef">No documentation.</param>
            <param name = "contextDestRef">No documentation.</param>
            <param name = "ixelFmtDestRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The currently supported formats for the <em>pIContextSource</em> and <em>pixelFmtDest</em> parameters are: 
            </p><ul> <li><see cref = "!:Format8bppGray"/></li> <li><see cref = "!:Format16bppGray"/></li> <li><see cref = "!:Format16bppBGR555"/></li> <li><see cref = "!:Format16bppBGR565"/></li> <li><see cref = "!:Format24bppBGR"/></li> <li><see cref = "!:Format24bppRGB"/></li> <li><see cref = "!:Format32bppBGR"/></li> <li><see cref = "!:Format32bppBGRA"/></li> <li><see cref = "!:Format32bppPBGRA"/></li> <li><see cref = "!:Format32bppPRGBA"/> (Windows?8 and later)</li> <li><see cref = "!:Format32bppRGBA"/></li> <li><see cref = "!:Format32bppBGR101010"/></li> <li><see cref = "!:Format32bppCMYK"/></li> <li><see cref = "!:Format48bppBGR"/></li> <li><see cref = "!:Format64bppBGRA"/> 		(Windows?8 and later)</li> <li> <see cref = "!:Format64bppPBGRA"/> (Windows?8 and later)</li> <li> <see cref = "!:Format64bppPRGBA"/> (Windows?8 and later)</li> <li> <see cref = "!:Format64bppRGBA"/> 		 (Windows?8 and later)</li> </ul><p>In order to get correct behavior from a color transform, the input and output pixel formats must be compatible with the source and destination color profiles. For example, an sRGB destination color profile will produce incorrect results when used with a CMYK destination pixel format.</p>
            </remarks>
            <doc-id>ee690202</doc-id>
            <unmanaged>HRESULT IWICColorTransform::Initialize([In, Optional] IWICBitmapSource* pIBitmapSource,[In, Optional] IWICColorContext* pIContextSource,[In, Optional] IWICColorContext* pIContextDest,[In] const GUID&amp; pixelFmtDest)</unmanaged>
            <unmanaged-short>IWICColorTransform::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.ComponentInfo"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="clsidComponent">The CLSID component.</param>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.Author">
            <summary>
            Gets the author.
            </summary>
            <unmanaged>HRESULT IWICComponentInfo::GetAuthor([In] unsigned int cchAuthor,[InOut, Buffer, Optional] wchar_t* wzAuthor,[Out] unsigned int* pcchActual)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.Version">
            <summary>
            Gets the version.
            </summary>
            <unmanaged>HRESULT IWICComponentInfo::GetVersion([In] unsigned int cchVersion,[InOut, Buffer, Optional] wchar_t* wzVersion,[Out] unsigned int* pcchActual)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.SpecVersion">
            <summary>
            Gets the spec version.
            </summary>
            <unmanaged>HRESULT IWICComponentInfo::GetSpecVersion([In] unsigned int cchSpecVersion,[InOut, Buffer, Optional] wchar_t* wzSpecVersion,[Out] unsigned int* pcchActual)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.FriendlyName">
            <summary>
            Gets the friendly name.
            </summary>
            <value>
            The name of the friendly.
            </value>
            <unmanaged>HRESULT IWICComponentInfo::GetFriendlyName([In] unsigned int cchFriendlyName,[InOut, Buffer, Optional] wchar_t* wzFriendlyName,[Out] unsigned int* pcchActual)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.ComponentType">
            <summary>
            <p>Retrieves the component's <strong><see cref = "T:SharpDX.WIC.ComponentType"/></strong>.</p>
            </summary>
            <doc-id>ee690218</doc-id>
            <unmanaged>GetComponentType</unmanaged>
            <unmanaged-short>GetComponentType</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.CLSID">
            <summary>
            <p>Proxy function for the <strong>GetCLSID</strong> method.</p>
            </summary>
            <doc-id>ee690217</doc-id>
            <unmanaged>GetCLSID</unmanaged>
            <unmanaged-short>GetCLSID</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.SigningStatus">
            <summary>
            <p>Retrieves the signing status of the component.</p>
            </summary>
            <remarks>
            <p>Signing is unused by WIC. Therefore, all components WICComponentSigned.</p><p>This function can be used to determine whether a component has no binary component or has been added to the disabled components list in the registry.</p>
            </remarks>
            <doc-id>ee690221</doc-id>
            <unmanaged>GetSigningStatus</unmanaged>
            <unmanaged-short>GetSigningStatus</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.ComponentInfo.VendorGUID">
            <summary>
            <p>Retrieves the vendor <see cref = "T:System.Guid"/>.</p>
            </summary>
            <doc-id>ee690225</doc-id>
            <unmanaged>GetVendorGUID</unmanaged>
            <unmanaged-short>GetVendorGUID</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetComponentType(SharpDX.WIC.ComponentType@)">
            <summary>
            <p>Retrieves the component's <strong><see cref = "T:SharpDX.WIC.ComponentType"/></strong>.</p>
            </summary>
            <param name = "typeRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690218</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetComponentType([Out] WICComponentType* pType)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetComponentType</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetCLSID(System.Guid@)">
            <summary>
            <p>Proxy function for the <strong>GetCLSID</strong> method.</p>
            </summary>
            <param name = "clsidRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690217</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetCLSID([Out] GUID* pclsid)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetCLSID</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetSigningStatus(System.Int32@)">
            <summary>
            <p>Retrieves the signing status of the component.</p>
            </summary>
            <param name = "statusRef"><dd>  <p>A reference that receives the <strong><see cref = "T:SharpDX.WIC.ComponentSigning"/></strong> status of the component.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Signing is unused by WIC. Therefore, all components WICComponentSigned.</p><p>This function can be used to determine whether a component has no binary component or has been added to the disabled components list in the registry.</p>
            </remarks>
            <doc-id>ee690221</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetSigningStatus([Out] DWORD* pStatus)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetSigningStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetAuthor(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the name of component's author.</p>
            </summary>
            <param name = "cchAuthor"><dd>  <p>The size of the <em>wzAuthor</em> buffer.</p> </dd></param>
            <param name = "author"><dd>  <p>A reference that receives the name of the component's author. The locale of the string depends on the value that the codec wrote to the registry at install time. For built-in components, these strings are always in English.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>A reference that receives the actual length of the component's authors name. The author name is optional; if an author name is not specified by the component, the length returned is 0.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>
            </remarks>
            <doc-id>ee690214</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetAuthor([In] unsigned int cchAuthor,[In] wchar_t* wzAuthor,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetAuthor</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetVendorGUID(System.Guid@)">
            <summary>
            <p>Retrieves the vendor <see cref = "T:System.Guid"/>.</p>
            </summary>
            <param name = "guidVendorRef"><dd>  <p>A reference that receives the component's vendor <see cref = "T:System.Guid"/>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690225</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetVendorGUID([Out] GUID* pguidVendor)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetVendorGUID</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetVersion(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetVersion</strong> method.</p>
            </summary>
            <param name = "cchVersion">No documentation.</param>
            <param name = "version">No documentation.</param>
            <param name = "cchActualRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690227</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetVersion([In] unsigned int cchVersion,[In] wchar_t* wzVersion,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetSpecVersion(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the component's specification version.</p>
            </summary>
            <param name = "cchSpecVersion"><dd>  <p>The size of the <em>wzSpecVersion</em> buffer.</p> </dd></param>
            <param name = "specVersion"><dd>  <p>When this method returns, contain a culture invarient string of the component's specification version. The version form is NN.NN.NN.NN.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>A reference that receives the actual length of the component's specification version. The specification version is optional; if a value is not specified by the component, the length returned is 0.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>All built-in components return "1.0.0.0", except for pixel formats, which do not have a spec version.</p><p>If <em>cchAuthor</em> is 0 and <em>wzAuthor</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>
            </remarks>
            <doc-id>ee690223</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetSpecVersion([In] unsigned int cchSpecVersion,[In] wchar_t* wzSpecVersion,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetSpecVersion</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ComponentInfo.GetFriendlyName(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the component's friendly name, which is a human-readable display name for the component.</p>
            </summary>
            <param name = "cchFriendlyName"><dd>  <p>The size of the <em>wzFriendlyName</em> buffer.</p> </dd></param>
            <param name = "friendlyName"><dd>  <p>A reference that receives the friendly name of the component. The locale of the string depends on the value that the codec wrote to the registry at install time. For built-in components, these strings are always in English.</p> </dd></param>
            <param name = "cchActualRef"><dd>  <p>A reference that receives the actual length of the component's friendly name.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If <em>cchFriendlyName</em> is 0 and <em>wzFriendlyName</em> is <strong><c>null</c></strong>, the required buffer size is returned in <em>pccchActual</em>.</p>
            </remarks>
            <doc-id>ee690219</doc-id>
            <unmanaged>HRESULT IWICComponentInfo::GetFriendlyName([In] unsigned int cchFriendlyName,[In] wchar_t* wzFriendlyName,[Out] unsigned int* pcchActual)</unmanaged>
            <unmanaged-short>IWICComponentInfo::GetFriendlyName</unmanaged-short>
        </member>
        <!-- Badly formed XML comment ignored for member "P:SharpDX.WIC.DdsFrameDecode.SizeInBlocks" -->
        <member name="M:SharpDX.WIC.DdsFrameDecode.CopyBlocks(System.Nullable{SharpDX.Mathematics.Interop.RawBox},System.Int32,SharpDX.DataStream)">
            <summary>	
            <p>[This documentation is preliminary and is subject to change.]</p><p>Requests pixel data as it is natively stored within the DDS file.</p>	
            </summary>	
            <param name="boundsInBlocks"><dd>  <p>The rectangle to copy from the source. A <c>null</c> value specifies the entire texture.</p> <p>If the texture uses a block-compressed <strong><see cref="T:SharpDX.DXGI.Format" /></strong>, all values of the rectangle are expressed in number of blocks, not pixels.</p> </dd></param>	
            <param name="stride"><dd>  <p>The stride, in bytes, of the destination buffer. This represents the number of bytes from the buffer reference to the next row of data. If the texture uses a block-compressed <strong><see cref="T:SharpDX.DXGI.Format" /></strong>, a "row of data" is defined as a row of blocks which contains multiple pixel scanlines.</p> </dd></param>	
            <param name="destination"><dd>  <p>A reference to the destination buffer.</p> </dd></param>	
            <returns><p>If this method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p></returns>	
            <remarks>	
            <p>If the texture does not use a block-compressed <strong><see cref="T:SharpDX.DXGI.Format" /></strong>, this method behaves similarly to <strong><see cref="M:SharpDX.WIC.BitmapSource.CopyPixels(SharpDX.Mathematics.Interop.RawBox,System.Int32,SharpDX.DataPointer)" /></strong>. However, it does not perform any pixel format conversion, and instead produces the raw data from the DDS file.</p><p>If the texture uses a block-compressed <strong><see cref="T:SharpDX.DXGI.Format" /></strong>, this method copies the block data directly into the provided buffer. In this case, the <em>prcBoundsInBlocks</em> parameter is defined in blocks, not pixels. To determine if this is the case, call <strong>GetFormatInfo</strong> and read the <strong>DxgiFormat</strong> member of the returned <strong><see cref="T:SharpDX.WIC.DdsFormatInfo" /></strong> structure.	
            </p>	
            </remarks>	
            <!-- No matching elements were found for the following include tag --><include file="..\Documentation\CodeComments.xml" path="/comments/comment[@id='IWICDdsFrameDecode::CopyBlocks']/*" />	
            <msdn-id>dn302087</msdn-id>	
            <unmanaged>HRESULT IWICDdsFrameDecode::CopyBlocks([In, Optional] const WICRect* prcBoundsInBlocks,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] void* pbBuffer)</unmanaged>	
            <unmanaged-short>IWICDdsFrameDecode::CopyBlocks</unmanaged-short>	
        </member>
        <member name="P:SharpDX.WIC.DdsFrameDecode.FormatInfo">
            <summary>
            <p>Gets information about the format in which the DDS image is stored.</p>
            </summary>
            <remarks>
            <p>This information can be used for allocating memory or constructing Direct3D or Direct2D resources, for example by using <strong>ID3D11Device::CreateTexture2D</strong> or <strong>ID2D1DeviceContext::CreateBitmap</strong>.</p>
            </remarks>
            <doc-id>dn302088</doc-id>
            <unmanaged>GetFormatInfo</unmanaged>
            <unmanaged-short>GetFormatInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsFrameDecode.GetSizeInBlocks(System.Int32@,System.Int32@)">
            <summary>
            <p>Gets the width and height, in blocks, of the DDS image.</p>
            </summary>
            <param name = "widthInBlocksRef"><dd>  <p>The width of the DDS image in blocks.</p> </dd></param>
            <param name = "heightInBlocksRef"><dd>  <p>The height of the DDS image in blocks.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For block compressed textures, the returned width and height values do not completely define the texture size because the image is padded to fit the closest whole block size. For example, three BC1 textures with pixel dimensions of 1x1, 2x2 and 4x4 will all report <em>pWidthInBlocks</em> = 1 and <em>pHeightInBlocks</em> = 1. </p><p>If the texture does not use a block-compressed <strong><see cref = "T:SharpDX.DXGI.Format"/></strong>, this method returns the texture size in pixels; for these formats the block size returned by <strong>IWICDdsFrameDecoder::GetFormatInfo</strong> is 1x1.
            </p>
            </remarks>
            <doc-id>dn302089</doc-id>
            <unmanaged>HRESULT IWICDdsFrameDecode::GetSizeInBlocks([Out] unsigned int* pWidthInBlocks,[Out] unsigned int* pHeightInBlocks)</unmanaged>
            <unmanaged-short>IWICDdsFrameDecode::GetSizeInBlocks</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsFrameDecode.GetFormatInfo(SharpDX.WIC.DdsFormatInfo@)">
            <summary>
            <p>Gets information about the format in which the DDS image is stored.</p>
            </summary>
            <param name = "formatInfoRef"><dd>  <p>Information about the DDS format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This information can be used for allocating memory or constructing Direct3D or Direct2D resources, for example by using <strong>ID3D11Device::CreateTexture2D</strong> or <strong>ID2D1DeviceContext::CreateBitmap</strong>.</p>
            </remarks>
            <doc-id>dn302088</doc-id>
            <unmanaged>HRESULT IWICDdsFrameDecode::GetFormatInfo([Out] WICDdsFormatInfo* pFormatInfo)</unmanaged>
            <unmanaged-short>IWICDdsFrameDecode::GetFormatInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsFrameDecode.CopyBlocks(System.Nullable{SharpDX.Mathematics.Interop.RawBox},System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <p>Requests pixel data as it is natively stored within the DDS file.</p>
            </summary>
            <param name = "rcBoundsInBlocksRef"><dd>  <p>The rectangle to copy from the source. A <c>null</c> value specifies the entire texture.</p> <p>If the texture uses a block-compressed <strong><see cref = "T:SharpDX.DXGI.Format"/></strong>, all values of the rectangle are expressed in number of blocks, not pixels.</p> </dd></param>
            <param name = "stride"><dd>  <p>The stride, in bytes, of the destination buffer. This represents the number of bytes from the buffer reference to the next row of data. If the texture uses a block-compressed <strong><see cref = "T:SharpDX.DXGI.Format"/></strong>, a "row of data" is defined as a row of blocks which contains multiple pixel scanlines.</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The size, in bytes, of the destination buffer.</p> </dd></param>
            <param name = "bufferRef"><dd>  <p>A reference to the destination buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the texture does not use a block-compressed <strong><see cref = "T:SharpDX.DXGI.Format"/></strong>, this method behaves similarly to <strong>IWICBitmapSource::CopyPixels</strong>. However, it does not perform any pixel format conversion, and instead produces the raw data from the DDS file.</p><p>If the texture uses a block-compressed <strong><see cref = "T:SharpDX.DXGI.Format"/></strong>, this method copies the block data directly into the provided buffer. In this case, the <em>prcBoundsInBlocks</em> parameter is defined in blocks, not pixels. To determine if this is the case, call <strong>GetFormatInfo</strong> and read the <strong>DxgiFormat</strong> member of the returned <strong><see cref = "T:SharpDX.WIC.DdsFormatInfo"/></strong> structure.
            </p>
            </remarks>
            <doc-id>dn302087</doc-id>
            <unmanaged>HRESULT IWICDdsFrameDecode::CopyBlocks([In, Optional] const WICRect* prcBoundsInBlocks,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer)</unmanaged>
            <unmanaged-short>IWICDdsFrameDecode::CopyBlocks</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.FastMetadataEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.BitmapDecoder)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.FastMetadataEncoder"/> class from a <see cref="T:SharpDX.WIC.BitmapDecoder"/>
            </summary>
            <param name="factory">The factory.</param>
            <param name="decoder">The decoder.</param>
        </member>
        <member name="M:SharpDX.WIC.FastMetadataEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.BitmapFrameDecode)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.FastMetadataEncoder"/> class from a <see cref="T:SharpDX.WIC.BitmapFrameDecode"/>
            </summary>
            <param name="factory">The factory.</param>
            <param name="frameDecoder">The frame decoder.</param>
        </member>
        <member name="P:SharpDX.WIC.FastMetadataEncoder.MetadataQueryWriter">
            <summary>
            <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
            </summary>
            <doc-id>ee690273</doc-id>
            <unmanaged>GetMetadataQueryWriter</unmanaged>
            <unmanaged-short>GetMetadataQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.FastMetadataEncoder.Commit">
            <summary>
            <p>Finalizes metadata changes to the image stream.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the commit fails and returns <strong><see cref = "!:StreamNotAvailable"/></strong>, ensure that the image decoder was loaded using the <strong>WICDecodeMetadataCacheOnDemand</strong> option. A fast metadata encoder is not supported when the decoder is created using the <strong>WICDecodeMetadataCacheOnLoad</strong> option. </p><p>If the commit fails for any reason, you will need to re-encode the image to ensure the new metadata is added to the image.</p>
            </remarks>
            <doc-id>ee690270</doc-id>
            <unmanaged>HRESULT IWICFastMetadataEncoder::Commit()</unmanaged>
            <unmanaged-short>IWICFastMetadataEncoder::Commit</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.FastMetadataEncoder.GetMetadataQueryWriter(SharpDX.WIC.MetadataQueryWriter@)">
            <summary>
            <p>Proxy function for the <strong>GetMetadataQueryWriter</strong> method.</p>
            </summary>
            <param name = "metadataQueryWriterOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690273</doc-id>
            <unmanaged>HRESULT IWICFastMetadataEncoder::GetMetadataQueryWriter([Out] IWICMetadataQueryWriter** ppIMetadataQueryWriter)</unmanaged>
            <unmanaged-short>IWICFastMetadataEncoder::GetMetadataQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.FormatConverter.#ctor(SharpDX.WIC.FormatConverterInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.FormatConverter"/> class.
            </summary>
            <param name="converterInfo">The converter info.</param>
        </member>
        <member name="M:SharpDX.WIC.FormatConverter.Initialize(SharpDX.WIC.BitmapSource,System.Guid)">
            <summary>
            Initializes this instance with the specified bitmap source and format
            </summary>
            <param name="sourceRef">The source ref.</param>
            <param name="dstFormat">The destination format.</param>
            <returns></returns>
        </member>
        <member name="M:SharpDX.WIC.FormatConverter.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.FormatConverter"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.FormatConverter.Initialize(SharpDX.WIC.BitmapSource,System.Guid,SharpDX.WIC.BitmapDitherType,SharpDX.WIC.Palette,System.Double,SharpDX.WIC.BitmapPaletteType)">
            <summary>
            <p>Initializes the format converter.</p>
            </summary>
            <param name = "sourceRef"><dd>  <p>The input bitmap to convert</p> </dd></param>
            <param name = "dstFormat"><dd>  <p>The destination pixel format <see cref = "T:System.Guid"/>.</p> </dd></param>
            <param name = "dither"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
            <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
            <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
            <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> If you do not have a predefined palette, you must first create one. Use <strong>InitializeFromBitmap</strong> to create the palette object, then pass it in along with your other parameters. </p><p><em>dither</em>, <em>pIPalette</em>, <em>alphaThresholdPercent</em>, and <em>paletteTranslate</em> are used to mitigate color loss when converting to a reduced bit-depth format. For conversions that do not need these settings, the following parameters values should be used: <em>dither</em> set to <strong>WICBitmapDitherTypeNone</strong>, <em>pIPalette</em> set to <strong><c>null</c></strong>, <em>alphaThresholdPercent</em> set to <strong>0.0f</strong>, and <em>paletteTranslate</em> set to <strong>WICBitmapPaletteTypeCustom</strong>.   </p><p> The basic algorithm involved when using an ordered dither requires a fixed palette, found in the <strong><see cref = "T:SharpDX.WIC.BitmapPaletteType"/></strong> enumeration, in a specific order. Often, the actual palette provided for the output may have a different ordering or some slight variation in the actual colors.  This is the case when using the Microsoft?Windows palette which has slight differences among versions of Windows. To provide for this, a palette and a palette translation are given to the format converter.  The <em>pIPalette</em> is the actual destination palette to be used and the <em>paletteTranslate</em> is a fixed palette.  Once the conversion is complete, the colors are mapped from the fixed palette to the actual colors in <em>pIPalette</em> using a nearest color matching algorithm.  </p><p> If colors in <em>pIPalette</em> do not closely match those in <em>paletteTranslate</em>, the mapping may produce undesireable results. </p><p><strong>WICBitmapDitherTypeOrdered4x4</strong> can be useful in format conversions from 8-bit formats to 5- or 6-bit formats as there is no way to accurately convert color data. </p><p><strong>WICBitmapDitherTypeErrorDiffusion</strong> selects the error diffusion algorithm and may be used with any palette.  If an arbitrary palette is provided, <strong>WICBitmapPaletteCustom</strong> should be passed in as the <em>paletteTranslate</em>.  Error diffusion often provides superior results compared to the ordered dithering algorithms especially when combined with the optimized palette generation functionality on the <strong><see cref = "T:SharpDX.WIC.Palette"/></strong>. </p><p> When converting a bitmap which has an alpha channel, such as a Portable Network Graphics (PNG), to 8bpp, the alpha channel is normally ignored.  Any pixels which were transparent in the original bitmap show up as black in the final output because both transparent and black have pixel values of zero in the respective formats.  </p><p> Some 8bpp content can contains an alpha color; for instance, the Graphics Interchange Format (GIF) format allows for a single palette entry to be used as a transparent color. For this type of content, <em>alphaThresholdPercent</em> specifies what percentage of transparency should map to the transparent color. Because the alpha value is directly proportional to the opacity (not transparency) of a pixel, the <em>alphaThresholdPercent</em> indicates what level of opacity is mapped to the fully transparent color.  For instance, 9.8% implies that any pixel with an alpha value of less than 25 will be mapped to the transparent color.  A value of 100% maps all pixels which are not fully opaque to the transparent color. Note that the palette should provide a transparent color. If it does not, the 'transparent' color will be the one closest to zero - often black. </p>
            </remarks>
            <doc-id>ee690279</doc-id>
            <unmanaged>HRESULT IWICFormatConverter::Initialize([In, Optional] IWICBitmapSource* pISource,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
            <unmanaged-short>IWICFormatConverter::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.FormatConverter.CanConvert(System.Guid,System.Guid)">
            <summary>
            <p>Determines if the source pixel format can be converted to the destination pixel format.</p>
            </summary>
            <param name = "srcPixelFormat"><dd>  <p>The source pixel format.</p> </dd></param>
            <param name = "dstPixelFormat"><dd>  <p>The destionation pixel format.</p> </dd></param>
            <returns><dd>  <p>A reference that receives a value indicating whether the source pixel format can be converted to the destination pixel format.</p> </dd></returns>
            <doc-id>ee690278</doc-id>
            <unmanaged>HRESULT IWICFormatConverter::CanConvert([In] const GUID&amp; srcPixelFormat,[In] const GUID&amp; dstPixelFormat,[Out] BOOL* pfCanConvert)</unmanaged>
            <unmanaged-short>IWICFormatConverter::CanConvert</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.FormatConverterInfo.PixelFormats">
            <summary>
            Gets the supported pixel formats.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.FormatConverterInfo.GetPixelFormats(System.Int32,System.Guid[],System.Int32@)">
            <summary>
            <p>Retrieves a list of GUIDs that signify which pixel formats the converter supports.</p>
            </summary>
            <param name = "formats"><dd>  <p>The size of the <em>pPixelFormatGUIDs</em> array.</p> </dd></param>
            <param name = "pixelFormatGUIDsRef"><dd>  <p>Pointer to a <see cref = "T:System.Guid"/> array that receives the pixel formats the converter supports.</p> </dd></param>
            <param name = "actualRef"><dd>  <p>The actual array size needed to retrieve all pixel formats supported by the converter.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The format converter does not necessarily guarantee symmetricality with respect to conversion; that is, a converter may be able to convert FROM a particular format without actually being able to convert TO a particular format. In order to test symmetricality, use <strong>CanConvert</strong>.</p><p>To determine the number of pixel formats a coverter can handle, set <em>cFormats</em> to <code>0</code> and <em>pPixelFormatGUIDs</em> to <code><c>null</c></code>. The converter will fill <em>pcActual</em> with the number of formats supported by that converter.</p>
            </remarks>
            <doc-id>ee690277</doc-id>
            <unmanaged>HRESULT IWICFormatConverterInfo::GetPixelFormats([In] unsigned int cFormats,[Out, Buffer, Optional] GUID* pPixelFormatGUIDs,[Out] unsigned int* pcActual)</unmanaged>
            <unmanaged-short>IWICFormatConverterInfo::GetPixelFormats</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.FormatConverterInfo.CreateInstance(SharpDX.WIC.FormatConverter)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.WIC.FormatConverter"/></strong> instance.</p>
            </summary>
            <param name = "converterOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690276</doc-id>
            <unmanaged>HRESULT IWICFormatConverterInfo::CreateInstance([Out, Fast] IWICFormatConverter** ppIConverter)</unmanaged>
            <unmanaged-short>IWICFormatConverterInfo::CreateInstance</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.GifBitmapDecoder">
            <summary>
            Gif bitmap encoder using <see cref="T:SharpDX.WIC.BitmapDecoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Gif"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapDecoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapDecoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="T:SharpDX.WIC.GifBitmapEncoder">
            <summary>
            Gif bitmap encoder using <see cref="T:SharpDX.WIC.BitmapEncoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Gif"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapEncoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapEncoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.GifBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.GifBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.ImageEncoder.#ctor(SharpDX.WIC.ImagingFactory2,SharpDX.Direct2D1.Device)">
            <summary>
            Creates a new image encoder object.
            </summary>
            <param name="factory">The WIC factory.</param>
            <param name="d2dDevice">The <see cref="T:SharpDX.Direct2D1.Device" /> object on which the corresponding image encoder is created.</param>
            <msdn-id>hh880849</msdn-id>
              <unmanaged>HRESULT IWICImagingFactory2::CreateImageEncoder([In] ID2D1Device* pD2DDevice,[In] IWICImageEncoder** ppWICImageEncoder)</unmanaged>
              <unmanaged-short>IWICImagingFactory2::CreateImageEncoder</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImageEncoder.WriteFrame(SharpDX.Direct2D1.Image,SharpDX.WIC.BitmapFrameEncode,SharpDX.WIC.ImageParameters)">
            <summary>
            <p>Encodes the image to the frame given by the <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong>.</p>
            </summary>
            <param name = "imageRef">No documentation.</param>
            <param name = "frameEncodeRef">No documentation.</param>
            <param name = "imageParametersRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The image passed in must be created on the same device as in <strong>IWICImagingFactory2::CreateImageEncoder</strong>. If the <em>pImageParameters</em> are not specified, a set of useful defaults will be assumed, see <strong><see cref = "T:SharpDX.WIC.ImageParameters"/></strong> for more info. </p><p>You must correctly and independently have set up the <see cref = "T:SharpDX.WIC.BitmapFrameEncode"/> before calling this API.
            </p>
            </remarks>
            <doc-id>hh880845</doc-id>
            <unmanaged>HRESULT IWICImageEncoder::WriteFrame([In] ID2D1Image* pImage,[In] IWICBitmapFrameEncode* pFrameEncode,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>
            <unmanaged-short>IWICImageEncoder::WriteFrame</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImageEncoder.WriteFrameThumbnail(SharpDX.Direct2D1.Image,SharpDX.WIC.BitmapFrameEncode,SharpDX.WIC.ImageParameters)">
            <summary>
            <p>Encodes the image as a thumbnail to the frame given by the <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong>. </p>
            </summary>
            <param name = "imageRef">No documentation.</param>
            <param name = "frameEncodeRef">No documentation.</param>
            <param name = "imageParametersRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The image passed in must be created on the same device as in <strong>IWICImagingFactory2::CreateImageEncoder</strong>. If the <em>pImageParameters</em> are not specified, a set of useful defaults will be assumed, see <strong><see cref = "T:SharpDX.WIC.ImageParameters"/></strong> for more info. </p><p>You must correctly and independently have set up the <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> before calling this API.
            </p>
            </remarks>
            <doc-id>hh880846</doc-id>
            <unmanaged>HRESULT IWICImageEncoder::WriteFrameThumbnail([In] ID2D1Image* pImage,[In] IWICBitmapFrameEncode* pFrameEncode,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>
            <unmanaged-short>IWICImageEncoder::WriteFrameThumbnail</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImageEncoder.WriteThumbnail(SharpDX.Direct2D1.Image,SharpDX.WIC.BitmapEncoder,SharpDX.WIC.ImageParameters)">
            <summary>
            <p>Encodes the given image as the thumbnail to the given WIC bitmap encoder.</p>
            </summary>
            <param name = "imageRef"><dd>  <p>The Direct2D image that will be encoded.</p> </dd></param>
            <param name = "encoderRef"><dd>  <p>The encoder on which the thumbnail is set.</p> </dd></param>
            <param name = "imageParametersRef"><dd>  <p>Additional parameters to control encoding.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You must create the image that you pass in on the same device as in <strong>IWICImagingFactory2::CreateImageEncoder</strong>. If you don't specify additional parameters in the variable that <em>pImageParameters</em> points to, the encoder uses a set of useful defaults. For info about these defaults, see <strong><see cref = "T:SharpDX.WIC.ImageParameters"/></strong>. </p><p>Before you call <strong>WriteThumbnail</strong>, you must set up the <strong><see cref = "T:SharpDX.WIC.BitmapEncoder"/></strong> interface for the encoder on which you want to set the thumbnail. </p><p>If <strong>WriteThumbnail</strong> fails, it might return E_OUTOFMEMORY, <see cref = "!:WrongResourceDomain"/>, or other error codes from the encoder.</p>
            </remarks>
            <doc-id>hh880847</doc-id>
            <unmanaged>HRESULT IWICImageEncoder::WriteThumbnail([In] ID2D1Image* pImage,[In] IWICBitmapEncoder* pEncoder,[In, Value] const WICImageParameters* pImageParameters)</unmanaged>
            <unmanaged-short>IWICImageEncoder::WriteThumbnail</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.ImageParameters">
            <summary>
            <p>This defines parameters that you can use to override the default parameters normally used when encoding an image. </p>
            </summary>
            <remarks>
            <p>If this parameter is not passed to the encoding API, the encoder uses these settings.</p><ul> <li>A pixel format of (<strong>DXGI_FORMAT_B8G8R8A8_UNORM</strong>, <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong>).</li> <li>An x and y DPI of 96.</li> <li>The entire image bounds will be used for encoding.</li> </ul><strong>Note</strong>??The parameters as specified can't result in a scale. The encoder can use a larger portion of the input image based on the passed in DPI and the pixel width and height.?
            </remarks>
            <doc-id>jj125331</doc-id>
            <unmanaged>WICImageParameters</unmanaged>
            <unmanaged-short>WICImageParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImageParameters.#ctor(SharpDX.Direct2D1.PixelFormat,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.ImageParameters" /> struct.
            </summary>
            <param name="pixelFormat">The pixel format.</param>
            <param name="dpiX">The dpi X.</param>
            <param name="dpiY">The dpi Y.</param>
            <param name="top">The top.</param>
            <param name="left">The left.</param>
            <param name="pixelWidth">Width in pixel.</param>
            <param name="pixelHeight">Height in pixel.</param>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.PixelFormat">
            <summary>
            <dd> <p>The pixel format to which the image is processed before it is written to the encoder.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>PixelFormat</unmanaged>
            <unmanaged-short>PixelFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.DpiX">
            <summary>
            <dd> <p>The DPI in the x dimension.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>DpiX</unmanaged>
            <unmanaged-short>DpiX</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.DpiY">
            <summary>
            <dd> <p>The DPI in the y dimension.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>DpiY</unmanaged>
            <unmanaged-short>DpiY</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.Top">
            <summary>
            <dd> <p>The top corner in pixels of the image space to be encoded to the destination.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>Top</unmanaged>
            <unmanaged-short>Top</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.Left">
            <summary>
            <dd> <p>The left corner in pixels of the image space to be encoded to the destination.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>Left</unmanaged>
            <unmanaged-short>Left</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.PixelWidth">
            <summary>
            <dd> <p>The width in pixels of the part of the image to write.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>PixelWidth</unmanaged>
            <unmanaged-short>PixelWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ImageParameters.PixelHeight">
            <summary>
            <dd> <p>The height in pixels of the part of the image to write.</p> </dd>
            </summary>
            <doc-id>jj125331</doc-id>
            <unmanaged>PixelHeight</unmanaged>
            <unmanaged-short>PixelHeight</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.ImagingFactory"/> class.
            </summary>
        </member>
        <member name="F:SharpDX.WIC.ImagingFactory.WICImagingFactoryClsid">
            <summary>Constant WICImagingFactoryClsid</summary>
            <unmanaged>CLSID_WICImagingFactory</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateDecoderFromFilename(System.String,System.Nullable{System.Guid},System.Int32,SharpDX.WIC.DecodeOptions,SharpDX.WIC.BitmapDecoder)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong> class based on the given file.</p>
            </summary>
            <param name = "filename">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "desiredAccess">No documentation.</param>
            <param name = "metadataOptions">No documentation.</param>
            <param name = "decoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690307</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFilename([In] const wchar_t* wzFilename,[In, Optional] const GUID* pguidVendor,[In] DWORD dwDesiredAccess,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateDecoderFromFilename</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateDecoderFromStream(SharpDX.Win32.IStream,System.Nullable{System.Guid},SharpDX.WIC.DecodeOptions,SharpDX.WIC.BitmapDecoder)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong> class based on the given <see cref = "T:SharpDX.Win32.IStream"/>.</p>
            </summary>
            <param name = "streamRef">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "metadataOptions">No documentation.</param>
            <param name = "decoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690309</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromStream([In, Optional] IStream* pIStream,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateDecoderFromStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateDecoderFromFileHandle(System.IntPtr,System.Nullable{System.Guid},SharpDX.WIC.DecodeOptions,SharpDX.WIC.BitmapDecoder)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong> based on the given file handle.</p>
            </summary>
            <param name = "hFile">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "metadataOptions">No documentation.</param>
            <param name = "decoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When a decoder is created using this method, the file handle must remain alive during the lifetime of the decoder.</p>
            </remarks>
            <doc-id>ee690305</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoderFromFileHandle([In] ULONG_PTR hFile,[In, Optional] const GUID* pguidVendor,[In] WICDecodeOptions metadataOptions,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateDecoderFromFileHandle</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateComponentInfo(System.Guid,SharpDX.WIC.ComponentInfo)">
            <summary>
            <p>Proxy function for the <strong>CreateComponentInfo</strong> method.</p>
            </summary>
            <param name = "clsidComponent">No documentation.</param>
            <param name = "infoOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690303</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateComponentInfo([In] const GUID&amp; clsidComponent,[Out, Fast] IWICComponentInfo** ppIInfo)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateComponentInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateDecoder(System.Guid,System.Nullable{System.Guid},SharpDX.WIC.BitmapDecoder)">
            <summary>
            <p>Creates a new instance of <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong>.</p>
            </summary>
            <param name = "guidContainerFormat">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "decoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Other values may be available for both <em>guidContainerFormat</em> and <em>pguidVendor</em> depending on the installed WIC-enabled encoders. The values listed are those that are natively supported by the operating system. </p>
            </remarks>
            <doc-id>ee690304</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateDecoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapDecoder** ppIDecoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateDecoder</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateEncoder(System.Guid,System.Nullable{System.Guid},SharpDX.WIC.BitmapEncoder)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.BitmapEncoder"/></strong> class.</p>
            </summary>
            <param name = "guidContainerFormat">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "encoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> Other values may be available for both <em>guidContainerFormat</em> and <em>pguidVendor</em> depending on the installed WIC-enabled encoders. The values listed are those that are natively supported by the operating system. </p>
            </remarks>
            <doc-id>ee690311</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateEncoder([In] const GUID&amp; guidContainerFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICBitmapEncoder** ppIEncoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateEncoder</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreatePalette(SharpDX.WIC.Palette)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.Palette"/></strong> class.</p>
            </summary>
            <param name = "paletteOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690319</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreatePalette([Out, Fast] IWICPalette** ppIPalette)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreatePalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateFormatConverter(SharpDX.WIC.FormatConverter)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.FormatConverter"/></strong> class.</p>
            </summary>
            <param name = "formatConverterOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690317</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateFormatConverter([Out, Fast] IWICFormatConverter** ppIFormatConverter)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateFormatConverter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapScaler(SharpDX.WIC.BitmapScaler)">
            <summary>
            <p>Creates a new instance of an <strong><see cref = "T:SharpDX.WIC.BitmapScaler"/></strong>.</p>
            </summary>
            <param name = "bitmapScalerOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690296</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapScaler([Out, Fast] IWICBitmapScaler** ppIBitmapScaler)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapScaler</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapClipper(SharpDX.WIC.BitmapClipper)">
            <summary>
            <p>Proxy function for the <strong>CreateBitmapClipper</strong> method.</p>
            </summary>
            <param name = "bitmapClipperOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690284</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapClipper([Out, Fast] IWICBitmapClipper** ppIBitmapClipper)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapClipper</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapFlipRotator(SharpDX.WIC.BitmapFlipRotator)">
            <summary>
            <p>Proxy function for the <strong>CreateBitmapFlipRotator</strong> method.</p>
            </summary>
            <param name = "bitmapFlipRotatorOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690286</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFlipRotator([Out, Fast] IWICBitmapFlipRotator** ppIBitmapFlipRotator)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapFlipRotator</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateStream(SharpDX.WIC.WICStream)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.WICStream"/></strong> class.</p>
            </summary>
            <param name = "wICStreamOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690325</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateStream([Out, Fast] IWICStream** ppIWICStream)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateColorContext(SharpDX.WIC.ColorContext)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong> class.</p>
            </summary>
            <param name = "wICColorContextOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690299</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateColorContext([Out, Fast] IWICColorContext** ppIWICColorContext)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateColorTransformer(SharpDX.WIC.ColorTransform)">
            <summary>
            <p>Creates a new instance of the <strong><see cref = "T:SharpDX.WIC.ColorTransform"/></strong> class.</p>
            </summary>
            <param name = "wICColorTransformOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690300</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateColorTransformer([Out, Fast] IWICColorTransform** ppIWICColorTransform)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateColorTransformer</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmap(System.Int32,System.Int32,System.Guid,SharpDX.WIC.BitmapCreateCacheOption,SharpDX.WIC.Bitmap)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> object.</p>
            </summary>
            <param name = "width">No documentation.</param>
            <param name = "height">No documentation.</param>
            <param name = "ixelFormatRef">No documentation.</param>
            <param name = "option">No documentation.</param>
            <param name = "bitmapOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690282</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmap([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapFromSource(SharpDX.WIC.BitmapSource,SharpDX.WIC.BitmapCreateCacheOption,SharpDX.WIC.Bitmap)">
            <summary>
            <p>Creates a <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> from a <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong>.</p>
            </summary>
            <param name = "bitmapSourceRef">No documentation.</param>
            <param name = "option">No documentation.</param>
            <param name = "bitmapOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690293</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSource([In, Optional] IWICBitmapSource* pIBitmapSource,[In] WICBitmapCreateCacheOption option,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapFromSourceRect(SharpDX.WIC.BitmapSource,System.Int32,System.Int32,System.Int32,System.Int32,SharpDX.WIC.Bitmap)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> from a specified rectangle of an <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong>.</p>
            </summary>
            <param name = "bitmapSourceRef">No documentation.</param>
            <param name = "x">No documentation.</param>
            <param name = "y">No documentation.</param>
            <param name = "width">No documentation.</param>
            <param name = "height">No documentation.</param>
            <param name = "bitmapOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Providing a rectangle that is larger than the source will produce undefined results.</p><p>This method always creates a separate copy of the source image, similar to the cache option <strong>WICBitmapCacheOnLoad</strong>.</p>
            </remarks>
            <doc-id>ee690294</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromSourceRect([In, Optional] IWICBitmapSource* pIBitmapSource,[In] unsigned int x,[In] unsigned int y,[In] unsigned int width,[In] unsigned int height,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromSourceRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapFromMemory(System.Int32,System.Int32,System.Guid,System.Int32,System.Int32,System.IntPtr,SharpDX.WIC.Bitmap)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> from a memory block.</p>
            </summary>
            <param name = "width">No documentation.</param>
            <param name = "height">No documentation.</param>
            <param name = "ixelFormatRef">No documentation.</param>
            <param name = "stride">No documentation.</param>
            <param name = "bufferSize">No documentation.</param>
            <param name = "bufferRef">No documentation.</param>
            <param name = "bitmapOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The size of the <see cref = "T:SharpDX.WIC.Bitmap"/> to be created must be smaller than or equal to the size of the image in <em>pbBuffer</em>.</p><p>The stride of the destination bitmap will equal the <em>stride</em> of the source data, regardless of the width and height specified.</p><p>The <em>pixelFormat</em> parameter defines the pixel format for both the input data and the output bitmap.</p>
            </remarks>
            <doc-id>ee690291</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromMemory([In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] const GUID&amp; pixelFormat,[In] unsigned int cbStride,[In] unsigned int cbBufferSize,[In] unsigned char* pbBuffer,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapFromHBITMAP(System.IntPtr,System.IntPtr,SharpDX.WIC.BitmapAlphaChannelOption,SharpDX.WIC.Bitmap)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> from a bitmap handle.</p>
            </summary>
            <param name = "hBitmap">No documentation.</param>
            <param name = "hPalette">No documentation.</param>
            <param name = "options">No documentation.</param>
            <param name = "bitmapOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For a non-palletized bitmap, set <c>null</c> for the <em>hPalette</em> parameter.</p>
            </remarks>
            <doc-id>ee690287</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromHBITMAP([In] HBITMAP hBitmap,[In, Optional] HPALETTE hPalette,[In] WICBitmapAlphaChannelOption options,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromHBITMAP</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateBitmapFromHICON(System.IntPtr,SharpDX.WIC.Bitmap)">
            <summary>
            <p>Creates an <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong> from an icon handle.</p>
            </summary>
            <param name = "hIcon">No documentation.</param>
            <param name = "bitmapOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690289</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateBitmapFromHICON([In] HICON hIcon,[Out, Fast] IWICBitmap** ppIBitmap)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateBitmapFromHICON</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateComponentEnumerator(System.Int32,System.Int32,SharpDX.ComObject)">
            <summary>
            <p>Creates an <see cref = "T:SharpDX.ComObject"/> object of the specified component types.</p>
            </summary>
            <param name = "componentTypes">No documentation.</param>
            <param name = "options">No documentation.</param>
            <param name = "enumUnknownOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Component types must be enumerated seperately. Combinations of component types and <strong>WICAllComponents</strong> are unsupported.</p>
            </remarks>
            <doc-id>ee690301</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateComponentEnumerator([In] DWORD componentTypes,[In] DWORD options,[Out, Fast] IEnumUnknown** ppIEnumUnknown)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateComponentEnumerator</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateFastMetadataEncoderFromDecoder(SharpDX.WIC.BitmapDecoder,SharpDX.WIC.FastMetadataEncoder)">
            <summary>
            <p>Creates a new instance of the fast metadata encoder based on the given <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong>.</p>
            </summary>
            <param name = "decoderRef">No documentation.</param>
            <param name = "fastEncoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The Windows provided codecs do not support fast metadata encoding at the decoder level, and only support fast metadata encoding at the frame level. To create a fast metadata encoder from a frame, see <strong>CreateFastMetadataEncoderFromFrameDecode</strong>.</p>
            </remarks>
            <doc-id>ee690313</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateFastMetadataEncoderFromDecoder([In, Optional] IWICBitmapDecoder* pIDecoder,[Out, Fast] IWICFastMetadataEncoder** ppIFastEncoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateFastMetadataEncoderFromDecoder</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateFastMetadataEncoderFromFrameDecode(SharpDX.WIC.BitmapFrameDecode,SharpDX.WIC.FastMetadataEncoder)">
            <summary>
            <p>Creates a new instance of the fast metadata encoder based on the given image frame.</p>
            </summary>
            <param name = "frameDecoderRef"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapFrameDecode"/></strong> to create the <strong><see cref = "T:SharpDX.WIC.FastMetadataEncoder"/></strong> from.</p> </dd></param>
            <param name = "fastEncoderOut"><dd>  <p>When this method returns, contains a reference to a new fast metadata encoder.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For a list of support metadata formats for fast metadata encoding, see WIC Metadata Overview.</p>
            </remarks>
            <doc-id>ee690315</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode([In, Optional] IWICBitmapFrameDecode* pIFrameDecoder,[Out, Fast] IWICFastMetadataEncoder** ppIFastEncoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateFastMetadataEncoderFromFrameDecode</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateQueryWriter(System.Guid,System.Nullable{System.Guid},SharpDX.WIC.MetadataQueryWriter)">
            <summary>
            <p>Proxy function for the <strong>CreateQueryWriter</strong> method.</p>
            </summary>
            <param name = "guidMetadataFormat">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "queryWriterOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690324</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriter([In] const GUID&amp; guidMetadataFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateQueryWriter</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory.CreateQueryWriterFromReader(SharpDX.WIC.MetadataQueryReader,System.Nullable{System.Guid},SharpDX.WIC.MetadataQueryWriter)">
            <summary>
            <p>Proxy function for the <strong>CreateQueryWriterFromReader</strong> method.</p>
            </summary>
            <param name = "queryReaderRef">No documentation.</param>
            <param name = "guidVendorRef">No documentation.</param>
            <param name = "queryWriterOut">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690323</doc-id>
            <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriterFromReader([In, Optional] IWICMetadataQueryReader* pIQueryReader,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>
            <unmanaged-short>IWICImagingFactory::CreateQueryWriterFromReader</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.ImagingFactory2"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.ImagingFactory2.CreateImageEncoder(SharpDX.Direct2D1.Device,SharpDX.WIC.ImageEncoder)">
            <summary>
            <p>Creates a new image encoder object.</p>
            </summary>
            <param name = "d2DDeviceRef"><dd> <p>The <strong><see cref = "T:SharpDX.Direct2D1.Device"/></strong> object on which the corresponding image encoder is created.</p> </dd></param>
            <param name = "wICImageEncoderOut"><dd> <p>A reference to a variable that receives a reference to the <strong><see cref = "T:SharpDX.WIC.ImageEncoder"/></strong> interface for the encoder object that you can use to encode Direct2D images.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You must create images to pass to the image encoder  on the same Direct2D device that you pass to this method. </p><p>You are responsible for setting up the bitmap encoder itself through the existing <strong><see cref = "T:SharpDX.WIC.BitmapEncoder"/></strong> APIs. The <strong><see cref = "T:SharpDX.WIC.BitmapEncoder"/></strong> or the <see cref = "T:SharpDX.WIC.BitmapFrameEncode"/> object is passed to each of the <strong><see cref = "T:SharpDX.WIC.ImageEncoder"/></strong> methods: <strong>WriteThumbnail</strong>, <strong>WriteFrame</strong>, and <strong>WriteFrameThumbnail</strong>. 
            </p>
            </remarks>
            <doc-id>hh880849</doc-id>
            <unmanaged>HRESULT IWICImagingFactory2::CreateImageEncoder([In] ID2D1Device* pD2DDevice,[Out, Fast] IWICImageEncoder** ppWICImageEncoder)</unmanaged>
            <unmanaged-short>IWICImagingFactory2::CreateImageEncoder</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegBitmapDecoder">
            <summary>
            Tiff bitmap encoder using <see cref="T:SharpDX.WIC.BitmapDecoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Jpeg"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapDecoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapDecoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="T:SharpDX.WIC.JpegBitmapEncoder">
            <summary>
            Tiff bitmap encoder using <see cref="T:SharpDX.WIC.BitmapEncoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Jpeg"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapEncoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapEncoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.JpegBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.JpegBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="P:SharpDX.WIC.MetadataQueryReader.Enumerator">
            <summary>
            Gets the enumerator on the metadata names.
            </summary>
        </member>
        <member name="P:SharpDX.WIC.MetadataQueryReader.QueryPaths">
            <summary>
            Gets the enumerator on all the metadata query paths.
            http://msdn.microsoft.com/en-us/library/windows/desktop/ee719796(v=vs.85).aspx#expressionanatomy
            </summary>
        </member>
        <member name="P:SharpDX.WIC.MetadataQueryReader.Location">
            <summary>
            Gets the location.
            </summary>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetLocation([In] unsigned int cchMaxLength,[InOut, Buffer, Optional] wchar_t* wzNamespace,[Out] unsigned int* pcchActualLength)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.TryGetMetadataByName(System.String,System.Object@)">
            <summary>
            Try to get the metadata value by name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The metadata value, or null if the metadata was not found or an error occurred</param>
            <returns>The WIC error code</returns>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetMetadataByName([In] const wchar_t* wzName,[InOut, Optional] PROPVARIANT* pvarValue)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.TryGetMetadataByName(System.String)">
            <summary>
            Try to get the metadata value by name.
            </summary>
            <param name="name">The name.</param>
            <returns>the metadata value, or null if the metadata was not found</returns>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetMetadataByName([In] const wchar_t* wzName,[InOut, Optional] PROPVARIANT* pvarValue)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.GetMetadataByName(System.String)">
            <summary>
            Gets the metadata value by name.
            </summary>
            <param name="name">The name.</param>
            <returns>Value of the metadata</returns>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetMetadataByName([In] const wchar_t* wzName,[InOut, Optional] PROPVARIANT* pvarValue)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.Dump(System.IO.TextWriter,System.Int32)">
            <summary>
            Dumps all metadata.
            </summary>
            <param name="writer">The text writer output.</param>
            <param name="level">The level of tabulations.</param>
            <remarks>
            This is a simple helper method to dump metadata stored in this instance.
            </remarks>
        </member>
        <member name="P:SharpDX.WIC.MetadataQueryReader.ContainerFormat">
            <summary>
            <p>Gets the metadata query readers container format.</p>
            </summary>
            <doc-id>ee719709</doc-id>
            <unmanaged>GetContainerFormat</unmanaged>
            <unmanaged-short>GetContainerFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.GetContainerFormat(System.Guid@)">
            <summary>
            <p>Gets the metadata query readers container format.</p>
            </summary>
            <param name = "guidContainerFormatRef"><dd>  <p>Pointer that receives the cointainer format <see cref = "T:System.Guid"/>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719709</doc-id>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetContainerFormat([Out] GUID* pguidContainerFormat)</unmanaged>
            <unmanaged-short>IWICMetadataQueryReader::GetContainerFormat</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.GetLocation(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Retrieves the current path relative to the root metadata block.</p>
            </summary>
            <param name = "cchMaxLength"><dd>  <p>The length of the <em>wzNamespace</em> buffer.</p> </dd></param>
            <param name = "@namespace"><dd>  <p>Pointer that receives the current namespace location.</p> </dd></param>
            <param name = "cchActualLengthRef"><dd>  <p>The actual buffer length that was needed to retrieve the current namespace location.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you pass <strong><c>null</c></strong> to <em>wzNamespace</em>, <strong>GetLocation</strong> ignores <em>cchMaxLength</em> and returns the required buffer length to store the path in the variable that <em>pcchActualLength</em> points to.
            </p><p>If the query reader is relative to the top of the metadata hierarchy, it will return a single-char string.</p><p>If the query reader is relative to a nested metadata block, this method will return the path to the current query reader.</p>
            </remarks>
            <doc-id>ee719713</doc-id>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetLocation([In] unsigned int cchMaxLength,[In] wchar_t* wzNamespace,[Out] unsigned int* pcchActualLength)</unmanaged>
            <unmanaged-short>IWICMetadataQueryReader::GetLocation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.GetMetadataByName(System.String,System.IntPtr)">
            <summary>
            <p>Retrieves the metadata block or item identified by a metadata query expression. </p>
            </summary>
            <param name = "name"><dd>  <p>The query expression to the requested metadata block or item.</p> </dd></param>
            <param name = "varValueRef"><dd>  <p>When this method returns, contains the metadata block or item requested.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>GetMetadataByName</strong> uses metadata query expressions to access embedded metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p>If multiple blocks or items exist that are expressed by the same query expression, the first metadata block or item found will be returned.</p>
            </remarks>
            <doc-id>ee719715</doc-id>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetMetadataByName([In] const wchar_t* wzName,[In] PROPVARIANT* pvarValue)</unmanaged>
            <unmanaged-short>IWICMetadataQueryReader::GetMetadataByName</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryReader.GetEnumerator">
            <summary>
            <p>Gets an enumerator of all metadata items at the current relative location within the metadata hierarchy.</p>
            </summary>
            <returns><dd>  <p>A reference to a variable that receives a reference to the <strong><see cref = "T:SharpDX.ComObject"/></strong> interface for the enumerator that contains query strings that can be used in the current <strong><see cref = "T:SharpDX.WIC.MetadataQueryReader"/></strong>.</p> </dd></returns>
            <remarks>
            <p>The retrieved enumerator only contains query strings for the metadata blocks and items in the current level of the hierarchy.
            </p>
            </remarks>
            <doc-id>ee719711</doc-id>
            <unmanaged>HRESULT IWICMetadataQueryReader::GetEnumerator([Out] IEnumString** ppIEnumString)</unmanaged>
            <unmanaged-short>IWICMetadataQueryReader::GetEnumerator</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.MetadataQueryWriter"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidMetadataFormat">The GUID metadata format.</param>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.MetadataQueryWriter"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidMetadataFormat">The GUID metadata format.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <unmanaged>HRESULT IWICImagingFactory::CreateQueryWriter([In] const GUID&amp; guidMetadataFormat,[In, Optional] const GUID* pguidVendor,[Out, Fast] IWICMetadataQueryWriter** ppIQueryWriter)</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.MetadataQueryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.MetadataQueryWriter"/> class from a <see cref="T:SharpDX.WIC.MetadataQueryReader"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="metadataQueryReader">The metadata query reader.</param>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.MetadataQueryReader,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.MetadataQueryWriter"/> class from a <see cref="T:SharpDX.WIC.MetadataQueryReader"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="metadataQueryReader">The metadata query reader.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.SetMetadataByName(System.String,System.Object)">
            <summary>
            Sets the value for a metadata name
            </summary>
            <param name="name">The name of the metadata.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.SetMetadataByName(System.String,System.IntPtr)">
            <summary>
            <p>Sets a metadata item to a specific location.</p>
            </summary>
            <param name = "name"><dd>  <p>The name of the metadata item.</p> </dd></param>
            <param name = "varValueRef"><dd>  <p>The metadata to set.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>SetMetadataByName</strong> uses metadata query expressions to remove metadata. For more information on the metadata query language, see the Metadata Query Language Overview.</p><p> If the value set is a nested metadata block then use variant type <code>VT_UNKNOWN</code> and <em>pvarValue</em> pointing to the <strong><see cref = "T:SharpDX.WIC.MetadataQueryWriter"/></strong> of the new metadata block.   The ordering of metadata items is at the discretion of the query writer since relative locations are not specified. </p>
            </remarks>
            <doc-id>ee719720</doc-id>
            <unmanaged>HRESULT IWICMetadataQueryWriter::SetMetadataByName([In] const wchar_t* wzName,[In] const PROPVARIANT* pvarValue)</unmanaged>
            <unmanaged-short>IWICMetadataQueryWriter::SetMetadataByName</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.MetadataQueryWriter.RemoveMetadataByName(System.String)">
            <summary>
            <p>Proxy function for the <strong>RemoveMetadataByName</strong> method.</p>
            </summary>
            <param name = "name">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719719</doc-id>
            <unmanaged>HRESULT IWICMetadataQueryWriter::RemoveMetadataByName([In] const wchar_t* wzName)</unmanaged>
            <unmanaged-short>IWICMetadataQueryWriter::RemoveMetadataByName</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.NamespaceDoc">
            <summary>
            The <see cref="N:SharpDX.WIC"/> namespace provides a managed WIC API.
            </summary>
            <msdn-id>ee719902</msdn-id>
            <unmanaged>WIC</unmanaged>	
            <unmanaged-short>WIC</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Palette.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.Palette"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <msdn-id>ee690319</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreatePalette([Out, Fast] IWICPalette** ppIPalette)</unmanaged>	
            <unmanaged-short>IWICImagingFactory::CreatePalette</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.Palette.Initialize``1(``0[])">
            <summary>
            Initializes with the specified colors.
            </summary>
            <typeparam name="T">Type of the color (must be 4 bytes, RGBA)</typeparam>
            <param name="colors">The colors.</param>
            <exception cref="T:System.ArgumentException">Color type must be 4 bytes</exception>
            <msdn-id>ee719750</msdn-id>
              <unmanaged>HRESULT IWICPalette::InitializeCustom([In, Buffer] void* pColors,[In] unsigned int cCount)</unmanaged>
              <unmanaged-short>IWICPalette::InitializeCustom</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.GetColors``1">
            <summary>
            Gets the colors.
            </summary>
            <msdn-id>ee719744</msdn-id>	
            <unmanaged>HRESULT IWICPalette::GetColors([In] unsigned int cCount,[Out, Buffer] void* pColors,[Out] unsigned int* pcActualColors)</unmanaged>	
            <unmanaged-short>IWICPalette::GetColors</unmanaged-short>	
        </member>
        <member name="P:SharpDX.WIC.Palette.TypeInfo">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.WIC.BitmapPaletteType"/></strong> that describes the palette. </p>
            </summary>
            <remarks>
            <p><strong>WICBitmapPaletteCustom</strong> is used for palettes initialized from both <strong>InitializeCustom</strong> and <strong>InitializeFromBitmap</strong>. There is no distinction is made between optimized and custom palettes.</p>
            </remarks>
            <doc-id>ee719746</doc-id>
            <unmanaged>GetType</unmanaged>
            <unmanaged-short>GetType</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.Palette.ColorCount">
            <summary>
            <p>Proxy function for the <strong>GetColorCount</strong> method.</p>
            </summary>
            <doc-id>ee719743</doc-id>
            <unmanaged>GetColorCount</unmanaged>
            <unmanaged-short>GetColorCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.Palette.IsBlackWhite">
            <summary>
            <p>Retrieves a value that describes whether the palette is black and white.</p>
            </summary>
            <remarks>
            <p>A palette is considered to be black and white only if it contains exactly two entries, one full black (0xFF000000) and one full white (0xFFFFFFF).
            </p>
            </remarks>
            <doc-id>ee719758</doc-id>
            <unmanaged>IsBlackWhite</unmanaged>
            <unmanaged-short>IsBlackWhite</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.Palette.IsGrayscale">
            <summary>
            <p>Retrieves a value that describes whether a palette is grayscale.</p>
            </summary>
            <remarks>
            <p>A palette is considered grayscale only if, for every entry, the alpha value is 0xFF and the red, green and blue values match.
            </p>
            </remarks>
            <doc-id>ee719759</doc-id>
            <unmanaged>IsGrayscale</unmanaged>
            <unmanaged-short>IsGrayscale</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.Initialize(SharpDX.WIC.BitmapPaletteType,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Initializes the palette to one of the pre-defined palettes specified by <strong><see cref = "T:SharpDX.WIC.BitmapPaletteType"/></strong> and optionally adds a transparent color.</p>
            </summary>
            <param name = "ePaletteType">No documentation.</param>
            <param name = "fAddTransparentColor">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If a transparent color is added to a palette, the palette is no longer predefined and is returned as <strong>WICBitmapPaletteTypeCustom</strong>. For palettes with less than 256 entries, the transparent entry is added to the end of the palette (that is, a 16-color palette becomes a 17-color palette). For palettes with 256 colors, the transparent palette entry will replace the last entry in the pre-defined palette.
            </p>
            </remarks>
            <doc-id>ee719756</doc-id>
            <unmanaged>HRESULT IWICPalette::InitializePredefined([In] WICBitmapPaletteType ePaletteType,[In] BOOL fAddTransparentColor)</unmanaged>
            <unmanaged-short>IWICPalette::InitializePredefined</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.Initialize(System.IntPtr,System.Int32)">
            <summary>
            <p>Proxy function for the <strong>InitializeCustom</strong> method.</p>
            </summary>
            <param name = "colorsRef">No documentation.</param>
            <param name = "count">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719751</doc-id>
            <unmanaged>HRESULT IWICPalette::InitializeCustom([In, Buffer] unsigned int* pColors,[In] unsigned int cCount)</unmanaged>
            <unmanaged-short>IWICPalette::InitializeCustom</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.Initialize(SharpDX.WIC.BitmapSource,System.Int32,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Initializes a palette using a computed optimized values based on the reference bitmap.</p>
            </summary>
            <param name = "surfaceRef"><dd>  <p>Pointer to the source bitmap.</p> </dd></param>
            <param name = "count"><dd>  <p>The number of colors to initialize the palette with.</p> </dd></param>
            <param name = "fAddTransparentColor"><dd>  <p>A value to indicate whether to add a transparent color.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The resulting palette contains the specified number of colors which best represent the colors present in the bitmap. The algorithm operates on the opaque RGB color value of each pixel in the reference bitmap and hence ignores any alpha values. If a transparent color is required, set the fAddTransparentColor parameter to <strong>TRUE</strong> and one fewer optimized color will be computed, reducing the <em>colorCount</em>, and a fully transparent color entry will be added. </p>
            </remarks>
            <doc-id>ee719752</doc-id>
            <unmanaged>HRESULT IWICPalette::InitializeFromBitmap([In, Optional] IWICBitmapSource* pISurface,[In] unsigned int cCount,[In] BOOL fAddTransparentColor)</unmanaged>
            <unmanaged-short>IWICPalette::InitializeFromBitmap</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.Initialize(SharpDX.WIC.Palette)">
            <summary>
            <p>Initialize the palette based on a given palette.</p>
            </summary>
            <param name = "paletteRef"><dd>  <p>Pointer to the source palette.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719754</doc-id>
            <unmanaged>HRESULT IWICPalette::InitializeFromPalette([In, Optional] IWICPalette* pIPalette)</unmanaged>
            <unmanaged-short>IWICPalette::InitializeFromPalette</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.GetTypeInfo(SharpDX.WIC.BitmapPaletteType@)">
            <summary>
            <p>Retrieves the <strong><see cref = "T:SharpDX.WIC.BitmapPaletteType"/></strong> that describes the palette. </p>
            </summary>
            <param name = "ePaletteTypeRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>WICBitmapPaletteCustom</strong> is used for palettes initialized from both <strong>InitializeCustom</strong> and <strong>InitializeFromBitmap</strong>. There is no distinction is made between optimized and custom palettes.</p>
            </remarks>
            <doc-id>ee719746</doc-id>
            <unmanaged>HRESULT IWICPalette::GetType([Out] WICBitmapPaletteType* pePaletteType)</unmanaged>
            <unmanaged-short>IWICPalette::GetType</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.GetColorCount(System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetColorCount</strong> method.</p>
            </summary>
            <param name = "countRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719743</doc-id>
            <unmanaged>HRESULT IWICPalette::GetColorCount([Out] unsigned int* pcCount)</unmanaged>
            <unmanaged-short>IWICPalette::GetColorCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.GetColors(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            <p>Fills out the supplied color array with the colors from the internal color table. The color array should be sized according to the return results from <strong>GetColorCount</strong>.</p>
            </summary>
            <param name = "count">No documentation.</param>
            <param name = "colorsRef">No documentation.</param>
            <param name = "actualColorsRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719744</doc-id>
            <unmanaged>HRESULT IWICPalette::GetColors([In] unsigned int cCount,[Out, Buffer] unsigned int* pColors,[Out] unsigned int* pcActualColors)</unmanaged>
            <unmanaged-short>IWICPalette::GetColors</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.IsBlackWhite_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves a value that describes whether the palette is black and white.</p>
            </summary>
            <param name = "fIsBlackWhiteRef"><dd>  <p>A reference to a variable  that receives a boolean value that indicates whether the palette is black and white. <strong>TRUE</strong> indicates that the palette is black and white; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>A palette is considered to be black and white only if it contains exactly two entries, one full black (0xFF000000) and one full white (0xFFFFFFF).
            </p>
            </remarks>
            <doc-id>ee719758</doc-id>
            <unmanaged>HRESULT IWICPalette::IsBlackWhite([Out] BOOL* pfIsBlackWhite)</unmanaged>
            <unmanaged-short>IWICPalette::IsBlackWhite</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.IsGrayscale_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves a value that describes whether a palette is grayscale.</p>
            </summary>
            <param name = "fIsGrayscaleRef"><dd>  <p>A reference to a variable that receives a boolean value that indicates whether the palette is grayscale. <strong>TRUE</strong> indicates that the palette is grayscale; otherwise <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>A palette is considered grayscale only if, for every entry, the alpha value is 0xFF and the red, green and blue values match.
            </p>
            </remarks>
            <doc-id>ee719759</doc-id>
            <unmanaged>HRESULT IWICPalette::IsGrayscale([Out] BOOL* pfIsGrayscale)</unmanaged>
            <unmanaged-short>IWICPalette::IsGrayscale</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.Palette.HasAlpha(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Proxy function for the <strong>HasAlpha</strong> method.</p>
            </summary>
            <param name = "fHasAlphaRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719749</doc-id>
            <unmanaged>HRESULT IWICPalette::HasAlpha([Out] BOOL* pfHasAlpha)</unmanaged>
            <unmanaged-short>IWICPalette::HasAlpha</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PixelFormat">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:SharpDX.WIC.PixelFormat.GetBitsPerPixel(System.Guid)">
            <summary>
            Gets the number of bits per pixel for a particular pixel format.
            </summary>
            <param name="guid">The pixel format guid.</param>
            <returns>The number of bits per pixel. If the pixel format guid is invalid, returns 0</returns>
        </member>
        <member name="M:SharpDX.WIC.PixelFormat.GetStride(System.Guid,System.Int32)">
            <summary>
            Gets the stride in bytes from a pixel format and a width..
            </summary>
            <param name="guid">The pixel format guid.</param>
            <param name="width">The width.</param>
            <returns>The number of bytes per row.</returns>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.FormatDontCare">
            <summary>Constant FormatDontCare</summary>
            <unmanaged>GUID_WICPixelFormatDontCare</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format1bppIndexed">
            <summary>Constant Format1bppIndexed</summary>
            <unmanaged>GUID_WICPixelFormat1bppIndexed</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format2bppIndexed">
            <summary>Constant Format2bppIndexed</summary>
            <unmanaged>GUID_WICPixelFormat2bppIndexed</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format4bppIndexed">
            <summary>Constant Format4bppIndexed</summary>
            <unmanaged>GUID_WICPixelFormat4bppIndexed</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format8bppIndexed">
            <summary>Constant Format8bppIndexed</summary>
            <unmanaged>GUID_WICPixelFormat8bppIndexed</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.FormatBlackWhite">
            <summary>Constant FormatBlackWhite</summary>
            <unmanaged>GUID_WICPixelFormatBlackWhite</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format2bppGray">
            <summary>Constant Format2bppGray</summary>
            <unmanaged>GUID_WICPixelFormat2bppGray</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format4bppGray">
            <summary>Constant Format4bppGray</summary>
            <unmanaged>GUID_WICPixelFormat4bppGray</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format8bppGray">
            <summary>Constant Format8bppGray</summary>
            <unmanaged>GUID_WICPixelFormat8bppGray</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format8bppAlpha">
            <summary>Constant Format8bppAlpha</summary>
            <unmanaged>GUID_WICPixelFormat8bppAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppBGR555">
            <summary>Constant Format16bppBGR555</summary>
            <unmanaged>GUID_WICPixelFormat16bppBGR555</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppBGR565">
            <summary>Constant Format16bppBGR565</summary>
            <unmanaged>GUID_WICPixelFormat16bppBGR565</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppBGRA5551">
            <summary>Constant Format16bppBGRA5551</summary>
            <unmanaged>GUID_WICPixelFormat16bppBGRA5551</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppGray">
            <summary>Constant Format16bppGray</summary>
            <unmanaged>GUID_WICPixelFormat16bppGray</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format24bppBGR">
            <summary>Constant Format24bppBGR</summary>
            <unmanaged>GUID_WICPixelFormat24bppBGR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format24bppRGB">
            <summary>Constant Format24bppRGB</summary>
            <unmanaged>GUID_WICPixelFormat24bppRGB</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppBGR">
            <summary>Constant Format32bppBGR</summary>
            <unmanaged>GUID_WICPixelFormat32bppBGR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppBGRA">
            <summary>Constant Format32bppBGRA</summary>
            <unmanaged>GUID_WICPixelFormat32bppBGRA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppPBGRA">
            <summary>Constant Format32bppPBGRA</summary>
            <unmanaged>GUID_WICPixelFormat32bppPBGRA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppGrayFloat">
            <summary>Constant Format32bppGrayFloat</summary>
            <unmanaged>GUID_WICPixelFormat32bppGrayFloat</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppRGB">
            <summary>Constant Format32bppRGB</summary>
            <unmanaged>GUID_WICPixelFormat32bppRGB</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppRGBA">
            <summary>Constant Format32bppRGBA</summary>
            <unmanaged>GUID_WICPixelFormat32bppRGBA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppPRGBA">
            <summary>Constant Format32bppPRGBA</summary>
            <unmanaged>GUID_WICPixelFormat32bppPRGBA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bppRGB">
            <summary>Constant Format48bppRGB</summary>
            <unmanaged>GUID_WICPixelFormat48bppRGB</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bppBGR">
            <summary>Constant Format48bppBGR</summary>
            <unmanaged>GUID_WICPixelFormat48bppBGR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppRGB">
            <summary>Constant Format64bppRGB</summary>
            <unmanaged>GUID_WICPixelFormat64bppRGB</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppRGBA">
            <summary>Constant Format64bppRGBA</summary>
            <unmanaged>GUID_WICPixelFormat64bppRGBA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppBGRA">
            <summary>Constant Format64bppBGRA</summary>
            <unmanaged>GUID_WICPixelFormat64bppBGRA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppPRGBA">
            <summary>Constant Format64bppPRGBA</summary>
            <unmanaged>GUID_WICPixelFormat64bppPRGBA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppPBGRA">
            <summary>Constant Format64bppPBGRA</summary>
            <unmanaged>GUID_WICPixelFormat64bppPBGRA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppGrayFixedPoint">
            <summary>Constant Format16bppGrayFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat16bppGrayFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppBGR101010">
            <summary>Constant Format32bppBGR101010</summary>
            <unmanaged>GUID_WICPixelFormat32bppBGR101010</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bppRGBFixedPoint">
            <summary>Constant Format48bppRGBFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat48bppRGBFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bppBGRFixedPoint">
            <summary>Constant Format48bppBGRFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat48bppBGRFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format96bppRGBFixedPoint">
            <summary>Constant Format96bppRGBFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat96bppRGBFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format96bppRGBFloat">
            <summary>Constant Format96bppRGBFloat</summary>
            <unmanaged>GUID_WICPixelFormat96bppRGBFloat</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bppRGBAFloat">
            <summary>Constant Format128bppRGBAFloat</summary>
            <unmanaged>GUID_WICPixelFormat128bppRGBAFloat</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bppPRGBAFloat">
            <summary>Constant Format128bppPRGBAFloat</summary>
            <unmanaged>GUID_WICPixelFormat128bppPRGBAFloat</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bppRGBFloat">
            <summary>Constant Format128bppRGBFloat</summary>
            <unmanaged>GUID_WICPixelFormat128bppRGBFloat</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppCMYK">
            <summary>Constant Format32bppCMYK</summary>
            <unmanaged>GUID_WICPixelFormat32bppCMYK</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppRGBAFixedPoint">
            <summary>Constant Format64bppRGBAFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat64bppRGBAFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppBGRAFixedPoint">
            <summary>Constant Format64bppBGRAFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat64bppBGRAFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppRGBFixedPoint">
            <summary>Constant Format64bppRGBFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat64bppRGBFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bppRGBAFixedPoint">
            <summary>Constant Format128bppRGBAFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat128bppRGBAFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bppRGBFixedPoint">
            <summary>Constant Format128bppRGBFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat128bppRGBFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppRGBAHalf">
            <summary>Constant Format64bppRGBAHalf</summary>
            <unmanaged>GUID_WICPixelFormat64bppRGBAHalf</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppPRGBAHalf">
            <summary>Constant Format64bppPRGBAHalf</summary>
            <unmanaged>GUID_WICPixelFormat64bppPRGBAHalf</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppRGBHalf">
            <summary>Constant Format64bppRGBHalf</summary>
            <unmanaged>GUID_WICPixelFormat64bppRGBHalf</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bppRGBHalf">
            <summary>Constant Format48bppRGBHalf</summary>
            <unmanaged>GUID_WICPixelFormat48bppRGBHalf</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppRGBE">
            <summary>Constant Format32bppRGBE</summary>
            <unmanaged>GUID_WICPixelFormat32bppRGBE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppGrayHalf">
            <summary>Constant Format16bppGrayHalf</summary>
            <unmanaged>GUID_WICPixelFormat16bppGrayHalf</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppGrayFixedPoint">
            <summary>Constant Format32bppGrayFixedPoint</summary>
            <unmanaged>GUID_WICPixelFormat32bppGrayFixedPoint</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppRGBA1010102">
            <summary>Constant Format32bppRGBA1010102</summary>
            <unmanaged>GUID_WICPixelFormat32bppRGBA1010102</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bppRGBA1010102XR">
            <summary>Constant Format32bppRGBA1010102XR</summary>
            <unmanaged>GUID_WICPixelFormat32bppRGBA1010102XR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bppCMYK">
            <summary>Constant Format64bppCMYK</summary>
            <unmanaged>GUID_WICPixelFormat64bppCMYK</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format24bpp3Channels">
            <summary>Constant Format24bpp3Channels</summary>
            <unmanaged>GUID_WICPixelFormat24bpp3Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bpp4Channels">
            <summary>Constant Format32bpp4Channels</summary>
            <unmanaged>GUID_WICPixelFormat32bpp4Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format40bpp5Channels">
            <summary>Constant Format40bpp5Channels</summary>
            <unmanaged>GUID_WICPixelFormat40bpp5Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bpp6Channels">
            <summary>Constant Format48bpp6Channels</summary>
            <unmanaged>GUID_WICPixelFormat48bpp6Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format56bpp7Channels">
            <summary>Constant Format56bpp7Channels</summary>
            <unmanaged>GUID_WICPixelFormat56bpp7Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bpp8Channels">
            <summary>Constant Format64bpp8Channels</summary>
            <unmanaged>GUID_WICPixelFormat64bpp8Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bpp3Channels">
            <summary>Constant Format48bpp3Channels</summary>
            <unmanaged>GUID_WICPixelFormat48bpp3Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bpp4Channels">
            <summary>Constant Format64bpp4Channels</summary>
            <unmanaged>GUID_WICPixelFormat64bpp4Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format80bpp5Channels">
            <summary>Constant Format80bpp5Channels</summary>
            <unmanaged>GUID_WICPixelFormat80bpp5Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format96bpp6Channels">
            <summary>Constant Format96bpp6Channels</summary>
            <unmanaged>GUID_WICPixelFormat96bpp6Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format112bpp7Channels">
            <summary>Constant Format112bpp7Channels</summary>
            <unmanaged>GUID_WICPixelFormat112bpp7Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bpp8Channels">
            <summary>Constant Format128bpp8Channels</summary>
            <unmanaged>GUID_WICPixelFormat128bpp8Channels</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format40bppCMYKAlpha">
            <summary>Constant Format40bppCMYKAlpha</summary>
            <unmanaged>GUID_WICPixelFormat40bppCMYKAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format80bppCMYKAlpha">
            <summary>Constant Format80bppCMYKAlpha</summary>
            <unmanaged>GUID_WICPixelFormat80bppCMYKAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format32bpp3ChannelsAlpha">
            <summary>Constant Format32bpp3ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat32bpp3ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format40bpp4ChannelsAlpha">
            <summary>Constant Format40bpp4ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat40bpp4ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format48bpp5ChannelsAlpha">
            <summary>Constant Format48bpp5ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat48bpp5ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format56bpp6ChannelsAlpha">
            <summary>Constant Format56bpp6ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat56bpp6ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bpp7ChannelsAlpha">
            <summary>Constant Format64bpp7ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat64bpp7ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format72bpp8ChannelsAlpha">
            <summary>Constant Format72bpp8ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat72bpp8ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format64bpp3ChannelsAlpha">
            <summary>Constant Format64bpp3ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat64bpp3ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format80bpp4ChannelsAlpha">
            <summary>Constant Format80bpp4ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat80bpp4ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format96bpp5ChannelsAlpha">
            <summary>Constant Format96bpp5ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat96bpp5ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format112bpp6ChannelsAlpha">
            <summary>Constant Format112bpp6ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat112bpp6ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format128bpp7ChannelsAlpha">
            <summary>Constant Format128bpp7ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat128bpp7ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format144bpp8ChannelsAlpha">
            <summary>Constant Format144bpp8ChannelsAlpha</summary>
            <unmanaged>GUID_WICPixelFormat144bpp8ChannelsAlpha</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format8bppY">
            <summary>Constant Format8bppY</summary>
            <unmanaged>GUID_WICPixelFormat8bppY</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format8bppCb">
            <summary>Constant Format8bppCb</summary>
            <unmanaged>GUID_WICPixelFormat8bppCb</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format8bppCr">
            <summary>Constant Format8bppCr</summary>
            <unmanaged>GUID_WICPixelFormat8bppCr</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppCbCr">
            <summary>Constant Format16bppCbCr</summary>
            <unmanaged>GUID_WICPixelFormat16bppCbCr</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppYQuantizedDctCoefficients">
            <summary>Constant Format16bppYQuantizedDctCoefficients</summary>
            <unmanaged>GUID_WICPixelFormat16bppYQuantizedDctCoefficients</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppCbQuantizedDctCoefficients">
            <summary>Constant Format16bppCbQuantizedDctCoefficients</summary>
            <unmanaged>GUID_WICPixelFormat16bppCbQuantizedDctCoefficients</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.PixelFormat.Format16bppCrQuantizedDctCoefficients">
            <summary>Constant Format16bppCrQuantizedDctCoefficients</summary>
            <unmanaged>GUID_WICPixelFormat16bppCrQuantizedDctCoefficients</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo.GetChannelMask(System.Int32)">
            <summary>
            Gets the channel mask.
            </summary>
            <param name="channelIndex">Index of the channel.</param>
            <returns></returns>
            <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelMask([In] unsigned int uiChannelIndex,[In] unsigned int cbMaskBuffer,[In] void* pbMaskBuffer,[Out] unsigned int* pcbActual)</unmanaged>
        </member>
        <member name="P:SharpDX.WIC.PixelFormatInfo.FormatGUID">
            <summary>
            <p>Gets the pixel format <see cref = "T:System.Guid"/>.</p>
            </summary>
            <doc-id>ee719774</doc-id>
            <unmanaged>GetFormatGUID</unmanaged>
            <unmanaged-short>GetFormatGUID</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.PixelFormatInfo.ColorContext">
            <summary>
            <p>Gets the pixel format's <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong>.</p>
            </summary>
            <remarks>
            <p>The returned color context is the default color space for the pixel format. However, if an <see cref = "T:SharpDX.WIC.BitmapSource"/> specifies its own color context, the source's context should be preferred over the pixel format's default.
            </p>
            </remarks>
            <doc-id>ee719773</doc-id>
            <unmanaged>GetColorContext</unmanaged>
            <unmanaged-short>GetColorContext</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.PixelFormatInfo.BitsPerPixel">
            <summary>
            <p>Proxy function for the <strong>GetBitsPerPixel</strong> method.</p>
            </summary>
            <doc-id>ee719768</doc-id>
            <unmanaged>GetBitsPerPixel</unmanaged>
            <unmanaged-short>GetBitsPerPixel</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.PixelFormatInfo.ChannelCount">
            <summary>
            <p>Proxy function for the <strong>GetChannelCount</strong> method.</p>
            </summary>
            <doc-id>ee719770</doc-id>
            <unmanaged>GetChannelCount</unmanaged>
            <unmanaged-short>GetChannelCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo.GetFormatGUID(System.Guid@)">
            <summary>
            <p>Gets the pixel format <see cref = "T:System.Guid"/>.</p>
            </summary>
            <param name = "formatRef"><dd>  <p>Pointer that receives the pixel format <see cref = "T:System.Guid"/>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719774</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo::GetFormatGUID([Out] GUID* pFormat)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo::GetFormatGUID</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo.GetColorContext(SharpDX.WIC.ColorContext@)">
            <summary>
            <p>Gets the pixel format's <strong><see cref = "T:SharpDX.WIC.ColorContext"/></strong>.</p>
            </summary>
            <param name = "colorContextOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The returned color context is the default color space for the pixel format. However, if an <see cref = "T:SharpDX.WIC.BitmapSource"/> specifies its own color context, the source's context should be preferred over the pixel format's default.
            </p>
            </remarks>
            <doc-id>ee719773</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo::GetColorContext([Out] IWICColorContext** ppIColorContext)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo::GetColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo.GetBitsPerPixel(System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetBitsPerPixel</strong> method.</p>
            </summary>
            <param name = "bitsPerPixelRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719768</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo::GetBitsPerPixel([Out] unsigned int* puiBitsPerPixel)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo::GetBitsPerPixel</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo.GetChannelCount(System.Int32@)">
            <summary>
            <p>Proxy function for the <strong>GetChannelCount</strong> method.</p>
            </summary>
            <param name = "channelCountRef">No documentation.</param>
            <returns><p>If this function succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719770</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelCount([Out] unsigned int* puiChannelCount)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo::GetChannelCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo.GetChannelMask(System.Int32,System.Int32,System.Byte[],System.Int32@)">
            <summary>
            <p>Gets the pixel format's channel mask.</p>
            </summary>
            <param name = "channelIndex"><dd>  <p>The index to the channel mask to retrieve.</p> </dd></param>
            <param name = "maskBuffer"><dd>  <p>The size of the <em>pbMaskBuffer</em> buffer.</p> </dd></param>
            <param name = "maskBufferRef"><dd>  <p>Pointer to the mask buffer.</p> </dd></param>
            <param name = "actualRef"><dd>  <p>The actual buffer size needed to obtain the channel mask.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If 0 and <c>null</c> are passed in for <em>cbMaskBuffer</em> and <em>pbMaskBuffer</em>, respectively, the required buffer size will be returned through <em>pcbActual</em>.
            </p>
            </remarks>
            <doc-id>ee719771</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo::GetChannelMask([In] unsigned int uiChannelIndex,[In] unsigned int cbMaskBuffer,[Out, Buffer, Optional] unsigned char* pbMaskBuffer,[Out] unsigned int* pcbActual)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo::GetChannelMask</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngBitmapDecoder">
            <summary>
            Png bitmap encoder using <see cref="T:SharpDX.WIC.BitmapDecoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Png"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapDecoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapDecoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="T:SharpDX.WIC.PngBitmapEncoder">
            <summary>
            Png bitmap encoder using <see cref="T:SharpDX.WIC.BitmapEncoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Png"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapEncoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapEncoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.PngBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.PngBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="T:SharpDX.WIC.TiffBitmapDecoder">
            <summary>
            Tiff bitmap encoder using <see cref="T:SharpDX.WIC.BitmapDecoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Tiff"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapDecoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapDecoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="T:SharpDX.WIC.TiffBitmapEncoder">
            <summary>
            Tiff bitmap encoder using <see cref="T:SharpDX.WIC.BitmapEncoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Tiff"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapEncoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapEncoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.TiffBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.TiffBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.WICStream.#ctor(SharpDX.WIC.ImagingFactory,System.String,SharpDX.IO.NativeFileAccess)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WICStream"/> class from a file.
            </summary>
            <param name="factory">The factory.</param>
            <param name="fileName">Name of the file.</param>
            <param name="fileAccess">The file access.</param>
            <msdn-id>ee690325</msdn-id>	
            <unmanaged>HRESULT IWICImagingFactory::CreateStream([Out, Fast] IWICStream** ppIWICStream)</unmanaged>	
        </member>
        <member name="M:SharpDX.WIC.WICStream.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WICStream"/> class from a <see cref="T:SharpDX.Win32.IStream"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The stream.</param>
            <msdn-id>ee719789</msdn-id>	
            <unmanaged>HRESULT IWICStream::InitializeFromIStream([In, Optional] IStream* pIStream)</unmanaged>	
            <unmanaged-short>IWICStream::InitializeFromIStream</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.WICStream.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.DataPointer)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WICStream"/> class from an unmanaged memory through a <see cref="T:SharpDX.DataStream"/>.
            </summary>
            <param name="factory">The factory.</param>
            <param name="dataStream">The unmanaged memory stream.</param>
            <msdn-id>ee719792</msdn-id>	
            <unmanaged>HRESULT IWICStream::InitializeFromMemory([In] void* pbBuffer,[In] unsigned int cbBufferSize)</unmanaged>	
            <unmanaged-short>IWICStream::InitializeFromMemory</unmanaged-short>	
        </member>
        <member name="M:SharpDX.WIC.WICStream.InitializeFromIStream(SharpDX.Win32.IStream)">
            <summary>
            <p>Initializes a stream from another stream. Access rights are inherited from the underlying stream.</p>
            </summary>
            <param name = "streamRef"><dd>  <p>The initialize stream.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719789</doc-id>
            <unmanaged>HRESULT IWICStream::InitializeFromIStream([In, Optional] IStream* pIStream)</unmanaged>
            <unmanaged-short>IWICStream::InitializeFromIStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.WICStream.InitializeFromFilename(System.String,System.Int32)">
            <summary>
            <p>Initializes a stream from a particular file.</p>
            </summary>
            <param name = "fileName"><dd>  <p>The file used to initialize the stream.</p> </dd></param>
            <param name = "desiredAccess"><dd>  <p>The desired file access mode.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td><dl> <dt><strong>GENERIC_READ</strong></dt> </dl> </td><td> <p>Read access.</p> </td></tr> <tr><td><dl> <dt><strong>GENERIC_WRITE</strong></dt> </dl> </td><td> <p>Write access.</p> </td></tr> </table> <p>?</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> The <strong><see cref = "T:SharpDX.WIC.WICStream"/></strong> interface methods do not enable you to provide a file sharing option. To create a shared file stream for an image, use the SHCreateStreamOnFileEx function. This stream can then be used to create an <strong><see cref = "T:SharpDX.WIC.BitmapDecoder"/></strong> using the <strong>CreateDecoderFromStream</strong> method. </p>
            </remarks>
            <doc-id>ee719788</doc-id>
            <unmanaged>HRESULT IWICStream::InitializeFromFilename([In] const wchar_t* wzFileName,[In] DWORD dwDesiredAccess)</unmanaged>
            <unmanaged-short>IWICStream::InitializeFromFilename</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.WICStream.InitializeFromMemory(System.IntPtr,System.Int32)">
            <summary>
            <p>Initializes a stream to treat a block of memory as a stream. The stream cannot grow beyond the buffer size. </p>
            </summary>
            <param name = "bufferRef"><dd>  <p>Pointer to the buffer used to initialize the stream.</p> </dd></param>
            <param name = "bufferSize"><dd>  <p>The size of buffer.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method should be avoided whenever possible. The caller is responsible for ensuring the memory block is valid for the lifetime of the stream when using <strong>InitializeFromMemory</strong>.  A workaround for this behavior is to create an <strong><see cref = "T:SharpDX.Win32.IStream"/></strong> and use <strong>InitializeFromIStream</strong> to create the <strong><see cref = "T:SharpDX.WIC.WICStream"/></strong>.</p><p>If you require a growable memory stream, use <strong>CreateStreamOnHGlobal</strong>.</p>
            </remarks>
            <doc-id>ee719792</doc-id>
            <unmanaged>HRESULT IWICStream::InitializeFromMemory([In] unsigned char* pbBuffer,[In] DWORD cbBufferSize)</unmanaged>
            <unmanaged-short>IWICStream::InitializeFromMemory</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.WICStream.InitializeFromIStreamRegion(SharpDX.Win32.IStream,System.Int64,System.Int64)">
            <summary>
            <p>Initializes the stream as a substream of another stream.</p>
            </summary>
            <param name = "streamRef"><dd>  <p>Pointer to the input stream.</p> </dd></param>
            <param name = "ulOffset"><dd>  <p>The stream offset used to create the new stream.</p> </dd></param>
            <param name = "ulMaxSize"><dd>  <p>The maximum size of the stream.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The stream functions with its own stream position, independent of the underlying stream but restricted to a region.  All seek positions are relative to the sub region.  It is allowed, though not recommended, to have multiple writable sub streams overlapping the same range.</p>
            </remarks>
            <doc-id>ee719790</doc-id>
            <unmanaged>HRESULT IWICStream::InitializeFromIStreamRegion([In, Optional] IStream* pIStream,[In] ULARGE_INTEGER ulOffset,[In] ULARGE_INTEGER ulMaxSize)</unmanaged>
            <unmanaged-short>IWICStream::InitializeFromIStreamRegion</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.WmpBitmapDecoder">
            <summary>
            Wmp bitmap encoder using <see cref="T:SharpDX.WIC.BitmapDecoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Wmp"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapDecoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapDecoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapDecoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapDecoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
        </member>
        <member name="T:SharpDX.WIC.WmpBitmapEncoder">
            <summary>
            WMP bitmap encoder using <see cref="T:SharpDX.WIC.BitmapEncoder"/> initialized with default guid <see cref="F:SharpDX.WIC.ContainerFormatGuids.Wmp"/>.
            </summary>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapEncoder.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapEncoder"/> class.
            </summary>
            <param name="nativePtr">The native PTR.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="M:SharpDX.WIC.WmpBitmapEncoder.#ctor(SharpDX.WIC.ImagingFactory,System.Guid,SharpDX.WIC.WICStream)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.WIC.WmpBitmapEncoder"/> class.
            </summary>
            <param name="factory">The factory.</param>
            <param name="guidVendorRef">The GUID vendor ref.</param>
            <param name="stream">The output stream.</param>
        </member>
        <member name="T:SharpDX.WIC.BIMIptcDigestProperties">
            <summary>
            <p>Specifies the identifiers of the metadata items in an 8BIM IPTC digest metadata block.</p>
            </summary>
            <doc-id>ee719802</doc-id>
            <unmanaged>WIC8BIMIptcDigestProperties</unmanaged>
            <unmanaged-short>WIC8BIMIptcDigestProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMIptcDigestProperties.PString">
            <summary>
            <dd> <p>[VT_LPSTR] A name that identifies the 8BIM block.</p> </dd>
            </summary>
            <doc-id>ee719802</doc-id>
            <unmanaged>WIC8BIMIptcDigestPString</unmanaged>
            <unmanaged-short>WIC8BIMIptcDigestPString</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMIptcDigestProperties.IptcDigest">
            <summary>
            <dd> <p>[VT_BLOB] The embedded IPTC digest value.</p> </dd>
            </summary>
            <doc-id>ee719802</doc-id>
            <unmanaged>WIC8BIMIptcDigestIptcDigest</unmanaged>
            <unmanaged-short>WIC8BIMIptcDigestIptcDigest</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BIMIptcProperties">
            <summary>
            <p>Specifies the identifiers of the metadata items in an 8BIM IPTC block.</p>
            </summary>
            <doc-id>ee719803</doc-id>
            <unmanaged>WIC8BIMIptcProperties</unmanaged>
            <unmanaged-short>WIC8BIMIptcProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMIptcProperties.PString">
            <summary>
            <dd> <p>[VT_LPSTR] A name that identifies the 8BIM block.</p> </dd>
            </summary>
            <doc-id>ee719803</doc-id>
            <unmanaged>WIC8BIMIptcPString</unmanaged>
            <unmanaged-short>WIC8BIMIptcPString</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMIptcProperties.EmbeddedIPTC">
            <summary>
            <dd> <p>[VT_UNKNOWN] The IPTC block embedded in this 8BIM IPTC block.</p> </dd>
            </summary>
            <doc-id>ee719803</doc-id>
            <unmanaged>WIC8BIMIptcEmbeddedIPTC</unmanaged>
            <unmanaged-short>WIC8BIMIptcEmbeddedIPTC</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BIMResolutionInfoProperties">
            <summary>
            <p>Specifies the identifiers of the metadata items in an 8BIMResolutionInfo block.</p>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoProperties</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.PString">
            <summary>
            <dd> <p>[VT_LPSTR] A name that identifies the 8BIM block.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoPString</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoPString</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.HResolution">
            <summary>
            <dd> <p>[VT_UI4] The horizontal resolution of the image.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoHResolution</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoHResolution</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.HResolutionUnit">
            <summary>
            <dd> <p>[VT_UI2] The units that the horizontal resolution is specified in; a 1 indicates pixels per inch and a 2 indicates pixels per centimeter.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoHResolutionUnit</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoHResolutionUnit</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.WidthUnit">
            <summary>
            <dd> <p>[VT_UI2] The units that the image width is specified in; a 1 indicates inches, a 2 indicates centimeters, a 3 indicates points, a 4 specifies picas, and a 5 specifies columns.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoWidthUnit</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoWidthUnit</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.VResolution">
            <summary>
            <dd> <p>[VT_UI4] The vertical resolution of the image.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoVResolution</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoVResolution</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.VResolutionUnit">
            <summary>
            <dd> <p>[VT_UI2] The units that the vertical resolution is specified in; a 1 indicates pixels per inch and a 2 indicates pixels per centimeter.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoVResolutionUnit</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoVResolutionUnit</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BIMResolutionInfoProperties.HeightUnit">
            <summary>
            <dd> <p>[VT_UI2] The units that the image height is specified in; a 1 indicates inches, a 2 indicates centimeters, a 3 indicates points, a 4 specifies picas, and a 5 specifies columns.</p> </dd>
            </summary>
            <doc-id>ee719804</doc-id>
            <unmanaged>WIC8BIMResolutionInfoHeightUnit</unmanaged>
            <unmanaged-short>WIC8BIMResolutionInfoHeightUnit</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapAlphaChannelOption">
            <summary>
            <p>Specifies the desired alpha channel usage.</p>
            </summary>
            <doc-id>ee719805</doc-id>
            <unmanaged>WICBitmapAlphaChannelOption</unmanaged>
            <unmanaged-short>WICBitmapAlphaChannelOption</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapAlphaChannelOption.UseAlpha">
            <summary>
            <dd> <p>Use alpha channel.</p> </dd>
            </summary>
            <doc-id>ee719805</doc-id>
            <unmanaged>WICBitmapUseAlpha</unmanaged>
            <unmanaged-short>WICBitmapUseAlpha</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapAlphaChannelOption.UsePremultipliedAlpha">
            <summary>
            <dd> <p>Use a pre-multiplied alpha channel.</p> </dd>
            </summary>
            <doc-id>ee719805</doc-id>
            <unmanaged>WICBitmapUsePremultipliedAlpha</unmanaged>
            <unmanaged-short>WICBitmapUsePremultipliedAlpha</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapAlphaChannelOption.IgnoreAlpha">
            <summary>
            <dd> <p>Ignore alpha channel.</p> </dd>
            </summary>
            <doc-id>ee719805</doc-id>
            <unmanaged>WICBitmapIgnoreAlpha</unmanaged>
            <unmanaged-short>WICBitmapIgnoreAlpha</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapCreateCacheOption">
            <summary>
            <p>Specifies the desired cache usage.</p>
            </summary>
            <remarks>
            <p>The <strong>CreateBitmap</strong> of the <strong><see cref = "T:SharpDX.WIC.ImagingFactory"/></strong> interface does not support WICBitmapNoCache when the <em>pixelFormat</em> is a native pixel format provided by Windows Imaging Component (WIC).</p>
            </remarks>
            <doc-id>ee719806</doc-id>
            <unmanaged>WICBitmapCreateCacheOption</unmanaged>
            <unmanaged-short>WICBitmapCreateCacheOption</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapCreateCacheOption.NoCache">
            <summary>
            <dd> <p>Do not cache the bitmap.</p> </dd>
            </summary>
            <doc-id>ee719806</doc-id>
            <unmanaged>WICBitmapNoCache</unmanaged>
            <unmanaged-short>WICBitmapNoCache</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapCreateCacheOption.CacheOnDemand">
            <summary>
            <dd> <p>Cache the bitmap when needed.</p> </dd>
            </summary>
            <doc-id>ee719806</doc-id>
            <unmanaged>WICBitmapCacheOnDemand</unmanaged>
            <unmanaged-short>WICBitmapCacheOnDemand</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapCreateCacheOption.CacheOnLoad">
            <summary>
            <dd> <p>Cache the bitmap at initialization.</p> </dd>
            </summary>
            <doc-id>ee719806</doc-id>
            <unmanaged>WICBitmapCacheOnLoad</unmanaged>
            <unmanaged-short>WICBitmapCacheOnLoad</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderCapabilities.SameEncoder">
            <summary>
            <dd> <p>Decoder recognizes the image was encoded with an encoder produced by the same vendor. </p> <p></p> </dd>
            </summary>
            <doc-id>ee719807</doc-id>
            <unmanaged>WICBitmapDecoderCapabilitySameEncoder</unmanaged>
            <unmanaged-short>WICBitmapDecoderCapabilitySameEncoder</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderCapabilities.CanDecodeAllImages">
            <summary>
            <dd> <p>Decoder can decode all the images within an image container.</p> </dd>
            </summary>
            <doc-id>ee719807</doc-id>
            <unmanaged>WICBitmapDecoderCapabilityCanDecodeAllImages</unmanaged>
            <unmanaged-short>WICBitmapDecoderCapabilityCanDecodeAllImages</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderCapabilities.CanDecodeSomeImages">
            <summary>
            <dd> <p>Decoder can decode some of the images within an image container.</p> </dd>
            </summary>
            <doc-id>ee719807</doc-id>
            <unmanaged>WICBitmapDecoderCapabilityCanDecodeSomeImages</unmanaged>
            <unmanaged-short>WICBitmapDecoderCapabilityCanDecodeSomeImages</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderCapabilities.CanEnumerateMetadata">
            <summary>
            <dd> <p>Decoder can enumerate the metadata blocks within a container format.</p> </dd>
            </summary>
            <doc-id>ee719807</doc-id>
            <unmanaged>WICBitmapDecoderCapabilityCanEnumerateMetadata</unmanaged>
            <unmanaged-short>WICBitmapDecoderCapabilityCanEnumerateMetadata</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderCapabilities.CanDecodeThumbnail">
            <summary>
            <dd> <p>Decoder can find and decode a thumbnail.</p> </dd>
            </summary>
            <doc-id>ee719807</doc-id>
            <unmanaged>WICBitmapDecoderCapabilityCanDecodeThumbnail</unmanaged>
            <unmanaged-short>WICBitmapDecoderCapabilityCanDecodeThumbnail</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderCapabilities.None">
            <summary>
            None
            </summary>
            <unmanaged>None</unmanaged>
            <unmanaged-short>None</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapDitherType">
            <summary>
            <p>Specifies the type of dither algorithm to apply when converting between image formats.</p>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherType</unmanaged>
            <unmanaged-short>WICBitmapDitherType</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.None">
            <summary>
            <dd> <p>A solid color algorithm without dither.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeNone</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeNone</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.Solid">
            <summary>
            <dd> <p>A solid color algorithm without dither.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeSolid</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeSolid</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.Ordered4x4">
            <summary>
            <dd> <p>A 4x4 ordered dither algorithm. </p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeOrdered4x4</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeOrdered4x4</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.Ordered8x8">
            <summary>
            <dd> <p>An 8x8 ordered dither algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeOrdered8x8</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeOrdered8x8</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.Ordered16x16">
            <summary>
            <dd> <p>A 16x16 ordered dither algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeOrdered16x16</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeOrdered16x16</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.Spiral4x4">
            <summary>
            <dd> <p>A 4x4 spiral dither algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeSpiral4x4</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeSpiral4x4</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.Spiral8x8">
            <summary>
            <dd> <p>An 8x8 spiral dither algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeSpiral8x8</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeSpiral8x8</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.DualSpiral4x4">
            <summary>
            <dd> <p>A 4x4 dual spiral dither algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeDualSpiral4x4</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeDualSpiral4x4</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.DualSpiral8x8">
            <summary>
            <dd> <p>An 8x8 dual spiral dither algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeDualSpiral8x8</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeDualSpiral8x8</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapDitherType.ErrorDiffusion">
            <summary>
            <dd> <p>An error diffusion algorithm.</p> </dd>
            </summary>
            <doc-id>ee719808</doc-id>
            <unmanaged>WICBitmapDitherTypeErrorDiffusion</unmanaged>
            <unmanaged-short>WICBitmapDitherTypeErrorDiffusion</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapEncoderCacheOption">
            <summary>
            <p>Specifies the cache options available for an encoder.</p>
            </summary>
            <doc-id>ee719809</doc-id>
            <unmanaged>WICBitmapEncoderCacheOption</unmanaged>
            <unmanaged-short>WICBitmapEncoderCacheOption</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderCacheOption.InMemory">
            <summary>
            <dd> <p>The encoder is cached in memory. This option is not supported.</p> </dd>
            </summary>
            <doc-id>ee719809</doc-id>
            <unmanaged>WICBitmapEncoderCacheInMemory</unmanaged>
            <unmanaged-short>WICBitmapEncoderCacheInMemory</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderCacheOption.TempFile">
            <summary>
            <dd> <p>The encoder is cached to a temporary file. This option is not supported.</p> </dd>
            </summary>
            <doc-id>ee719809</doc-id>
            <unmanaged>WICBitmapEncoderCacheTempFile</unmanaged>
            <unmanaged-short>WICBitmapEncoderCacheTempFile</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderCacheOption.NoCache">
            <summary>
            <dd> <p>The encoder is not cached.</p> </dd>
            </summary>
            <doc-id>ee719809</doc-id>
            <unmanaged>WICBitmapEncoderNoCache</unmanaged>
            <unmanaged-short>WICBitmapEncoderNoCache</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapInterpolationMode">
            <summary>
            <p>Specifies the sampling or filtering mode to use when scaling an image.</p>
            </summary>
            <doc-id>ee719810</doc-id>
            <unmanaged>WICBitmapInterpolationMode</unmanaged>
            <unmanaged-short>WICBitmapInterpolationMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapInterpolationMode.NearestNeighbor">
            <summary>
            <dd> <p>A nearest neighbor interpolation algorithm. Also known as nearest pixel or point interpolation. </p> <p>The output pixel is assigned the value of the pixel that the point falls within. No other pixels are considered.</p> </dd>
            </summary>
            <doc-id>ee719810</doc-id>
            <unmanaged>WICBitmapInterpolationModeNearestNeighbor</unmanaged>
            <unmanaged-short>WICBitmapInterpolationModeNearestNeighbor</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapInterpolationMode.Linear">
            <summary>
            <dd> <p>A bilinear interpolation algorithm. </p> <p>The output pixel values are computed as a weighted average of the nearest four pixels in a 2x2 grid.</p> </dd>
            </summary>
            <doc-id>ee719810</doc-id>
            <unmanaged>WICBitmapInterpolationModeLinear</unmanaged>
            <unmanaged-short>WICBitmapInterpolationModeLinear</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapInterpolationMode.Cubic">
            <summary>
            <dd> <p>A bicubic interpolation algorithm. </p> <p>Destination pixel values are computed as a weighted average of the nearest sixteen pixels in a 4x4 grid. </p> </dd>
            </summary>
            <doc-id>ee719810</doc-id>
            <unmanaged>WICBitmapInterpolationModeCubic</unmanaged>
            <unmanaged-short>WICBitmapInterpolationModeCubic</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapInterpolationMode.Fant">
            <summary>
            <dd> <p>A Fant resampling algorithm. </p> <p>Destination pixel values are computed as a weighted average of the all the pixels that map to the new pixel.</p> </dd>
            </summary>
            <doc-id>ee719810</doc-id>
            <unmanaged>WICBitmapInterpolationModeFant</unmanaged>
            <unmanaged-short>WICBitmapInterpolationModeFant</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapInterpolationMode.HighQualityCubic">
            <summary>
            <dd> <p>A high quality bicubic interpolation algorithm. Destination pixel values are computed using a much denser sampling  kernel than regular cubic. The kernel is resized in response to the scale factor, making it suitable for downscaling by factors greater than 2.</p> <strong>Note</strong>??This value is supported beginning with Windows?10. ? </dd>
            </summary>
            <doc-id>ee719810</doc-id>
            <unmanaged>WICBitmapInterpolationModeHighQualityCubic</unmanaged>
            <unmanaged-short>WICBitmapInterpolationModeHighQualityCubic</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapLockFlags">
            <summary>
            <p>Specifies access to an <strong><see cref = "T:SharpDX.WIC.Bitmap"/></strong>.</p>
            </summary>
            <doc-id>ee719811</doc-id>
            <unmanaged>WICBitmapLockFlags</unmanaged>
            <unmanaged-short>WICBitmapLockFlags</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapLockFlags.Read">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719811</doc-id>
            <unmanaged>WICBitmapLockRead</unmanaged>
            <unmanaged-short>WICBitmapLockRead</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapLockFlags.Write">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719811</doc-id>
            <unmanaged>WICBitmapLockWrite</unmanaged>
            <unmanaged-short>WICBitmapLockWrite</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapPaletteType">
            <summary>
            <p>Specifies the type of palette used for an indexed image format.</p>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteType</unmanaged>
            <unmanaged-short>WICBitmapPaletteType</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.Custom">
            <summary>
            <dd> <p>An arbitrary custom palette provided by caller.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeCustom</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeCustom</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.MedianCut">
            <summary>
            <dd> <p>An optimal palette generated using a median-cut algorithm. Derived from the colors in an image.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeMedianCut</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeMedianCut</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedBW">
            <summary>
            <dd> <p>A black and white palette.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedBW</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedBW</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone8">
            <summary>
            <dd> <p>A palette that has its 8-color on-off primaries and the 16 system colors added. With duplicates removed, 16 colors are available.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone8</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone8</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone27">
            <summary>
            <dd> <p>A palette that has 3 intensity levels of each primary: 27-color on-off primaries and the 16 system colors added. With duplicates removed, 35 colors are available.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone27</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone27</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone64">
            <summary>
            <dd> <p>A palette that has 4 intensity levels of each primary: 64-color on-off primaries and the 16 system colors added. With duplicates removed, 72 colors are available.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone64</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone64</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone125">
            <summary>
            <dd> <p>A palette that has 5 intensity levels of each primary: 125-color on-off primaries and the 16 system colors added. With duplicates removed, 133 colors are available.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone125</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone125</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone216">
            <summary>
            <dd> <p>A palette that has 6 intensity levels of each primary: 216-color on-off primaries and the 16 system colors added. With duplicates removed, 224 colors are available. This is the same as <strong>WICBitmapPaletteFixedHalftoneWeb</strong>.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone216</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone216</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedWebPalette">
            <summary>
            <dd> <p>A palette that has 6 intensity levels of each primary: 216-color on-off primaries and the 16 system colors added. With duplicates removed, 224 colors are available. This is the same as <strong>WICBitmapPaletteTypeFixedHalftone216</strong>.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedWebPalette</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedWebPalette</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone252">
            <summary>
            <dd> <p>A palette that has its 252-color on-off primaries and the 16 system colors added. With duplicates removed, 256 colors are available.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone252</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone252</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedHalftone256">
            <summary>
            <dd> <p>A palette that has its 256-color on-off primaries and the 16 system colors added. With duplicates removed, 256 colors are available.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedHalftone256</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedHalftone256</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedGray4">
            <summary>
            <dd> <p>A palette that has 4 shades of gray.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedGray4</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedGray4</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedGray16">
            <summary>
            <dd> <p>A palette that has 16 shades of gray.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedGray16</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedGray16</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPaletteType.FixedGray256">
            <summary>
            <dd> <p>A palette that has 256 shades of gray.</p> </dd>
            </summary>
            <doc-id>ee719812</doc-id>
            <unmanaged>WICBitmapPaletteTypeFixedGray256</unmanaged>
            <unmanaged-short>WICBitmapPaletteTypeFixedGray256</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapTransformOptions.Rotate0">
            <summary>
            <dd> <p>A rotation of 0 degrees.</p> </dd>
            </summary>
            <doc-id>ee719814</doc-id>
            <unmanaged>WICBitmapTransformRotate0</unmanaged>
            <unmanaged-short>WICBitmapTransformRotate0</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapTransformOptions.Rotate90">
            <summary>
            <dd> <p>A clockwise rotation of 90 degrees.</p> </dd>
            </summary>
            <doc-id>ee719814</doc-id>
            <unmanaged>WICBitmapTransformRotate90</unmanaged>
            <unmanaged-short>WICBitmapTransformRotate90</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapTransformOptions.Rotate180">
            <summary>
            <dd> <p>A clockwise rotation of 180 degrees.</p> </dd>
            </summary>
            <doc-id>ee719814</doc-id>
            <unmanaged>WICBitmapTransformRotate180</unmanaged>
            <unmanaged-short>WICBitmapTransformRotate180</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapTransformOptions.Rotate270">
            <summary>
            <dd> <p>A clockwise rotation of 270 degrees.</p> </dd>
            </summary>
            <doc-id>ee719814</doc-id>
            <unmanaged>WICBitmapTransformRotate270</unmanaged>
            <unmanaged-short>WICBitmapTransformRotate270</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapTransformOptions.FlipHorizontal">
            <summary>
            <dd> <p>A horizontal flip. Pixels are flipped around the vertical y-axis.</p> </dd>
            </summary>
            <doc-id>ee719814</doc-id>
            <unmanaged>WICBitmapTransformFlipHorizontal</unmanaged>
            <unmanaged-short>WICBitmapTransformFlipHorizontal</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapTransformOptions.FlipVertical">
            <summary>
            <dd> <p>A vertical flip. Pixels are flipped around the horizontal x-axis.</p> </dd>
            </summary>
            <doc-id>ee719814</doc-id>
            <unmanaged>WICBitmapTransformFlipVertical</unmanaged>
            <unmanaged-short>WICBitmapTransformFlipVertical</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.ColorContextType">
            <summary>
            <p>Specifies the color context types.</p>
            </summary>
            <doc-id>ee719815</doc-id>
            <unmanaged>WICColorContextType</unmanaged>
            <unmanaged-short>WICColorContextType</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ColorContextType.Uninitialized">
            <summary>
            <dd> <p>An uninitialized color context.</p> </dd>
            </summary>
            <doc-id>ee719815</doc-id>
            <unmanaged>WICColorContextUninitialized</unmanaged>
            <unmanaged-short>WICColorContextUninitialized</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ColorContextType.Profile">
            <summary>
            <dd> <p>A color context that is a full ICC color profile.</p> </dd>
            </summary>
            <doc-id>ee719815</doc-id>
            <unmanaged>WICColorContextProfile</unmanaged>
            <unmanaged-short>WICColorContextProfile</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ColorContextType.ExifColorSpace">
            <summary>
            <dd> <p>A color context that is one of a number of set color spaces (sRGB, AdobeRGB) that are defined in the EXIF specification.</p> </dd>
            </summary>
            <doc-id>ee719815</doc-id>
            <unmanaged>WICColorContextExifColorSpace</unmanaged>
            <unmanaged-short>WICColorContextExifColorSpace</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentEnumerateOptions.Default">
            <summary>
            <dd> <p>Enumerate any components that are not disabled. Because this value is 0x0, it is always included with the other options.</p> </dd>
            </summary>
            <doc-id>ee719816</doc-id>
            <unmanaged>WICComponentEnumerateDefault</unmanaged>
            <unmanaged-short>WICComponentEnumerateDefault</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentEnumerateOptions.Refresh">
            <summary>
            <dd> <p>Force a read of the registry before enumerating components.</p> </dd>
            </summary>
            <doc-id>ee719816</doc-id>
            <unmanaged>WICComponentEnumerateRefresh</unmanaged>
            <unmanaged-short>WICComponentEnumerateRefresh</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentEnumerateOptions.Disabled">
            <summary>
            <dd> <p>Include disabled components in the enumeration. The set of disabled components is disjoint with the set of default enumerated components</p> </dd>
            </summary>
            <doc-id>ee719816</doc-id>
            <unmanaged>WICComponentEnumerateDisabled</unmanaged>
            <unmanaged-short>WICComponentEnumerateDisabled</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentEnumerateOptions.Unsigned">
            <summary>
            <dd> <p>Include unsigned components in the enumeration. This option has no effect.</p> </dd>
            </summary>
            <doc-id>ee719816</doc-id>
            <unmanaged>WICComponentEnumerateUnsigned</unmanaged>
            <unmanaged-short>WICComponentEnumerateUnsigned</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentEnumerateOptions.BuiltInOnly">
            <summary>
            <dd> <p>At the end of component enumeration, filter out any components that are not Windows provided.</p> </dd>
            </summary>
            <doc-id>ee719816</doc-id>
            <unmanaged>WICComponentEnumerateBuiltInOnly</unmanaged>
            <unmanaged-short>WICComponentEnumerateBuiltInOnly</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentSigning.Signed">
            <summary>
            <dd> <p>A signed component.</p> </dd>
            </summary>
            <doc-id>ee719817</doc-id>
            <unmanaged>WICComponentSigned</unmanaged>
            <unmanaged-short>WICComponentSigned</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentSigning.Unsigned">
            <summary>
            <dd> <p>An unsigned component</p> </dd>
            </summary>
            <doc-id>ee719817</doc-id>
            <unmanaged>WICComponentUnsigned</unmanaged>
            <unmanaged-short>WICComponentUnsigned</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentSigning.Safe">
            <summary>
            <dd> <p>A component is safe. </p> <p>Components that do not have a binary component to sign, such as a pixel format, should return this value.</p> </dd>
            </summary>
            <doc-id>ee719817</doc-id>
            <unmanaged>WICComponentSafe</unmanaged>
            <unmanaged-short>WICComponentSafe</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentSigning.Disabled">
            <summary>
            <dd> <p>A component has been disabled.</p> </dd>
            </summary>
            <doc-id>ee719817</doc-id>
            <unmanaged>WICComponentDisabled</unmanaged>
            <unmanaged-short>WICComponentDisabled</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.Decoder">
            <summary>
            <dd> <p>A WIC decoder.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICDecoder</unmanaged>
            <unmanaged-short>WICDecoder</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.Encoder">
            <summary>
            <dd> <p>A WIC encoder.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICEncoder</unmanaged>
            <unmanaged-short>WICEncoder</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.PixelFormatConverter">
            <summary>
            <dd> <p>A WIC pixel converter.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICPixelFormatConverter</unmanaged>
            <unmanaged-short>WICPixelFormatConverter</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.MetadataReader">
            <summary>
            <dd> <p>A WIC metadata reader.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICMetadataReader</unmanaged>
            <unmanaged-short>WICMetadataReader</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.MetadataWriter">
            <summary>
            <dd> <p>A WIC metadata writer.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICMetadataWriter</unmanaged>
            <unmanaged-short>WICMetadataWriter</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.PixelFormat">
            <summary>
            <dd> <p>A WIC pixel format.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICPixelFormat</unmanaged>
            <unmanaged-short>WICPixelFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ComponentType.AllComponents">
            <summary>
            <dd> <p>All WIC components.</p> </dd>
            </summary>
            <doc-id>ee719818</doc-id>
            <unmanaged>WICAllComponents</unmanaged>
            <unmanaged-short>WICAllComponents</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.DdsAlphaMode">
            <summary>
            <p>Specifies the the meaning of pixel color component values contained in the DDS image.</p>
            </summary>
            <doc-id>dn302101</doc-id>
            <unmanaged>WICDdsAlphaMode</unmanaged>
            <unmanaged-short>WICDdsAlphaMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsAlphaMode.DdsAlphaModeUnknown">
            <summary>
            <dd> <p>Alpha behavior is unspecified and must be determined by the reader.</p> </dd>
            </summary>
            <doc-id>dn302101</doc-id>
            <unmanaged>WICDdsAlphaModeUnknown</unmanaged>
            <unmanaged-short>WICDdsAlphaModeUnknown</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsAlphaMode.DdsAlphaModeStraight">
            <summary>
            <dd> <p>The alpha data is straight.</p> </dd>
            </summary>
            <doc-id>dn302101</doc-id>
            <unmanaged>WICDdsAlphaModeStraight</unmanaged>
            <unmanaged-short>WICDdsAlphaModeStraight</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsAlphaMode.DdsAlphaModePremultiplied">
            <summary>
            <dd> <p>The alpha data is premultiplied.</p> </dd>
            </summary>
            <doc-id>dn302101</doc-id>
            <unmanaged>WICDdsAlphaModePremultiplied</unmanaged>
            <unmanaged-short>WICDdsAlphaModePremultiplied</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsAlphaMode.DdsAlphaModeOpaque">
            <summary>
            <dd> <p>The alpha data is opaque (UNORM value of 1). This can be used by a compliant reader as a performance optimization. For example, blending operations can be converted to copies.</p> </dd>
            </summary>
            <doc-id>dn302101</doc-id>
            <unmanaged>WICDdsAlphaModeOpaque</unmanaged>
            <unmanaged-short>WICDdsAlphaModeOpaque</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsAlphaMode.DdsAlphaModeCustom">
            <summary>
            <dd> <p>The alpha channel contains custom data that is not alpha.</p> </dd>
            </summary>
            <doc-id>dn302101</doc-id>
            <unmanaged>WICDdsAlphaModeCustom</unmanaged>
            <unmanaged-short>WICDdsAlphaModeCustom</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.DdsDimension">
            <summary>
            <p>Specifies the dimension type of the data contained in DDS image.</p>
            </summary>
            <remarks>
            <p>Both <strong>WICDdsTexture2d</strong> and <strong>WICDdsTextureCube</strong> correspond to <strong>D3D11_RESOURCE_DIMENSION_TEXTURE2D</strong>. When using <strong>ID3D11Device::CreateTexture2D</strong>, they are distinguished by the flag <strong>D3D11_RESOURCE_MISC_TEXTURECUBE</strong> in the structure <strong><see cref = "!:SharpDX.Direct3D11.Texture2DDescription"/></strong>.</p>
            </remarks>
            <doc-id>dn302102</doc-id>
            <unmanaged>WICDdsDimension</unmanaged>
            <unmanaged-short>WICDdsDimension</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsDimension.DdsTexture1D">
            <summary>
            <dd> <p>DDS image contains a 1-dimensional texture .  </p> </dd>
            </summary>
            <doc-id>dn302102</doc-id>
            <unmanaged>WICDdsTexture1D</unmanaged>
            <unmanaged-short>WICDdsTexture1D</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsDimension.DdsTexture2D">
            <summary>
            <dd> <p>DDS image contains a 2-dimensional texture .  </p> </dd>
            </summary>
            <doc-id>dn302102</doc-id>
            <unmanaged>WICDdsTexture2D</unmanaged>
            <unmanaged-short>WICDdsTexture2D</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsDimension.DdsTexture3D">
            <summary>
            <dd> <p>DDS image contains a 3-dimensional texture .  </p> </dd>
            </summary>
            <doc-id>dn302102</doc-id>
            <unmanaged>WICDdsTexture3D</unmanaged>
            <unmanaged-short>WICDdsTexture3D</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsDimension.DdsTextureCube">
            <summary>
            <dd> <p>The DDS image contains a cube texture represented as an array of 6 faces.  </p> </dd>
            </summary>
            <doc-id>dn302102</doc-id>
            <unmanaged>WICDdsTextureCube</unmanaged>
            <unmanaged-short>WICDdsTextureCube</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.DecodeOptions">
            <summary>
            <p>Specifies decode options.</p>
            </summary>
            <doc-id>ee719824</doc-id>
            <unmanaged>WICDecodeOptions</unmanaged>
            <unmanaged-short>WICDecodeOptions</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DecodeOptions.CacheOnDemand">
            <summary>
            <dd> <p>Cache metadata when needed.</p> </dd>
            </summary>
            <doc-id>ee719824</doc-id>
            <unmanaged>WICDecodeMetadataCacheOnDemand</unmanaged>
            <unmanaged-short>WICDecodeMetadataCacheOnDemand</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DecodeOptions.CacheOnLoad">
            <summary>
            <dd> <p>Cache metadata when decoder is loaded.</p> </dd>
            </summary>
            <doc-id>ee719824</doc-id>
            <unmanaged>WICDecodeMetadataCacheOnLoad</unmanaged>
            <unmanaged-short>WICDecodeMetadataCacheOnLoad</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.GifApplicationExtensionProperties">
            <summary>
            <p>Specifies the application extension metadata properties for a Graphics Interchange Format (GIF) image.</p>
            </summary>
            <doc-id>ee719826</doc-id>
            <unmanaged>WICGifApplicationExtensionProperties</unmanaged>
            <unmanaged-short>WICGifApplicationExtensionProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifApplicationExtensionProperties.Application">
            <summary>
            <dd> <p>[VT_UI1 | VT_VECTOR] Indicates a string that identifies the application.</p> </dd>
            </summary>
            <doc-id>ee719826</doc-id>
            <unmanaged>WICGifApplicationExtensionApplication</unmanaged>
            <unmanaged-short>WICGifApplicationExtensionApplication</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifApplicationExtensionProperties.Data">
            <summary>
            <dd> <p>[VT_UI1 | VT_VECTOR] Indicates data that is exposed by the application.</p> </dd>
            </summary>
            <doc-id>ee719826</doc-id>
            <unmanaged>WICGifApplicationExtensionData</unmanaged>
            <unmanaged-short>WICGifApplicationExtensionData</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.GifCommentExtensionProperties">
            <summary>
            <p>Specifies the comment extension metadata properties for a Graphics Interchange Format (GIF) image.</p>
            </summary>
            <doc-id>ee719827</doc-id>
            <unmanaged>WICGifCommentExtensionProperties</unmanaged>
            <unmanaged-short>WICGifCommentExtensionProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifCommentExtensionProperties.Text">
            <summary>
            <dd> <p>[VT_LPSTR] Indicates the comment text.</p> </dd>
            </summary>
            <doc-id>ee719827</doc-id>
            <unmanaged>WICGifCommentExtensionText</unmanaged>
            <unmanaged-short>WICGifCommentExtensionText</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.GifGraphicControlExtensionProperties">
            <summary>
            <p>Specifies the graphic control extension metadata properties that define the transitions between each frame animation for Graphics Interchange Format (GIF) images.</p>
            </summary>
            <doc-id>ee719828</doc-id>
            <unmanaged>WICGifGraphicControlExtensionProperties</unmanaged>
            <unmanaged-short>WICGifGraphicControlExtensionProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifGraphicControlExtensionProperties.Disposal">
            <summary>
            <dd> <p>[VT_UI1] Indicates  the disposal requirements. 0 - no disposal, 1 - do not dispose, 2 - restore to background color, 3 - restore to previous.</p> </dd>
            </summary>
            <doc-id>ee719828</doc-id>
            <unmanaged>WICGifGraphicControlExtensionDisposal</unmanaged>
            <unmanaged-short>WICGifGraphicControlExtensionDisposal</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifGraphicControlExtensionProperties.UserInputFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the user input flag. <strong>TRUE</strong> if user input should advance to the next frame; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719828</doc-id>
            <unmanaged>WICGifGraphicControlExtensionUserInputFlag</unmanaged>
            <unmanaged-short>WICGifGraphicControlExtensionUserInputFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifGraphicControlExtensionProperties.TransparencyFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the transparency flag. <strong>TRUE</strong> if a transparent color in is in the color table for this frame; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719828</doc-id>
            <unmanaged>WICGifGraphicControlExtensionTransparencyFlag</unmanaged>
            <unmanaged-short>WICGifGraphicControlExtensionTransparencyFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifGraphicControlExtensionProperties.Delay">
            <summary>
            <dd> <p>[VT_UI2] Indicates  how long to display the next frame before advancing to the next frame, in units of 1/100th of a second.</p> </dd>
            </summary>
            <doc-id>ee719828</doc-id>
            <unmanaged>WICGifGraphicControlExtensionDelay</unmanaged>
            <unmanaged-short>WICGifGraphicControlExtensionDelay</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifGraphicControlExtensionProperties.TransparentColorIndex">
            <summary>
            <dd> <p>[VT_UI1] Indicates which color in the palette should be treated as transparent.</p> </dd>
            </summary>
            <doc-id>ee719828</doc-id>
            <unmanaged>WICGifGraphicControlExtensionTransparentColorIndex</unmanaged>
            <unmanaged-short>WICGifGraphicControlExtensionTransparentColorIndex</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.GifImageDescriptorProperties">
            <summary>
            <p>Specifies the image descriptor metadata properties for  Graphics Interchange Format (GIF) frames.</p>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorProperties</unmanaged>
            <unmanaged-short>WICGifImageDescriptorProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.Left">
            <summary>
            <dd> <p>[VT_UI2] Indicates the X offset at which to locate this frame within the logical screen.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorLeft</unmanaged>
            <unmanaged-short>WICGifImageDescriptorLeft</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.Top">
            <summary>
            <dd> <p>[VT_UI2] Indicates the Y offset at which to locate this frame within the logical screen.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorTop</unmanaged>
            <unmanaged-short>WICGifImageDescriptorTop</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.Width">
            <summary>
            <dd> <p>[VT_UI2] Indicates width of this frame, in pixels.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorWidth</unmanaged>
            <unmanaged-short>WICGifImageDescriptorWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.Height">
            <summary>
            <dd> <p>[VT_UI2] Indicates height of this frame, in pixels.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorHeight</unmanaged>
            <unmanaged-short>WICGifImageDescriptorHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.LocalColorTableFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the local color table flag. <strong>TRUE</strong> if global color table is present; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorLocalColorTableFlag</unmanaged>
            <unmanaged-short>WICGifImageDescriptorLocalColorTableFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.InterlaceFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the interlace flag. <strong>TRUE</strong> if image is interlaced; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorInterlaceFlag</unmanaged>
            <unmanaged-short>WICGifImageDescriptorInterlaceFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.SortFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the sorted color table flag. <strong>TRUE</strong> if the color table is sorted from most frequently to least frequently used color; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorSortFlag</unmanaged>
            <unmanaged-short>WICGifImageDescriptorSortFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifImageDescriptorProperties.LocalColorTableSize">
            <summary>
            <dd> <p>[VT_UI1] Indicates the value used to calculate the number of bytes contained in the global color table. </p> <p>To calculate the actual size of the color table, raise 2 to the value of the field + 1.</p> </dd>
            </summary>
            <doc-id>ee719829</doc-id>
            <unmanaged>WICGifImageDescriptorLocalColorTableSize</unmanaged>
            <unmanaged-short>WICGifImageDescriptorLocalColorTableSize</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.GifLogicalScreenDescriptorProperties">
            <summary>
            <p>Specifies the logical screen descriptor properties for Graphics Interchange Format (GIF) metadata.</p>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorProperties</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.Signature">
            <summary>
            <dd> <p> [VT_UI1 | VT_VECTOR] Indicates the signature property.</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenSignature</unmanaged>
            <unmanaged-short>WICGifLogicalScreenSignature</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.Width">
            <summary>
            <dd> <p>[VT_UI2] Indicates the width in pixels. </p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorWidth</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.Height">
            <summary>
            <dd> <p>[VT_UI2] Indicates the height in pixels. </p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorHeight</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorHeight</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.GlobalColorTableFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the  global color table flag. <strong>TRUE</strong> if a global color table is present; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorGlobalColorTableFlag</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorGlobalColorTableFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.ColorResolution">
            <summary>
            <dd> <p>[VT_UI1] Indicates the color resolution in bits per pixel.</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorColorResolution</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorColorResolution</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.SortFlag">
            <summary>
            <dd> <p>[VT_BOOL] Indicates the sorted color table flag. <strong>TRUE</strong> if the table is sorted; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorSortFlag</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorSortFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.GlobalColorTableSize">
            <summary>
            <dd> <p>[VT_UI1] Indicates the value used to calculate the number of bytes contained in the global color table. </p> <p>To calculate the actual size of the color table, raise 2 to the value of the field + 1.</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorGlobalColorTableSize</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorGlobalColorTableSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.BackgroundColorIndex">
            <summary>
            <dd> <p>[VT_UI1] Indicates the index within the color table to use for the background (pixels not defined in the image).</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorBackgroundColorIndex</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorBackgroundColorIndex</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.GifLogicalScreenDescriptorProperties.PixelAspectRatio">
            <summary>
            <dd> <p>[VT_UI1] Indicates the factor used to compute an approximation of the aspect ratio.</p> </dd>
            </summary>
            <doc-id>ee719830</doc-id>
            <unmanaged>WICGifLogicalScreenDescriptorPixelAspectRatio</unmanaged>
            <unmanaged-short>WICGifLogicalScreenDescriptorPixelAspectRatio</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegChrominanceProperties">
            <summary>
            <p>Specifies the JPEG chrominance table property.</p>
            </summary>
            <doc-id>ee719831</doc-id>
            <unmanaged>WICJpegChrominanceProperties</unmanaged>
            <unmanaged-short>WICJpegChrominanceProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegChrominanceProperties.Table">
            <summary>
            <dd> <p>[VT_UI2|VT_VECTOR] Indicates the metadata property is a chrominance table.</p> </dd>
            </summary>
            <doc-id>ee719831</doc-id>
            <unmanaged>WICJpegChrominanceTable</unmanaged>
            <unmanaged-short>WICJpegChrominanceTable</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegCommentProperties">
            <summary>
            <p>Specifies the JPEG comment properties.</p>
            </summary>
            <doc-id>ee719832</doc-id>
            <unmanaged>WICJpegCommentProperties</unmanaged>
            <unmanaged-short>WICJpegCommentProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegCommentProperties.Text">
            <summary>
            <dd> <p>Indicates the metadata property is comment text.</p> </dd>
            </summary>
            <doc-id>ee719832</doc-id>
            <unmanaged>WICJpegCommentText</unmanaged>
            <unmanaged-short>WICJpegCommentText</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegIndexingOptions">
            <summary>
            <p>Specifies the options for indexing a JPEG image. </p>
            </summary>
            <doc-id>dn903880</doc-id>
            <unmanaged>WICJpegIndexingOptions</unmanaged>
            <unmanaged-short>WICJpegIndexingOptions</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegIndexingOptions.JpegIndexingOptionsGenerateOnDemand">
            <summary>
            <dd> <p>Index generation is deferred until <strong>IWICBitmapSource::CopyPixels</strong> is called on the image.</p> </dd>
            </summary>
            <doc-id>dn903880</doc-id>
            <unmanaged>WICJpegIndexingOptionsGenerateOnDemand</unmanaged>
            <unmanaged-short>WICJpegIndexingOptionsGenerateOnDemand</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegIndexingOptions.JpegIndexingOptionsGenerateOnLoad">
            <summary>
            <dd> <p>Index generation is performed when the when the image is initially loaded.</p> </dd>
            </summary>
            <doc-id>dn903880</doc-id>
            <unmanaged>WICJpegIndexingOptionsGenerateOnLoad</unmanaged>
            <unmanaged-short>WICJpegIndexingOptionsGenerateOnLoad</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegLuminanceProperties">
            <summary>
            <p>Specifies the JPEG luminance table property.</p>
            </summary>
            <doc-id>ee719833</doc-id>
            <unmanaged>WICJpegLuminanceProperties</unmanaged>
            <unmanaged-short>WICJpegLuminanceProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegLuminanceProperties.Table">
            <summary>
            <dd> <p>[VT_UI2|VT_VECTOR] Indicates the metadata property is a luminance table.</p> </dd>
            </summary>
            <doc-id>ee719833</doc-id>
            <unmanaged>WICJpegLuminanceTable</unmanaged>
            <unmanaged-short>WICJpegLuminanceTable</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegScanType">
            <summary>
            <p>Specifies the memory layout of pixel data in a JPEG image scan. </p>
            </summary>
            <doc-id>dn903892</doc-id>
            <unmanaged>WICJpegScanType</unmanaged>
            <unmanaged-short>WICJpegScanType</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanType.JpegScanTypeInterleaved">
            <summary>
            <dd> <p>The pixel data is stored in an interleaved memory layout.</p> </dd>
            </summary>
            <doc-id>dn903892</doc-id>
            <unmanaged>WICJpegScanTypeInterleaved</unmanaged>
            <unmanaged-short>WICJpegScanTypeInterleaved</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanType.JpegScanTypePlanarComponents">
            <summary>
            <dd> <p>The pixel data is stored in a planar memory layout.</p> </dd>
            </summary>
            <doc-id>dn903892</doc-id>
            <unmanaged>WICJpegScanTypePlanarComponents</unmanaged>
            <unmanaged-short>WICJpegScanTypePlanarComponents</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanType.JpegScanTypeProgressive">
            <summary>
            <dd> <p>The pixel data is stored in a progressive layout.</p> </dd>
            </summary>
            <doc-id>dn903892</doc-id>
            <unmanaged>WICJpegScanTypeProgressive</unmanaged>
            <unmanaged-short>WICJpegScanTypeProgressive</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegTransferMatrix">
            <summary>
            <p>Specifies conversion matrix from Y'Cb'Cr' to R'G'B'. </p>
            </summary>
            <doc-id>dn903893</doc-id>
            <unmanaged>WICJpegTransferMatrix</unmanaged>
            <unmanaged-short>WICJpegTransferMatrix</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegTransferMatrix.JpegTransferMatrixIdentity">
            <summary>
            <dd> <p>Specifies the identity transfer matrix.</p> </dd>
            </summary>
            <doc-id>dn903893</doc-id>
            <unmanaged>WICJpegTransferMatrixIdentity</unmanaged>
            <unmanaged-short>WICJpegTransferMatrixIdentity</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegTransferMatrix.JpegTransferMatrixBT601">
            <summary>
            <dd> <p>Specifies the BT601 transfer matrix.</p> </dd>
            </summary>
            <doc-id>dn903893</doc-id>
            <unmanaged>WICJpegTransferMatrixBT601</unmanaged>
            <unmanaged-short>WICJpegTransferMatrixBT601</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegYCrCbSubsamplingOption">
            <summary>
            <p>Specifies the JPEG YCrCB subsampling options. </p>
            </summary>
            <remarks>
            <p>The native JPEG encoder uses <strong>WICJpegYCrCbSubsampling420</strong>.</p>
            </remarks>
            <doc-id>ee719834</doc-id>
            <unmanaged>WICJpegYCrCbSubsamplingOption</unmanaged>
            <unmanaged-short>WICJpegYCrCbSubsamplingOption</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegYCrCbSubsamplingOption.Default">
            <summary>
            <dd> <p>The default subsampling option. </p> </dd>
            </summary>
            <doc-id>ee719834</doc-id>
            <unmanaged>WICJpegYCrCbSubsamplingDefault</unmanaged>
            <unmanaged-short>WICJpegYCrCbSubsamplingDefault</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegYCrCbSubsamplingOption.Mode420">
            <summary>
            <dd> <p>Subsampling option that uses both horizontal and vertical decimation.</p> </dd>
            </summary>
            <doc-id>ee719834</doc-id>
            <unmanaged>WICJpegYCrCbSubsampling420</unmanaged>
            <unmanaged-short>WICJpegYCrCbSubsampling420</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegYCrCbSubsamplingOption.Mode422">
            <summary>
            <dd> <p>Subsampling option that uses horizontal decimation  .</p> </dd>
            </summary>
            <doc-id>ee719834</doc-id>
            <unmanaged>WICJpegYCrCbSubsampling422</unmanaged>
            <unmanaged-short>WICJpegYCrCbSubsampling422</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegYCrCbSubsamplingOption.Mode444">
            <summary>
            <dd> <p>Subsampling option that uses no decimation.</p> </dd>
            </summary>
            <doc-id>ee719834</doc-id>
            <unmanaged>WICJpegYCrCbSubsampling444</unmanaged>
            <unmanaged-short>WICJpegYCrCbSubsampling444</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegYCrCbSubsamplingOption.Mode440">
            <summary>
            <dd> <p>Subsampling option that uses 2x vertical downsampling only. This option is only available in Windows?8.1 and later.</p> </dd>
            </summary>
            <doc-id>ee719834</doc-id>
            <unmanaged>WICJpegYCrCbSubsampling440</unmanaged>
            <unmanaged-short>WICJpegYCrCbSubsampling440</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Default">
            <summary>
            <dd> <p>The default white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointDefault</unmanaged>
            <unmanaged-short>WICWhitePointDefault</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Daylight">
            <summary>
            <dd> <p>A daylight white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointDaylight</unmanaged>
            <unmanaged-short>WICWhitePointDaylight</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Cloudy">
            <summary>
            <dd> <p>A cloudy white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointCloudy</unmanaged>
            <unmanaged-short>WICWhitePointCloudy</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Shade">
            <summary>
            <dd> <p>A shade white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointShade</unmanaged>
            <unmanaged-short>WICWhitePointShade</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Tungsten">
            <summary>
            <dd> <p>A tungsten white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointTungsten</unmanaged>
            <unmanaged-short>WICWhitePointTungsten</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Fluorescent">
            <summary>
            <dd> <p>A fluorescent white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointFluorescent</unmanaged>
            <unmanaged-short>WICWhitePointFluorescent</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Flash">
            <summary>
            <dd> <p>Daylight white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointFlash</unmanaged>
            <unmanaged-short>WICWhitePointFlash</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Underwater">
            <summary>
            <dd> <p>A flash white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointUnderwater</unmanaged>
            <unmanaged-short>WICWhitePointUnderwater</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.Custom">
            <summary>
            <dd> <p>A custom white balance. This is typically used when using a picture (grey-card) as white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointCustom</unmanaged>
            <unmanaged-short>WICWhitePointCustom</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.AutoWhiteBalance">
            <summary>
            <dd> <p>An automatic balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointAutoWhiteBalance</unmanaged>
            <unmanaged-short>WICWhitePointAutoWhiteBalance</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.NamedWhitePoint.AsShot">
            <summary>
            <dd> <p>An "as shot" white balance.</p> </dd>
            </summary>
            <doc-id>ee719842</doc-id>
            <unmanaged>WICWhitePointAsShot</unmanaged>
            <unmanaged-short>WICWhitePointAsShot</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PixelFormatNumericRepresentation">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentation</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentation</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PixelFormatNumericRepresentation.Unspecified">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentationUnspecified</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentationUnspecified</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PixelFormatNumericRepresentation.Indexed">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentationIndexed</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentationIndexed</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PixelFormatNumericRepresentation.UnsignedInteger">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentationUnsignedInteger</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentationUnsignedInteger</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PixelFormatNumericRepresentation.SignedInteger">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentationSignedInteger</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentationSignedInteger</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PixelFormatNumericRepresentation.Fixed">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentationFixed</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentationFixed</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PixelFormatNumericRepresentation.Float">
            <summary>
            <dd></dd>
            </summary>
            <doc-id>ee719844</doc-id>
            <unmanaged>WICPixelFormatNumericRepresentationFloat</unmanaged>
            <unmanaged-short>WICPixelFormatNumericRepresentationFloat</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PlanarOptions">
            <summary>
            <p>Specifies additional options to an <strong><see cref = "T:SharpDX.WIC.PlanarBitmapSourceTransform"/></strong> implementation.  </p>
            </summary>
            <doc-id>dn302105</doc-id>
            <unmanaged>WICPlanarOptions</unmanaged>
            <unmanaged-short>WICPlanarOptions</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PlanarOptions.PlanarOptionsDefault">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302105</doc-id>
            <unmanaged>WICPlanarOptionsDefault</unmanaged>
            <unmanaged-short>WICPlanarOptionsDefault</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PlanarOptions.PlanarOptionsPreserveSubsampling">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302105</doc-id>
            <unmanaged>WICPlanarOptionsPreserveSubsampling</unmanaged>
            <unmanaged-short>WICPlanarOptionsPreserveSubsampling</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngBkgdProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) background (bKGD) chunk metadata properties.</p>
            </summary>
            <doc-id>ee719845</doc-id>
            <unmanaged>WICPngBkgdProperties</unmanaged>
            <unmanaged-short>WICPngBkgdProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngBkgdProperties.Color">
            <summary>
            <dd> <p>Indicates the background color. There are three possible types, depending on the image's pixel format.</p> <p></p> <dl> <dt>VT_UI1</dt> <dd> <p>Specifies the index of the background color in an image with an indexed pixel format.</p> </dd> <dt>VT_UI2</dt> <dd> <p>Specifies the background color in a grayscale image.</p> </dd> <dt>VT_VECTOR|VT_UI2</dt> <dd> <p>Specifies the background color in an RGB image as three USHORT values: {0x<em>RRRR</em>, 0x<em>GGGG</em>, 0x<em>BBBB</em>}.</p> </dd> </dl> </dd>
            </summary>
            <doc-id>ee719845</doc-id>
            <unmanaged>WICPngBkgdBackgroundColor</unmanaged>
            <unmanaged-short>WICPngBkgdBackgroundColor</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngChrmProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) cHRM chunk metadata properties for CIE XYZ chromaticity.</p>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmProperties</unmanaged>
            <unmanaged-short>WICPngChrmProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.WhitePointX">
            <summary>
            <dd> <p>[VT_UI4] Indicates the whitepoint x value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmWhitePointX</unmanaged>
            <unmanaged-short>WICPngChrmWhitePointX</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.WhitePointY">
            <summary>
            <dd> <p>[VT_UI4] Indicates the whitepoint y value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmWhitePointY</unmanaged>
            <unmanaged-short>WICPngChrmWhitePointY</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.RedX">
            <summary>
            <dd> <p>[VT_UI4] Indicates the red x value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmRedX</unmanaged>
            <unmanaged-short>WICPngChrmRedX</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.RedY">
            <summary>
            <dd> <p>[VT_UI4] Indicates the red y value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmRedY</unmanaged>
            <unmanaged-short>WICPngChrmRedY</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.GreenX">
            <summary>
            <dd> <p>[VT_UI4] Indicates the green x value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmGreenX</unmanaged>
            <unmanaged-short>WICPngChrmGreenX</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.GreenY">
            <summary>
            <dd> <p>[VT_UI4] Indicates the green y value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmGreenY</unmanaged>
            <unmanaged-short>WICPngChrmGreenY</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.BlueX">
            <summary>
            <dd> <p>[VT_UI4] Indicates the blue x value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmBlueX</unmanaged>
            <unmanaged-short>WICPngChrmBlueX</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngChrmProperties.BlueY">
            <summary>
            <dd> <p>[VT_UI4] Indicates the blue y value ratio.</p> </dd>
            </summary>
            <doc-id>ee719846</doc-id>
            <unmanaged>WICPngChrmBlueY</unmanaged>
            <unmanaged-short>WICPngChrmBlueY</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngFilterOption">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) filters available for compression optimization.</p>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterOption</unmanaged>
            <unmanaged-short>WICPngFilterOption</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.Unspecified">
            <summary>
            <dd> <p>Indicates an unspecified PNG filter. This enables WIC to algorithmically choose the best filtering option for the image.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterUnspecified</unmanaged>
            <unmanaged-short>WICPngFilterUnspecified</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.None">
            <summary>
            <dd> <p>Indicates no PNG filter.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterNone</unmanaged>
            <unmanaged-short>WICPngFilterNone</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.Sub">
            <summary>
            <dd> <p>Indicates a PNG sub filter.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterSub</unmanaged>
            <unmanaged-short>WICPngFilterSub</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.Up">
            <summary>
            <dd> <p>Indicates a PNG up filter.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterUp</unmanaged>
            <unmanaged-short>WICPngFilterUp</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.Average">
            <summary>
            <dd> <p>Indicates a PNG average filter.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterAverage</unmanaged>
            <unmanaged-short>WICPngFilterAverage</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.Paeth">
            <summary>
            <dd> <p>Indicates a PNG paeth filter.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterPaeth</unmanaged>
            <unmanaged-short>WICPngFilterPaeth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngFilterOption.Adaptive">
            <summary>
            <dd> <p>Indicates a PNG adaptive filter. This enables WIC to choose the best filtering mode on a per-scanline basis.</p> </dd>
            </summary>
            <doc-id>ee719847</doc-id>
            <unmanaged>WICPngFilterAdaptive</unmanaged>
            <unmanaged-short>WICPngFilterAdaptive</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngGamaProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) gAMA chunk metadata properties.</p>
            </summary>
            <doc-id>ee719848</doc-id>
            <unmanaged>WICPngGamaProperties</unmanaged>
            <unmanaged-short>WICPngGamaProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngGamaProperties.Gamma">
            <summary>
            <dd> <p>[VT_UI4] Indicates the gamma value.</p> </dd>
            </summary>
            <doc-id>ee719848</doc-id>
            <unmanaged>WICPngGamaGamma</unmanaged>
            <unmanaged-short>WICPngGamaGamma</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngHistProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) hIST chunk metadata properties.</p>
            </summary>
            <doc-id>ee719849</doc-id>
            <unmanaged>WICPngHistProperties</unmanaged>
            <unmanaged-short>WICPngHistProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngHistProperties.Frequencies">
            <summary>
            <dd> <p>[VT_VECTOR | VT_UI2] Indicates the approximate usage frequency of each color in the color palette. </p> </dd>
            </summary>
            <doc-id>ee719849</doc-id>
            <unmanaged>WICPngHistFrequencies</unmanaged>
            <unmanaged-short>WICPngHistFrequencies</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngIccpProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) iCCP chunk metadata properties.</p>
            </summary>
            <doc-id>ee719850</doc-id>
            <unmanaged>WICPngIccpProperties</unmanaged>
            <unmanaged-short>WICPngIccpProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngIccpProperties.ProfileName">
            <summary>
            <dd> <p>[VT_LPSTR] Indicates the International Color Consortium (ICC) profile name.</p> </dd>
            </summary>
            <doc-id>ee719850</doc-id>
            <unmanaged>WICPngIccpProfileName</unmanaged>
            <unmanaged-short>WICPngIccpProfileName</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngIccpProperties.ProfileData">
            <summary>
            <dd> <p>[VT_VECTOR | VT_UI1] Indicates the embedded ICC profile.</p> </dd>
            </summary>
            <doc-id>ee719850</doc-id>
            <unmanaged>WICPngIccpProfileData</unmanaged>
            <unmanaged-short>WICPngIccpProfileData</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngItxtProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) iTXT chunk metadata properties.</p>
            </summary>
            <doc-id>ee719851</doc-id>
            <unmanaged>WICPngItxtProperties</unmanaged>
            <unmanaged-short>WICPngItxtProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngItxtProperties.Keyword">
            <summary>
            <dd> <p>[VT_LPSTR] Indicates the keywords in the iTXT metadata chunk.</p> </dd>
            </summary>
            <doc-id>ee719851</doc-id>
            <unmanaged>WICPngItxtKeyword</unmanaged>
            <unmanaged-short>WICPngItxtKeyword</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngItxtProperties.CompressionFlag">
            <summary>
            <dd> <p>[VT_UI1] Indicates whether the text in the iTXT chunk is compressed. 1 if the text is compressed; otherwise, 0.</p> </dd>
            </summary>
            <doc-id>ee719851</doc-id>
            <unmanaged>WICPngItxtCompressionFlag</unmanaged>
            <unmanaged-short>WICPngItxtCompressionFlag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngItxtProperties.LanguageTag">
            <summary>
            <dd> <p>[VT_LPSTR] Indicates the human language used by the translated keyword and the text.</p> </dd>
            </summary>
            <doc-id>ee719851</doc-id>
            <unmanaged>WICPngItxtLanguageTag</unmanaged>
            <unmanaged-short>WICPngItxtLanguageTag</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngItxtProperties.TranslatedKeyword">
            <summary>
            <dd> <p>[VT_LPWSTR] Indicates a translation of the keyword into the language indicated by the language tag.</p> </dd>
            </summary>
            <doc-id>ee719851</doc-id>
            <unmanaged>WICPngItxtTranslatedKeyword</unmanaged>
            <unmanaged-short>WICPngItxtTranslatedKeyword</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngItxtProperties.Text">
            <summary>
            <dd> <p>[VT_LPWSTR] Indicates additional text in the iTXT metadata chunk.</p> </dd>
            </summary>
            <doc-id>ee719851</doc-id>
            <unmanaged>WICPngItxtText</unmanaged>
            <unmanaged-short>WICPngItxtText</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngSrgbProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) sRGB chunk metadata properties.</p>
            </summary>
            <doc-id>ee719852</doc-id>
            <unmanaged>WICPngSrgbProperties</unmanaged>
            <unmanaged-short>WICPngSrgbProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngSrgbProperties.RenderingIntent">
            <summary>
            <dd> <p>[VT_UI1] Indicates the rendering intent for an sRGB color space image. The rendering intents have the following meaning.</p> <table> <tr><th>Value</th><th>Meaning</th></tr> <tr><td>0</td><td>Perceptual</td></tr> <tr><td>1</td><td>Relative colorimetric</td></tr> <tr><td>2</td><td>Saturation</td></tr> <tr><td>3</td><td>Absolute colorimetric</td></tr> </table> <p>?</p> </dd>
            </summary>
            <doc-id>ee719852</doc-id>
            <unmanaged>WICPngSrgbRenderingIntent</unmanaged>
            <unmanaged-short>WICPngSrgbRenderingIntent</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.PngTimeProperties">
            <summary>
            <p>Specifies the Portable Network Graphics (PNG) tIME chunk metadata properties.</p>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeProperties</unmanaged>
            <unmanaged-short>WICPngTimeProperties</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngTimeProperties.Year">
            <summary>
            <dd> <p>[VT_UI2] Indicates the year of the last modification.</p> </dd>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeYear</unmanaged>
            <unmanaged-short>WICPngTimeYear</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngTimeProperties.Month">
            <summary>
            <dd> <p>[VT_UI1] Indicates the month of the last modification.</p> </dd>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeMonth</unmanaged>
            <unmanaged-short>WICPngTimeMonth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngTimeProperties.Day">
            <summary>
            <dd> <p>[VT_UI1] Indicates day of the last modification.</p> </dd>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeDay</unmanaged>
            <unmanaged-short>WICPngTimeDay</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngTimeProperties.Hour">
            <summary>
            <dd> <p>[VT_UI1] Indicates the hour of the last modification.</p> </dd>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeHour</unmanaged>
            <unmanaged-short>WICPngTimeHour</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngTimeProperties.Minute">
            <summary>
            <dd> <p>[VT_UI1] Indicates the minute of the last modification.</p> </dd>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeMinute</unmanaged>
            <unmanaged-short>WICPngTimeMinute</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.PngTimeProperties.Second">
            <summary>
            <dd> <p>[VT_UI1] Indicates the second of the last modification.</p> </dd>
            </summary>
            <doc-id>ee719853</doc-id>
            <unmanaged>WICPngTimeSecond</unmanaged>
            <unmanaged-short>WICPngTimeSecond</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressNotification.Begin">
            <summary>
            <dd> <p>The callback should be called when codec operations begin.</p> </dd>
            </summary>
            <doc-id>ee719854</doc-id>
            <unmanaged>WICProgressNotificationBegin</unmanaged>
            <unmanaged-short>WICProgressNotificationBegin</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressNotification.End">
            <summary>
            <dd> <p>The callback should be called when codec operations end.</p> </dd>
            </summary>
            <doc-id>ee719854</doc-id>
            <unmanaged>WICProgressNotificationEnd</unmanaged>
            <unmanaged-short>WICProgressNotificationEnd</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressNotification.Frequent">
            <summary>
            <dd> <p>The callback should be called frequently to report status.</p> </dd>
            </summary>
            <doc-id>ee719854</doc-id>
            <unmanaged>WICProgressNotificationFrequent</unmanaged>
            <unmanaged-short>WICProgressNotificationFrequent</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressNotification.All">
            <summary>
            <dd> <p>The callback should be called on all available progress notifications.</p> </dd>
            </summary>
            <doc-id>ee719854</doc-id>
            <unmanaged>WICProgressNotificationAll</unmanaged>
            <unmanaged-short>WICProgressNotificationAll</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressOperation.CopyPixels">
            <summary>
            <dd> <p>Receive copy pixel operation.</p> </dd>
            </summary>
            <doc-id>ee719855</doc-id>
            <unmanaged>WICProgressOperationCopyPixels</unmanaged>
            <unmanaged-short>WICProgressOperationCopyPixels</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressOperation.WritePixels">
            <summary>
            <dd> <p>Receive write pixel operation.</p> </dd>
            </summary>
            <doc-id>ee719855</doc-id>
            <unmanaged>WICProgressOperationWritePixels</unmanaged>
            <unmanaged-short>WICProgressOperationWritePixels</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.ProgressOperation.All">
            <summary>
            <dd> <p>Receive all progress operations available.</p> </dd>
            </summary>
            <doc-id>ee719855</doc-id>
            <unmanaged>WICProgressOperationAll</unmanaged>
            <unmanaged-short>WICProgressOperationAll</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawCapabilities">
            <summary>
            <p>Specifies the capability support of a raw image.</p>
            </summary>
            <doc-id>ee719856</doc-id>
            <unmanaged>WICRawCapabilities</unmanaged>
            <unmanaged-short>WICRawCapabilities</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilities.NotSupported">
            <summary>
            <dd> <p>The capability is not supported.</p> </dd>
            </summary>
            <doc-id>ee719856</doc-id>
            <unmanaged>WICRawCapabilityNotSupported</unmanaged>
            <unmanaged-short>WICRawCapabilityNotSupported</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilities.GetSupported">
            <summary>
            <dd> <p>The capability supports only get operations.</p> </dd>
            </summary>
            <doc-id>ee719856</doc-id>
            <unmanaged>WICRawCapabilityGetSupported</unmanaged>
            <unmanaged-short>WICRawCapabilityGetSupported</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilities.FullySupported">
            <summary>
            <dd> <p>The capability supports get and set operations.</p> </dd>
            </summary>
            <doc-id>ee719856</doc-id>
            <unmanaged>WICRawCapabilityFullySupported</unmanaged>
            <unmanaged-short>WICRawCapabilityFullySupported</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawParameterSet">
            <summary>
            <p>Specifies the parameter set used by a raw codec.</p>
            </summary>
            <doc-id>ee719858</doc-id>
            <unmanaged>WICRawParameterSet</unmanaged>
            <unmanaged-short>WICRawParameterSet</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawParameterSet.AsShot">
            <summary>
            <dd> <p>An as shot parameter set.</p> </dd>
            </summary>
            <doc-id>ee719858</doc-id>
            <unmanaged>WICAsShotParameterSet</unmanaged>
            <unmanaged-short>WICAsShotParameterSet</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawParameterSet.UserAdjusted">
            <summary>
            <dd> <p>A user adjusted parameter set.</p> </dd>
            </summary>
            <doc-id>ee719858</doc-id>
            <unmanaged>WICUserAdjustedParameterSet</unmanaged>
            <unmanaged-short>WICUserAdjustedParameterSet</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawParameterSet.AutoAdjusted">
            <summary>
            <dd> <p>A codec adjusted parameter set.</p> </dd>
            </summary>
            <doc-id>ee719858</doc-id>
            <unmanaged>WICAutoAdjustedParameterSet</unmanaged>
            <unmanaged-short>WICAutoAdjustedParameterSet</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawRenderMode">
            <summary>
            <p>Specifies the render intent of the next <strong>CopyPixels</strong> call. </p>
            </summary>
            <doc-id>ee719859</doc-id>
            <unmanaged>WICRawRenderMode</unmanaged>
            <unmanaged-short>WICRawRenderMode</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRenderMode.Draft">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719859</doc-id>
            <unmanaged>WICRawRenderModeDraft</unmanaged>
            <unmanaged-short>WICRawRenderModeDraft</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRenderMode.Normal">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719859</doc-id>
            <unmanaged>WICRawRenderModeNormal</unmanaged>
            <unmanaged-short>WICRawRenderModeNormal</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRenderMode.BestQuality">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719859</doc-id>
            <unmanaged>WICRawRenderModeBestQuality</unmanaged>
            <unmanaged-short>WICRawRenderModeBestQuality</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawRotationCapabilities">
            <summary>
            <p>Specifies the rotation capabilities of the codec.</p>
            </summary>
            <doc-id>ee719860</doc-id>
            <unmanaged>WICRawRotationCapabilities</unmanaged>
            <unmanaged-short>WICRawRotationCapabilities</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRotationCapabilities.NotSupported">
            <summary>
            <dd> <p>Rotation is not supported.</p> </dd>
            </summary>
            <doc-id>ee719860</doc-id>
            <unmanaged>WICRawRotationCapabilityNotSupported</unmanaged>
            <unmanaged-short>WICRawRotationCapabilityNotSupported</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRotationCapabilities.GetSupported">
            <summary>
            <dd> <p>Set operations for rotation is not supported.</p> </dd>
            </summary>
            <doc-id>ee719860</doc-id>
            <unmanaged>WICRawRotationCapabilityGetSupported</unmanaged>
            <unmanaged-short>WICRawRotationCapabilityGetSupported</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRotationCapabilities.NinetyDegreesSupported">
            <summary>
            <dd> <p>90 degree rotations are supported.</p> </dd>
            </summary>
            <doc-id>ee719860</doc-id>
            <unmanaged>WICRawRotationCapabilityNinetyDegreesSupported</unmanaged>
            <unmanaged-short>WICRawRotationCapabilityNinetyDegreesSupported</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawRotationCapabilities.FullySupported">
            <summary>
            <dd> <p>All rotation angles are supported.</p> </dd>
            </summary>
            <doc-id>ee719860</doc-id>
            <unmanaged>WICRawRotationCapabilityFullySupported</unmanaged>
            <unmanaged-short>WICRawRotationCapabilityFullySupported</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.SectionAccessLevel">
            <summary>
            <p>Specifies the access level of a Windows Graphics Device Interface (GDI) section.</p>
            </summary>
            <doc-id>ee719864</doc-id>
            <unmanaged>WICSectionAccessLevel</unmanaged>
            <unmanaged-short>WICSectionAccessLevel</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.SectionAccessLevel.Read">
            <summary>
            <dd> <p>Indicates a read only access level.</p> </dd>
            </summary>
            <doc-id>ee719864</doc-id>
            <unmanaged>WICSectionAccessLevelRead</unmanaged>
            <unmanaged-short>WICSectionAccessLevelRead</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.SectionAccessLevel.ReadWrite">
            <summary>
            <dd> <p>Indicates a read/write access level.</p> </dd>
            </summary>
            <doc-id>ee719864</doc-id>
            <unmanaged>WICSectionAccessLevelReadWrite</unmanaged>
            <unmanaged-short>WICSectionAccessLevelReadWrite</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.TiffCompressionOption">
            <summary>
            <p>Specifies the Tagged Image File Format (TIFF) compression options.</p>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionOption</unmanaged>
            <unmanaged-short>WICTiffCompressionOption</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.DontCare">
            <summary>
            <dd> <p>Indicates a suitable compression algorithm based on the image and pixel format.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionDontCare</unmanaged>
            <unmanaged-short>WICTiffCompressionDontCare</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.None">
            <summary>
            <dd> <p>Indicates no compression.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionNone</unmanaged>
            <unmanaged-short>WICTiffCompressionNone</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.CCITT3">
            <summary>
            <dd> <p>Indicates a CCITT3 compression algorithm. This algorithm is only valid for 1bpp pixel formats.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionCCITT3</unmanaged>
            <unmanaged-short>WICTiffCompressionCCITT3</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.CCITT4">
            <summary>
            <dd> <p>Indicates a CCITT4 compression algorithm. This algorithm is only valid for 1bpp pixel formats.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionCCITT4</unmanaged>
            <unmanaged-short>WICTiffCompressionCCITT4</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.LZW">
            <summary>
            <dd> <p>Indicates a LZW compression algorithm.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionLZW</unmanaged>
            <unmanaged-short>WICTiffCompressionLZW</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.RLE">
            <summary>
            <dd> <p>Indicates a RLE compression algorithm. This algorithm is only valid for 1bpp pixel formats.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionRLE</unmanaged>
            <unmanaged-short>WICTiffCompressionRLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.ZIP">
            <summary>
            <dd> <p>Indicates a ZIP compression algorithm.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionZIP</unmanaged>
            <unmanaged-short>WICTiffCompressionZIP</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.TiffCompressionOption.LZWHDifferencing">
            <summary>
            <dd> <p>Indicates an LZWH differencing algorithm.</p> </dd>
            </summary>
            <doc-id>ee719867</doc-id>
            <unmanaged>WICTiffCompressionLZWHDifferencing</unmanaged>
            <unmanaged-short>WICTiffCompressionLZWHDifferencing</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapDecoderGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Png">
            <summary>Constant Png</summary>
            <unmanaged>CLSID_WICPngDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Bmp">
            <summary>Constant Bmp</summary>
            <unmanaged>CLSID_WICBmpDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Ico">
            <summary>Constant Ico</summary>
            <unmanaged>CLSID_WICIcoDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Jpeg">
            <summary>Constant Jpeg</summary>
            <unmanaged>CLSID_WICJpegDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Gif">
            <summary>Constant Gif</summary>
            <unmanaged>CLSID_WICGifDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Tiff">
            <summary>Constant Tiff</summary>
            <unmanaged>CLSID_WICTiffDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Wmp">
            <summary>Constant Wmp</summary>
            <unmanaged>CLSID_WICWmpDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Dds">
            <summary>Constant Dds</summary>
            <unmanaged>CLSID_WICDdsDecoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapDecoderGuids.Adng">
            <summary>Constant Adng</summary>
            <unmanaged>CLSID_WICAdngDecoder</unmanaged>
        </member>
        <member name="T:SharpDX.WIC.BitmapEncoderGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Bmp">
            <summary>Constant Bmp</summary>
            <unmanaged>CLSID_WICBmpEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Png">
            <summary>Constant Png</summary>
            <unmanaged>CLSID_WICPngEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Jpeg">
            <summary>Constant Jpeg</summary>
            <unmanaged>CLSID_WICJpegEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Gif">
            <summary>Constant Gif</summary>
            <unmanaged>CLSID_WICGifEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Tiff">
            <summary>Constant Tiff</summary>
            <unmanaged>CLSID_WICTiffEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Wmp">
            <summary>Constant Wmp</summary>
            <unmanaged>CLSID_WICWmpEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.Dds">
            <summary>Constant Dds</summary>
            <unmanaged>CLSID_WICDdsEncoder</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.BitmapEncoderGuids.JpegQualcommPhone">
            <summary>Constant JpegQualcommPhone</summary>
            <unmanaged>CLSID_WICJpegQualcommPhoneEncoder</unmanaged>
        </member>
        <member name="T:SharpDX.WIC.ContainerFormatGuids">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Bmp">
            <summary>Constant Bmp</summary>
            <unmanaged>GUID_ContainerFormatBmp</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Png">
            <summary>Constant Png</summary>
            <unmanaged>GUID_ContainerFormatPng</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Ico">
            <summary>Constant Ico</summary>
            <unmanaged>GUID_ContainerFormatIco</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Jpeg">
            <summary>Constant Jpeg</summary>
            <unmanaged>GUID_ContainerFormatJpeg</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Tiff">
            <summary>Constant Tiff</summary>
            <unmanaged>GUID_ContainerFormatTiff</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Gif">
            <summary>Constant Gif</summary>
            <unmanaged>GUID_ContainerFormatGif</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Wmp">
            <summary>Constant Wmp</summary>
            <unmanaged>GUID_ContainerFormatWmp</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Dds">
            <summary>Constant Dds</summary>
            <unmanaged>GUID_ContainerFormatDds</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ContainerFormatGuids.Adng">
            <summary>Constant Adng</summary>
            <unmanaged>GUID_ContainerFormatAdng</unmanaged>
        </member>
        <member name="T:SharpDX.WIC.ResultCode">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Base">
            <summary>Constant Base</summary>
            <unmanaged>WINCODEC_ERR_BASE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.GenericError">
            <summary>Constant GenericError</summary>
            <unmanaged>WINCODEC_ERR_GENERIC_ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.InvalidParameter">
            <summary>Constant InvalidParameter</summary>
            <unmanaged>WINCODEC_ERR_INVALIDPARAMETER</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.OufOfMemory">
            <summary>Constant OufOfMemory</summary>
            <unmanaged>WINCODEC_ERR_OUTOFMEMORY</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.NotImplemented">
            <summary>Constant NotImplemented</summary>
            <unmanaged>WINCODEC_ERR_NOTIMPLEMENTED</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Aborted">
            <summary>Constant Aborted</summary>
            <unmanaged>WINCODEC_ERR_ABORTED</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.AccessDenied">
            <summary>Constant AccessDenied</summary>
            <unmanaged>WINCODEC_ERR_ACCESSDENIED</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Valueoverflow">
            <summary>Constant Valueoverflow</summary>
            <unmanaged>WINCODEC_ERR_VALUEOVERFLOW</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.WrongState">
            <summary>Constant WrongState</summary>
            <unmanaged>WINCODEC_ERR_WRONGSTATE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Valueoutofrange">
            <summary>Constant Valueoutofrange</summary>
            <unmanaged>WINCODEC_ERR_VALUEOUTOFRANGE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Unknownimageformat">
            <summary>Constant Unknownimageformat</summary>
            <unmanaged>WINCODEC_ERR_UNKNOWNIMAGEFORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.UnsupportedVersion">
            <summary>Constant UnsupportedVersion</summary>
            <unmanaged>WINCODEC_ERR_UNSUPPORTEDVERSION</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.NotInitializeD">
            <summary>Constant NotInitializeD</summary>
            <unmanaged>WINCODEC_ERR_NOTINITIALIZED</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Alreadylocked">
            <summary>Constant Alreadylocked</summary>
            <unmanaged>WINCODEC_ERR_ALREADYLOCKED</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Propertynotfound">
            <summary>Constant Propertynotfound</summary>
            <unmanaged>WINCODEC_ERR_PROPERTYNOTFOUND</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Propertynotsupported">
            <summary>Constant Propertynotsupported</summary>
            <unmanaged>WINCODEC_ERR_PROPERTYNOTSUPPORTED</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Propertysize">
            <summary>Constant Propertysize</summary>
            <unmanaged>WINCODEC_ERR_PROPERTYSIZE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Codecpresent">
            <summary>Constant Codecpresent</summary>
            <unmanaged>WINCODEC_ERR_CODECPRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Codecnothumbnail">
            <summary>Constant Codecnothumbnail</summary>
            <unmanaged>WINCODEC_ERR_CODECNOTHUMBNAIL</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Paletteunavailable">
            <summary>Constant Paletteunavailable</summary>
            <unmanaged>WINCODEC_ERR_PALETTEUNAVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Codectoomanyscanlines">
            <summary>Constant Codectoomanyscanlines</summary>
            <unmanaged>WINCODEC_ERR_CODECTOOMANYSCANLINES</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Internalerror">
            <summary>Constant Internalerror</summary>
            <unmanaged>WINCODEC_ERR_INTERNALERROR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.SourceRectangleDoesnotmatchdimensions">
            <summary>Constant SourceRectangleDoesnotmatchdimensions</summary>
            <unmanaged>WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Componentnotfound">
            <summary>Constant Componentnotfound</summary>
            <unmanaged>WINCODEC_ERR_COMPONENTNOTFOUND</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Imagesizeoutofrange">
            <summary>Constant Imagesizeoutofrange</summary>
            <unmanaged>WINCODEC_ERR_IMAGESIZEOUTOFRANGE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.TooMuchmetadata">
            <summary>Constant TooMuchmetadata</summary>
            <unmanaged>WINCODEC_ERR_TOOMUCHMETADATA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Badimage">
            <summary>Constant Badimage</summary>
            <unmanaged>WINCODEC_ERR_BADIMAGE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Badheader">
            <summary>Constant Badheader</summary>
            <unmanaged>WINCODEC_ERR_BADHEADER</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.FrameMissing">
            <summary>Constant FrameMissing</summary>
            <unmanaged>WINCODEC_ERR_FRAMEMISSING</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Badmetadataheader">
            <summary>Constant Badmetadataheader</summary>
            <unmanaged>WINCODEC_ERR_BADMETADATAHEADER</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Badstreamdata">
            <summary>Constant Badstreamdata</summary>
            <unmanaged>WINCODEC_ERR_BADSTREAMDATA</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.StreamWrite">
            <summary>Constant StreamWrite</summary>
            <unmanaged>WINCODEC_ERR_STREAMWRITE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.StreamRead">
            <summary>Constant StreamRead</summary>
            <unmanaged>WINCODEC_ERR_STREAMREAD</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.StreamNotAvailable">
            <summary>Constant StreamNotAvailable</summary>
            <unmanaged>WINCODEC_ERR_STREAMNOTAVAILABLE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.UnsupportedPixelFormat">
            <summary>Constant UnsupportedPixelFormat</summary>
            <unmanaged>WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.UnsupportedOperation">
            <summary>Constant UnsupportedOperation</summary>
            <unmanaged>WINCODEC_ERR_UNSUPPORTEDOPERATION</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.InvalidRegistration">
            <summary>Constant InvalidRegistration</summary>
            <unmanaged>WINCODEC_ERR_INVALIDREGISTRATION</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Componentinitializefailure">
            <summary>Constant Componentinitializefailure</summary>
            <unmanaged>WINCODEC_ERR_COMPONENTINITIALIZEFAILURE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Insufficientbuffer">
            <summary>Constant Insufficientbuffer</summary>
            <unmanaged>WINCODEC_ERR_INSUFFICIENTBUFFER</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Duplicatemetadatapresent">
            <summary>Constant Duplicatemetadatapresent</summary>
            <unmanaged>WINCODEC_ERR_DUPLICATEMETADATAPRESENT</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Propertyunexpectedtype">
            <summary>Constant Propertyunexpectedtype</summary>
            <unmanaged>WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.UnexpectedSize">
            <summary>Constant UnexpectedSize</summary>
            <unmanaged>WINCODEC_ERR_UNEXPECTEDSIZE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.InvalidQueryRequest">
            <summary>Constant InvalidQueryRequest</summary>
            <unmanaged>WINCODEC_ERR_INVALIDQUERYREQUEST</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.UnexpectedMetadataType">
            <summary>Constant UnexpectedMetadataType</summary>
            <unmanaged>WINCODEC_ERR_UNEXPECTEDMETADATATYPE</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Requestonlyvalidatmetadataroot">
            <summary>Constant Requestonlyvalidatmetadataroot</summary>
            <unmanaged>WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.InvalidQueryCharacter">
            <summary>Constant InvalidQueryCharacter</summary>
            <unmanaged>WINCODEC_ERR_INVALIDQUERYCHARACTER</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.Win32error">
            <summary>Constant Win32error</summary>
            <unmanaged>WINCODEC_ERR_WIN32ERROR</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.InvalidProgressivelevel">
            <summary>Constant InvalidProgressivelevel</summary>
            <unmanaged>WINCODEC_ERR_INVALIDPROGRESSIVELEVEL</unmanaged>
        </member>
        <member name="F:SharpDX.WIC.ResultCode.InvalidJpegscanindex">
            <summary>Constant InvalidJpegscanindex</summary>
            <unmanaged>WINCODEC_ERR_INVALIDJPEGSCANINDEX</unmanaged>
        </member>
        <member name="M:SharpDX.WIC.BitmapCodecProgressNotification.RegisterProgressNotification(SharpDX.FunctionCallback,System.IntPtr,System.Int32)">
            <summary>
            <p>Registers a progress notification callback function.</p>
            </summary>
            <param name = "fnProgressNotificationRef"><dd>  <p>A function reference to the application defined progress notification callback function. See <strong>ProgressNotificationCallback</strong> for the callback signature.</p> </dd></param>
            <param name = "vDataRef"><dd>  <p>A reference to component data for the callback method.</p> </dd></param>
            <param name = "progressFlags"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.ProgressOperation"/></strong> and <strong><see cref = "T:SharpDX.WIC.ProgressNotification"/></strong> flags to use for progress notification.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Applications can only register a single callback. Subsequent registration calls will replace the previously registered callback. To unregister a callback, pass in <strong><c>null</c></strong> or register a new callback function.</p><p> Progress is reported in an increasing order between 0.0 and 1.0.  If <em>dwProgressFlags</em> includes <strong>WICProgressNotificationBegin</strong>, the callback is guaranteed to be called with progress 0.0. If <em>dwProgressFlags</em> includes <strong>WICProgressNotificationEnd</strong>, the callback is guaranteed to be called with progress 1.0. </p><p><strong>WICProgressNotificationFrequent</strong> increases the frequency in which the callback is called. If an operation is expected to take more than 30 seconds, <strong>WICProgressNotificationFrequent</strong> should be added to <em>dwProgressFlags</em>. </p>
            </remarks>
            <doc-id>ee690085</doc-id>
            <unmanaged>HRESULT IWICBitmapCodecProgressNotification::RegisterProgressNotification([In, Optional] __function__stdcall* pfnProgressNotification,[In, Optional] void* pvData,[In] DWORD dwProgressFlags)</unmanaged>
            <unmanaged-short>IWICBitmapCodecProgressNotification::RegisterProgressNotification</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.BitmapEncoderInfo.CreateInstance(SharpDX.WIC.BitmapEncoder@)">
            <summary>
            <p>Creates a new <strong><see cref = "T:SharpDX.WIC.BitmapEncoder"/></strong> instance.</p>
            </summary>
            <param name = "bitmapEncoderOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690113</doc-id>
            <unmanaged>HRESULT IWICBitmapEncoderInfo::CreateInstance([Out] IWICBitmapEncoder** ppIBitmapEncoder)</unmanaged>
            <unmanaged-short>IWICBitmapEncoderInfo::CreateInstance</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DdsDecoder.Parameters">
            <summary>
            <p>Gets DDS-specific data.</p>
            </summary>
            <doc-id>dn302081</doc-id>
            <unmanaged>GetParameters</unmanaged>
            <unmanaged-short>GetParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsDecoder.GetParameters(SharpDX.WIC.DdsParameters@)">
            <summary>
            <p>Gets DDS-specific data.</p>
            </summary>
            <param name = "parametersRef"><dd>  <p>A reference to the structure where the information is returned.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302081</doc-id>
            <unmanaged>HRESULT IWICDdsDecoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>
            <unmanaged-short>IWICDdsDecoder::GetParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsDecoder.GetFrame(System.Int32,System.Int32,System.Int32,SharpDX.WIC.BitmapFrameDecode@)">
            <summary>
            <p>Retrieves the specified frame of the DDS image.</p>
            </summary>
            <param name = "arrayIndex"><dd>  <p> The requested index within the texture array.</p> </dd></param>
            <param name = "mipLevel"><dd>  <p> The requested mip level.</p> </dd></param>
            <param name = "sliceIndex"><dd>  <p>The requested slice within the 3D texture.</p> </dd></param>
            <param name = "bitmapFrameOut"><dd>  <p>A reference to a  <strong><see cref = "T:SharpDX.WIC.BitmapFrameDecode"/></strong> object.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>A DDS file can contain multiple images that are organized into a three level hierarchy. First, DDS file may contain multiple textures in a texture array. Second, each texture can have multiple mip levels. Finally, the texture may be a 3D (volume) texture and have multiple slices, each of which is a 2D texture. See the DDS documentation for more information.</p><p>WIC maps this three level hierarchy into a linear array of <strong><see cref = "T:SharpDX.WIC.BitmapFrameDecode"/></strong>, accessible via <strong>IWICBitmapDecoder::GetFrame</strong>. However, determining which frame corresponds to a triad of <em>arrayIndex</em>, <em>mipLevel</em>, and <em>sliceIndex</em> value is not trivial because each mip level of a 3D texture has a different depth (number of slices). This method provides additional convenience over <strong>IWICBitmapDecoder::GetFrame</strong> for DDS images by calculating the correct frame given the three indices.
            </p>
            </remarks>
            <doc-id>dn302080</doc-id>
            <unmanaged>HRESULT IWICDdsDecoder::GetFrame([In] unsigned int arrayIndex,[In] unsigned int mipLevel,[In] unsigned int sliceIndex,[Out] IWICBitmapFrameDecode** ppIBitmapFrame)</unmanaged>
            <unmanaged-short>IWICDdsDecoder::GetFrame</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DdsEncoder.Parameters">
            <summary>
            <p>Gets or sets DDS-specific data.</p>
            </summary>
            <remarks>
            <p>An application can call <strong>GetParameters</strong> to obtain the default DDS parameters, modify some or all of them, and then call <strong>SetParameters</strong>.</p>
            </remarks>
            <doc-id>dn302084</doc-id>
            <unmanaged>GetParameters / SetParameters</unmanaged>
            <unmanaged-short>GetParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsEncoder.SetParameters(SharpDX.WIC.DdsParameters@)">
            <summary>
            <p>Sets DDS-specific data.</p>
            </summary>
            <param name = "parametersRef"><dd>  <p>Points to the structure where the information is described.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>You cannot call this method after you have started to write frame data, for example by calling <strong>IWICDdsEncoder::CreateNewFrame</strong>. </p><p>Setting DDS parameters using this method provides the DDS encoder with information about the expected number of frames and the dimensions and other parameters of each frame. The DDS encoder will fail if you do not set frame data that matches these expectations. For example, if you set <strong>WICDdsParameters::Width</strong> and <strong>Height</strong> to 32, and <strong>MipLevels</strong> to 6, the DDS encoder will expect 6 frames with the following dimensions:</p><ul> <li>32x32 pixels.</li> <li>16x16 pixels.</li> <li>8x8 pixels.</li> <li>4x4 pixels.</li> <li>2x2 pixels.</li> <li>1x1 pixels.</li> </ul>
            </remarks>
            <doc-id>dn302085</doc-id>
            <unmanaged>HRESULT IWICDdsEncoder::SetParameters([In] WICDdsParameters* pParameters)</unmanaged>
            <unmanaged-short>IWICDdsEncoder::SetParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsEncoder.GetParameters(SharpDX.WIC.DdsParameters@)">
            <summary>
            <p>Gets DDS-specific data.</p>
            </summary>
            <param name = "parametersRef"><dd>  <p>Points to the structure where the information is returned.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>An application can call <strong>GetParameters</strong> to obtain the default DDS parameters, modify some or all of them, and then call <strong>SetParameters</strong>.</p>
            </remarks>
            <doc-id>dn302084</doc-id>
            <unmanaged>HRESULT IWICDdsEncoder::GetParameters([Out] WICDdsParameters* pParameters)</unmanaged>
            <unmanaged-short>IWICDdsEncoder::GetParameters</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DdsEncoder.CreateNewFrame(SharpDX.WIC.BitmapFrameEncode@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            <p>Creates a new frame to encode.</p>
            </summary>
            <param name = "frameEncodeOut"><dd> <p>A reference to the newly created frame object.</p> </dd></param>
            <param name = "arrayIndexRef"><dd> <p>Points to the location where the array index is returned.</p> </dd></param>
            <param name = "mipLevelRef"><dd> <p>Points to the location where the mip level index is returned.</p> </dd></param>
            <param name = "sliceIndexRef"><dd> <p>Points to the location where the slice index is returned.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This is equivalent to <strong>IWICBitmapEncoder::CreateNewFrame</strong>, but returns additional information about the array index, mip level and slice of the newly created frame. In contrast to <strong>IWICBitmapEncoder::CreateNewFrame</strong>, there is no <strong><see cref = "T:SharpDX.Win32.PropertyBag"/></strong>* parameter because individual DDS frames do not have separate properties.</p>
            </remarks>
            <doc-id>dn302083</doc-id>
            <unmanaged>HRESULT IWICDdsEncoder::CreateNewFrame([Out] IWICBitmapFrameEncode** ppIFrameEncode,[Out] unsigned int* pArrayIndex,[Out] unsigned int* pMipLevel,[Out] unsigned int* pSliceIndex)</unmanaged>
            <unmanaged-short>IWICDdsEncoder::CreateNewFrame</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.CurrentParameterSet">
            <summary>
            <p>Gets the current set of parameters.</p>
            </summary>
            <doc-id>ee690233</doc-id>
            <unmanaged>GetCurrentParameterSet</unmanaged>
            <unmanaged-short>GetCurrentParameterSet</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.ExposureCompensation">
            <summary>
            <p>Gets or sets the exposure compensation stop value of the raw image.</p>
            </summary>
            <doc-id>ee690234</doc-id>
            <unmanaged>GetExposureCompensation / SetExposureCompensation</unmanaged>
            <unmanaged-short>GetExposureCompensation</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.NamedWhitePoint">
            <summary>
            <p>Gets or sets the named white point of the raw image.</p>
            </summary>
            <remarks>
            <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in <strong><see cref = "T:SharpDX.WIC.NamedWhitePoint"/></strong>.</p>
            </remarks>
            <doc-id>ee690237</doc-id>
            <unmanaged>GetNamedWhitePoint / SetNamedWhitePoint</unmanaged>
            <unmanaged-short>GetNamedWhitePoint</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.WhitePointKelvin">
            <summary>
            <p>Gets or sets the white point Kelvin temperature of the raw image.</p>
            </summary>
            <doc-id>ee690245</doc-id>
            <unmanaged>GetWhitePointKelvin / SetWhitePointKelvin</unmanaged>
            <unmanaged-short>GetWhitePointKelvin</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.Contrast">
            <summary>
            <p>Gets or sets the contrast value of the raw image.</p>
            </summary>
            <doc-id>ee690232</doc-id>
            <unmanaged>GetContrast / SetContrast</unmanaged>
            <unmanaged-short>GetContrast</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.Gamma">
            <summary>
            <p>Gets or sets the current gamma setting of the raw image.</p>
            </summary>
            <doc-id>ee690235</doc-id>
            <unmanaged>GetGamma / SetGamma</unmanaged>
            <unmanaged-short>GetGamma</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.Sharpness">
            <summary>
            <p>Gets or sets the sharpness value of the raw image.</p>
            </summary>
            <doc-id>ee690242</doc-id>
            <unmanaged>GetSharpness / SetSharpness</unmanaged>
            <unmanaged-short>GetSharpness</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.Saturation">
            <summary>
            <p>Gets or sets the saturation value of the raw image.</p>
            </summary>
            <doc-id>ee690241</doc-id>
            <unmanaged>GetSaturation / SetSaturation</unmanaged>
            <unmanaged-short>GetSaturation</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.Tint">
            <summary>
            <p>Gets or sets the tint value of the raw image.</p>
            </summary>
            <doc-id>ee690243</doc-id>
            <unmanaged>GetTint / SetTint</unmanaged>
            <unmanaged-short>GetTint</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.NoiseReduction">
            <summary>
            <p>Gets or sets the noise reduction value of the raw image.</p>
            </summary>
            <doc-id>ee690238</doc-id>
            <unmanaged>GetNoiseReduction / SetNoiseReduction</unmanaged>
            <unmanaged-short>GetNoiseReduction</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.DestinationColorContext">
            <summary>
            <p>Sets the destination color context.</p>
            </summary>
            <doc-id>ee690250</doc-id>
            <unmanaged>SetDestinationColorContext</unmanaged>
            <unmanaged-short>SetDestinationColorContext</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.Rotation">
            <summary>
            <p>Gets or sets the current rotation angle.</p>
            </summary>
            <doc-id>ee690240</doc-id>
            <unmanaged>GetRotation / SetRotation</unmanaged>
            <unmanaged-short>GetRotation</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.RenderMode">
            <summary>
            <p>Gets or sets the current <strong><see cref = "T:SharpDX.WIC.RawRenderMode"/></strong>.</p>
            </summary>
            <doc-id>ee690239</doc-id>
            <unmanaged>GetRenderMode / SetRenderMode</unmanaged>
            <unmanaged-short>GetRenderMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.DevelopRaw.NotificationCallback">
            <summary>
            <p>Sets the notification callback method.</p>
            </summary>
            <doc-id>ee690255</doc-id>
            <unmanaged>SetNotificationCallback</unmanaged>
            <unmanaged-short>SetNotificationCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.QueryRawCapabilitiesInfo(SharpDX.WIC.RawCapabilitiesInfo@)">
            <summary>
            <p>Retrieves information about which capabilities are supported for a raw image.</p>
            </summary>
            <param name = "infoRef"><dd>  <p>A reference that receives <strong><see cref = "T:SharpDX.WIC.RawCapabilitiesInfo"/></strong> that provides the capabilities supported by the raw image.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>It is recommended that a codec report that a capability is supported even if the results at the outer range limits are not of perfect quality.</p>
            </remarks>
            <doc-id>ee690248</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::QueryRawCapabilitiesInfo([In] WICRawCapabilitiesInfo* pInfo)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::QueryRawCapabilitiesInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.LoadParameterSet(SharpDX.WIC.RawParameterSet)">
            <summary>
            <p>Sets the desired <strong><see cref = "T:SharpDX.WIC.RawParameterSet"/></strong> option.</p>
            </summary>
            <param name = "parameterSet">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690247</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::LoadParameterSet([In] WICRawParameterSet ParameterSet)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::LoadParameterSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetCurrentParameterSet(SharpDX.Win32.PropertyBag@)">
            <summary>
            <p>Gets the current set of parameters.</p>
            </summary>
            <param name = "currentParameterSetOut"><dd>  <p>A reference that receives a reference to the current set of parameters.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690233</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetCurrentParameterSet([Out] IPropertyBag2** ppCurrentParameterSet)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetCurrentParameterSet</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetExposureCompensation(System.Double)">
            <summary>
            <p>Sets the exposure compensation stop value.</p>
            </summary>
            <param name = "ev"><dd>  <p>The exposure compensation value. The value range for exposure compensation is -5.0 through +5.0, which equates to 10 full stops.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>It is recommended that a codec report that this method is supported even if the results at the outer range limits are not of perfect quality.</p>
            </remarks>
            <doc-id>ee690251</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetExposureCompensation([In] double ev)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetExposureCompensation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetExposureCompensation(System.Double@)">
            <summary>
            <p>Gets the exposure compensation stop value of the raw image.</p>
            </summary>
            <param name = "eVRef"><dd>  <p>A reference that receives the exposure compensation stop value. The default is the "as-shot" setting.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690234</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetExposureCompensation([Out] double* pEV)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetExposureCompensation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetWhitePointRGB(System.Int32,System.Int32,System.Int32)">
            <summary>
            <p>Sets the white point RGB values.</p>
            </summary>
            <param name = "red"><dd>  <p>The red white point value.</p> </dd></param>
            <param name = "green"><dd>  <p>The green white point value.</p> </dd></param>
            <param name = "blue"><dd>  <p>The blue white point value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Due to other white point setting methods (e.g. <strong>SetWhitePointKelvin</strong>), care must be taken by codec implementers to ensure proper interoperability. For instance, if the caller sets via a named white point then the codec implementer may whis to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wishes to deny a given action because of previous calls, <strong><see cref = "!:WrongState"/></strong> should be returned.</p>
            </remarks>
            <doc-id>ee690263</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetWhitePointRGB([In] unsigned int Red,[In] unsigned int Green,[In] unsigned int Blue)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetWhitePointRGB</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetWhitePointRGB(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            <p>Gets the white point RGB values.</p>
            </summary>
            <param name = "redRef"><dd>  <p>A reference that receives the red white point value.</p> </dd></param>
            <param name = "greenRef"><dd>  <p>A reference that receives the green white point value.</p> </dd></param>
            <param name = "blueRef"><dd>  <p>A reference that receives the blue white point value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690246</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointRGB([Out] unsigned int* pRed,[Out] unsigned int* pGreen,[Out] unsigned int* pBlue)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetWhitePointRGB</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetNamedWhitePoint(SharpDX.WIC.NamedWhitePoint)">
            <summary>
            <p>Sets the named white point of the raw file.</p>
            </summary>
            <param name = "whitePoint"><dd>  <p>A bitwise combination of the enumeration values.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in the API.</p><p>Due to other white point setting methods (e.g. <strong>SetWhitePointKelvin</strong>), care must be taken by codec implementers to ensure proper interoperability. For instance, if the caller sets via a named white point then the codec implementer may whis to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wishes to deny a given action because of previous calls, <strong><see cref = "!:WrongState"/></strong> should be returned.</p>
            </remarks>
            <doc-id>ee690253</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetNamedWhitePoint([In] WICNamedWhitePoint WhitePoint)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetNamedWhitePoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetNamedWhitePoint(SharpDX.WIC.NamedWhitePoint@)">
            <summary>
            <p>Gets the named white point of the raw image.</p>
            </summary>
            <param name = "whitePointRef"><dd>  <p>A reference that receives the bitwise combination of the enumeration values.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the named white points are not supported by the raw image or the raw file contains named white points that are not supported by this API, the codec implementer should still mark this capability as supported.</p><p>If the named white points are not supported by the raw image, a best effort should be made to adjust the image to the named white point even when it isn't a pre-defined white point of the raw file.</p><p>If the raw file containes named white points not supported by this API, the codec implementer should support the named white points in <strong><see cref = "T:SharpDX.WIC.NamedWhitePoint"/></strong>.</p>
            </remarks>
            <doc-id>ee690237</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetNamedWhitePoint([Out] WICNamedWhitePoint* pWhitePoint)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetNamedWhitePoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetWhitePointKelvin(System.Int32)">
            <summary>
            <p>Sets the white point Kelvin value.</p>
            </summary>
            <param name = "whitePointKelvin"><dd>  <p>The white point Kelvin value. Acceptable Kelvin values are 1,500 through 30,000.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Codec implementers should faithfully adjust the color temperature within the range supported natively by the raw image. For values outside the native support range, the codec implementer should provide a best effort representation of the image at that color temperature.</p><p>Codec implementers should return <strong><see cref = "!:Valueoutofrange"/></strong> if the value is out of defined acceptable range.</p><p>Codec implementers must ensure proper interoperability with other white point setting methods such as <strong>SetWhitePointRGB</strong>. For example, if the caller sets the white point via <strong>SetNamedWhitePoint</strong> then the codec implementer may want to disable reading back the correspoinding Kelvin temperature. In specific cases where the codec implementer wants to deny a given action because of previous calls, <strong><see cref = "!:WrongState"/></strong> should be returned.</p>
            </remarks>
            <doc-id>ee690262</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetWhitePointKelvin([In] unsigned int WhitePointKelvin)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetWhitePointKelvin</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetWhitePointKelvin(System.Int32@)">
            <summary>
            <p>Gets the white point Kelvin temperature of the raw image.</p>
            </summary>
            <param name = "whitePointKelvinRef"><dd>  <p>A reference that receives the white point Kelvin temperature of the raw image. The default is the "as-shot" setting value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690245</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetWhitePointKelvin([Out] unsigned int* pWhitePointKelvin)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetWhitePointKelvin</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetKelvinRangeInfo(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            <p>Gets the information about the current Kelvin range of the raw image.</p>
            </summary>
            <param name = "minKelvinTempRef"><dd>  <p>A reference that receives the minimum Kelvin temperature.</p> </dd></param>
            <param name = "maxKelvinTempRef"><dd>  <p>A reference that receives the maximum Kelvin temperature. </p> </dd></param>
            <param name = "kelvinTempStepValueRef"><dd>  <p>A reference that receives the Kelvin step value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690236</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetKelvinRangeInfo([Out] unsigned int* pMinKelvinTemp,[Out] unsigned int* pMaxKelvinTemp,[Out] unsigned int* pKelvinTempStepValue)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetKelvinRangeInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetContrast(System.Double)">
            <summary>
            <p>Sets the contrast value of the raw image.</p>
            </summary>
            <param name = "contrast"><dd>  <p>The contrast value of the raw image.  The default value is the "as-shot" setting. The value range for contrast is 0.0 through 1.0. The 0.0 lower limit represents no contrast applied to the image, while the 1.0 upper limit represents the highest amount of contrast that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
            </remarks>
            <doc-id>ee690249</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetContrast([In] double Contrast)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetContrast</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetContrast(System.Double@)">
            <summary>
            <p>Gets the contrast value of the raw image.</p>
            </summary>
            <param name = "contrastRef"><dd>  <p>A reference that receives the contrast value of the raw image. The default value is the "as-shot" setting. The value range for contrast is 0.0 through 1.0. The 0.0 lower limit represents no contrast applied to the image, while the 1.0 upper limit represents the highest amount of contrast that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690232</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetContrast([Out] double* pContrast)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetContrast</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetGamma(System.Double)">
            <summary>
            <p>Sets the desired gamma value.</p>
            </summary>
            <param name = "gamma"><dd>  <p>The desired gamma value.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690252</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetGamma([In] double Gamma)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetGamma</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetGamma(System.Double@)">
            <summary>
            <p>Gets the current gamma setting of the raw image.</p>
            </summary>
            <param name = "gammaRef"><dd>  <p>A reference that receives the current gamma setting.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690235</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetGamma([Out] double* pGamma)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetGamma</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetSharpness(System.Double)">
            <summary>
            <p>Sets the sharpness value of the raw image.</p>
            </summary>
            <param name = "sharpness"><dd>  <p>The sharpness value of the raw image. The default value is the "as-shot" setting. The value range for sharpness is 0.0 through 1.0. The 0.0 lower limit represents no sharpening applied to the image, while the 1.0 upper limit represents the highest amount of sharpness that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
            </remarks>
            <doc-id>ee690259</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetSharpness([In] double Sharpness)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetSharpness</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetSharpness(System.Double@)">
            <summary>
            <p>Gets the sharpness value of the raw image.</p>
            </summary>
            <param name = "sharpnessRef"><dd>  <p>A reference that receives the sharpness value of the raw image. The default value is the "as-shot" setting. The value range for sharpness is 0.0 through 1.0. The 0.0 lower limit represents no sharpening applied to the image, while the 1.0 upper limit represents the highest amount of sharpness that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690242</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetSharpness([Out] double* pSharpness)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetSharpness</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetSaturation(System.Double)">
            <summary>
            <p>Sets the saturation value of the raw image.</p>
            </summary>
            <param name = "saturation"><dd>  <p>The saturation value of the raw image. The value range for saturation is 0.0 through 1.0. A value of 0.0 represents an image with a fully de-saturated image, while a value of 1.0 represents the highest amount of saturation that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
            </remarks>
            <doc-id>ee690258</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetSaturation([In] double Saturation)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetSaturation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetSaturation(System.Double@)">
            <summary>
            <p>Gets the saturation value of the raw image.</p>
            </summary>
            <param name = "saturationRef"><dd>  <p>A reference that receives the saturation value of the raw image. The default value is the "as-shot" setting. The value range for saturation is 0.0 through 1.0. A value of 0.0 represents an image with a fully de-saturated image, while a value of 1.0 represents the highest amount of saturation that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690241</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetSaturation([Out] double* pSaturation)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetSaturation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetTint(System.Double)">
            <summary>
            <p>Sets the tint value of the raw image.</p>
            </summary>
            <param name = "tint"><dd>  <p>The tint value of the raw image. The default value is the "as-shot" setting if it exists or 0.0. The value range for sharpness is -1.0 through +1.0. The -1.0 lower limit represents a full green bias to the image, while the 1.0 upper limit represents a full magenta bias.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The codec implementer must determine what the outer range values represent and must determine how to map the values to their image processing routines.</p>
            </remarks>
            <doc-id>ee690260</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetTint([In] double Tint)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetTint</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetTint(System.Double@)">
            <summary>
            <p>Gets the tint value of the raw image.</p>
            </summary>
            <param name = "tintRef"><dd>  <p>A reference that receives the tint value of the raw image. The default value is the "as-shot" setting if it exists or 0.0. The value range for sharpness is -1.0 through +1.0. The -1.0 lower limit represents a full green bias to the image, while the 1.0 upper limit represents a full magenta bias.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690243</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetTint([Out] double* pTint)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetTint</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetNoiseReduction(System.Double)">
            <summary>
            <p>Sets the noise reduction value of the raw image.</p>
            </summary>
            <param name = "noiseReduction"><dd>  <p>The noise reduction value of the raw image.  The default value is the "as-shot" setting if it exists or 0.0. The value range for noise reduction is 0.0 through 1.0. The 0.0 lower limit represents no noise reduction applied to the image, while the 1.0 upper limit represents highest noise reduction amount that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The codec implementer must determine what the upper range value represents and must determine how to map the value to their image processing routines.</p>
            </remarks>
            <doc-id>ee690254</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetNoiseReduction([In] double NoiseReduction)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetNoiseReduction</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetNoiseReduction(System.Double@)">
            <summary>
            <p>Gets the noise reduction value of the raw image.</p>
            </summary>
            <param name = "noiseReductionRef"><dd>  <p>A reference that receives the noise reduction value of the raw image.  The default value is the "as-shot" setting if it exists or 0.0. The value range for noise reduction is 0.0 through 1.0. The 0.0 lower limit represents no noise reduction applied to the image, while the 1.0 upper limit represents full highest noise reduction amount that can be applied.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690238</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetNoiseReduction([Out] double* pNoiseReduction)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetNoiseReduction</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetDestinationColorContext(SharpDX.WIC.ColorContext)">
            <summary>
            <p>Sets the destination color context.</p>
            </summary>
            <param name = "colorContextRef"><dd>  <p>The destination color context.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690250</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetDestinationColorContext([In, Optional] IWICColorContext* pColorContext)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetDestinationColorContext</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetToneCurve(System.Int32,SharpDX.WIC.RawToneCurve[])">
            <summary>
            <p>Sets the tone curve for the raw image.</p>
            </summary>
            <param name = "toneCurveSize"><dd>  <p>The size of the <em>pToneCurve</em> structure.</p> </dd></param>
            <param name = "toneCurveRef"><dd>  <p>The desired tone curve.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690261</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetToneCurve([In] unsigned int cbToneCurveSize,[In, Buffer] const WICRawToneCurve* pToneCurve)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetToneCurve</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetToneCurve(System.Int32,SharpDX.WIC.RawToneCurve[],System.IntPtr)">
            <summary>
            <p>Gets the tone curve of the raw image.</p>
            </summary>
            <param name = "toneCurveBufferSize"><dd>  <p>The size of the <em>pToneCurve</em> buffer.</p> </dd></param>
            <param name = "toneCurveRef"><dd>  <p>A reference that receives the <strong><see cref = "T:SharpDX.WIC.RawToneCurve"/></strong> of the raw image.</p> </dd></param>
            <param name = "actualToneCurveBufferSizeRef"><dd>  <p>A reference that receives the size needed to obtain the tone curve structure.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690244</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetToneCurve([In] unsigned int cbToneCurveBufferSize,[Out, Buffer, Optional] WICRawToneCurve* pToneCurve,[InOut, Optional] unsigned int* pcbActualToneCurveBufferSize)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetToneCurve</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetRotation(System.Double)">
            <summary>
            <p>Sets the desired rotation angle.</p>
            </summary>
            <param name = "rotation"><dd>  <p>The desired rotation angle.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690257</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetRotation([In] double Rotation)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetRotation(System.Double@)">
            <summary>
            <p>Gets the current rotation angle.</p>
            </summary>
            <param name = "rotationRef"><dd>  <p>A reference that receives the current rotation angle.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690240</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetRotation([Out] double* pRotation)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetRotation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetRenderMode(SharpDX.WIC.RawRenderMode)">
            <summary>
            <p>Sets the current <strong><see cref = "T:SharpDX.WIC.RawRenderMode"/></strong>.</p>
            </summary>
            <param name = "renderMode">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690256</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetRenderMode([In] WICRawRenderMode RenderMode)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetRenderMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.GetRenderMode(SharpDX.WIC.RawRenderMode@)">
            <summary>
            <p>Gets the current <strong><see cref = "T:SharpDX.WIC.RawRenderMode"/></strong>.</p>
            </summary>
            <param name = "renderModeRef">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690239</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::GetRenderMode([Out] WICRawRenderMode* pRenderMode)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::GetRenderMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRaw.SetNotificationCallback(SharpDX.WIC.DevelopRawNotificationCallback)">
            <summary>
            <p>Sets the notification callback method.</p>
            </summary>
            <param name = "callbackRef"><dd>  <p>Pointer to the notification callback method.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690255</doc-id>
            <unmanaged>HRESULT IWICDevelopRaw::SetNotificationCallback([In, Optional] IWICDevelopRawNotificationCallback* pCallback)</unmanaged>
            <unmanaged-short>IWICDevelopRaw::SetNotificationCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.DevelopRawNotificationCallback.Notify(System.Int32)">
            <summary>
            <p>An application-defined callback method used for raw image parameter change notifications.</p>
            </summary>
            <param name = "notificationMask"><dd>  <p>A set of <strong><see cref = "T:SharpDX.WIC.DevelopRawNotificationCallback"/> Constants</strong> parameter notification flags.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690230</doc-id>
            <unmanaged>HRESULT IWICDevelopRawNotificationCallback::Notify([In] unsigned int NotificationMask)</unmanaged>
            <unmanaged-short>IWICDevelopRawNotificationCallback::Notify</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.EnumMetadataItem.Skip(System.Int32)">
            <summary>
            <p>Skips to given number of objects.</p>
            </summary>
            <param name = "celt"><dd>  <p>The number of objects to skip.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690268</doc-id>
            <unmanaged>HRESULT IWICEnumMetadataItem::Skip([In] ULONG celt)</unmanaged>
            <unmanaged-short>IWICEnumMetadataItem::Skip</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.EnumMetadataItem.Reset">
            <summary>
            <p>Resets the current position to the beginning of the enumeration.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690267</doc-id>
            <unmanaged>HRESULT IWICEnumMetadataItem::Reset()</unmanaged>
            <unmanaged-short>IWICEnumMetadataItem::Reset</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.EnumMetadataItem.Clone(SharpDX.WIC.EnumMetadataItem@)">
            <summary>
            <p>Creates a copy of the current <strong><see cref = "T:SharpDX.WIC.EnumMetadataItem"/></strong>.</p>
            </summary>
            <param name = "enumMetadataItemOut">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee690265</doc-id>
            <unmanaged>HRESULT IWICEnumMetadataItem::Clone([Out] IWICEnumMetadataItem** ppIEnumMetadataItem)</unmanaged>
            <unmanaged-short>IWICEnumMetadataItem::Clone</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.JpegFrameDecode.FrameHeader">
            <summary>
            <p>Retrieves  header data from the entire frame.  The result includes parameters from the Start Of Frame (SOF) marker for the scan as well as parameters derived from other metadata such as the color model of the compressed data.</p>
            </summary>
            <doc-id>dn903851</doc-id>
            <unmanaged>GetFrameHeader</unmanaged>
            <unmanaged-short>GetFrameHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.DoesSupportIndexing(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Retrieves a value indicating whether this decoder supports indexing for efficient random access.</p>
            </summary>
            <param name = "fIndexingSupportedRef"><dd>  <p>True if indexing is supported; otherwise, false.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on successful completion.</p></returns>
            <remarks>
            <p>Indexing is only supported for some JPEG types. Call this method</p>
            </remarks>
            <doc-id>dn903843</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::DoesSupportIndexing([Out] BOOL* pfIndexingSupported)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::DoesSupportIndexing</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.SetIndexing(SharpDX.WIC.JpegIndexingOptions,System.Int32)">
            <summary>
            <p>Enables indexing of the JPEG for efficient random access.</p>
            </summary>
            <param name = "options"><dd>  <p>A value specifying whether indexes should be generated immediately or deferred until a future call to <strong>IWICBitmapSource::CopyPixels</strong>.</p> </dd></param>
            <param name = "horizontalIntervalSize"><dd>  <p>The granularity of the indexing, in pixels.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> upon successful completion.</p></returns>
            <remarks>
            <p>This method enables efficient random-access to the image pixels at the expense of memory usage.  The amount of memory required for indexing depends on the requested index granularity.   Unless <strong>SetIndexing</strong> is called, it is much more efficient to access a JPEG by progressing through its pixels top-down during calls to <strong>IWICBitmapSource::CopyPixels</strong>.
            </p><p>This method will fail if indexing is unsupported on the file.  <strong>IWICJpegFrameDecode::DoesSupportIndexing</strong> should be called to first determine whether indexing is supported.  If this method is called multiple times, the final call changes the index granularity to the requested size.
            </p><p>The provided interval size controls horizontal spacing of index entries.  This value is internally rounded up according to the JPEG?s MCU (minimum coded unit) size, which is typically either 8 or 16 unscaled pixels.  The vertical size of the index interval is always equal to one MCU size.</p><p> Indexes can be generated immediately, or during future calls to <strong>IWICBitmapSource::CopyPixels</strong> to reduce redundant decompression work. </p>
            </remarks>
            <doc-id>dn903861</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::SetIndexing([In] WICJpegIndexingOptions options,[In] unsigned int horizontalIntervalSize)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::SetIndexing</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.ClearIndexing">
            <summary>
            <p>Removes the indexing from a JPEG that has been indexed using <strong>IWICJpegFrameDecode::SetIndexing</strong>.</p>
            </summary>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> upons successful completion.</p></returns>
            <doc-id>dn903837</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::ClearIndexing()</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::ClearIndexing</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.GetAcHuffmanTable(System.Int32,System.Int32,SharpDX.DXGI.JpegAcHuffmanTable@)">
            <summary>
            <p>Retrieves a copy of the AC Huffman table for the specified scan and table.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "tableIndex"><dd>  <p>The index of the AC Huffman table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p> </dd></param>
            <param name = "acHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pAcHuffmanTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903845</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::GetAcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_AC_HUFFMAN_TABLE* pAcHuffmanTable)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::GetAcHuffmanTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.GetDcHuffmanTable(System.Int32,System.Int32,SharpDX.DXGI.JpegDeviceContextHuffmanTable@)">
            <summary>
            <p>Retrieves a copy of the DC Huffman table for the specified scan and table.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "tableIndex"><dd>  <p>The index of the DC Huffman table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p> </dd></param>
            <param name = "dcHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903848</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::GetDcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_DC_HUFFMAN_TABLE* pDcHuffmanTable)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::GetDcHuffmanTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.GetQuantizationTable(System.Int32,System.Int32,SharpDX.DXGI.JpegQuantizationTable@)">
            <summary>
            <p>Retrieves a copy of the quantization table.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "tableIndex"><dd>  <p>The index of the quantization table to retrieve. Valid indices for a given scan can be determined by retrieving the scan header with <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p> </dd></param>
            <param name = "quantizationTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903854</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::GetQuantizationTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_QUANTIZATION_TABLE* pQuantizationTable)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::GetQuantizationTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.GetFrameHeader(SharpDX.WIC.JpegFrameHeader@)">
            <summary>
            <p>Retrieves  header data from the entire frame.  The result includes parameters from the Start Of Frame (SOF) marker for the scan as well as parameters derived from other metadata such as the color model of the compressed data.</p>
            </summary>
            <param name = "frameHeaderRef"><dd>  <p>A reference that receives the frame header data.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on successful completion.</p></returns>
            <doc-id>dn903851</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::GetFrameHeader([Out] WICJpegFrameHeader* pFrameHeader)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::GetFrameHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.GetScanHeader(System.Int32,SharpDX.WIC.JpegScanHeader@)">
            <summary>
            <p>Retrieves parameters from the Start Of Scan (SOS) marker for the scan with the specified index.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The index of the scan for which header data is retrieved.</p> </dd></param>
            <param name = "scanHeaderRef"><dd>  <p>A reference that receives the frame header data.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on successful completion.</p></returns>
            <doc-id>dn903858</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::GetScanHeader([In] unsigned int scanIndex,[Out] WICJpegScanHeader* pScanHeader)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::GetScanHeader</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.CopyScan(System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32@)">
            <summary>
            <p>Retrieves a copy of the compressed JPEG scan directly from the WIC decoder frame's output stream.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "scanOffset"><dd>  <p>The byte position in the scan data to begin copying.  Use 0 on the first call.  If the output buffer size is insufficient to store the entire scan, this offset allows you to resume copying from the end of the previous copy operation.</p> </dd></param>
            <param name = "scanData"><dd>  <p>The size, in bytes, of the <em>pbScanData</em> array.</p> </dd></param>
            <param name = "scanDataRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <param name = "scanDataActualRef"><dd>  <p>A reference that receives the size of the scan data actually copied into <em>pbScanData</em>. The size returned may be smaller that the size of <em>cbScanData</em>. This  parameter may be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903841</doc-id>
            <unmanaged>HRESULT IWICJpegFrameDecode::CopyScan([In] unsigned int scanIndex,[In] unsigned int scanOffset,[In] unsigned int cbScanData,[Out, Buffer] unsigned char* pbScanData,[Out] unsigned int* pcbScanDataActual)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::CopyScan</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameDecode.CopyMinimalStream(System.Int32,System.Int32,System.Byte[],System.Int32@)">
            <summary>
            No documentation.
            </summary>
            <param name = "streamOffset">No documentation.</param>
            <param name = "streamData">No documentation.</param>
            <param name = "streamDataRef">No documentation.</param>
            <param name = "streamDataActualRef">No documentation.</param>
            <returns>No documentation.</returns>
            <unmanaged>HRESULT IWICJpegFrameDecode::CopyMinimalStream([In] unsigned int streamOffset,[In] unsigned int cbStreamData,[Out, Buffer] unsigned char* pbStreamData,[Out] unsigned int* pcbStreamDataActual)</unmanaged>
            <unmanaged-short>IWICJpegFrameDecode::CopyMinimalStream</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameEncode.GetAcHuffmanTable(System.Int32,System.Int32,SharpDX.DXGI.JpegAcHuffmanTable@)">
            <summary>
            <p>Retrieves a copy of the AC Huffman table for the specified scan and table.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "tableIndex"><dd>  <p>The index of the AC Huffman table to retrieve.</p> </dd></param>
            <param name = "acHuffmanTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pAcHuffmanTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903867</doc-id>
            <unmanaged>HRESULT IWICJpegFrameEncode::GetAcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_AC_HUFFMAN_TABLE* pAcHuffmanTable)</unmanaged>
            <unmanaged-short>IWICJpegFrameEncode::GetAcHuffmanTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameEncode.GetDcHuffmanTable(System.Int32,System.Int32,SharpDX.DXGI.JpegDeviceContextHuffmanTable@)">
            <summary>
            <p>Retrieves a copy of the DC Huffman table for the specified scan and table.</p>
            </summary>
            <param name = "scanIndex"><dd> <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "tableIndex"><dd> <p>The index of the DC Huffman table to retrieve. </p> </dd></param>
            <param name = "dcHuffmanTableRef"><dd> <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903870</doc-id>
            <unmanaged>HRESULT IWICJpegFrameEncode::GetDcHuffmanTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_DC_HUFFMAN_TABLE* pDcHuffmanTable)</unmanaged>
            <unmanaged-short>IWICJpegFrameEncode::GetDcHuffmanTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameEncode.GetQuantizationTable(System.Int32,System.Int32,SharpDX.DXGI.JpegQuantizationTable@)">
            <summary>
            <p>Retrieves a copy of the quantization table.</p>
            </summary>
            <param name = "scanIndex"><dd>  <p>The zero-based index of the scan for which data is retrieved.</p> </dd></param>
            <param name = "tableIndex"><dd>  <p>The index of the quantization table to retrieve. </p> </dd></param>
            <param name = "quantizationTableRef"><dd>  <p>A reference that receives the table data. This parameter must not be <c>null</c>.</p> </dd></param>
            <returns><p>This method can return one of these values.</p><table> <tr><th>Return value</th><th>Description</th></tr> <tr><td> <dl> <dt><see cref = "F:SharpDX.Result.Ok"/></dt> </dl> </td><td> <p>The operation was successful.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidJpegscanindex"/> </dt> </dl> </td><td> <p>The specified scan index is invalid.</p> </td></tr> <tr><td> <dl> <dt><see cref = "!:InvalidParameter"/></dt> </dl> </td><td> <p>Can occur if <em>pTable</em> is <c>null</c> or if <em>tableIndex</em> does not point to a valid table slot. Check the scan header for valid table indices.</p> </td></tr> </table><p>?</p></returns>
            <doc-id>dn903873</doc-id>
            <unmanaged>HRESULT IWICJpegFrameEncode::GetQuantizationTable([In] unsigned int scanIndex,[In] unsigned int tableIndex,[Out] DXGI_JPEG_QUANTIZATION_TABLE* pQuantizationTable)</unmanaged>
            <unmanaged-short>IWICJpegFrameEncode::GetQuantizationTable</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.JpegFrameEncode.WriteScan(System.Int32,System.Byte[])">
            <summary>
            <p>Writes scan data to a JPEG frame.</p>
            </summary>
            <param name = "scanData"><dd>  <p>The size of the data in the <em>pbScanData</em> parameter.</p> </dd></param>
            <param name = "scanDataRef"><dd>  <p>The scan data to write.</p> </dd></param>
            <returns><p>Returns <see cref = "F:SharpDX.Result.Ok"/> on successful completion.</p></returns>
            <remarks>
            <p><strong>WriteScan</strong> may be called multiple times.  Each call appends the scan data specified to any previous scan data.  Complete the scan by calling <strong>IWICBitmapFrameEncode::Commit</strong>. </p><p>Any calls to set encoder parameters or image metadata that will appear before the scan data in the resulting JPEG file must be completed before the first call to this method.  This includes calls to <strong>IWICBitmapFrameEncode::SetColorContexts</strong> , <strong>IWICBitmapFrameEncode::SetPalette</strong>, <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, <strong>IWICBitmapFrameEncode::SetResolution</strong>, and <strong>IWICBitmapFrameEncode::SetThumbnail</strong>.  <strong>IWICBitmapFrameEncode::SetSize</strong> is required as it has no default value for encoded image size.
            </p>
            </remarks>
            <doc-id>dn903875</doc-id>
            <unmanaged>HRESULT IWICJpegFrameEncode::WriteScan([In] unsigned int cbScanData,[In, Buffer] const unsigned char* pbScanData)</unmanaged>
            <unmanaged-short>IWICJpegFrameEncode::WriteScan</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.PixelFormatInfo2.IsSupportingTransparency">
            <summary>
            <p>Returns whether the format supports transparent pixels.</p>
            </summary>
            <remarks>
            <p> An indexed pixel format will not return <strong>TRUE</strong> even though it may have some transparency support.
            </p>
            </remarks>
            <doc-id>ee719766</doc-id>
            <unmanaged>SupportsTransparency</unmanaged>
            <unmanaged-short>SupportsTransparency</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.PixelFormatInfo2.NumericRepresentation">
            <summary>
            No documentation.
            </summary>
            <doc-id>ee719765</doc-id>
            <unmanaged>GetNumericRepresentation</unmanaged>
            <unmanaged-short>GetNumericRepresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo2.IsSupportingTransparency_(SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Returns whether the format supports transparent pixels.</p>
            </summary>
            <param name = "fSupportsTransparencyRef"><dd>  <p>Returns <strong>TRUE</strong> if the pixel format supports transparency; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> An indexed pixel format will not return <strong>TRUE</strong> even though it may have some transparency support.
            </p>
            </remarks>
            <doc-id>ee719766</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo2::SupportsTransparency([Out] BOOL* pfSupportsTransparency)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo2::SupportsTransparency</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PixelFormatInfo2.GetNumericRepresentation(SharpDX.WIC.PixelFormatNumericRepresentation@)">
            <summary>
            No documentation.
            </summary>
            <param name = "numericRepresentationRef"><dd>  <p>Returns the <strong><see cref = "T:SharpDX.WIC.PixelFormatNumericRepresentation"/></strong> of the pixel format.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719765</doc-id>
            <unmanaged>HRESULT IWICPixelFormatInfo2::GetNumericRepresentation([Out] WICPixelFormatNumericRepresentation* pNumericRepresentation)</unmanaged>
            <unmanaged-short>IWICPixelFormatInfo2::GetNumericRepresentation</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarBitmapFrameEncode.WritePixels(System.Int32,SharpDX.WIC.BitmapPlane[],System.Int32)">
            <summary>
            <p>Writes lines from the source planes to the encoded format.</p>
            </summary>
            <param name = "lineCount"><dd>  <p>The number of lines to encode.  See the Remarks section for WIC Jpeg specific line count restrictions.</p> </dd></param>
            <param name = "planesRef"><dd>  <p>Specifies the source buffers for each component plane encoded.  </p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the <em>pPlanes</em> parameter.</p> </dd></param>
            <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "!:Imagesizeoutofrange"/></strong>. If the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "!:UnsupportedPixelFormat"/></strong>.</p></returns>
            <remarks>
            <p>Successive <strong>WritePixels</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
            </p><p>WIC JPEG Encoder:
            QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
            </p><table> <tr><th>Chroma Subsampling</th><th>Line Count Restriction</th><th>Chroma Plane Width</th><th>Chroma  Plane Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2, unless the call covers the last scanline of the image</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Multiple of 2, unless the call covers the last scanline of the image</td><td>Any</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "!:Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
            </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format8bppCb"/></td><td><see cref = "!:Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dn302091</doc-id>
            <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WritePixels([In] unsigned int lineCount,[In, Buffer] WICBitmapPlane* pPlanes,[In] unsigned int cPlanes)</unmanaged>
            <unmanaged-short>IWICPlanarBitmapFrameEncode::WritePixels</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarBitmapFrameEncode.WriteSource(SharpDX.WIC.BitmapSource[],System.Int32,System.Nullable{SharpDX.Mathematics.Interop.RawBox})">
            <summary>
            <p>Writes lines from the source planes to the encoded format.</p>
            </summary>
            <param name = "planesOut"><dd>  <p>Specifies an array of <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
            <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>
            <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "!:Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "!:UnsupportedPixelFormat"/></strong>.</p></returns>
            <remarks>
            <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
            </p><p>WIC JPEG Encoder:
            QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
            </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "!:Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
            </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format8bppCb"/></td><td><see cref = "!:Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dn302092</doc-id>
            <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>
            <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarBitmapFrameEncode.WriteSource(SharpDX.ComArray{SharpDX.WIC.BitmapSource},System.Int32,System.Nullable{SharpDX.Mathematics.Interop.RawBox})">
            <summary>
            <p>Writes lines from the source planes to the encoded format.</p>
            </summary>
            <param name = "planesOut"><dd>  <p>Specifies an array of <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
            <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>
            <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "!:Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "!:UnsupportedPixelFormat"/></strong>.</p></returns>
            <remarks>
            <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
            </p><p>WIC JPEG Encoder:
            QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
            </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "!:Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
            </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format8bppCb"/></td><td><see cref = "!:Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dn302092</doc-id>
            <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>
            <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarBitmapFrameEncode.WriteSource(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            <p>Writes lines from the source planes to the encoded format.</p>
            </summary>
            <param name = "planesOut"><dd>  <p>Specifies an array of <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> that represent image planes.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
            <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to encode from the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> planes.  Null indicates the entire source.  The source rect width must match the width set through <strong>SetSize</strong>. Repeated <strong>WriteSource</strong> calls can be made as long as the total accumulated source rect height is the same as set through <strong>SetSize</strong>.  </p> </dd></param>
            <returns><p>If the planes and source rectangle do not meet the requirements, this method fails with <strong><see cref = "!:Imagesizeoutofrange"/></strong>. </p><p>If the <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> format does not meet the encoder requirements, this method fails with <strong><see cref = "!:UnsupportedPixelFormat"/></strong>.</p></returns>
            <remarks>
            <p>Successive <strong>WriteSource</strong> calls are assumed sequentially add scanlines to the output image.  <strong>IWICBitmapFrameEncode::Initialize</strong>, <strong>IWICBitmapFrameEncode::SetSize</strong> and <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> must be called before this method or it will fail.</p><p>The interleaved pixel format set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong> and the codec specific encode parameters determine the supported planar formats.
            </p><p>WIC JPEG Encoder:
            QueryInterface can be used to obtain this interface from the WIC JPEG <strong><see cref = "T:SharpDX.WIC.BitmapFrameEncode"/></strong> implementation.  When using this method to encode Y?CbCr data with the WIC JPEG encoder, chroma subsampling can be configured with encoder options during frame creation.  See the Encoding Overview and <strong>IWICBitmapEncoder::CreateNewFrame</strong> for more details.   </p><p>Depending upon the configured chroma subsampling, the lineCount parameter has the following restrictions:
            </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>Any</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>Any</td><td>Any</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The full scanline width must be encoded, and the width of the bitmap sources must match their planar configuration.</p><p>Additionally, if a pixel format is set via <strong>IWICBitmapFrameEncode::SetPixelFormat</strong>, it must be <see cref = "!:Format24bppBGR"/>.   </p><p>The supported pixel formats of the bitmap sources passed into this method are as follows:
            </p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format8bppCb"/></td><td><see cref = "!:Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dn302092</doc-id>
            <unmanaged>HRESULT IWICPlanarBitmapFrameEncode::WriteSource([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In, Optional] WICRect* prcSource)</unmanaged>
            <unmanaged-short>IWICPlanarBitmapFrameEncode::WriteSource</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarBitmapSourceTransform.DoesSupportTransform(System.Int32@,System.Int32@,SharpDX.WIC.BitmapTransformOptions,SharpDX.WIC.PlanarOptions,System.Guid[],SharpDX.WIC.BitmapPlaneDescription[],System.Int32,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Use this method to determine if a desired planar output is supported and allow the caller to choose an optimized code path if it is.   Otherwise, callers should fall back to <strong><see cref = "T:SharpDX.WIC.BitmapSourceTransform"/></strong> or <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> and retrieve interleaved pixels.</p><p> The following transforms can be checked:</p><ul> <li> Determine if the flip/rotate option specified via <strong><see cref = "T:SharpDX.WIC.BitmapTransformOptions"/></strong> is supported.</li> <li>Determine if the requested planar pixel format configuration is supported.</li> <li>Determine the closest dimensions the implementation can natively scale to given the desired dimensions. 
            </li> </ul><p>When a transform is supported, this method returns the description of the resulting planes in the <em>pPlaneDescriptions</em> parameter.
            </p>
            </summary>
            <param name = "widthRef">No documentation.</param>
            <param name = "heightRef">No documentation.</param>
            <param name = "dstTransform">No documentation.</param>
            <param name = "dstPlanarOptions">No documentation.</param>
            <param name = "guidDstFormatsRef">No documentation.</param>
            <param name = "planeDescriptionsRef">No documentation.</param>
            <param name = "planes">No documentation.</param>
            <param name = "fIsSupportedRef">No documentation.</param>
            <returns><p>Check the value of <em>pfIsSupported</em> to determine if the transform is supported via <strong>IWICPlanarBitmapSourceTransform::CopyPixels</strong>.  If this method fails, the output parameters for width, height, and plane descriptions are zero initialized.Other return values indicate failure. </p></returns>
            <doc-id>dn302095</doc-id>
            <unmanaged>HRESULT IWICPlanarBitmapSourceTransform::DoesSupportTransform([InOut] unsigned int* puiWidth,[InOut] unsigned int* puiHeight,[In] WICBitmapTransformOptions dstTransform,[In] WICPlanarOptions dstPlanarOptions,[In, Buffer] const GUID* pguidDstFormats,[Out, Buffer] WICBitmapPlaneDescription* pPlaneDescriptions,[In] unsigned int cPlanes,[Out] BOOL* pfIsSupported)</unmanaged>
            <unmanaged-short>IWICPlanarBitmapSourceTransform::DoesSupportTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarBitmapSourceTransform.CopyPixels(System.Nullable{SharpDX.Mathematics.Interop.RawBox},System.Int32,System.Int32,SharpDX.WIC.BitmapTransformOptions,SharpDX.WIC.PlanarOptions,SharpDX.WIC.BitmapPlane[],System.Int32)">
            <summary>
            <p>Copies pixels into the destination planes.  Configured by the supplied input parameters.  </p><p>If a <em>dstTransform</em>, scale, or format conversion is specified, <em>cbStride</em> is the transformed stride and is based on the destination pixel format of the <em>pDstPlanes</em> parameter, not the original source's pixel format.</p>
            </summary>
            <param name = "rcSourceRef"><dd>  <p>The source rectangle of pixels to copy.  </p> </dd></param>
            <param name = "width"><dd>  <p>The width to scale the source bitmap.  This parameter must be equal to a value obtainable through <strong>IWICPlanarBitmapSourceTransform:: DoesSupportTransform</strong>.</p> </dd></param>
            <param name = "height"><dd>  <p>The height to scale the source bitmap.  This parameter must be equal to a value obtainable through <strong>IWICPlanarBitmapSourceTransform:: DoesSupportTransform</strong>.</p> </dd></param>
            <param name = "dstTransform"><dd>  <p>The desired rotation or flip to perform prior to the pixel copy.  A rotate can be combined with a flip horizontal or a flip vertical, see <strong><see cref = "T:SharpDX.WIC.BitmapTransformOptions"/></strong>.</p> </dd></param>
            <param name = "dstPlanarOptions"><dd>  <p>Used to specify additional configuration options for the transform.  See <strong><see cref = "T:SharpDX.WIC.PlanarOptions"/></strong> for more detail.</p> <p>WIC JPEG Decoder:<strong>WICPlanarOptionsPreserveSubsampling</strong> can be specified to retain the subsampling ratios when downscaling.  By default, the JPEG decoder attempts to preserve quality by downscaling only the Y plane in some cases, changing the image to 4:4:4 chroma subsampling.</p> </dd></param>
            <param name = "dstPlanesRef"><dd>  <p>Specifies the pixel format and output buffer for each component plane.  The number of planes and pixel format of each plane must match values obtainable through  <strong>IWICPlanarBitmapSourceTransform::DoesSupportTransform</strong>.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the <em>pDstPlanes</em> parameter.</p> </dd></param>
            <returns><p>If the specified scale, flip/rotate, and planar format configuration is not supported this method fails with <strong><see cref = "!:InvalidParameter"/></strong>.  You can check if a transform is supported by calling <strong>IWICPlanarBitmapSourceTransform::DoesSupportTransform</strong>.</p></returns>
            <remarks>
            <p>WIC JPEG Decoder:
            Depending on the configured chroma subsampling of the image, the source rectangle has the following restrictions:
            </p><table> <tr><th>Chroma Subsampling</th><th>X Coordinate</th><th>Y Coordinate</th><th>Chroma Width</th><th>Chroma Height</th></tr> <tr><td>4:2:0</td><td>Multiple of 2</td><td>Multiple of 2</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight / 2 Rounded up to the nearest integer.</td></tr> <tr><td>4:2:2</td><td>Multiple of 2</td><td>Any</td><td>lumaWidth / 2 Rounded up to the nearest integer.</td><td>lumaHeight</td></tr> <tr><td>4:4:4</td><td>Any</td><td>Any</td><td>llumaWidth</td><td>llumaHeight</td></tr> <tr><td>4:4:0</td><td>Any</td><td>Multiple of 2</td><td>lumaWidth</td><td>llumaHeight / 2 Rounded up to the nearest integer.</td></tr> </table><p>?</p><p>The <em>pDstPlanes</em> parameter supports the following pixel formats.</p><table> <tr><th>Plane Count</th><th>Plane 1</th><th>Plane 2</th><th>Plane 3</th></tr> <tr><td>3</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format8bppCb"/></td><td><see cref = "!:Format8bppCr"/></td></tr> <tr><td>2</td><td><see cref = "!:Format8bppY"/></td><td><see cref = "!:Format16bppCbCr"/></td><td>N/A</td></tr> </table><p>?</p>
            </remarks>
            <doc-id>dn302094</doc-id>
            <unmanaged>HRESULT IWICPlanarBitmapSourceTransform::CopyPixels([In, Optional] const WICRect* prcSource,[In] unsigned int uiWidth,[In] unsigned int uiHeight,[In] WICBitmapTransformOptions dstTransform,[In] WICPlanarOptions dstPlanarOptions,[In, Buffer] const WICBitmapPlane* pDstPlanes,[In] unsigned int cPlanes)</unmanaged>
            <unmanaged-short>IWICPlanarBitmapSourceTransform::CopyPixels</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarFormatConverter.Initialize(SharpDX.WIC.BitmapSource[],System.Int32,System.Guid,SharpDX.WIC.BitmapDitherType,SharpDX.WIC.Palette,System.Double,SharpDX.WIC.BitmapPaletteType)">
            <summary>
            <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>
            </summary>
            <param name = "planesOut"><dd>  <p>An array of <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
            <param name = "dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>
            <param name = "dither"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
            <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
            <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
            <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302098</doc-id>
            <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
            <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarFormatConverter.CanConvert(System.Guid[],System.Int32,System.Guid,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Query if the format converter can convert from one format to another.</p>
            </summary>
            <param name = "srcPixelFormatsRef"><dd> <p>An array of WIC pixel formats that represents source image planes.</p> </dd></param>
            <param name = "srcPlanes"><dd> <p>The number of source pixel formats specified by the <em>pSrcFormats</em> parameter.</p> </dd></param>
            <param name = "dstPixelFormat"><dd> <p>The destination interleaved pixel format.</p> </dd></param>
            <param name = "fCanConvertRef"><dd> <p>True if the conversion is supported.</p> </dd></param>
            <returns><p>If the conversion is not supported, this method returns <see cref = "F:SharpDX.Result.Ok"/>, but *<em>pfCanConvert</em> is set to <see cref = "F:SharpDX.Result.False"/>. </p><p>If this method fails, the out parameter <em>pfCanConvert</em> is invalid.</p></returns>
            <remarks>
            <p>To specify an interleaved input pixel format, provide a length 1 array to <em>pSrcPixelFormats</em>.</p>
            </remarks>
            <doc-id>dn302097</doc-id>
            <unmanaged>HRESULT IWICPlanarFormatConverter::CanConvert([In, Buffer] const GUID* pSrcPixelFormats,[In] unsigned int cSrcPlanes,[In] const GUID&amp; dstPixelFormat,[Out] BOOL* pfCanConvert)</unmanaged>
            <unmanaged-short>IWICPlanarFormatConverter::CanConvert</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarFormatConverter.Initialize(SharpDX.ComArray{SharpDX.WIC.BitmapSource},System.Int32,System.Guid,SharpDX.WIC.BitmapDitherType,SharpDX.WIC.Palette,System.Double,SharpDX.WIC.BitmapPaletteType)">
            <summary>
            <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>
            </summary>
            <param name = "planesOut"><dd>  <p>An array of <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
            <param name = "dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>
            <param name = "dither"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
            <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
            <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
            <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302098</doc-id>
            <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
            <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.PlanarFormatConverter.Initialize(System.IntPtr,System.Int32,System.IntPtr,SharpDX.WIC.BitmapDitherType,System.IntPtr,System.Double,SharpDX.WIC.BitmapPaletteType)">
            <summary>
            <p>Initializes a format converter with a planar source, and specifies the interleaved output pixel format.</p>
            </summary>
            <param name = "planesOut"><dd>  <p>An array of <strong><see cref = "T:SharpDX.WIC.BitmapSource"/></strong> that represents image planes.</p> </dd></param>
            <param name = "planes"><dd>  <p>The number of component planes specified by the planes parameter.</p> </dd></param>
            <param name = "dstFormat"><dd>  <p>The destination interleaved pixel format.</p> </dd></param>
            <param name = "dither"><dd>  <p>The <strong><see cref = "T:SharpDX.WIC.BitmapDitherType"/></strong> used for conversion.</p> </dd></param>
            <param name = "paletteRef"><dd>  <p>The palette to use for conversion.</p> </dd></param>
            <param name = "alphaThresholdPercent"><dd>  <p>The alpha threshold to use for conversion.</p> </dd></param>
            <param name = "paletteTranslate"><dd>  <p>The palette translation type to use for conversion.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn302098</doc-id>
            <unmanaged>HRESULT IWICPlanarFormatConverter::Initialize([In, Buffer] IWICBitmapSource** ppPlanes,[In] unsigned int cPlanes,[In] const GUID&amp; dstFormat,[In] WICBitmapDitherType dither,[In, Optional] IWICPalette* pIPalette,[In] double alphaThresholdPercent,[In] WICBitmapPaletteType paletteTranslate)</unmanaged>
            <unmanaged-short>IWICPlanarFormatConverter::Initialize</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ProgressCallback.Notify(System.Int32,SharpDX.WIC.ProgressOperation,System.Double)">
            <summary>
            <p><strong>Notify</strong> method is documented only for compliance; its use is not recommended and may be altered or unavailable in the future. Instead, and use <strong>RegisterProgressNotification</strong>. 
            </p>
            </summary>
            <param name = "frameNum">No documentation.</param>
            <param name = "operation">No documentation.</param>
            <param name = "dblProgress">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>ee719776</doc-id>
            <unmanaged>HRESULT IWICProgressCallback::Notify([In] ULONG uFrameNum,[In] WICProgressOperation operation,[In] double dblProgress)</unmanaged>
            <unmanaged-short>IWICProgressCallback::Notify</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.ProgressiveLevelControl.LevelCount">
            <summary>
            <p>Gets the number of levels of progressive decoding supported by the CODEC.</p>
            </summary>
            <remarks>
            <p>Users should not use this function to iterate through the progressive levels of a progressive JPEG image. JPEG progressive levels are determined by the image and do not have a fixed level count. Using this method will force the application to wait for all progressive levels to be downloaded before it can return. Instead, applications should use the following code to iterate through the progressive levels of a progressive JPEG image.</p>
            </remarks>
            <doc-id>ee719780</doc-id>
            <unmanaged>GetLevelCount</unmanaged>
            <unmanaged-short>GetLevelCount</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.ProgressiveLevelControl.CurrentLevel">
            <summary>
            <p>Gets or sets the decoder's current progressive level.</p>
            </summary>
            <remarks>
            <p>The level always defaults to the highest progressive level. In order to decode a lower progressive level, <strong>SetCurrentLevel</strong> must first be called.</p>
            </remarks>
            <doc-id>ee719779</doc-id>
            <unmanaged>GetCurrentLevel / SetCurrentLevel</unmanaged>
            <unmanaged-short>GetCurrentLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ProgressiveLevelControl.GetLevelCount(System.Int32@)">
            <summary>
            <p>Gets the number of levels of progressive decoding supported by the CODEC.</p>
            </summary>
            <param name = "levelsRef"><dd>  <p>Indicates the number of levels supported by the CODEC.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Users should not use this function to iterate through the progressive levels of a progressive JPEG image. JPEG progressive levels are determined by the image and do not have a fixed level count. Using this method will force the application to wait for all progressive levels to be downloaded before it can return. Instead, applications should use the following code to iterate through the progressive levels of a progressive JPEG image.</p>
            </remarks>
            <doc-id>ee719780</doc-id>
            <unmanaged>HRESULT IWICProgressiveLevelControl::GetLevelCount([Out] unsigned int* pcLevels)</unmanaged>
            <unmanaged-short>IWICProgressiveLevelControl::GetLevelCount</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ProgressiveLevelControl.GetCurrentLevel(System.Int32@)">
            <summary>
            <p>Gets the decoder's current progressive level.</p>
            </summary>
            <param name = "nLevelRef"><dd>  <p>Indicates the current level specified.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The level always defaults to the highest progressive level. In order to decode a lower progressive level, <strong>SetCurrentLevel</strong> must first be called.</p>
            </remarks>
            <doc-id>ee719779</doc-id>
            <unmanaged>HRESULT IWICProgressiveLevelControl::GetCurrentLevel([Out] unsigned int* pnLevel)</unmanaged>
            <unmanaged-short>IWICProgressiveLevelControl::GetCurrentLevel</unmanaged-short>
        </member>
        <member name="M:SharpDX.WIC.ProgressiveLevelControl.SetCurrentLevel(System.Int32)">
            <summary>
            <p>Specifies the level to retrieve on the next call to <strong>CopyPixels</strong>.</p>
            </summary>
            <param name = "nLevel">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> A call does not have to request every level supported. If a caller requests level 1, without having previously requested level 0, the bits returned by the next call to <strong>CopyPixels</strong> will include both levels. </p><p> If the requested level is invalid, the error returned is <see cref = "!:InvalidProgressivelevel"/>.</p>
            </remarks>
            <doc-id>ee719781</doc-id>
            <unmanaged>HRESULT IWICProgressiveLevelControl::SetCurrentLevel([In] unsigned int nLevel)</unmanaged>
            <unmanaged-short>IWICProgressiveLevelControl::SetCurrentLevel</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapPattern">
            <summary>
            <p>Contains members that identify a pattern within an image file which can be used to identify a particular format.</p>
            </summary>
            <doc-id>ee719813</doc-id>
            <unmanaged>WICBitmapPattern</unmanaged>
            <unmanaged-short>WICBitmapPattern</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPattern.Position">
            <summary>
            <dd> <p>The offset the pattern is located in the file.</p> </dd>
            </summary>
            <doc-id>ee719813</doc-id>
            <unmanaged>Position</unmanaged>
            <unmanaged-short>Position</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPattern.Length">
            <summary>
            <dd> <p>The pattern length.</p> </dd>
            </summary>
            <doc-id>ee719813</doc-id>
            <unmanaged>Length</unmanaged>
            <unmanaged-short>Length</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPattern.Pattern">
            <summary>
            <dd> <p>The actual pattern.</p> </dd>
            </summary>
            <doc-id>ee719813</doc-id>
            <unmanaged>Pattern</unmanaged>
            <unmanaged-short>Pattern</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPattern.Mask">
            <summary>
            <dd> <p>The pattern mask.</p> </dd>
            </summary>
            <doc-id>ee719813</doc-id>
            <unmanaged>Mask</unmanaged>
            <unmanaged-short>Mask</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPattern.EndOfStream">
            <summary>
            <dd> <p>The end of the stream.</p> </dd>
            </summary>
            <doc-id>ee719813</doc-id>
            <unmanaged>EndOfStream</unmanaged>
            <unmanaged-short>EndOfStream</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapPlane">
            <summary>
            <p>Specifies the pixel format, buffer, stride and size of a component plane for a planar pixel format.</p>
            </summary>
            <doc-id>dn302099</doc-id>
            <unmanaged>WICBitmapPlane</unmanaged>
            <unmanaged-short>WICBitmapPlane</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlane.Format">
            <summary>
            <dd> <p>Describes the pixel format of the plane. </p> </dd>
            </summary>
            <doc-id>dn302099</doc-id>
            <unmanaged>Format</unmanaged>
            <unmanaged-short>Format</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlane.PbBuffer">
            <summary>
            <dd> <p>Pointer to the buffer that holds the plane?s pixel components.</p> </dd>
            </summary>
            <doc-id>dn302099</doc-id>
            <unmanaged>pbBuffer</unmanaged>
            <unmanaged-short>pbBuffer</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlane.CbStride">
            <summary>
            <dd> <p>The stride of the buffer ponted to by <em>pbData</em>.  Stride indicates the total number of bytes to go from the beginning of one scanline to the beginning of the next scanline.</p> </dd>
            </summary>
            <doc-id>dn302099</doc-id>
            <unmanaged>cbStride</unmanaged>
            <unmanaged-short>cbStride</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlane.CbBufferSize">
            <summary>
            <dd> <p>The total size of the buffer pointed to by <em>pbBuffer</em>.</p> </dd>
            </summary>
            <doc-id>dn302099</doc-id>
            <unmanaged>cbBufferSize</unmanaged>
            <unmanaged-short>cbBufferSize</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.BitmapPlaneDescription">
            <summary>
            <p>Specifies the pixel format and size of a component plane.</p>
            </summary>
            <doc-id>dn302100</doc-id>
            <unmanaged>WICBitmapPlaneDescription</unmanaged>
            <unmanaged-short>WICBitmapPlaneDescription</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlaneDescription.Format">
            <summary>
            <dd> <p>Describes the pixel format of the plane. </p> </dd>
            </summary>
            <doc-id>dn302100</doc-id>
            <unmanaged>Format</unmanaged>
            <unmanaged-short>Format</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlaneDescription.Width">
            <summary>
            <dd> <p>Component width of the plane.</p> </dd>
            </summary>
            <doc-id>dn302100</doc-id>
            <unmanaged>Width</unmanaged>
            <unmanaged-short>Width</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.BitmapPlaneDescription.Height">
            <summary>
            <dd> <p>Component height of the plane.</p> </dd>
            </summary>
            <doc-id>dn302100</doc-id>
            <unmanaged>Height</unmanaged>
            <unmanaged-short>Height</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.DdsFormatInfo">
            <summary>
            <p>Specifies the <strong><see cref = "T:SharpDX.DXGI.Format"/></strong> and block information of a DDS format.</p>
            </summary>
            <doc-id>dn302103</doc-id>
            <unmanaged>WICDdsFormatInfo</unmanaged>
            <unmanaged-short>WICDdsFormatInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsFormatInfo.DxgiFormat">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302103</doc-id>
            <unmanaged>DxgiFormat</unmanaged>
            <unmanaged-short>DxgiFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsFormatInfo.BytesPerBlock">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302103</doc-id>
            <unmanaged>BytesPerBlock</unmanaged>
            <unmanaged-short>BytesPerBlock</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsFormatInfo.BlockWidth">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302103</doc-id>
            <unmanaged>BlockWidth</unmanaged>
            <unmanaged-short>BlockWidth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsFormatInfo.BlockHeight">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302103</doc-id>
            <unmanaged>BlockHeight</unmanaged>
            <unmanaged-short>BlockHeight</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.DdsParameters">
            <summary>
            <p>Specifies the DDS image dimension, <strong><see cref = "T:SharpDX.DXGI.Format"/></strong> and alpha mode of contained data.</p>
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>WICDdsParameters</unmanaged>
            <unmanaged-short>WICDdsParameters</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.Width">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>Width</unmanaged>
            <unmanaged-short>Width</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.Height">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>Height</unmanaged>
            <unmanaged-short>Height</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.Depth">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>Depth</unmanaged>
            <unmanaged-short>Depth</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.MipLevels">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>MipLevels</unmanaged>
            <unmanaged-short>MipLevels</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.ArraySize">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>ArraySize</unmanaged>
            <unmanaged-short>ArraySize</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.DxgiFormat">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>DxgiFormat</unmanaged>
            <unmanaged-short>DxgiFormat</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.Dimension">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>Dimension</unmanaged>
            <unmanaged-short>Dimension</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.DdsParameters.AlphaMode">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn302104</doc-id>
            <unmanaged>AlphaMode</unmanaged>
            <unmanaged-short>AlphaMode</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegFrameHeader">
            <summary>
            <p>Represents a JPEG frame header.</p>
            </summary>
            <remarks>
            <p>Get the frame header for an image by calling <strong>IWICJpegFrameDecode::GetFrameHeader</strong>.</p>
            </remarks>
            <doc-id>dn903878</doc-id>
            <unmanaged>WICJpegFrameHeader</unmanaged>
            <unmanaged-short>WICJpegFrameHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.Width">
            <summary>
            <dd> <p>The width of the JPEG frame.</p> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>Width</unmanaged>
            <unmanaged-short>Width</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.Height">
            <summary>
            <dd> <p>The height of the JPEG frame.</p> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>Height</unmanaged>
            <unmanaged-short>Height</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.TransferMatrix">
            <summary>
            <dd> <p>The transfer matrix of the JPEG frame.</p> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>TransferMatrix</unmanaged>
            <unmanaged-short>TransferMatrix</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.ScanType">
            <summary>
            <dd> <p>The scan type of the JPEG frame.</p> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>ScanType</unmanaged>
            <unmanaged-short>ScanType</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.CComponents">
            <summary>
            <dd> <p>The number of components in the frame.</p> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>cComponents</unmanaged>
            <unmanaged-short>cComponents</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.ComponentIdentifiers">
            <summary>
            <dd> <p>The component identifiers.</p> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>ComponentIdentifiers</unmanaged>
            <unmanaged-short>ComponentIdentifiers</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.SampleFactors">
            <summary>
            <dd> <p>The sample factors. Use one of the following constants, described in <strong><see cref = "T:SharpDX.WIC.JpegFrameDecode"/> Constants</strong>.</p> <ul> <li>WIC_JPEG_SAMPLE_FACTORS_ONE</li> <li>WIC_JPEG_SAMPLE_FACTORS_THREE_420</li> <li>WIC_JPEG_SAMPLE_FACTORS_THREE_422</li> <li>WIC_JPEG_SAMPLE_FACTORS_THREE_440</li> <li>WIC_JPEG_SAMPLE_FACTORS_THREE_444</li> </ul> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>SampleFactors</unmanaged>
            <unmanaged-short>SampleFactors</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegFrameHeader.QuantizationTableIndices">
            <summary>
            <dd> <p>The format of the quantization table indices. Use one of the following constants, described in <strong><see cref = "T:SharpDX.WIC.JpegFrameDecode"/> Constants</strong>.</p> <ul> <li>WIC_JPEG_QUANTIZATION_BASELINE_ONE</li> <li>WIC_JPEG_QUANTIZATION_BASELINE_THREE </li> </ul> </dd>
            </summary>
            <doc-id>dn903878</doc-id>
            <unmanaged>QuantizationTableIndices</unmanaged>
            <unmanaged-short>QuantizationTableIndices</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.JpegScanHeader">
            <summary>
            <p>Represents a JPEG frame header.</p>
            </summary>
            <remarks>
            <p>Get the scan header for an image by calling <strong>IWICJpegFrameDecode::GetScanHeader</strong>.</p>
            </remarks>
            <doc-id>dn903883</doc-id>
            <unmanaged>WICJpegScanHeader</unmanaged>
            <unmanaged-short>WICJpegScanHeader</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.CComponents">
            <summary>
            <dd> <p>The number of components in the scan.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>cComponents</unmanaged>
            <unmanaged-short>cComponents</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.RestartInterval">
            <summary>
            <dd> <p>The interval of reset markers within the scan.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>RestartInterval</unmanaged>
            <unmanaged-short>RestartInterval</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.ComponentSelectors">
            <summary>
            <dd> <p>The component identifiers.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>ComponentSelectors</unmanaged>
            <unmanaged-short>ComponentSelectors</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.HuffmanTableIndices">
            <summary>
            <dd> <p>The format of the quantization table indices. Use one of the following constants, described in <strong><see cref = "T:SharpDX.WIC.JpegFrameDecode"/> Constants</strong>.</p> <ul> <li>WIC_JPEG_HUFFMAN_BASELINE_ONE</li> <li>WIC_JPEG_HUFFMAN_BASELINE_THREE </li> </ul> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>HuffmanTableIndices</unmanaged>
            <unmanaged-short>HuffmanTableIndices</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.StartSpectralSelection">
            <summary>
            <dd> <p>The start of the spectral selection.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>StartSpectralSelection</unmanaged>
            <unmanaged-short>StartSpectralSelection</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.EndSpectralSelection">
            <summary>
            <dd> <p>The end of the spectral selection.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>EndSpectralSelection</unmanaged>
            <unmanaged-short>EndSpectralSelection</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.SuccessiveApproximationHigh">
            <summary>
            <dd> <p>The successive approximation high.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>SuccessiveApproximationHigh</unmanaged>
            <unmanaged-short>SuccessiveApproximationHigh</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.JpegScanHeader.SuccessiveApproximationLow">
            <summary>
            <dd> <p>The successive approximation low.</p> </dd>
            </summary>
            <doc-id>dn903883</doc-id>
            <unmanaged>SuccessiveApproximationLow</unmanaged>
            <unmanaged-short>SuccessiveApproximationLow</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawCapabilitiesInfo">
            <summary>
            <p>Defines raw codec capabilites.</p>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>WICRawCapabilitiesInfo</unmanaged>
            <unmanaged-short>WICRawCapabilitiesInfo</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.CbSize">
            <summary>
            <dd> <p>Size of the <strong><see cref = "T:SharpDX.WIC.RawCapabilitiesInfo"/></strong> structure.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>cbSize</unmanaged>
            <unmanaged-short>cbSize</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.CodecMajorVersion">
            <summary>
            <dd> <p>The codec's major version.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>CodecMajorVersion</unmanaged>
            <unmanaged-short>CodecMajorVersion</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.CodecMinorVersion">
            <summary>
            <dd> <p>The codec's minor version.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>CodecMinorVersion</unmanaged>
            <unmanaged-short>CodecMinorVersion</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.ExposureCompensationSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of exposure compensation support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>ExposureCompensationSupport</unmanaged>
            <unmanaged-short>ExposureCompensationSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.ContrastSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of contrast support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>ContrastSupport</unmanaged>
            <unmanaged-short>ContrastSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.RGBWhitePointSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of RGB white point support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>RGBWhitePointSupport</unmanaged>
            <unmanaged-short>RGBWhitePointSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.NamedWhitePointSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of <strong><see cref = "T:SharpDX.WIC.NamedWhitePoint"/></strong> support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>NamedWhitePointSupport</unmanaged>
            <unmanaged-short>NamedWhitePointSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.NamedWhitePointSupportMask">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.NamedWhitePoint"/></strong> mask.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>NamedWhitePointSupportMask</unmanaged>
            <unmanaged-short>NamedWhitePointSupportMask</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.KelvinWhitePointSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of kelvin white point support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>KelvinWhitePointSupport</unmanaged>
            <unmanaged-short>KelvinWhitePointSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.GammaSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of gamma support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>GammaSupport</unmanaged>
            <unmanaged-short>GammaSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.TintSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of tint support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>TintSupport</unmanaged>
            <unmanaged-short>TintSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.SaturationSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of saturation support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>SaturationSupport</unmanaged>
            <unmanaged-short>SaturationSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.SharpnessSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of sharpness support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>SharpnessSupport</unmanaged>
            <unmanaged-short>SharpnessSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.NoiseReductionSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of noise reduction support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>NoiseReductionSupport</unmanaged>
            <unmanaged-short>NoiseReductionSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.DestinationColorProfileSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of destination color profile support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>DestinationColorProfileSupport</unmanaged>
            <unmanaged-short>DestinationColorProfileSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.ToneCurveSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of tone curve support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>ToneCurveSupport</unmanaged>
            <unmanaged-short>ToneCurveSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.RotationSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawRotationCapabilities"/></strong> of rotation support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>RotationSupport</unmanaged>
            <unmanaged-short>RotationSupport</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawCapabilitiesInfo.RenderModeSupport">
            <summary>
            <dd> <p>The <strong><see cref = "T:SharpDX.WIC.RawCapabilities"/></strong> of <strong><see cref = "T:SharpDX.WIC.RawRenderMode"/></strong> support.</p> </dd>
            </summary>
            <doc-id>ee719857</doc-id>
            <unmanaged>RenderModeSupport</unmanaged>
            <unmanaged-short>RenderModeSupport</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawToneCurve">
            <summary>
            <p>Represents a raw image tone curve.</p>
            </summary>
            <doc-id>ee719861</doc-id>
            <unmanaged>WICRawToneCurve</unmanaged>
            <unmanaged-short>WICRawToneCurve</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawToneCurve.CPoints">
            <summary>
            <dd> <p>The number of tone curve points.</p> </dd>
            </summary>
            <doc-id>ee719861</doc-id>
            <unmanaged>cPoints</unmanaged>
            <unmanaged-short>cPoints</unmanaged-short>
        </member>
        <member name="P:SharpDX.WIC.RawToneCurve.APoints">
            <summary>
            <dd> <p>The array of tone curve points.</p> </dd>
            </summary>
            <doc-id>ee719861</doc-id>
            <unmanaged>aPoints</unmanaged>
            <unmanaged-short>aPoints</unmanaged-short>
        </member>
        <member name="T:SharpDX.WIC.RawToneCurvePoint">
            <summary>
            <p>Represents a raw image tone curve point.</p>
            </summary>
            <doc-id>ee719862</doc-id>
            <unmanaged>WICRawToneCurvePoint</unmanaged>
            <unmanaged-short>WICRawToneCurvePoint</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawToneCurvePoint.Input">
            <summary>
            <dd> <p>The tone curve input.</p> </dd>
            </summary>
            <doc-id>ee719862</doc-id>
            <unmanaged>Input</unmanaged>
            <unmanaged-short>Input</unmanaged-short>
        </member>
        <member name="F:SharpDX.WIC.RawToneCurvePoint.Output">
            <summary>
            <dd> <p>The tone curve output.</p> </dd>
            </summary>
            <doc-id>ee719862</doc-id>
            <unmanaged>Output</unmanaged>
            <unmanaged-short>Output</unmanaged-short>
        </member>
    </members>
</doc>
